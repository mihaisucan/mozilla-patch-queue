# HG changeset patch
# Parent f88227ac42f8e7b90c48c8bce860257fa6096ea4
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1339175186 -10800
Bug 759351 - Update Orion from upstream

diff --git a/browser/devtools/sourceeditor/orion/Makefile.dryice.js b/browser/devtools/sourceeditor/orion/Makefile.dryice.js
--- a/browser/devtools/sourceeditor/orion/Makefile.dryice.js
+++ b/browser/devtools/sourceeditor/orion/Makefile.dryice.js
@@ -1,56 +1,147 @@
 #!/usr/bin/env node
 /* vim:set ts=2 sw=2 sts=2 et tw=80:
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+"use strict";
+
 var copy = require('dryice').copy;
+var ujs = require("uglify-js");
+var vm = require("vm");
 
-const ORION_EDITOR = "org.eclipse.orion.client.editor/web";
+var FIREFOX_HOME = process.env.FIREFOX_HOME;
+var ORION_CLIENT_HOME = process.env.ORION_CLIENT_HOME;
+if (!FIREFOX_HOME) {
+  throw new Error("The FIREFOX_HOME environment variable must point to " +
+                  "the Firefox source code folder.");
+}
+if (!ORION_CLIENT_HOME) {
+  throw new Error("The ORION_CLIENT_HOME environment variable must point to " +
+                  "the Orion client source code folder.");
+}
 
-var js_src = copy.createDataObject();
+var ORION_EDITOR = ORION_CLIENT_HOME +
+                    "/bundles/org.eclipse.orion.client.editor/web";
+var DEST_JS = FIREFOX_HOME + "/browser/devtools/sourceeditor/orion/orion.js";
+var DEST_CSS = FIREFOX_HOME + "/browser/devtools/sourceeditor/orion/orion.css";
+var DEST_L10N = FIREFOX_HOME +
+                  "/browser/locales/en-US/chrome/browser/devtools/orion.properties";
+
+var project = copy.createCommonJsProject({
+  roots: [ ORION_EDITOR ],
+});
+
+project.ignoredModules["orion/textview/i18nUtil"] = true;
+project.ignoredModules["i18n!orion/textview/nls/messages"] = true;
 
 copy({
-  source: [
-    ORION_EDITOR + "/orion/textview/global.js",
-    ORION_EDITOR + "/orion/textview/eventTarget.js",
-    ORION_EDITOR + "/orion/editor/regex.js",
-    ORION_EDITOR + "/orion/textview/keyBinding.js",
-    ORION_EDITOR + "/orion/textview/annotations.js",
-    ORION_EDITOR + "/orion/textview/rulers.js",
-    ORION_EDITOR + "/orion/textview/undoStack.js",
-    ORION_EDITOR + "/orion/textview/textModel.js",
-    ORION_EDITOR + "/orion/textview/projectionTextModel.js",
-    ORION_EDITOR + "/orion/textview/tooltip.js",
-    ORION_EDITOR + "/orion/textview/textView.js",
-    ORION_EDITOR + "/orion/textview/textDND.js",
-    ORION_EDITOR + "/orion/editor/htmlGrammar.js",
-    ORION_EDITOR + "/orion/editor/textMateStyler.js",
-    ORION_EDITOR + "/examples/textview/textStyler.js",
-  ],
-  dest: js_src,
+  source: [createOrionScriptPrefix, {
+    project: project,
+    require: [
+      "examples/textview/textStyler",
+      "orion/editor/htmlGrammar",
+      "orion/editor/textMateStyler",
+      "orion/textview/rulers",
+      "orion/textview/textDND",
+      "orion/textview/textView",
+      "orion/textview/undoStack",
+    ],
+  }, createOrionScriptSuffix],
+  dest: DEST_JS,
 });
 
 copy({
-    source: js_src,
-    dest: "orion.js",
-});
-
-var css_src = copy.createDataObject();
-
-copy({
   source: [
     ORION_EDITOR + "/orion/textview/textview.css",
     ORION_EDITOR + "/orion/textview/rulers.css",
     ORION_EDITOR + "/orion/textview/annotations.css",
+    ORION_EDITOR + "/orion/textview/tooltip.css",
     ORION_EDITOR + "/examples/textview/textstyler.css",
     ORION_EDITOR + "/examples/editor/htmlStyles.css",
   ],
-  dest: css_src,
+  dest: DEST_CSS,
+});
+
+var l10n_output = copy.createDataObject();
+
+copy({
+  source: ORION_EDITOR + "/orion/textview/nls/root/messages.js",
+  filter: tweakStrings,
+  dest: l10n_output,
 });
 
 copy({
-    source: css_src,
-    dest: "orion.css",
+  source: [ createStringsPrefix, l10n_output ],
+  dest: DEST_L10N,
 });
 
+function tweakStrings(script, path) {
+  var strings = null;
+
+  var sandbox = {
+    define: function _define() {
+      if (arguments.length != 1) {
+        console.error("define() is called with " + arguments.length + " arguments in " + path + "! this is not supported!");
+        return;
+      }
+      if (typeof arguments[0] != "object") {
+        console.error("the define() argument is not an object in " + path);
+        return;
+      }
+      if (strings) {
+        console.warn("define() is called more than once in " + path);
+      }
+      strings = arguments[0];
+    },
+    require: function _require() {
+      console.warn("invoking require() is not supported for " + path);
+    },
+  };
+
+  vm.runInNewContext(script, sandbox, path);
+
+  if (!strings) {
+    console.error("no strings found in " + path);
+    return "";
+  }
+
+  var properties = [];
+  for (var key in strings) {
+    var value = strings[key];
+    var matches = value.match(/\$\{\d+}/g);
+    if (matches && matches.length > 1) {
+      value = value.replace(/\$\{(\d+)}/g, "%$1$$S");
+    } else {
+      value = value.replace(/\$\{\d+}/, "%S");
+    }
+    properties.push(key + "=" + value);
+  }
+
+  return properties.join("\n");
+}
+
+tweakStrings.onRead = true;
+
+function createStringsPrefix() {
+  return {
+    value: [
+    "# LOCALIZATION NOTE: These strings are used in the Orion code editor.",
+    "# This editor is integrated into several developer tools, like",
+    "# Scratchpad, Style Editor and JavaScript debugger.",
+    "", ""].join("\n")
+  };
+}
+
+function createOrionScriptPrefix() {
+  return {
+    value: "function initializeOrion() {\n",
+  };
+}
+
+function createOrionScriptSuffix() {
+  var modules = Object.keys(project.currentModules).join("', '");
+  return {
+    value: "\n}\nwindow.knownOrionModules = ['" + modules + "'];\n",
+  };
+}
diff --git a/browser/devtools/sourceeditor/orion/orion.css b/browser/devtools/sourceeditor/orion/orion.css
--- a/browser/devtools/sourceeditor/orion/orion.css
+++ b/browser/devtools/sourceeditor/orion/orion.css
@@ -1,26 +1,23 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-.view {
+.textview {
 	background-color: white;
+	padding: 1px 2px;
 }
 
-.viewContainer {
+.textviewContainer {
 	background-color: #eeeeee;
 	font-family: monospace;
 	font-size: 10pt;
 }
 ::-webkit-scrollbar-corner {
 	background-color: #eeeeee;
 }
 
-.viewContent {
+.textviewContent {
 }/* Styles for rulers */
 .ruler {
 	background-color: white;
 }
 .ruler.annotations {
 	border-right: 1px solid lightgray;
 	width: 16px;
 }
@@ -37,173 +34,226 @@
 	width: 14px;
 }
 
 /* Styles for the line number ruler */
 .rulerLines {
 }
 .rulerLines.even
 .rulerLines.odd {
-}/* Styles for the annotation ruler (all lines) */
-.annotation {
-}
-.annotation.error,
-.annotation.warning
-.annotation.task,
-.annotation.bookmark,
-.annotation.breakpoint,
-.annotation.collapsed
-.annotation.expanded {
-}
-
-/* Styles for the annotation ruler (first line) */
-.annotationHTML {
-	cursor: pointer;
-	width: 16px;
-	height: 16px;
-	display: inline-block;
-	vertical-align: middle;
-	background-position: center;
-	background-repeat: no-repeat;
-}
-.annotationHTML.error {
-	/* images/error.gif */
-	background-image: url("data:image/gif;base64,R0lGODlhEAAQANUAAPVvcvWHiPVucvRuc+ttcfV6f91KVN5LU99PV/FZY/JhaM4oN84pONE4Rd1ATfJLWutVYPRgbdxpcsgWKMgZKs4lNfE/UvE/U+artcpdSc5uXveimslHPuBhW/eJhfV5efaCgO2CgP+/v+PExP///////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAACUALAAAAAAQABAAAAZ+wJJwSCwaScgkySgkjTQZTkYzWhadnE5oE+pwqkSshwQqkzxfa4kkQXxEpA9J9EFI1KQGQQBAigYCBA14ExEWF0gXihETeA0QD3AkD5QQg0NsDnAJmwkOd5gYFSQKpXAFDBhqaxgLBwQBBAapq00YEg0UDRKqTGtKSL7Cw8JBADs=");
-}
-.annotationHTML.warning {
-	/* images/warning.gif */
-	background-image: url("data:image/gif;base64,R0lGODlhEAAQANUAAP7bc//egf/ij/7ijv/jl/7kl//mnv7lnv/uwf7CTP7DTf7DT/7IW//Na/7Na//NbP7QdP/dmbltAIJNAF03AMSAJMSCLKqASa2DS6uBSquCSrGHTq6ETbCHT7WKUrKIUcCVXL+UXMOYX8GWXsSZYMiib6+ETbOIUcOXX86uhd3Muf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAACsALAAAAAAQABAAAAZowJVwSCwaj0ihikRSJYcoBEL0XKlGkcjImQQhJBREKFnyICoThKeE/AAW6AXgdPyUAgrLJBEo0YsbAQyDhAEdRRwDDw8OaA4NDQImRBgFEJdglxAEGEQZKQcHBqOkKRpFF6mqq1WtrUEAOw==");
-}
-.annotationHTML.task {
-	/* images/task.gif */
-	background-image: url("data:image/gif;base64,R0lGODlhEAAQAMQAAN7s4uTy6ICvY423c2WdP2ugR3mqWYeza2ejOl6VNVqPM1aJMURsJ2GaOnKlT8PbsbPDqGmmO1OCLk98LEhxKGWfOWKaN0t2KkJoJf///////wAAAAAAAAAAAAAAAAAAACH5BAEAABoALAAAAAAQABAAAAVmoCaOZDk+UaquDxkNcCxHJHLceI6QleD/vkCmQrIYjkiDMGAhJRzQ6NKRICkKgYJ2qVWQFktCmEBYkCSNZSbQaDckpAl5TCZMSBdtAaDXX0gUUYJRFCQMSYgGDCQQGI6PkBAmkyUhADs=");
-}
-.annotationHTML.bookmark {
-	/* images/bookmark.gif */
-	background-image: url("data:image/gif;base64,R0lGODlhEAAQALMAAP7//+/VNPzZS/vifeumAPrBOOSlHOSuRP///wAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAARLEMlJq5Xn3EvIrkenfRIhCB5pmKhRdbAJAGhssuc8n6eJoAKdkOaTAIdEQeWoA1oGsiZhYAnIcqiApVPjElyUbkFSgCkn5XElLYkAADs=");
-}
-.annotationHTML.breakpoint {
-	/* images/breakpoint.gif */
-	background-image: url("data:image/gif;base64,R0lGODlhEAAQANUAAFheoFxkoFxnpmt0pmZxpnF7rYyWwmJwpnaFs3aDrWt8rXGBrYycwmZ3mXuNs42cu77F03GIs3aJrYGVu2J5oKCuxeDj6LK/03GLrYieu3aIoIygu6m4zcLN3MTM1m6Rs2aLriRgkSZilXGXtoGcs7LD0QBLhSZikihol3ScubrO2Yaqu5q4xpO0wpm7yabF0ZO9yaXI0r3X3tHj6P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADQALAAAAAAQABAAAAafQJpwSCwWLYZBIDAwWIw0A+FFpW6aRUPCxe1yE4ahhdCCxWSzmSwGgxGeUceKpUqhUCkVa7UK0wgkJCUjJoUmIyWBBEIEGhoeJ4YmJx6OAUIADQ0QIZIhEJoAQgEUFBUgkiAVpZdRCxIPFx8iIh8XDw4FfhYHDhgZHB0dHBkYEwdwUQoTEc3OEwp+QwYHCBMMDBMIB9JESAJLAk5Q5EVBADs=");
-}
-.annotationHTML.collapsed {
-	/* images/collapsed.png */
-	width: 14px;
-	height: 14px;
-	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAWBJREFUeNpi/P//PwMlgImBQkCxASzoAp++fo+6de+Z+fXbD/Jev/nAICoiwKCpqrBBTUlqNR835zJ09YzIYfDxy7eo/cevLmXlYGNQUJAEahZieP3mHcODB08Zfv/4w+BoqR3Nz8O1DKcXzt94HPqXmZlBU1+LgZNfkMHazIOBA0hr6uswgMTP33gYijcMLlx/EMAnLs7w7sc/hg9AG0HgPZB+B8S84hJA+UcBeMPg+at3DJIMnAxZzt5wsUhnXzDdsmIVWB6vAcLCfAys3z4wzN64huEfkJ/uH8IwexOQDQymD2/fgeXxekFLRWHD51evGDhZGRi4WSFSnCwgNjB2Xr1m0AbK4zXAQkdhNdPf3wx3r91g+PruLcOqnasYvn54x3Dv2k0G5r+/GMyB8nijEQTefvoadeH6w9Cbtx8GvH//kUFQkJ9BQ1V+g76m/GphPu5lBA0YenmBYgMAAgwA34GIKjmLxOUAAAAASUVORK5CYII=");
-}
-.annotationHTML.expanded {
-	/* images/expanded.png */
-	width: 14px;
-	height: 14px;	
-	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAT5JREFUeNrUksFKw0AURW+mTWw67SSEiG209U90r4jddFO34l+5U0HdZCHiFwiCOz9AlMSmGEpMOqk1TWJSFGyFbATR2dyZd+Dw3mOENE3xkyP8PYHrBT3OX7uW43ZefA6FUaw1dJPSyrmu1k8KBYOh37Od4XFZLEPXFdRrFMGIw3U9TKMYqw1tb0VjcxLy9eEF425CCIxWE5JcxSQGxCyNloG87gXhwWIHc4J767lTZQw8ShFGSZbxRyaQmZJxd3NRUJ6ffwQNEi6PzG/L2tjdmvFCgcKqKL2F2Olu43MzggDka+IjPuOFI7Sbujn2fUglYKkkzFIi+R0I/QDrGS8UqDX5QkhiOHYfE84hkhSTkGNgOyDJFCzjhYLTq+vDtrG8r1LZtB6fcHtzB+uhD5VWzLx+lvF/8JV/XfAuwADsrJbMGG4l4AAAAABJRU5ErkJggg==");
-}
-.annotationHTML.multiple {
-	/* images/multiple.gif */
-	background-image: url("data:image/gif;base64,R0lGODlhEAAQANUAAOdpa+yJiuFYXOFYXeBYXONwded8f+NwdmhwkHB4iPr7/ezx+fP2+2h4kOzy+Wh4iPr8/gCBwTaczjaXyjaYyjaXyTaYyfr8/QCMzQCMzACHxzao2jal2Dak1zag03iAgI/Ckn64fZrHmX+4fZLCianPopPCiarOoqbLlafLlbnXq7nWq6fLlMTcsoCIeJCQcIiIeKCYaJiQcO16ee16evGVlfGWlfahn/ahoPWhn/WhoPe1tP///////wAAAAAAACH5BAEAAD0ALAAAAAAQABAAAAaRwJ5wSCwaj8WYcslcDmObaDTGq1Zjzw4mk+FQIRcFTzaUeTRoj4zHaI+HL0lkLnnxFgsH7zWEWSoTFBMwVlUwQy6JMDCJjYwuQx8tk5MfOzk4OjcfkSssKCkqHzY0MzQ1nEIJJSYkJCcJAQCzAQlDDyIjISMiCQYEAgMGD0MNIMfHDQUHBc3EQgjR0tPSSNY9QQA7");
-}
-.annotationHTML.overlay {
-	/* images/plus.png */
-	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAAXNSR0IArs4c6QAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJEAQvB2JVdrAAAAAdaVRYdENvbW1lbnQAAAAAAENyZWF0ZWQgd2l0aCBHSU1QZC5lBwAAAD1JREFUCNdtjkESADAEAzemf69f66HMqGlOIhYiFRFRtSQBWAY7mzx+EDTL6sSgb1jTk7Q87rxyqe37fXsAa78gLyZnRgEAAAAASUVORK5CYII=");
-	background-position: right bottom;
-	position: relative;
-	top: -16px;
-}
-.annotationHTML.currentBracket {
-	/* images/currentBracket.png */
-	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sLEBULCGQmEKAAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAnklEQVQ4y7VTsRHDIBATJg1HCUzAHEzFBExAzwZsRMkE9gifKhc72ODYibr/+xcnoQdugq0LAujEwmbn0UxQh4OxpjX1XgshwFqLnPM5PQTQGlprWpbl3RhJ/CSQUm7qPYLp7i8cEpRSoJT6ju0lIaVEQgiKMQ4lHHpQayVjzHWCn5jIOcc8z9dMBADvPZxz3SC1tzCI8vgWdvL+VzwB8JSj2GFTyxIAAAAASUVORK5CYII=");
-}
-.annotationHTML.matchingBracket {
-	/* images/matchingBracket.png */
-	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sLEBUMAsuyb3kAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAoklEQVQ4y61TsQ3EIAw80DcI0USKGIApWIsB2IGGKbJPugxBR3VfvfRRCOSTvw7LPuPzGXgI8f0gwAsFu5rXIYMdDiEOIdnKW5YFzjnEGH+bhwA/KKVwmibu0BhRnpEZY1BrHTaVT7fQJZjnGeu63tOAJFNKVEox53yqQZfAWstt27oidgm01ve3UEqBaBjnspG89wgh3LiFgZXHt3Dh23/FGxKViehm0X85AAAAAElFTkSuQmCC");
-}
-.annotationHTML.currentLine {
-	/* images/currentLine.gif */
-	background-image: url("data:image/gif;base64,R0lGODlhEAAQAMQAALxe0bNWzbdZzrlb0KpPx61RybBTy6VLxadNxZGctIeUroyYsG92hHyMqIKRq2l9nmyAoHGDonaIpStXj6q80k1aXf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAABYALAAAAAAQABAAAAVCoCWOZGmeKDql5ppOMGXBk/zOoltSNO6XrlXwxIPNYiMGq8SoLC2MaNPygEQkDYdikUg6LQcEoWAICAaA5HPNLoUAADs=");
-}
-
-/* Styles for the overview ruler  */
-.annotationOverview {
-	cursor: pointer;
-	border-radius: 2px;
-	left: 2px;
-	width: 8px;
-}
-.annotationOverview.task {
-	background-color: lightgreen;
-	border: 1px solid green;
-}
-.annotationOverview.breakpoint {
-	background-color: lightblue;
-	border: 1px solid blue;
-}
-.annotationOverview.bookmark {
-	background-color: yellow;
-	border: 1px solid orange;
-}
-.annotationOverview.error {
-	background-color: lightcoral;
-	border: 1px solid darkred;
-}
-.annotationOverview.warning {
-	background-color: Gold;
-	border: 1px solid black;
-}
-.annotationOverview.currentBracket {
-	background-color: lightgray;
-	border: 1px solid red;
-}
-.annotationOverview.matchingBracket {
-	background-color: lightgray;
-	border: 1px solid red;
-}
-.annotationOverview.currentLine {
-	background-color: #EAF2FE;
-	border: 1px solid black;
-}
-
-/* Styles for text range */
-.annotationRange {
-	background-repeat: repeat-x;
- 	background-position: left bottom;
-}
-.annotationRange.task {
-	/* images/squiggly_task.png */
-	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sLDhEoIrb7JmcAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAGUlEQVQI12NggIH/DGdhDCM45z/DfyiBAADgdQjGhI/4DAAAAABJRU5ErkJggg==");
-}
-.annotationRange.breakpoint {
-	/* images/squiggly_breakpoint.png */
-	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sLDhEqHTKradgAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAIklEQVQI11XJMQ0AMAzAMGMafwrFlD19+sUKIJTFo9k+B/kQ+Qr2bIVKOgAAAABJRU5ErkJggg==");
-}
-.annotationRange.bookmark {
-	/* images/squiggly_bookmark.png */
-	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=");
-}
-.annotationRange.error {
-	/* images/squiggly_error.png */
-	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==");
-}
-.annotationRange.warning {
-	/* images/squiggly_warning.png */
-	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=");
-}
-.annotationRange.currentBracket {
-}
-.annotationRange.matchingBracket {
-	outline: 1px solid red;
-}
-
-/* Styles for lines of text */
-.annotationLine {
-}
-.annotationLine.currentLine {
-	background-color: #EAF2FE;
-}
-
-.token_singleline_comment {
+}/* Styles for the annotation ruler (all lines) */
+.annotation {
+}
+.annotation.error,
+.annotation.warning,
+.annotation.task,
+.annotation.bookmark,
+.annotation.breakpoint,
+.annotation.collapsed,
+.annotation.expanded, 
+.annotation.currentBracket, 
+.annotation.matchingBracket, 
+.annotation.currentLine, 
+.annotation.matchingSearch,  
+.annotation.currentSearch {
+}
+
+/* Styles for the annotation ruler (first line) */
+.annotationHTML {
+	cursor: pointer;
+	width: 16px;
+	height: 16px;
+	display: inline-block;
+	vertical-align: middle;
+	background-position: center;
+	background-repeat: no-repeat;
+}
+.annotationHTML.error {
+	/* images/error.gif */
+	background-image: url("data:image/gif;base64,R0lGODlhEAAQANUAAPVvcvWHiPVucvRuc+ttcfV6f91KVN5LU99PV/FZY/JhaM4oN84pONE4Rd1ATfJLWutVYPRgbdxpcsgWKMgZKs4lNfE/UvE/U+artcpdSc5uXveimslHPuBhW/eJhfV5efaCgO2CgP+/v+PExP///////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAACUALAAAAAAQABAAAAZ+wJJwSCwaScgkySgkjTQZTkYzWhadnE5oE+pwqkSshwQqkzxfa4kkQXxEpA9J9EFI1KQGQQBAigYCBA14ExEWF0gXihETeA0QD3AkD5QQg0NsDnAJmwkOd5gYFSQKpXAFDBhqaxgLBwQBBAapq00YEg0UDRKqTGtKSL7Cw8JBADs=");
+}
+.annotationHTML.warning {
+	/* images/warning.gif */
+	background-image: url("data:image/gif;base64,R0lGODlhEAAQANUAAP7bc//egf/ij/7ijv/jl/7kl//mnv7lnv/uwf7CTP7DTf7DT/7IW//Na/7Na//NbP7QdP/dmbltAIJNAF03AMSAJMSCLKqASa2DS6uBSquCSrGHTq6ETbCHT7WKUrKIUcCVXL+UXMOYX8GWXsSZYMiib6+ETbOIUcOXX86uhd3Muf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAACsALAAAAAAQABAAAAZowJVwSCwaj0ihikRSJYcoBEL0XKlGkcjImQQhJBREKFnyICoThKeE/AAW6AXgdPyUAgrLJBEo0YsbAQyDhAEdRRwDDw8OaA4NDQImRBgFEJdglxAEGEQZKQcHBqOkKRpFF6mqq1WtrUEAOw==");
+}
+.annotationHTML.task {
+	/* images/task.gif */
+	background-image: url("data:image/gif;base64,R0lGODlhEAAQAMQAAN7s4uTy6ICvY423c2WdP2ugR3mqWYeza2ejOl6VNVqPM1aJMURsJ2GaOnKlT8PbsbPDqGmmO1OCLk98LEhxKGWfOWKaN0t2KkJoJf///////wAAAAAAAAAAAAAAAAAAACH5BAEAABoALAAAAAAQABAAAAVmoCaOZDk+UaquDxkNcCxHJHLceI6QleD/vkCmQrIYjkiDMGAhJRzQ6NKRICkKgYJ2qVWQFktCmEBYkCSNZSbQaDckpAl5TCZMSBdtAaDXX0gUUYJRFCQMSYgGDCQQGI6PkBAmkyUhADs=");
+}
+.annotationHTML.bookmark {
+	/* images/bookmark.gif */
+	background-image: url("data:image/gif;base64,R0lGODlhEAAQALMAAP7//+/VNPzZS/vifeumAPrBOOSlHOSuRP///wAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAARLEMlJq5Xn3EvIrkenfRIhCB5pmKhRdbAJAGhssuc8n6eJoAKdkOaTAIdEQeWoA1oGsiZhYAnIcqiApVPjElyUbkFSgCkn5XElLYkAADs=");
+}
+.annotationHTML.breakpoint {
+	/* images/breakpoint.gif */
+	background-image: url("data:image/gif;base64,R0lGODlhEAAQANUAAFheoFxkoFxnpmt0pmZxpnF7rYyWwmJwpnaFs3aDrWt8rXGBrYycwmZ3mXuNs42cu77F03GIs3aJrYGVu2J5oKCuxeDj6LK/03GLrYieu3aIoIygu6m4zcLN3MTM1m6Rs2aLriRgkSZilXGXtoGcs7LD0QBLhSZikihol3ScubrO2Yaqu5q4xpO0wpm7yabF0ZO9yaXI0r3X3tHj6P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADQALAAAAAAQABAAAAafQJpwSCwWLYZBIDAwWIw0A+FFpW6aRUPCxe1yE4ahhdCCxWSzmSwGgxGeUceKpUqhUCkVa7UK0wgkJCUjJoUmIyWBBEIEGhoeJ4YmJx6OAUIADQ0QIZIhEJoAQgEUFBUgkiAVpZdRCxIPFx8iIh8XDw4FfhYHDhgZHB0dHBkYEwdwUQoTEc3OEwp+QwYHCBMMDBMIB9JESAJLAk5Q5EVBADs=");
+}
+.annotationHTML.collapsed {
+	/* images/collapsed.png */
+	width: 14px;
+	height: 14px;
+	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAWBJREFUeNpi/P//PwMlgImBQkCxASzoAp++fo+6de+Z+fXbD/Jev/nAICoiwKCpqrBBTUlqNR835zJ09YzIYfDxy7eo/cevLmXlYGNQUJAEahZieP3mHcODB08Zfv/4w+BoqR3Nz8O1DKcXzt94HPqXmZlBU1+LgZNfkMHazIOBA0hr6uswgMTP33gYijcMLlx/EMAnLs7w7sc/hg9AG0HgPZB+B8S84hJA+UcBeMPg+at3DJIMnAxZzt5wsUhnXzDdsmIVWB6vAcLCfAys3z4wzN64huEfkJ/uH8IwexOQDQymD2/fgeXxekFLRWHD51evGDhZGRi4WSFSnCwgNjB2Xr1m0AbK4zXAQkdhNdPf3wx3r91g+PruLcOqnasYvn54x3Dv2k0G5r+/GMyB8nijEQTefvoadeH6w9Cbtx8GvH//kUFQkJ9BQ1V+g76m/GphPu5lBA0YenmBYgMAAgwA34GIKjmLxOUAAAAASUVORK5CYII=");
+}
+.annotationHTML.expanded {
+	/* images/expanded.png */
+	width: 14px;
+	height: 14px;	
+	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAT5JREFUeNrUksFKw0AURW+mTWw67SSEiG209U90r4jddFO34l+5U0HdZCHiFwiCOz9AlMSmGEpMOqk1TWJSFGyFbATR2dyZd+Dw3mOENE3xkyP8PYHrBT3OX7uW43ZefA6FUaw1dJPSyrmu1k8KBYOh37Od4XFZLEPXFdRrFMGIw3U9TKMYqw1tb0VjcxLy9eEF425CCIxWE5JcxSQGxCyNloG87gXhwWIHc4J767lTZQw8ShFGSZbxRyaQmZJxd3NRUJ6ffwQNEi6PzG/L2tjdmvFCgcKqKL2F2Olu43MzggDka+IjPuOFI7Sbujn2fUglYKkkzFIi+R0I/QDrGS8UqDX5QkhiOHYfE84hkhSTkGNgOyDJFCzjhYLTq+vDtrG8r1LZtB6fcHtzB+uhD5VWzLx+lvF/8JV/XfAuwADsrJbMGG4l4AAAAABJRU5ErkJggg==");
+}
+.annotationHTML.multiple {
+	/* images/multiple.gif */
+	background-image: url("data:image/gif;base64,R0lGODlhEAAQANUAAOdpa+yJiuFYXOFYXeBYXONwded8f+NwdmhwkHB4iPr7/ezx+fP2+2h4kOzy+Wh4iPr8/gCBwTaczjaXyjaYyjaXyTaYyfr8/QCMzQCMzACHxzao2jal2Dak1zag03iAgI/Ckn64fZrHmX+4fZLCianPopPCiarOoqbLlafLlbnXq7nWq6fLlMTcsoCIeJCQcIiIeKCYaJiQcO16ee16evGVlfGWlfahn/ahoPWhn/WhoPe1tP///////wAAAAAAACH5BAEAAD0ALAAAAAAQABAAAAaRwJ5wSCwaj8WYcslcDmObaDTGq1Zjzw4mk+FQIRcFTzaUeTRoj4zHaI+HL0lkLnnxFgsH7zWEWSoTFBMwVlUwQy6JMDCJjYwuQx8tk5MfOzk4OjcfkSssKCkqHzY0MzQ1nEIJJSYkJCcJAQCzAQlDDyIjISMiCQYEAgMGD0MNIMfHDQUHBc3EQgjR0tPSSNY9QQA7");
+}
+.annotationHTML.overlay {
+	/* images/plus.png */
+	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAAXNSR0IArs4c6QAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJEAQvB2JVdrAAAAAdaVRYdENvbW1lbnQAAAAAAENyZWF0ZWQgd2l0aCBHSU1QZC5lBwAAAD1JREFUCNdtjkESADAEAzemf69f66HMqGlOIhYiFRFRtSQBWAY7mzx+EDTL6sSgb1jTk7Q87rxyqe37fXsAa78gLyZnRgEAAAAASUVORK5CYII=");
+	background-position: right bottom;
+	position: relative;
+	top: -16px;
+}
+.annotationHTML.currentBracket {
+	/* images/currentBracket.png */
+	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sLEBULCGQmEKAAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAnklEQVQ4y7VTsRHDIBATJg1HCUzAHEzFBExAzwZsRMkE9gifKhc72ODYibr/+xcnoQdugq0LAujEwmbn0UxQh4OxpjX1XgshwFqLnPM5PQTQGlprWpbl3RhJ/CSQUm7qPYLp7i8cEpRSoJT6ju0lIaVEQgiKMQ4lHHpQayVjzHWCn5jIOcc8z9dMBADvPZxz3SC1tzCI8vgWdvL+VzwB8JSj2GFTyxIAAAAASUVORK5CYII=");
+}
+.annotationHTML.matchingBracket {
+	/* images/matchingBracket.png */
+	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sLEBUMAsuyb3kAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAoklEQVQ4y61TsQ3EIAw80DcI0USKGIApWIsB2IGGKbJPugxBR3VfvfRRCOSTvw7LPuPzGXgI8f0gwAsFu5rXIYMdDiEOIdnKW5YFzjnEGH+bhwA/KKVwmibu0BhRnpEZY1BrHTaVT7fQJZjnGeu63tOAJFNKVEox53yqQZfAWstt27oidgm01ve3UEqBaBjnspG89wgh3LiFgZXHt3Dh23/FGxKViehm0X85AAAAAElFTkSuQmCC");
+}
+.annotationHTML.currentLine {
+	/* images/currentLine.gif */
+	background-image: url("data:image/gif;base64,R0lGODlhEAAQAMQAALxe0bNWzbdZzrlb0KpPx61RybBTy6VLxadNxZGctIeUroyYsG92hHyMqIKRq2l9nmyAoHGDonaIpStXj6q80k1aXf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAABYALAAAAAAQABAAAAVCoCWOZGmeKDql5ppOMGXBk/zOoltSNO6XrlXwxIPNYiMGq8SoLC2MaNPygEQkDYdikUg6LQcEoWAICAaA5HPNLoUAADs=");
+}
+.annotationHTML.matchingSearch {
+	/* images/search.gif */
+	background-image: url("data:image/gif;base64,R0lGODlhEAAQANUAALClrLu1ubOpsKqdp6eapKufqMTAw7attLSrsrGnr62jq8C7v765vaebpb22vLmyuMbCxsnGycfEx8G+wcrIysTBxUltof//yf///v70jergpPvws+nWc/npqvrpqvrpq/raffffnvXVkfTVkvXUkd+9f+SiOemvV+uyXa2OX7mYZqeIXKuNX/ClO7KQYqiIXJ59Vp19VpFvTo9uTZBvTpNyUJNyUf///////wAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADgALAAAAAAQABAAAAZ4QJxwSCwajS2aS1U6DlunzcagcuKgG4sn5HJiLZ2QiHbEbj6hEapVTKVYr3OItG5TIhVGLF0npigUEAsPAjV9Q24pEhMBCAoybEUmGRcrDgcAAzNGkxcYNzAJBQSbRJ0YqBc2DaVEHJ6pGTStRBqfGBcZILRWvThBADs=");
+}
+.annotationHTML.currentSearch {
+	/* images/search.gif */
+	background-image: url("data:image/gif;base64,R0lGODlhEAAQANUAALClrLu1ubOpsKqdp6eapKufqMTAw7attLSrsrGnr62jq8C7v765vaebpb22vLmyuMbCxsnGycfEx8G+wcrIysTBxUltof//yf///v70jergpPvws+nWc/npqvrpqvrpq/raffffnvXVkfTVkvXUkd+9f+SiOemvV+uyXa2OX7mYZqeIXKuNX/ClO7KQYqiIXJ59Vp19VpFvTo9uTZBvTpNyUJNyUf///////wAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADgALAAAAAAQABAAAAZ4QJxwSCwajS2aS1U6DlunzcagcuKgG4sn5HJiLZ2QiHbEbj6hEapVTKVYr3OItG5TIhVGLF0npigUEAsPAjV9Q24pEhMBCAoybEUmGRcrDgcAAzNGkxcYNzAJBQSbRJ0YqBc2DaVEHJ6pGTStRBqfGBcZILRWvThBADs=");
+}
+
+/* Styles for the overview ruler  */
+.annotationOverview {
+	cursor: pointer;
+	border-radius: 2px;
+	left: 2px;
+	width: 8px;
+}
+.annotationOverview.task {
+	background-color: lightgreen;
+	border: 1px solid green;
+}
+.annotationOverview.breakpoint {
+	background-color: lightblue;
+	border: 1px solid blue;
+}
+.annotationOverview.bookmark {
+	background-color: yellow;
+	border: 1px solid orange;
+}
+.annotationOverview.error {
+	background-color: lightcoral;
+	border: 1px solid darkred;
+}
+.annotationOverview.warning {
+	background-color: Gold;
+	border: 1px solid black;
+}
+.annotationOverview.currentBracket {
+	background-color: lightgray;
+	border: 1px solid red;
+}
+.annotationOverview.matchingBracket {
+	background-color: lightgray;
+	border: 1px solid red;
+}
+.annotationOverview.currentLine {
+	background-color: #EAF2FE;
+	border: 1px solid black;
+}
+.annotationOverview.matchingSearch {
+	background-color: #C3E1FF;
+	border: 1px solid black;
+}
+.annotationOverview.currentSearch {
+	background-color: #53D1FF;
+	border: 1px solid black;
+}
+
+/* Styles for text range */
+.annotationRange {
+	background-repeat: repeat-x;
+ 	background-position: left bottom;
+}
+.annotationRange.task {
+	/* images/squiggly_task.png */
+	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sLDhEoIrb7JmcAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAGUlEQVQI12NggIH/DGdhDCM45z/DfyiBAADgdQjGhI/4DAAAAABJRU5ErkJggg==");
+}
+.annotationRange.breakpoint {
+	/* images/squiggly_breakpoint.png */
+	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sLDhEqHTKradgAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAIklEQVQI11XJMQ0AMAzAMGMafwrFlD19+sUKIJTFo9k+B/kQ+Qr2bIVKOgAAAABJRU5ErkJggg==");
+}
+.annotationRange.bookmark {
+	/* images/squiggly_bookmark.png */
+	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=");
+}
+.annotationRange.error {
+	/* images/squiggly_error.png */
+	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==");
+}
+.annotationRange.warning {
+	/* images/squiggly_warning.png */
+	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=");
+}
+.annotationRange.currentBracket {
+}
+.annotationRange.matchingBracket {
+	outline: 1px solid red;
+}
+.annotationRange.currentSearch {
+	background-color: #53D1FF;
+}
+.annotationRange.matchingSearch {
+	background-color: #C3E1FF;
+}
+.annotationRange.currentSearch {
+	background-color: #53D1FF;
+}
+
+/* Styles for lines of text */
+.annotationLine {
+}
+.annotationLine.currentLine {
+	background-color: #EAF2FE;
+}
+
+.tooltip .textview {
+	color: InfoText !important;
+	background-color: InfoBackground !important;
+	padding: 0px;
+}
+
+/* Styles for the view tooltips */
+.textviewTooltip {
+	font-family: monospace;
+	font-size: 10pt;
+	background-color: InfoBackground;
+	color: InfoText;
+	padding: 2px;
+	border-radius: 4px;
+	border: 1px solid black;
+	z-index: 100;
+	position: fixed;
+	overflow: hidden;
+	white-space: pre;
+}
+.textviewTooltip em {
+	font-style: normal;
+	font-weight: bold;
+}.token_singleline_comment {
 	color: green;
 }
 
 .token_multiline_comment {
 	color: green;
 }
 
 .token_doc_comment {
@@ -221,16 +271,20 @@
 .token_task_tag {
 	color: #7F9FBF;
 }
 
 .token_string {
 	color: blue;
 }
 
+.token_number {
+	color: blue;
+}
+
 .token_keyword {
 	color: darkred;
 	font-weight: bold;
 }
 
 .token_space {
 	/* images/white_space.png */
 	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAIAAABv85FHAAAABnRSTlMA/wAAAACkwsAdAAAAIUlEQVR4nGP4z8CAC+GUIEXuABhgkTuABEiRw2cmae4EAH05X7xDolNRAAAAAElFTkSuQmCC");
diff --git a/browser/devtools/sourceeditor/orion/orion.js b/browser/devtools/sourceeditor/orion/orion.js
--- a/browser/devtools/sourceeditor/orion/orion.js
+++ b/browser/devtools/sourceeditor/orion/orion.js
@@ -1,234 +1,3570 @@
+function initializeOrion() {
 /*******************************************************************************
  * @license
  * Copyright (c) 2010, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials are made 
  * available under the terms of the Eclipse Public License v1.0 
  * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
  * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
  * 
- * Contributors: 
- *		Felipe Heidrich (IBM Corporation) - initial API and implementation
- *		Silenio Quarti (IBM Corporation) - initial API and implementation
- *		Mihai Sucan (Mozilla Foundation) - fix for Bug#364214
- */
-
-/*global window */
-
-/**
- * Evaluates the definition function and mixes in the returned module with
- * the module specified by <code>moduleName</code>.
- * <p>
- * This function is intented to by used when RequireJS is not available.
- * </p>
- *
- * @param {String} name The mixin module name.
- * @param {String[]} deps The array of dependency names.
- * @param {Function} callback The definition function.
- */
-if (!window.define) {
-	window.define = function(name, deps, callback) {
-		var module = this;
-		var split = (name || "").split("/"), i, j;
-		for (i = 0; i < split.length - 1; i++) {
-			module = module[split[i]] = (module[split[i]] || {});
-		}
-		var depModules = [], depModule;
-		for (j = 0; j < deps.length; j++) {
-			depModule = this;
-			split = deps[j].split("/");
-			for (i = 0; i < split.length - 1; i++) {
-				depModule = depModule[split[i]] = (depModule[split[i]] || {});
-			}
-			depModules.push(depModule);
-		}
-		var newModule = callback.apply(this, depModules);
-		for (var p in newModule) {
-			if (newModule.hasOwnProperty(p)) {
-				module[p] = newModule[p];
-			}
+ * Contributors: IBM Corporation - initial API and implementation
+ *               Alex Lakatos - fix for bug#369781
+ ******************************************************************************/
+
+/*global document window navigator define */
+
+define("examples/textview/textStyler", ['orion/textview/annotations'], function(mAnnotations) {
+
+	var JS_KEYWORDS =
+		["break",
+		 "case", "class", "catch", "continue", "const", 
+		 "debugger", "default", "delete", "do",
+		 "else", "enum", "export", "extends",  
+		 "false", "finally", "for", "function",
+		 "if", "implements", "import", "in", "instanceof", "interface", 
+		 "let",
+		 "new", "null",
+		 "package", "private", "protected", "public",
+		 "return", 
+		 "static", "super", "switch",
+		 "this", "throw", "true", "try", "typeof",
+		 "undefined",
+		 "var", "void",
+		 "while", "with",
+		 "yield"];
+
+	var JAVA_KEYWORDS =
+		["abstract",
+		 "boolean", "break", "byte",
+		 "case", "catch", "char", "class", "continue",
+		 "default", "do", "double",
+		 "else", "extends",
+		 "false", "final", "finally", "float", "for",
+		 "if", "implements", "import", "instanceof", "int", "interface",
+		 "long",
+		 "native", "new", "null",
+		 "package", "private", "protected", "public",
+		 "return",
+		 "short", "static", "super", "switch", "synchronized",
+		 "this", "throw", "throws", "transient", "true", "try",
+		 "void", "volatile",
+		 "while"];
+
+	var CSS_KEYWORDS =
+		["alignment-adjust", "alignment-baseline", "animation", "animation-delay", "animation-direction", "animation-duration",
+		 "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance",
+		 "azimuth", "backface-visibility", "background", "background-attachment", "background-clip", "background-color",
+		 "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift",
+		 "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom",
+		 "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width",
+		 "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice",
+		 "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width",
+		 "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style",
+		 "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width",
+		 "border-width", "bottom", "box-align", "box-decoration-break", "box-direction", "box-flex", "box-flex-group", "box-lines",
+		 "box-ordinal-group", "box-orient", "box-pack", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
+		 "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule",
+		 "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment",
+		 "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline",
+		 "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size",
+		 "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex-align", "flex-flow", "flex-inline-pack", "flex-order",
+		 "flex-pack", "float", "float-offset", "font", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style",
+		 "font-variant", "font-weight", "grid-columns", "grid-rows", "hanging-punctuation", "height", "hyphenate-after",
+		 "hyphenate-before", "hyphenate-character", "hyphenate-lines", "hyphenate-resource", "hyphens", "icon", "image-orientation",
+		 "image-rendering", "image-resolution", "inline-box-align", "left", "letter-spacing", "line-height", "line-stacking",
+		 "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position",
+		 "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "mark", "mark-after", "mark-before",
+		 "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
+		 "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "opacity", "orphans",
+		 "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-x",
+		 "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before",
+		 "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "phonemes", "pitch",
+		 "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "rendering-intent", "resize",
+		 "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position",
+		 "ruby-span", "size", "speak", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "table-layout",
+		 "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-emphasis",
+		 "text-height", "text-indent", "text-justify", "text-outline", "text-shadow", "text-transform", "text-wrap", "top", "transform",
+		 "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property",
+		 "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family",
+		 "voice-pitch", "voice-pitch-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "white-space-collapse",
+		 "widows", "width", "word-break", "word-spacing", "word-wrap", "z-index"
+		];
+
+	// Scanner constants
+	var UNKOWN = 1;
+	var KEYWORD = 2;
+	var NUMBER = 3;
+	var STRING = 4;
+	var SINGLELINE_COMMENT = 5;
+	var MULTILINE_COMMENT = 6;
+	var DOC_COMMENT = 7;
+	var WHITE = 8;
+	var WHITE_TAB = 9;
+	var WHITE_SPACE = 10;
+	var HTML_MARKUP = 11;
+	var DOC_TAG = 12;
+	var TASK_TAG = 13;
+
+	// Styles 
+	var singleCommentStyle = {styleClass: "token_singleline_comment"};
+	var multiCommentStyle = {styleClass: "token_multiline_comment"};
+	var docCommentStyle = {styleClass: "token_doc_comment"};
+	var htmlMarkupStyle = {styleClass: "token_doc_html_markup"};
+	var tasktagStyle = {styleClass: "token_task_tag"};
+	var doctagStyle = {styleClass: "token_doc_tag"};
+	var stringStyle = {styleClass: "token_string"};
+	var numberStyle = {styleClass: "token_number"};
+	var keywordStyle = {styleClass: "token_keyword"};
+	var spaceStyle = {styleClass: "token_space"};
+	var tabStyle = {styleClass: "token_tab"};
+	var caretLineStyle = {styleClass: "line_caret"};
+	
+	function Scanner (keywords, whitespacesVisible) {
+		this.keywords = keywords;
+		this.whitespacesVisible = whitespacesVisible;
+		this.setText("");
+	}
+	
+	Scanner.prototype = {
+		getOffset: function() {
+			return this.offset;
+		},
+		getStartOffset: function() {
+			return this.startOffset;
+		},
+		getData: function() {
+			return this.text.substring(this.startOffset, this.offset);
+		},
+		getDataLength: function() {
+			return this.offset - this.startOffset;
+		},
+		_default: function(c) {
+			switch (c) {
+				case 32: // SPACE
+				case 9: // TAB
+					if (this.whitespacesVisible) {
+						return c === 32 ? WHITE_SPACE : WHITE_TAB;
+					}
+					do {
+						c = this._read();
+					} while(c === 32 || c === 9);
+					this._unread(c);
+					return WHITE;
+				case 123: // {
+				case 125: // }
+				case 40: // (
+				case 41: // )
+				case 91: // [
+				case 93: // ]
+				case 60: // <
+				case 62: // >
+					// BRACKETS
+					return c;
+				default:
+					var isCSS = this.isCSS;
+					var off = this.offset - 1;
+					if (48 <= c && c <= 57) {
+						var floating = false, exponential = false, hex = false, firstC = c;
+						do {
+							c = this._read();
+							if (c === 46 /* dot */ && !floating) {
+								floating = true;
+							} else if (c === 101 /* e */ && !exponential) {
+								floating = exponential = true;
+								c = this._read();
+								if (c !== 45 /* MINUS */) {
+									this._unread(c);
+								}
+							} else if (c === 120 /* x */ && firstC === 48 && (this.offset - off === 2)) {
+								floating = exponential = hex = true;
+							} else if (!(48 <= c && c <= 57 || (hex && ((65 <= c && c <= 70) || (97 <= c && c <= 102))))) { //NUMBER DIGIT or HEX
+								break;
+							}
+						} while(true);
+						this._unread(c);
+						return NUMBER;
+					}
+					if ((97 <= c && c <= 122) || (65 <= c && c <= 90) || c === 95 || (45 /* DASH */ === c && isCSS)) { //LETTER OR UNDERSCORE OR NUMBER
+						do {
+							c = this._read();
+						} while((97 <= c && c <= 122) || (65 <= c && c <= 90) || c === 95 || (48 <= c && c <= 57) || (45 /* DASH */ === c && isCSS));  //LETTER OR UNDERSCORE OR NUMBER
+						this._unread(c);
+						var keywords = this.keywords;
+						if (keywords.length > 0) {
+							var word = this.text.substring(off, this.offset);
+							//TODO slow
+							for (var i=0; i<keywords.length; i++) {
+								if (this.keywords[i] === word) { return KEYWORD; }
+							}
+						}
+					}
+					return UNKOWN;
+			}
+		},
+		_read: function() {
+			if (this.offset < this.text.length) {
+				return this.text.charCodeAt(this.offset++);
+			}
+			return -1;
+		},
+		_unread: function(c) {
+			if (c !== -1) { this.offset--; }
+		},
+		nextToken: function() {
+			this.startOffset = this.offset;
+			while (true) {
+				var c = this._read();
+				switch (c) {
+					case -1: return null;
+					case 47:	// SLASH -> comment
+						c = this._read();
+						if (!this.isCSS) {
+							if (c === 47) { // SLASH -> single line
+								while (true) {
+									c = this._read();
+									if ((c === -1) || (c === 10) || (c === 13)) {
+										this._unread(c);
+										return SINGLELINE_COMMENT;
+									}
+								}
+							}
+						}
+						if (c === 42) { // STAR -> multi line 
+							c = this._read();
+							var token = MULTILINE_COMMENT;
+							if (c === 42) {
+								token = DOC_COMMENT;
+							}
+							while (true) {
+								while (c === 42) {
+									c = this._read();
+									if (c === 47) {
+										return token;
+									}
+								}
+								if (c === -1) {
+									this._unread(c);
+									return token;
+								}
+								c = this._read();
+							}
+						}
+						this._unread(c);
+						return UNKOWN;
+					case 39:	// SINGLE QUOTE -> char const
+						while(true) {
+							c = this._read();
+							switch (c) {
+								case 39:
+									return STRING;
+								case 13:
+								case 10:
+								case -1:
+									this._unread(c);
+									return STRING;
+								case 92: // BACKSLASH
+									c = this._read();
+									break;
+							}
+						}
+						break;
+					case 34:	// DOUBLE QUOTE -> string
+						while(true) {
+							c = this._read();
+							switch (c) {
+								case 34: // DOUBLE QUOTE
+									return STRING;
+								case 13:
+								case 10:
+								case -1:
+									this._unread(c);
+									return STRING;
+								case 92: // BACKSLASH
+									c = this._read();
+									break;
+							}
+						}
+						break;
+					default:
+						return this._default(c);
+				}
+			}
+		},
+		setText: function(text) {
+			this.text = text;
+			this.offset = 0;
+			this.startOffset = 0;
 		}
 	};
-}
-
-/**
- * Require/get the defined modules.
- * <p>
- * This function is intented to by used when RequireJS is not available.
- * </p>
- *
- * @param {String[]|String} deps The array of dependency names. This can also be
- * a string, a single dependency name.
- * @param {Function} [callback] Optional, the callback function to execute when
- * multiple dependencies are required. The callback arguments will have
- * references to each module in the same order as the deps array.
- * @returns {Object|undefined} If the deps parameter is a string, then this
- * function returns the required module definition, otherwise undefined is
- * returned.
- */
-if (!window.require) {
-	window.require = function(deps, callback) {
-		var depsArr = typeof deps === "string" ? [deps] : deps;
-		var depModules = [], depModule, split, i, j;
-		for (j = 0; j < depsArr.length; j++) {
-			depModule = this;
-			split = depsArr[j].split("/");
-			for (i = 0; i < split.length - 1; i++) {
-				depModule = depModule[split[i]] = (depModule[split[i]] || {});
-			}
-			depModules.push(depModule);
+	
+	function WhitespaceScanner () {
+		Scanner.call(this, null, true);
+	}
+	WhitespaceScanner.prototype = new Scanner(null);
+	WhitespaceScanner.prototype.nextToken = function() {
+		this.startOffset = this.offset;
+		while (true) {
+			var c = this._read();
+			switch (c) {
+				case -1: return null;
+				case 32: // SPACE
+					return WHITE_SPACE;
+				case 9: // TAB
+					return WHITE_TAB;
+				default:
+					do {
+						c = this._read();
+					} while(!(c === 32 || c === 9 || c === -1));
+					this._unread(c);
+					return UNKOWN;
+			}
 		}
-		if (callback) {
-			callback.apply(this, depModules);
+	};
+	
+	function CommentScanner (whitespacesVisible) {
+		Scanner.call(this, null, whitespacesVisible);
+	}
+	CommentScanner.prototype = new Scanner(null);
+	CommentScanner.prototype.setType = function(type) {
+		this._type = type;
+	};
+	CommentScanner.prototype.nextToken = function() {
+		this.startOffset = this.offset;
+		while (true) {
+			var c = this._read();
+			switch (c) {
+				case -1: return null;
+				case 32: // SPACE
+				case 9: // TAB
+					if (this.whitespacesVisible) {
+						return c === 32 ? WHITE_SPACE : WHITE_TAB;
+					}
+					do {
+						c = this._read();
+					} while(c === 32 || c === 9);
+					this._unread(c);
+					return WHITE;
+				case 60: // <
+					if (this._type === DOC_COMMENT) {
+						do {
+							c = this._read();
+						} while(!(c === 62 || c === -1)); // >
+						if (c === 62) {
+							return HTML_MARKUP;
+						}
+					}
+					return UNKOWN;
+				case 64: // @
+					if (this._type === DOC_COMMENT) {
+						do {
+							c = this._read();
+						} while((97 <= c && c <= 122) || (65 <= c && c <= 90) || c === 95 || (48 <= c && c <= 57));  //LETTER OR UNDERSCORE OR NUMBER
+						this._unread(c);
+						return DOC_TAG;
+					}
+					return UNKOWN;
+				case 84: // T
+					if ((c = this._read()) === 79) { // O
+						if ((c = this._read()) === 68) { // D
+							if ((c = this._read()) === 79) { // O
+								c = this._read();
+								if (!((97 <= c && c <= 122) || (65 <= c && c <= 90) || c === 95 || (48 <= c && c <= 57))) {
+									this._unread(c);
+									return TASK_TAG;
+								}
+								this._unread(c);
+							} else {
+								this._unread(c);
+							}
+						} else {
+							this._unread(c);
+						}
+					} else {
+						this._unread(c);
+					}
+					//FALL THROUGH
+				default:
+					do {
+						c = this._read();
+					} while(!(c === 32 || c === 9 || c === -1 || c === 60 || c === 64 || c === 84));
+					this._unread(c);
+					return UNKOWN;
+			}
 		}
-		return typeof deps === "string" ? depModules[0] : undefined;
 	};
-}/*******************************************************************************
- * Copyright (c) 2010, 2011 IBM Corporation and others.
+	
+	function FirstScanner () {
+		Scanner.call(this, null, false);
+	}
+	FirstScanner.prototype = new Scanner(null);
+	FirstScanner.prototype._default = function(c) {
+		while(true) {
+			c = this._read();
+			switch (c) {
+				case 47: // SLASH
+				case 34: // DOUBLE QUOTE
+				case 39: // SINGLE QUOTE
+				case -1:
+					this._unread(c);
+					return UNKOWN;
+			}
+		}
+	};
+	
+	function TextStyler (view, lang, annotationModel) {
+		this.commentStart = "/*";
+		this.commentEnd = "*/";
+		var keywords = [];
+		switch (lang) {
+			case "java": keywords = JAVA_KEYWORDS; break;
+			case "js": keywords = JS_KEYWORDS; break;
+			case "css": keywords = CSS_KEYWORDS; break;
+		}
+		this.whitespacesVisible = false;
+		this.detectHyperlinks = true;
+		this.highlightCaretLine = false;
+		this.foldingEnabled = true;
+		this.detectTasks = true;
+		this._scanner = new Scanner(keywords, this.whitespacesVisible);
+		this._firstScanner = new FirstScanner();
+		this._commentScanner = new CommentScanner(this.whitespacesVisible);
+		this._whitespaceScanner = new WhitespaceScanner();
+		//TODO these scanners are not the best/correct way to parse CSS
+		if (lang === "css") {
+			this._scanner.isCSS = true;
+			this._firstScanner.isCSS = true;
+		}
+		this.view = view;
+		this.annotationModel = annotationModel;
+		this._bracketAnnotations = undefined; 
+		
+		var self = this;
+		this._listener = {
+			onChanged: function(e) {
+				self._onModelChanged(e);
+			},
+			onDestroy: function(e) {
+				self._onDestroy(e);
+			},
+			onLineStyle: function(e) {
+				self._onLineStyle(e);
+			},
+			onSelection: function(e) {
+				self._onSelection(e);
+			}
+		};
+		var model = view.getModel();
+		if (model.getBaseModel) {
+			model.getBaseModel().addEventListener("Changed", this._listener.onChanged);
+		} else {
+			//TODO still needed to keep the event order correct (styler before view)
+			view.addEventListener("ModelChanged", this._listener.onChanged);
+		}
+		view.addEventListener("Selection", this._listener.onSelection);
+		view.addEventListener("Destroy", this._listener.onDestroy);
+		view.addEventListener("LineStyle", this._listener.onLineStyle);
+		this._computeComments ();
+		this._computeFolding();
+		view.redrawLines();
+	}
+	
+	TextStyler.prototype = {
+		getClassNameForToken: function(token) {
+			switch (token) {
+				case "singleLineComment": return singleCommentStyle.styleClass;
+				case "multiLineComment": return multiCommentStyle.styleClass;
+				case "docComment": return docCommentStyle.styleClass;
+				case "docHtmlComment": return htmlMarkupStyle.styleClass;
+				case "tasktag": return tasktagStyle.styleClass;
+				case "doctag": return doctagStyle.styleClass;
+				case "string": return stringStyle.styleClass;
+				case "number": return numberStyle.styleClass;
+				case "keyword": return keywordStyle.styleClass;
+				case "space": return spaceStyle.styleClass;
+				case "tab": return tabStyle.styleClass;
+				case "caretLine": return caretLineStyle.styleClass;
+			}
+			return null;
+		},
+		destroy: function() {
+			var view = this.view;
+			if (view) {
+				var model = view.getModel();
+				if (model.getBaseModel) {
+					model.getBaseModel().removeEventListener("Changed", this._listener.onChanged);
+				} else {
+					view.removeEventListener("ModelChanged", this._listener.onChanged);
+				}
+				view.removeEventListener("Selection", this._listener.onSelection);
+				view.removeEventListener("Destroy", this._listener.onDestroy);
+				view.removeEventListener("LineStyle", this._listener.onLineStyle);
+				this.view = null;
+			}
+		},
+		setHighlightCaretLine: function(highlight) {
+			this.highlightCaretLine = highlight;
+		},
+		setWhitespacesVisible: function(visible) {
+			this.whitespacesVisible = visible;
+			this._scanner.whitespacesVisible = visible;
+			this._commentScanner.whitespacesVisible = visible;
+		},
+		setDetectHyperlinks: function(enabled) {
+			this.detectHyperlinks = enabled;
+		},
+		setFoldingEnabled: function(enabled) {
+			this.foldingEnabled = enabled;
+		},
+		setDetectTasks: function(enabled) {
+			this.detectTasks = enabled;
+		},
+		_binarySearch: function (array, offset, inclusive, low, high) {
+			var index;
+			if (low === undefined) { low = -1; }
+			if (high === undefined) { high = array.length; }
+			while (high - low > 1) {
+				index = Math.floor((high + low) / 2);
+				if (offset <= array[index].start) {
+					high = index;
+				} else if (inclusive && offset < array[index].end) {
+					high = index;
+					break;
+				} else {
+					low = index;
+				}
+			}
+			return high;
+		},
+		_computeComments: function() {
+			var model = this.view.getModel();
+			if (model.getBaseModel) { model = model.getBaseModel(); }
+			this.comments = this._findComments(model.getText());
+		},
+		_computeFolding: function() {
+			if (!this.foldingEnabled) { return; }
+			var view = this.view;
+			var viewModel = view.getModel();
+			if (!viewModel.getBaseModel) { return; }
+			var annotationModel = this.annotationModel;
+			if (!annotationModel) { return; }
+			annotationModel.removeAnnotations(mAnnotations.AnnotationType.ANNOTATION_FOLDING);
+			var add = [];
+			var baseModel = viewModel.getBaseModel();
+			var comments = this.comments;
+			for (var i=0; i<comments.length; i++) {
+				var comment = comments[i];
+				var annotation = this._createFoldingAnnotation(viewModel, baseModel, comment.start, comment.end);
+				if (annotation) { 
+					add.push(annotation);
+				}
+			}
+			annotationModel.replaceAnnotations(null, add);
+		},
+		_createFoldingAnnotation: function(viewModel, baseModel, start, end) {
+			var startLine = baseModel.getLineAtOffset(start);
+			var endLine = baseModel.getLineAtOffset(end);
+			if (startLine === endLine) {
+				return null;
+			}
+			return new (mAnnotations.AnnotationType.getType(mAnnotations.AnnotationType.ANNOTATION_FOLDING))(start, end, viewModel);
+		},
+		_computeTasks: function(type, commentStart, commentEnd) {
+			if (!this.detectTasks) { return; }
+			var annotationModel = this.annotationModel;
+			if (!annotationModel) { return; }
+			var view = this.view;
+			var viewModel = view.getModel(), baseModel = viewModel;
+			if (viewModel.getBaseModel) { baseModel = viewModel.getBaseModel(); }
+			var annotations = annotationModel.getAnnotations(commentStart, commentEnd);
+			var remove = [];
+			var annotationType = mAnnotations.AnnotationType.ANNOTATION_TASK;
+			while (annotations.hasNext()) {
+				var annotation = annotations.next();
+				if (annotation.type === annotationType) {
+					remove.push(annotation);
+				}
+			}
+			var add = [];
+			var scanner = this._commentScanner;
+			scanner.setText(baseModel.getText(commentStart, commentEnd));
+			var token;
+			while ((token = scanner.nextToken())) {
+				var tokenStart = scanner.getStartOffset() + commentStart;
+				if (token === TASK_TAG) {
+					var end = baseModel.getLineEnd(baseModel.getLineAtOffset(tokenStart));
+					if (type !== SINGLELINE_COMMENT) {
+						end = Math.min(end, commentEnd - this.commentEnd.length);
+					}
+					add.push(mAnnotations.AnnotationType.createAnnotation(annotationType, tokenStart, end, baseModel.getText(tokenStart, end)));
+				}
+			}
+			annotationModel.replaceAnnotations(remove, add);
+		},
+		_getLineStyle: function(lineIndex) {
+			if (this.highlightCaretLine) {
+				var view = this.view;
+				var model = view.getModel();
+				var selection = view.getSelection();
+				if (selection.start === selection.end && model.getLineAtOffset(selection.start) === lineIndex) {
+					return caretLineStyle;
+				}
+			}
+			return null;
+		},
+		_getStyles: function(model, text, start) {
+			if (model.getBaseModel) {
+				start = model.mapOffset(start);
+			}
+			var end = start + text.length;
+			
+			var styles = [];
+			
+			// for any sub range that is not a comment, parse code generating tokens (keywords, numbers, brackets, line comments, etc)
+			var offset = start, comments = this.comments;
+			var startIndex = this._binarySearch(comments, start, true);
+			for (var i = startIndex; i < comments.length; i++) {
+				if (comments[i].start >= end) { break; }
+				var commentStart = comments[i].start;
+				var commentEnd = comments[i].end;
+				if (offset < commentStart) {
+					this._parse(text.substring(offset - start, commentStart - start), offset, styles);
+				}
+				var style = comments[i].type === DOC_COMMENT ? docCommentStyle : multiCommentStyle;
+				if (this.whitespacesVisible || this.detectHyperlinks) {
+					var s = Math.max(offset, commentStart);
+					var e = Math.min(end, commentEnd);
+					this._parseComment(text.substring(s - start, e - start), s, styles, style, comments[i].type);
+				} else {
+					styles.push({start: commentStart, end: commentEnd, style: style});
+				}
+				offset = commentEnd;
+			}
+			if (offset < end) {
+				this._parse(text.substring(offset - start, end - start), offset, styles);
+			}
+			if (model.getBaseModel) {
+				for (var j = 0; j < styles.length; j++) {
+					var length = styles[j].end - styles[j].start;
+					styles[j].start = model.mapOffset(styles[j].start, true);
+					styles[j].end = styles[j].start + length;
+				}
+			}
+			return styles;
+		},
+		_parse: function(text, offset, styles) {
+			var scanner = this._scanner;
+			scanner.setText(text);
+			var token;
+			while ((token = scanner.nextToken())) {
+				var tokenStart = scanner.getStartOffset() + offset;
+				var style = null;
+				switch (token) {
+					case KEYWORD: style = keywordStyle; break;
+					case NUMBER: style = numberStyle; break;
+					case STRING:
+						if (this.whitespacesVisible) {
+							this._parseString(scanner.getData(), tokenStart, styles, stringStyle);
+							continue;
+						} else {
+							style = stringStyle;
+						}
+						break;
+					case DOC_COMMENT: 
+						this._parseComment(scanner.getData(), tokenStart, styles, docCommentStyle, token);
+						continue;
+					case SINGLELINE_COMMENT:
+						this._parseComment(scanner.getData(), tokenStart, styles, singleCommentStyle, token);
+						continue;
+					case MULTILINE_COMMENT: 
+						this._parseComment(scanner.getData(), tokenStart, styles, multiCommentStyle, token);
+						continue;
+					case WHITE_TAB:
+						if (this.whitespacesVisible) {
+							style = tabStyle;
+						}
+						break;
+					case WHITE_SPACE:
+						if (this.whitespacesVisible) {
+							style = spaceStyle;
+						}
+						break;
+				}
+				styles.push({start: tokenStart, end: scanner.getOffset() + offset, style: style});
+			}
+		},
+		_parseComment: function(text, offset, styles, s, type) {
+			var scanner = this._commentScanner;
+			scanner.setText(text);
+			scanner.setType(type);
+			var token;
+			while ((token = scanner.nextToken())) {
+				var tokenStart = scanner.getStartOffset() + offset;
+				var style = s;
+				switch (token) {
+					case WHITE_TAB:
+						if (this.whitespacesVisible) {
+							style = tabStyle;
+						}
+						break;
+					case WHITE_SPACE:
+						if (this.whitespacesVisible) {
+							style = spaceStyle;
+						}
+						break;
+					case HTML_MARKUP:
+						style = htmlMarkupStyle;
+						break;
+					case DOC_TAG:
+						style = doctagStyle;
+						break;
+					case TASK_TAG:
+						style = tasktagStyle;
+						break;
+					default:
+						if (this.detectHyperlinks) {
+							style = this._detectHyperlinks(scanner.getData(), tokenStart, styles, style);
+						}
+				}
+				if (style) {
+					styles.push({start: tokenStart, end: scanner.getOffset() + offset, style: style});
+				}
+			}
+		},
+		_parseString: function(text, offset, styles, s) {
+			var scanner = this._whitespaceScanner;
+			scanner.setText(text);
+			var token;
+			while ((token = scanner.nextToken())) {
+				var tokenStart = scanner.getStartOffset() + offset;
+				var style = s;
+				switch (token) {
+					case WHITE_TAB:
+						if (this.whitespacesVisible) {
+							style = tabStyle;
+						}
+						break;
+					case WHITE_SPACE:
+						if (this.whitespacesVisible) {
+							style = spaceStyle;
+						}
+						break;
+				}
+				if (style) {
+					styles.push({start: tokenStart, end: scanner.getOffset() + offset, style: style});
+				}
+			}
+		},
+		_detectHyperlinks: function(text, offset, styles, s) {
+			var href = null, index, linkStyle;
+			if ((index = text.indexOf("://")) > 0) {
+				href = text;
+				var start = index;
+				while (start > 0) {
+					var c = href.charCodeAt(start - 1);
+					if (!((97 <= c && c <= 122) || (65 <= c && c <= 90) || 0x2d === c || (48 <= c && c <= 57))) { //LETTER OR DASH OR NUMBER
+						break;
+					}
+					start--;
+				}
+				if (start > 0) {
+					var brackets = "\"\"''(){}[]<>";
+					index = brackets.indexOf(href.substring(start - 1, start));
+					if (index !== -1 && (index & 1) === 0 && (index = href.lastIndexOf(brackets.substring(index + 1, index + 2))) !== -1) {
+						var end = index;
+						linkStyle = this._clone(s);
+						linkStyle.tagName = "A";
+						linkStyle.attributes = {href: href.substring(start, end)};
+						styles.push({start: offset, end: offset + start, style: s});
+						styles.push({start: offset + start, end: offset + end, style: linkStyle});
+						styles.push({start: offset + end, end: offset + text.length, style: s});
+						return null;
+					}
+				}
+			} else if (text.toLowerCase().indexOf("bug#") === 0) {
+				href = "https://bugs.eclipse.org/bugs/show_bug.cgi?id=" + parseInt(text.substring(4), 10);
+			}
+			if (href) {
+				linkStyle = this._clone(s);
+				linkStyle.tagName = "A";
+				linkStyle.attributes = {href: href};
+				return linkStyle;
+			}
+			return s;
+		},
+		_clone: function(obj) {
+			if (!obj) { return obj; }
+			var newObj = {};
+			for (var p in obj) {
+				if (obj.hasOwnProperty(p)) {
+					var value = obj[p];
+					newObj[p] = value;
+				}
+			}
+			return newObj;
+		},
+		_findComments: function(text, offset) {
+			offset = offset || 0;
+			var scanner = this._firstScanner, token;
+			scanner.setText(text);
+			var result = [];
+			while ((token = scanner.nextToken())) {
+				if (token === MULTILINE_COMMENT || token === DOC_COMMENT) {
+					var comment = {
+						start: scanner.getStartOffset() + offset,
+						end: scanner.getOffset() + offset,
+						type: token
+					};
+					result.push(comment);
+					//TODO can we avoid this work if edition does not overlap comment?
+					this._computeTasks(token, scanner.getStartOffset() + offset, scanner.getOffset() + offset);
+				}
+				if (token === SINGLELINE_COMMENT) {
+					//TODO can we avoid this work if edition does not overlap comment?
+					this._computeTasks(token, scanner.getStartOffset() + offset, scanner.getOffset() + offset);
+				}
+			}
+			return result;
+		}, 
+		_findMatchingBracket: function(model, offset) {
+			var brackets = "{}()[]<>";
+			var bracket = model.getText(offset, offset + 1);
+			var bracketIndex = brackets.indexOf(bracket, 0);
+			if (bracketIndex === -1) { return -1; }
+			var closingBracket;
+			if (bracketIndex & 1) {
+				closingBracket = brackets.substring(bracketIndex - 1, bracketIndex);
+			} else {
+				closingBracket = brackets.substring(bracketIndex + 1, bracketIndex + 2);
+			}
+			var lineIndex = model.getLineAtOffset(offset);
+			var lineText = model.getLine(lineIndex);
+			var lineStart = model.getLineStart(lineIndex);
+			var lineEnd = model.getLineEnd(lineIndex);
+			brackets = this._findBrackets(bracket, closingBracket, lineText, lineStart, lineStart, lineEnd);
+			for (var i=0; i<brackets.length; i++) {
+				var sign = brackets[i] >= 0 ? 1 : -1;
+				if (brackets[i] * sign === offset) {
+					var level = 1;
+					if (bracketIndex & 1) {
+						i--;
+						for (; i>=0; i--) {
+							sign = brackets[i] >= 0 ? 1 : -1;
+							level += sign;
+							if (level === 0) {
+								return brackets[i] * sign;
+							}
+						}
+						lineIndex -= 1;
+						while (lineIndex >= 0) {
+							lineText = model.getLine(lineIndex);
+							lineStart = model.getLineStart(lineIndex);
+							lineEnd = model.getLineEnd(lineIndex);
+							brackets = this._findBrackets(bracket, closingBracket, lineText, lineStart, lineStart, lineEnd);
+							for (var j=brackets.length - 1; j>=0; j--) {
+								sign = brackets[j] >= 0 ? 1 : -1;
+								level += sign;
+								if (level === 0) {
+									return brackets[j] * sign;
+								}
+							}
+							lineIndex--;
+						}
+					} else {
+						i++;
+						for (; i<brackets.length; i++) {
+							sign = brackets[i] >= 0 ? 1 : -1;
+							level += sign;
+							if (level === 0) {
+								return brackets[i] * sign;
+							}
+						}
+						lineIndex += 1;
+						var lineCount = model.getLineCount ();
+						while (lineIndex < lineCount) {
+							lineText = model.getLine(lineIndex);
+							lineStart = model.getLineStart(lineIndex);
+							lineEnd = model.getLineEnd(lineIndex);
+							brackets = this._findBrackets(bracket, closingBracket, lineText, lineStart, lineStart, lineEnd);
+							for (var k=0; k<brackets.length; k++) {
+								sign = brackets[k] >= 0 ? 1 : -1;
+								level += sign;
+								if (level === 0) {
+									return brackets[k] * sign;
+								}
+							}
+							lineIndex++;
+						}
+					}
+					break;
+				}
+			}
+			return -1;
+		},
+		_findBrackets: function(bracket, closingBracket, text, textOffset, start, end) {
+			var result = [];
+			var bracketToken = bracket.charCodeAt(0);
+			var closingBracketToken = closingBracket.charCodeAt(0);
+			// for any sub range that is not a comment, parse code generating tokens (keywords, numbers, brackets, line comments, etc)
+			var offset = start, scanner = this._scanner, token, comments = this.comments;
+			var startIndex = this._binarySearch(comments, start, true);
+			for (var i = startIndex; i < comments.length; i++) {
+				if (comments[i].start >= end) { break; }
+				var commentStart = comments[i].start;
+				var commentEnd = comments[i].end;
+				if (offset < commentStart) {
+					scanner.setText(text.substring(offset - start, commentStart - start));
+					while ((token = scanner.nextToken())) {
+						if (token === bracketToken) {
+							result.push(scanner.getStartOffset() + offset - start + textOffset);
+						} else if (token === closingBracketToken) {
+							result.push(-(scanner.getStartOffset() + offset - start + textOffset));
+						}
+					}
+				}
+				offset = commentEnd;
+			}
+			if (offset < end) {
+				scanner.setText(text.substring(offset - start, end - start));
+				while ((token = scanner.nextToken())) {
+					if (token === bracketToken) {
+						result.push(scanner.getStartOffset() + offset - start + textOffset);
+					} else if (token === closingBracketToken) {
+						result.push(-(scanner.getStartOffset() + offset - start + textOffset));
+					}
+				}
+			}
+			return result;
+		},
+		_onDestroy: function(e) {
+			this.destroy();
+		},
+		_onLineStyle: function (e) {
+			if (e.textView === this.view) {
+				e.style = this._getLineStyle(e.lineIndex);
+			}
+			e.ranges = this._getStyles(e.textView.getModel(), e.lineText, e.lineStart);
+		},
+		_onSelection: function(e) {
+			var oldSelection = e.oldValue;
+			var newSelection = e.newValue;
+			var view = this.view;
+			var model = view.getModel();
+			var lineIndex;
+			if (this.highlightCaretLine) {
+				var oldLineIndex = model.getLineAtOffset(oldSelection.start);
+				lineIndex = model.getLineAtOffset(newSelection.start);
+				var newEmpty = newSelection.start === newSelection.end;
+				var oldEmpty = oldSelection.start === oldSelection.end;
+				if (!(oldLineIndex === lineIndex && oldEmpty && newEmpty)) {
+					if (oldEmpty) {
+						view.redrawLines(oldLineIndex, oldLineIndex + 1);
+					}
+					if ((oldLineIndex !== lineIndex || !oldEmpty) && newEmpty) {
+						view.redrawLines(lineIndex, lineIndex + 1);
+					}
+				}
+			}
+			if (!this.annotationModel) { return; }
+			var remove = this._bracketAnnotations, add, caret;
+			if (newSelection.start === newSelection.end && (caret = view.getCaretOffset()) > 0) {
+				var mapCaret = caret - 1;
+				if (model.getBaseModel) {
+					mapCaret = model.mapOffset(mapCaret);
+					model = model.getBaseModel();
+				}
+				var bracket = this._findMatchingBracket(model, mapCaret);
+				if (bracket !== -1) {
+					add = [
+						mAnnotations.AnnotationType.createAnnotation(mAnnotations.AnnotationType.ANNOTATION_MATCHING_BRACKET, bracket, bracket + 1),
+						mAnnotations.AnnotationType.createAnnotation(mAnnotations.AnnotationType.ANNOTATION_CURRENT_BRACKET, mapCaret, mapCaret + 1)
+					];
+				}
+			}
+			this._bracketAnnotations = add;
+			this.annotationModel.replaceAnnotations(remove, add);
+		},
+		_onModelChanged: function(e) {
+			var start = e.start;
+			var removedCharCount = e.removedCharCount;
+			var addedCharCount = e.addedCharCount;
+			var changeCount = addedCharCount - removedCharCount;
+			var view = this.view;
+			var viewModel = view.getModel();
+			var baseModel = viewModel.getBaseModel ? viewModel.getBaseModel() : viewModel;
+			var end = start + removedCharCount;
+			var charCount = baseModel.getCharCount();
+			var commentCount = this.comments.length;
+			var lineStart = baseModel.getLineStart(baseModel.getLineAtOffset(start));
+			var commentStart = this._binarySearch(this.comments, lineStart, true);
+			var commentEnd = this._binarySearch(this.comments, end, false, commentStart - 1, commentCount);
+			
+			var ts;
+			if (commentStart < commentCount && this.comments[commentStart].start <= lineStart && lineStart < this.comments[commentStart].end) {
+				ts = this.comments[commentStart].start;
+				if (ts > start) { ts += changeCount; }
+			} else {
+				if (commentStart === commentCount && commentCount > 0 && charCount - changeCount === this.comments[commentCount - 1].end) {
+					ts = this.comments[commentCount - 1].start;
+				} else {
+					ts = lineStart;
+				}
+			}
+			var te;
+			if (commentEnd < commentCount) {
+				te = this.comments[commentEnd].end;
+				if (te > start) { te += changeCount; }
+				commentEnd += 1;
+			} else {
+				commentEnd = commentCount;
+				te = charCount;//TODO could it be smaller?
+			}
+			var text = baseModel.getText(ts, te), comment;
+			var newComments = this._findComments(text, ts), i;
+			for (i = commentStart; i < this.comments.length; i++) {
+				comment = this.comments[i];
+				if (comment.start > start) { comment.start += changeCount; }
+				if (comment.start > start) { comment.end += changeCount; }
+			}
+			var redraw = (commentEnd - commentStart) !== newComments.length;
+			if (!redraw) {
+				for (i=0; i<newComments.length; i++) {
+					comment = this.comments[commentStart + i];
+					var newComment = newComments[i];
+					if (comment.start !== newComment.start || comment.end !== newComment.end || comment.type !== newComment.type) {
+						redraw = true;
+						break;
+					} 
+				}
+			}
+			var args = [commentStart, commentEnd - commentStart].concat(newComments);
+			Array.prototype.splice.apply(this.comments, args);
+			if (redraw) {
+				var redrawStart = ts;
+				var redrawEnd = te;
+				if (viewModel !== baseModel) {
+					redrawStart = viewModel.mapOffset(redrawStart, true);
+					redrawEnd = viewModel.mapOffset(redrawEnd, true);
+				}
+				view.redrawRange(redrawStart, redrawEnd);
+			}
+
+			if (this.foldingEnabled && baseModel !== viewModel && this.annotationModel) {
+				var annotationModel = this.annotationModel;
+				var iter = annotationModel.getAnnotations(ts, te);
+				var remove = [], all = [];
+				var annotation;
+				while (iter.hasNext()) {
+					annotation = iter.next();
+					if (annotation.type === mAnnotations.AnnotationType.ANNOTATION_FOLDING) {
+						all.push(annotation);
+						for (i = 0; i < newComments.length; i++) {
+							if (annotation.start === newComments[i].start && annotation.end === newComments[i].end) {
+								break;
+							}
+						}
+						if (i === newComments.length) {
+							remove.push(annotation);
+							annotation.expand();
+						} else {
+							var annotationStart = annotation.start;
+							var annotationEnd = annotation.end;
+							if (annotationStart > start) {
+								annotationStart -= changeCount;
+							}
+							if (annotationEnd > start) {
+								annotationEnd -= changeCount;
+							}
+							if (annotationStart <= start && start < annotationEnd && annotationStart <= end && end < annotationEnd) {
+								var startLine = baseModel.getLineAtOffset(annotation.start);
+								var endLine = baseModel.getLineAtOffset(annotation.end);
+								if (startLine !== endLine) {
+									if (!annotation.expanded) {
+										annotation.expand();
+										annotationModel.modifyAnnotation(annotation);
+									}
+								} else {
+									annotationModel.removeAnnotation(annotation);
+								}
+							}
+						}
+					}
+				}
+				var add = [];
+				for (i = 0; i < newComments.length; i++) {
+					comment = newComments[i];
+					for (var j = 0; j < all.length; j++) {
+						if (all[j].start === comment.start && all[j].end === comment.end) {
+							break;
+						}
+					}
+					if (j === all.length) {
+						annotation = this._createFoldingAnnotation(viewModel, baseModel, comment.start, comment.end);
+						if (annotation) {
+							add.push(annotation);
+						}
+					}
+				}
+				annotationModel.replaceAnnotations(remove, add);
+			}
+		}
+	};
+	
+	return {TextStyler: TextStyler};
+});
+/*******************************************************************************
+ * @license
+ * Copyright (c) 2010, 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials are made 
+ * available under the terms of the Eclipse Public License v1.0 
+ * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
+ * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
+ * 
+ * Contributors: 
+ *		Felipe Heidrich (IBM Corporation) - initial API and implementation
+ *		Silenio Quarti (IBM Corporation) - initial API and implementation
+ ******************************************************************************/
+
+/*global define */
+
+define("orion/textview/annotations", ['i18n!orion/textview/nls/messages', 'orion/textview/eventTarget'], function(messages, mEventTarget) {
+	/**
+	 * @class This object represents a decoration attached to a range of text. Annotations are added to a
+	 * <code>AnnotationModel</code> which is attached to a <code>TextModel</code>.
+	 * <p>
+	 * <b>See:</b><br/>
+	 * {@link orion.textview.AnnotationModel}<br/>
+	 * {@link orion.textview.Ruler}<br/>
+	 * </p>		 
+	 * @name orion.textview.Annotation
+	 * 
+	 * @property {String} type The annotation type (for example, orion.annotation.error).
+	 * @property {Number} start The start offset of the annotation in the text model.
+	 * @property {Number} end The end offset of the annotation in the text model.
+	 * @property {String} html The HTML displayed for the annotation.
+	 * @property {String} title The text description for the annotation.
+	 * @property {orion.textview.Style} style The style information for the annotation used in the annotations ruler and tooltips.
+	 * @property {orion.textview.Style} overviewStyle The style information for the annotation used in the overview ruler.
+	 * @property {orion.textview.Style} rangeStyle The style information for the annotation used in the text view to decorate a range of text.
+	 * @property {orion.textview.Style} lineStyle The style information for the annotation used in the text view to decorate a line of text.
+	 */
+	/**
+	 * Constructs a new folding annotation.
+	 * 
+	 * @param {Number} start The start offset of the annotation in the text model.
+	 * @param {Number} end The end offset of the annotation in the text model.
+	 * @param {orion.textview.ProjectionTextModel} projectionModel The projection text model.
+	 * 
+	 * @class This object represents a folding annotation.
+	 * @name orion.textview.FoldingAnnotation
+	 */
+	function FoldingAnnotation (start, end, projectionModel) {
+		this.start = start;
+		this.end = end;
+		this._projectionModel = projectionModel;
+		this.html = this._expandedHTML;
+		this.style = this._expandedStyle;
+		this.expanded = true;
+	}
+	
+	FoldingAnnotation.prototype = /** @lends orion.textview.FoldingAnnotation.prototype */ {
+		_expandedHTML: "<div class='annotationHTML expanded'></div>",
+		_expandedStyle: {styleClass: "annotation expanded"}, 
+		_collapsedHTML: "<div class='annotationHTML collapsed'></div>",
+		_collapsedStyle: {styleClass: "annotation collapsed"},
+		/**
+		 * Collapses the annotation.
+		 */
+		collapse: function () {
+			if (!this.expanded) { return; }
+			this.expanded = false;
+			this.html = this._collapsedHTML;
+			this.style = this._collapsedStyle;
+			var projectionModel = this._projectionModel;
+			var baseModel = projectionModel.getBaseModel();
+			this._projection = {
+				start: baseModel.getLineStart(baseModel.getLineAtOffset(this.start) + 1),
+				end: baseModel.getLineEnd(baseModel.getLineAtOffset(this.end), true)
+			};
+			projectionModel.addProjection(this._projection);
+		},
+		/**
+		 * Expands the annotation.
+		 */
+		expand: function () {
+			if (this.expanded) { return; }
+			this.expanded = true;
+			this.html = this._expandedHTML;
+			this.style = this._expandedStyle;
+			this._projectionModel.removeProjection(this._projection);
+		}
+	};
+	 
+	/**
+	 * @class This object represents a regitry of annotation types.
+	 * @name orion.textview.AnnotationType
+	 */
+	function AnnotationType() {
+	}
+	
+	/**
+	 * Error annotation type.
+	 */
+	AnnotationType.ANNOTATION_ERROR = "orion.annotation.error";
+	/**
+	 * Warning annotation type.
+	 */
+	AnnotationType.ANNOTATION_WARNING = "orion.annotation.warning";
+	/**
+	 * Task annotation type.
+	 */
+	AnnotationType.ANNOTATION_TASK = "orion.annotation.task";
+	/**
+	 * Breakpoint annotation type.
+	 */
+	AnnotationType.ANNOTATION_BREAKPOINT = "orion.annotation.breakpoint";
+	/**
+	 * Bookmark annotation type.
+	 */
+	AnnotationType.ANNOTATION_BOOKMARK = "orion.annotation.bookmark";
+	/**
+	 * Folding annotation type.
+	 */
+	AnnotationType.ANNOTATION_FOLDING = "orion.annotation.folding";
+	/**
+	 * Curent bracket annotation type.
+	 */
+	AnnotationType.ANNOTATION_CURRENT_BRACKET = "orion.annotation.currentBracket";
+	/**
+	 * Matching bracket annotation type.
+	 */
+	AnnotationType.ANNOTATION_MATCHING_BRACKET = "orion.annotation.matchingBracket";
+	/**
+	 * Current line annotation type.
+	 */
+	AnnotationType.ANNOTATION_CURRENT_LINE = "orion.annotation.currentLine";
+	/**
+	 * Current search annotation type.
+	 */
+	AnnotationType.ANNOTATION_CURRENT_SEARCH = "orion.annotation.currentSearch";
+	/**
+	 * Matching search annotation type.
+	 */
+	AnnotationType.ANNOTATION_MATCHING_SEARCH = "orion.annotation.matchingSearch";
+	
+	/** @private */
+	var annotationTypes = {};
+	
+	/**
+	 * Register an annotation type.
+	 *
+	 * @param {String} type The annotation type (for example, orion.annotation.error).
+	 * @param {Object|Function} properties The common annotation properties of the registered
+	 *		annotation type. All annotations create with this annotation type will expose these
+	 *		properties.	 */
+	AnnotationType.registerType = function(type, properties) {
+		var constructor = properties;
+		if (typeof constructor !== "function") {
+			constructor = function(start, end, title) {
+				this.start = start;
+				this.end = end;
+				if (title) { this.title = title; }
+			};
+			constructor.prototype = properties;
+		}
+		constructor.prototype.type = type;
+		annotationTypes[type] = constructor;
+		return type;
+	};
+	
+	/**
+	 * Creates an annotation of a given type with the specified start end end offsets.
+	 *
+	 * @param {String} type The annotation type (for example, orion.annotation.error).
+	 * @param {Number} start The start offset of the annotation in the text model.
+	 * @param {Number} end The end offset of the annotation in the text model.
+	 * @param {String} [title] The text description for the annotation if different then the type description.
+	 * @return {orion.textview.Annotation} the new annotation
+	 */
+	AnnotationType.createAnnotation = function(type, start, end, title) {
+		return new (this.getType(type))(start, end, title);
+	};
+	
+	/**
+	 * Gets the registered annotation type with specified type. The returned
+	 * value is a constructor that can be used to create annotations of the
+	 * speficied type.  The constructor takes the start and end offsets of
+	 * the annotation.
+	 *
+	 * @param {String} type The annotation type (for example, orion.annotation.error).
+	 * @return {Function} The annotation type constructor ( i.e function(start, end, title) ).
+	 */
+	AnnotationType.getType = function(type) {
+		return annotationTypes[type];
+	};
+	
+	/** @private */
+	function registerType(type, lineStyling) {
+		var index = type.lastIndexOf('.');
+		var suffix = type.substring(index + 1);
+		var properties = {
+			title: messages[suffix],
+			style: {styleClass: "annotation " + suffix},
+			html: "<div class='annotationHTML " + suffix + "'></div>",
+			overviewStyle: {styleClass: "annotationOverview " + suffix}
+		};
+		if (lineStyling) {
+			properties.lineStyle = {styleClass: "annotationLine " + suffix};
+		} else {
+			properties.rangeStyle = {styleClass: "annotationRange " + suffix};
+		}
+		AnnotationType.registerType(type, properties);
+	}
+	registerType(AnnotationType.ANNOTATION_ERROR);
+	registerType(AnnotationType.ANNOTATION_WARNING);
+	registerType(AnnotationType.ANNOTATION_TASK);
+	registerType(AnnotationType.ANNOTATION_BREAKPOINT);
+	registerType(AnnotationType.ANNOTATION_BOOKMARK);
+	registerType(AnnotationType.ANNOTATION_CURRENT_BRACKET);
+	registerType(AnnotationType.ANNOTATION_MATCHING_BRACKET);
+	registerType(AnnotationType.ANNOTATION_CURRENT_SEARCH);
+	registerType(AnnotationType.ANNOTATION_MATCHING_SEARCH);
+	registerType(AnnotationType.ANNOTATION_CURRENT_LINE, true);
+	AnnotationType.registerType(AnnotationType.ANNOTATION_FOLDING, FoldingAnnotation);
+	
+	/** 
+	 * Constructs a new AnnotationTypeList object.
+	 * 
+	 * @class This represents an interface of prioritized annotation types.
+	 * @name orion.textview.AnnotationTypeList
+	 */
+	function AnnotationTypeList () {
+	}
+	/**
+	 * Adds in the annotation type interface into the specified object.
+	 *
+	 * @param {Object} object The object to add in the annotation type interface.
+	 */
+	AnnotationTypeList.addMixin = function(object) {
+		var proto = AnnotationTypeList.prototype;
+		for (var p in proto) {
+			if (proto.hasOwnProperty(p)) {
+				object[p] = proto[p];
+			}
+		}
+	};	
+	AnnotationTypeList.prototype = /** @lends orion.textview.AnnotationTypeList.prototype */ {
+		/**
+		 * Adds an annotation type to the receiver.
+		 * <p>
+		 * Only annotations of the specified types will be shown by
+		 * the receiver.
+		 * </p>
+		 *
+		 * @param {Object} type the annotation type to be shown
+		 * 
+		 * @see #removeAnnotationType
+		 * @see #isAnnotationTypeVisible
+		 */
+		addAnnotationType: function(type) {
+			if (!this._annotationTypes) { this._annotationTypes = []; }
+			this._annotationTypes.push(type);
+		},
+		/**
+		 * Gets the annotation type priority.  The priority is determined by the
+		 * order the annotation type is added to the receiver.  Annotation types
+		 * added first have higher priority.
+		 * <p>
+		 * Returns <code>0</code> if the annotation type is not added.
+		 * </p>
+		 *
+		 * @param {Object} type the annotation type
+		 * 
+		 * @see #addAnnotationType
+		 * @see #removeAnnotationType
+		 * @see #isAnnotationTypeVisible
+		 */
+		getAnnotationTypePriority: function(type) {
+			if (this._annotationTypes) { 
+				for (var i = 0; i < this._annotationTypes.length; i++) {
+					if (this._annotationTypes[i] === type) {
+						return i + 1;
+					}
+				}
+			}
+			return 0;
+		},
+		/**
+		 * Returns an array of annotations in the specified annotation model for the given range of text sorted by type.
+		 *
+		 * @param {orion.textview.AnnotationModel} annotationModel the annotation model.
+		 * @param {Number} start the start offset of the range.
+		 * @param {Number} end the end offset of the range.
+		 * @return {orion.textview.Annotation[]} an annotation array.
+		 */
+		getAnnotationsByType: function(annotationModel, start, end) {
+			var iter = annotationModel.getAnnotations(start, end);
+			var annotation, annotations = [];
+			while (iter.hasNext()) {
+				annotation = iter.next();
+				var priority = this.getAnnotationTypePriority(annotation.type);
+				if (priority === 0) { continue; }
+				annotations.push(annotation);
+			}
+			var self = this;
+			annotations.sort(function(a, b) {
+				return self.getAnnotationTypePriority(a.type) - self.getAnnotationTypePriority(b.type);
+			});
+			return annotations;
+		},
+		/**
+		 * Returns whether the receiver shows annotations of the specified type.
+		 *
+		 * @param {Object} type the annotation type 
+		 * @returns {Boolean} whether the specified annotation type is shown
+		 * 
+		 * @see #addAnnotationType
+		 * @see #removeAnnotationType
+		 */
+		isAnnotationTypeVisible: function(type) {
+			return this.getAnnotationTypePriority(type) !== 0;
+		},
+		/**
+		 * Removes an annotation type from the receiver.
+		 *
+		 * @param {Object} type the annotation type to be removed
+		 * 
+		 * @see #addAnnotationType
+		 * @see #isAnnotationTypeVisible
+		 */
+		removeAnnotationType: function(type) {
+			if (!this._annotationTypes) { return; }
+			for (var i = 0; i < this._annotationTypes.length; i++) {
+				if (this._annotationTypes[i] === type) {
+					this._annotationTypes.splice(i, 1);
+					break;
+				}
+			}
+		}
+	};
+	
+	/**
+	 * Constructs an annotation model.
+	 * 
+	 * @param {textModel} textModel The text model.
+	 * 
+	 * @class This object manages annotations for a <code>TextModel</code>.
+	 * <p>
+	 * <b>See:</b><br/>
+	 * {@link orion.textview.Annotation}<br/>
+	 * {@link orion.textview.TextModel}<br/> 
+	 * </p>	
+	 * @name orion.textview.AnnotationModel
+	 * @borrows orion.textview.EventTarget#addEventListener as #addEventListener
+	 * @borrows orion.textview.EventTarget#removeEventListener as #removeEventListener
+	 * @borrows orion.textview.EventTarget#dispatchEvent as #dispatchEvent
+	 */
+	function AnnotationModel(textModel) {
+		this._annotations = [];
+		var self = this;
+		this._listener = {
+			onChanged: function(modelChangedEvent) {
+				self._onChanged(modelChangedEvent);
+			}
+		};
+		this.setTextModel(textModel);
+	}
+
+	AnnotationModel.prototype = /** @lends orion.textview.AnnotationModel.prototype */ {
+		/**
+		 * Adds an annotation to the annotation model. 
+		 * <p>The annotation model listeners are notified of this change.</p>
+		 * 
+		 * @param {orion.textview.Annotation} annotation the annotation to be added.
+		 * 
+		 * @see #removeAnnotation
+		 */
+		addAnnotation: function(annotation) {
+			if (!annotation) { return; }
+			var annotations = this._annotations;
+			var index = this._binarySearch(annotations, annotation.start);
+			annotations.splice(index, 0, annotation);
+			var e = {
+				type: "Changed",
+				added: [annotation],
+				removed: [],
+				changed: []
+			};
+			this.onChanged(e);
+		},
+		/**
+		 * Returns the text model. 
+		 * 
+		 * @return {orion.textview.TextModel} The text model.
+		 * 
+		 * @see #setTextModel
+		 */
+		getTextModel: function() {
+			return this._model;
+		},
+		/**
+		 * @class This object represents an annotation iterator.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link orion.textview.AnnotationModel#getAnnotations}<br/>
+		 * </p>		 
+		 * @name orion.textview.AnnotationIterator
+		 * 
+		 * @property {Function} hasNext Determines whether there are more annotations in the iterator.
+		 * @property {Function} next Returns the next annotation in the iterator.
+		 */		
+		/**
+		 * Returns an iterator of annotations for the given range of text.
+		 *
+		 * @param {Number} start the start offset of the range.
+		 * @param {Number} end the end offset of the range.
+		 * @return {orion.textview.AnnotationIterator} an annotation iterartor.
+		 */
+		getAnnotations: function(start, end) {
+			var annotations = this._annotations, current;
+			//TODO binary search does not work for range intersection when there are overlaping ranges, need interval search tree for this
+			var i = 0;
+			var skip = function() {
+				while (i < annotations.length) {
+					var a =  annotations[i++];
+					if ((start === a.start) || (start > a.start ? start < a.end : a.start < end)) {
+						return a;
+					}
+					if (a.start >= end) {
+						break;
+					}
+				}
+				return null;
+			};
+			current = skip();
+			return {
+				next: function() {
+					var result = current;
+					if (result) { current = skip(); }
+					return result;					
+				},
+				hasNext: function() {
+					return current !== null;
+				}
+			};
+		},
+		/**
+		 * Notifies the annotation model that the given annotation has been modified.
+		 * <p>The annotation model listeners are notified of this change.</p>
+		 * 
+		 * @param {orion.textview.Annotation} annotation the modified annotation.
+		 * 
+		 * @see #addAnnotation
+		 */
+		modifyAnnotation: function(annotation) {
+			if (!annotation) { return; }
+			var index = this._getAnnotationIndex(annotation);
+			if (index < 0) { return; }
+			var e = {
+				type: "Changed",
+				added: [],
+				removed: [],
+				changed: [annotation]
+			};
+			this.onChanged(e);
+		},
+		/**
+		 * Notifies all listeners that the annotation model has changed.
+		 *
+		 * @param {orion.textview.Annotation[]} added The list of annotation being added to the model.
+		 * @param {orion.textview.Annotation[]} changed The list of annotation modified in the model.
+		 * @param {orion.textview.Annotation[]} removed The list of annotation being removed from the model.
+		 * @param {ModelChangedEvent} textModelChangedEvent the text model changed event that trigger this change, can be null if the change was trigger by a method call (for example, {@link #addAnnotation}).
+		 */
+		onChanged: function(e) {
+			return this.dispatchEvent(e);
+		},
+		/**
+		 * Removes all annotations of the given <code>type</code>. All annotations
+		 * are removed if the type is not specified. 
+		 * <p>The annotation model listeners are notified of this change.  Only one changed event is generated.</p>
+		 * 
+		 * @param {Object} type the type of annotations to be removed.
+		 * 
+		 * @see #removeAnnotation
+		 */
+		removeAnnotations: function(type) {
+			var annotations = this._annotations;
+			var removed, i; 
+			if (type) {
+				removed = [];
+				for (i = annotations.length - 1; i >= 0; i--) {
+					var annotation = annotations[i];
+					if (annotation.type === type) {
+						annotations.splice(i, 1);
+					}
+					removed.splice(0, 0, annotation);
+				}
+			} else {
+				removed = annotations;
+				annotations = [];
+			}
+			var e = {
+				type: "Changed",
+				removed: removed,
+				added: [],
+				changed: []
+			};
+			this.onChanged(e);
+		},
+		/**
+		 * Removes an annotation from the annotation model. 
+		 * <p>The annotation model listeners are notified of this change.</p>
+		 * 
+		 * @param {orion.textview.Annotation} annotation the annotation to be removed.
+		 * 
+		 * @see #addAnnotation
+		 */
+		removeAnnotation: function(annotation) {
+			if (!annotation) { return; }
+			var index = this._getAnnotationIndex(annotation);
+			if (index < 0) { return; }
+			var e = {
+				type: "Changed",
+				removed: this._annotations.splice(index, 1),
+				added: [],
+				changed: []
+			};
+			this.onChanged(e);
+		},
+		/**
+		 * Removes and adds the specifed annotations to the annotation model. 
+		 * <p>The annotation model listeners are notified of this change.  Only one changed event is generated.</p>
+		 * 
+		 * @param {orion.textview.Annotation} remove the annotations to be removed.
+		 * @param {orion.textview.Annotation} add the annotations to be added.
+		 * 
+		 * @see #addAnnotation
+		 * @see #removeAnnotation
+		 */
+		replaceAnnotations: function(remove, add) {
+			var annotations = this._annotations, i, index, annotation, removed = [];
+			if (remove) {
+				for (i = remove.length - 1; i >= 0; i--) {
+					annotation = remove[i];
+					index = this._getAnnotationIndex(annotation);
+					if (index < 0) { continue; }
+					annotations.splice(index, 1);
+					removed.splice(0, 0, annotation);
+				}
+			}
+			if (!add) { add = []; }
+			for (i = 0; i < add.length; i++) {
+				annotation = add[i];
+				index = this._binarySearch(annotations, annotation.start);
+				annotations.splice(index, 0, annotation);
+			}
+			var e = {
+				type: "Changed",
+				removed: removed,
+				added: add,
+				changed: []
+			};
+			this.onChanged(e);
+		},
+		/**
+		 * Sets the text model of the annotation model.  The annotation
+		 * model listens for changes in the text model to update and remove
+		 * annotations that are affected by the change.
+		 * 
+		 * @param {orion.textview.TextModel} textModel the text model.
+		 * 
+		 * @see #getTextModel
+		 */
+		setTextModel: function(textModel) {
+			if (this._model) {
+				this._model.removeEventListener("Changed", this._listener.onChanged);
+			}
+			this._model = textModel;
+			if (this._model) {
+				this._model.addEventListener("Changed", this._listener.onChanged);
+			}
+		},
+		/** @ignore */
+		_binarySearch: function (array, offset) {
+			var high = array.length, low = -1, index;
+			while (high - low > 1) {
+				index = Math.floor((high + low) / 2);
+				if (offset <= array[index].start) {
+					high = index;
+				} else {
+					low = index;
+				}
+			}
+			return high;
+		},
+		/** @ignore */
+		_getAnnotationIndex: function(annotation) {
+			var annotations = this._annotations;
+			var index = this._binarySearch(annotations, annotation.start);
+			while (index < annotations.length && annotations[index].start === annotation.start) {
+				if (annotations[index] === annotation) {
+					return index;
+				}
+				index++;
+			}
+			return -1;
+		},
+		/** @ignore */
+		_onChanged: function(modelChangedEvent) {
+			var start = modelChangedEvent.start;
+			var addedCharCount = modelChangedEvent.addedCharCount;
+			var removedCharCount = modelChangedEvent.removedCharCount;
+			var annotations = this._annotations, end = start + removedCharCount;
+			//TODO binary search does not work for range intersection when there are overlaping ranges, need interval search tree for this
+			var startIndex = 0;
+			if (!(0 <= startIndex && startIndex < annotations.length)) { return; }
+			var e = {
+				type: "Changed",
+				added: [],
+				removed: [],
+				changed: [],
+				textModelChangedEvent: modelChangedEvent
+			};
+			var changeCount = addedCharCount - removedCharCount, i;
+			for (i = startIndex; i < annotations.length; i++) {
+				var annotation = annotations[i];
+				if (annotation.start >= end) {
+					annotation.start += changeCount;
+					annotation.end += changeCount;
+					e.changed.push(annotation);
+				} else if (annotation.end <= start) {
+					//nothing
+				} else if (annotation.start < start && end < annotation.end) {
+					annotation.end += changeCount;
+					e.changed.push(annotation);
+				} else {
+					annotations.splice(i, 1);
+					e.removed.push(annotation);
+					i--;
+				}
+			}
+			if (e.added.length > 0 || e.removed.length > 0 || e.changed.length > 0) {
+				this.onChanged(e);
+			}
+		}
+	};
+	mEventTarget.EventTarget.addMixin(AnnotationModel.prototype);
+
+	/**
+	 * Constructs a new styler for annotations.
+	 * 
+	 * @param {orion.textview.TextView} view The styler view.
+	 * @param {orion.textview.AnnotationModel} view The styler annotation model.
+	 * 
+	 * @class This object represents a styler for annotation attached to a text view.
+	 * @name orion.textview.AnnotationStyler
+	 * @borrows orion.textview.AnnotationTypeList#addAnnotationType as #addAnnotationType
+	 * @borrows orion.textview.AnnotationTypeList#getAnnotationTypePriority as #getAnnotationTypePriority
+	 * @borrows orion.textview.AnnotationTypeList#getAnnotationsByType as #getAnnotationsByType
+	 * @borrows orion.textview.AnnotationTypeList#isAnnotationTypeVisible as #isAnnotationTypeVisible
+	 * @borrows orion.textview.AnnotationTypeList#removeAnnotationType as #removeAnnotationType
+	 */
+	function AnnotationStyler (view, annotationModel) {
+		this._view = view;
+		this._annotationModel = annotationModel;
+		var self = this;
+		this._listener = {
+			onDestroy: function(e) {
+				self._onDestroy(e);
+			},
+			onLineStyle: function(e) {
+				self._onLineStyle(e);
+			},
+			onChanged: function(e) {
+				self._onAnnotationModelChanged(e);
+			}
+		};
+		view.addEventListener("Destroy", this._listener.onDestroy);
+		view.addEventListener("LineStyle", this._listener.onLineStyle);
+		annotationModel.addEventListener("Changed", this._listener.onChanged);
+	}
+	AnnotationStyler.prototype = /** @lends orion.textview.AnnotationStyler.prototype */ {
+		/**
+		 * Destroys the styler. 
+		 * <p>
+		 * Removes all listeners added by this styler.
+		 * </p>
+		 */
+		destroy: function() {
+			var view = this._view;
+			if (view) {
+				view.removeEventListener("Destroy", this._listener.onDestroy);
+				view.removeEventListener("LineStyle", this._listener.onLineStyle);
+				this.view = null;
+			}
+			var annotationModel = this._annotationModel;
+			if (annotationModel) {
+				annotationModel.removeEventListener("Changed", this._listener.onChanged);
+				annotationModel = null;
+			}
+		},
+		_mergeStyle: function(result, style) {
+			if (style) {
+				if (!result) { result = {}; }
+				if (result.styleClass && style.styleClass && result.styleClass !== style.styleClass) {
+					result.styleClass += " " + style.styleClass;
+				} else {
+					result.styleClass = style.styleClass;
+				}
+				var prop;
+				if (style.style) {
+					if (!result.style) { result.style  = {}; }
+					for (prop in style.style) {
+						if (!result.style[prop]) {
+							result.style[prop] = style.style[prop];
+						}
+					}
+				}
+				if (style.attributes) {
+					if (!result.attributes) { result.attributes  = {}; }
+					for (prop in style.attributes) {
+						if (!result.attributes[prop]) {
+							result.attributes[prop] = style.attributes[prop];
+						}
+					}
+				}
+			}
+			return result;
+		},
+		_mergeStyleRanges: function(ranges, styleRange) {
+			if (!ranges) {
+				ranges = [];
+			}
+			var mergedStyle, i;
+			for (i=0; i<ranges.length && styleRange; i++) {
+				var range = ranges[i];
+				if (styleRange.end <= range.start) { break; }
+				if (styleRange.start >= range.end) { continue; }
+				mergedStyle = this._mergeStyle({}, range.style);
+				mergedStyle = this._mergeStyle(mergedStyle, styleRange.style);
+				var args = [];
+				args.push(i, 1);
+				if (styleRange.start < range.start) {
+					args.push({start: styleRange.start, end: range.start, style: styleRange.style});
+				}
+				if (styleRange.start > range.start) {
+					args.push({start: range.start, end: styleRange.start, style: range.style});
+				}
+				args.push({start: Math.max(range.start, styleRange.start), end: Math.min(range.end, styleRange.end), style: mergedStyle});
+				if (styleRange.end < range.end) {
+					args.push({start: styleRange.end, end: range.end, style: range.style});
+				}
+				if (styleRange.end > range.end) {
+					styleRange = {start: range.end, end: styleRange.end, style: styleRange.style};
+				} else {
+					styleRange = null;
+				}
+				Array.prototype.splice.apply(ranges, args);
+			}
+			if (styleRange) {
+				mergedStyle = this._mergeStyle({}, styleRange.style);
+				ranges.splice(i, 0, {start: styleRange.start, end: styleRange.end, style: mergedStyle});
+			}
+			return ranges;
+		},
+		_onAnnotationModelChanged: function(e) {
+			if (e.textModelChangedEvent) {
+				return;
+			}
+			var view = this._view;
+			if (!view) { return; }
+			var self = this;
+			var model = view.getModel();
+			function redraw(changes) {
+				for (var i = 0; i < changes.length; i++) {
+					if (!self.isAnnotationTypeVisible(changes[i].type)) { continue; }
+					var start = changes[i].start;
+					var end = changes[i].end;
+					if (model.getBaseModel) {
+						start = model.mapOffset(start, true);
+						end = model.mapOffset(end, true);
+					}
+					if (start !== -1 && end !== -1) {
+						view.redrawRange(start, end);
+					}
+				}
+			}
+			redraw(e.added);
+			redraw(e.removed);
+			redraw(e.changed);
+		},
+		_onDestroy: function(e) {
+			this.destroy();
+		},
+		_onLineStyle: function (e) {
+			var annotationModel = this._annotationModel;
+			var viewModel = e.textView.getModel();
+			var baseModel = annotationModel.getTextModel();
+			var start = e.lineStart;
+			var end = e.lineStart + e.lineText.length;
+			if (baseModel !== viewModel) {
+				start = viewModel.mapOffset(start);
+				end = viewModel.mapOffset(end);
+			}
+			var annotations = annotationModel.getAnnotations(start, end);
+			while (annotations.hasNext()) {
+				var annotation = annotations.next();
+				if (!this.isAnnotationTypeVisible(annotation.type)) { continue; }
+				if (annotation.rangeStyle) {
+					var annotationStart = annotation.start;
+					var annotationEnd = annotation.end;
+					if (baseModel !== viewModel) {
+						annotationStart = viewModel.mapOffset(annotationStart, true);
+						annotationEnd = viewModel.mapOffset(annotationEnd, true);
+					}
+					e.ranges = this._mergeStyleRanges(e.ranges, {start: annotationStart, end: annotationEnd, style: annotation.rangeStyle});
+				}
+				if (annotation.lineStyle) {
+					e.style = this._mergeStyle({}, e.style);
+					e.style = this._mergeStyle(e.style, annotation.lineStyle);
+				}
+			}
+		}
+	};
+	AnnotationTypeList.addMixin(AnnotationStyler.prototype);
+	
+	return {
+		FoldingAnnotation: FoldingAnnotation,
+		AnnotationType: AnnotationType,
+		AnnotationTypeList: AnnotationTypeList,
+		AnnotationModel: AnnotationModel,
+		AnnotationStyler: AnnotationStyler
+	};
+});
+/*******************************************************************************
+ * Copyright (c) 2010, 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials are made 
+ * available under the terms of the Eclipse Public License v1.0 
+ * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
+ * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
+ * 
+ * Contributors: 
+ *		Felipe Heidrich (IBM Corporation) - initial API and implementation
+ *		Silenio Quarti (IBM Corporation) - initial API and implementation
+ ******************************************************************************/
+ 
+/*global define */
+define("orion/textview/eventTarget", [], function() {
+	/** 
+	 * Constructs a new EventTarget object.
+	 * 
+	 * @class 
+	 * @name orion.textview.EventTarget
+	 */
+	function EventTarget() {
+	}
+	/**
+	 * Adds in the event target interface into the specified object.
+	 *
+	 * @param {Object} object The object to add in the event target interface.
+	 */
+	EventTarget.addMixin = function(object) {
+		var proto = EventTarget.prototype;
+		for (var p in proto) {
+			if (proto.hasOwnProperty(p)) {
+				object[p] = proto[p];
+			}
+		}
+	};
+	EventTarget.prototype = /** @lends orion.textview.EventTarget.prototype */ {
+		/**
+		 * Adds an event listener to this event target.
+		 * 
+		 * @param {String} type The event type.
+		 * @param {Function|EventListener} listener The function or the EventListener that will be executed when the event happens. 
+		 * @param {Boolean} [useCapture=false] <code>true</code> if the listener should be trigged in the capture phase.
+		 * 
+		 * @see #removeEventListener
+		 */
+		addEventListener: function(type, listener, useCapture) {
+			if (!this._eventTypes) { this._eventTypes = {}; }
+			var state = this._eventTypes[type];
+			if (!state) {
+				state = this._eventTypes[type] = {level: 0, listeners: []};
+			}
+			var listeners = state.listeners;
+			listeners.push({listener: listener, useCapture: useCapture});
+		},
+		/**
+		 * Dispatches the given event to the listeners added to this event target.
+		 * @param {Event} evt The event to dispatch.
+		 */
+		dispatchEvent: function(evt) {
+			if (!this._eventTypes) { return; }
+			var type = evt.type;
+			var state = this._eventTypes[type];
+			if (state) {
+				var listeners = state.listeners;
+				try {
+					state.level++;
+					if (listeners) {
+						for (var i=0, len=listeners.length; i < len; i++) {
+							if (listeners[i]) {
+								var l = listeners[i].listener;
+								if (typeof l === "function") {
+									l.call(this, evt);
+								} else if (l.handleEvent && typeof l.handleEvent === "function") {
+									l.handleEvent(evt);
+								}
+							}
+						}
+					}
+				} finally {
+					state.level--;
+					if (state.compact && state.level === 0) {
+						for (var j=listeners.length - 1; j >= 0; j--) {
+							if (!listeners[j]) {
+								listeners.splice(j, 1);
+							}
+						}
+						if (listeners.length === 0) {
+							delete this._eventTypes[type];
+						}
+						state.compact = false;
+					}
+				}
+			}
+		},
+		/**
+		 * Returns whether there is a listener for the specified event type.
+		 * 
+		 * @param {String} type The event type
+		 * 
+		 * @see #addEventListener
+		 * @see #removeEventListener
+		 */
+		isListening: function(type) {
+			if (!this._eventTypes) { return false; }
+			return this._eventTypes[type] !== undefined;
+		},		
+		/**
+		 * Removes an event listener from the event target.
+		 * <p>
+		 * All the parameters must be the same ones used to add the listener.
+		 * </p>
+		 * 
+		 * @param {String} type The event type
+		 * @param {Function|EventListener} listener The function or the EventListener that will be executed when the event happens. 
+		 * @param {Boolean} [useCapture=false] <code>true</code> if the listener should be trigged in the capture phase.
+		 * 
+		 * @see #addEventListener
+		 */
+		removeEventListener: function(type, listener, useCapture){
+			if (!this._eventTypes) { return; }
+			var state = this._eventTypes[type];
+			if (state) {
+				var listeners = state.listeners;
+				for (var i=0, len=listeners.length; i < len; i++) {
+					var l = listeners[i];
+					if (l && l.listener === listener && l.useCapture === useCapture) {
+						if (state.level !== 0) {
+							listeners[i] = null;
+							state.compact = true;
+						} else {
+							listeners.splice(i, 1);
+						}
+						break;
+					}
+				}
+				if (listeners.length === 0) {
+					delete this._eventTypes[type];
+				}
+			}
+		}
+	};
+	return {EventTarget: EventTarget};
+});
+/******************************************************************************* 
+ * @license
+ * Copyright (c) 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials are made 
  * available under the terms of the Eclipse Public License v1.0 
  * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
  * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
  * 
- * Contributors: 
- *		Felipe Heidrich (IBM Corporation) - initial API and implementation
- *		Silenio Quarti (IBM Corporation) - initial API and implementation
+ * Contributors: IBM Corporation - initial API and implementation 
  ******************************************************************************/
- 
+
+/*jslint */
 /*global define */
-define("orion/textview/eventTarget", [], function() {
-	/** 
-	 * Constructs a new EventTarget object.
-	 * 
-	 * @class 
-	 * @name orion.textview.EventTarget
+
+define("orion/editor/htmlGrammar", [], function() {
+
+	/**
+	 * Provides a grammar that can do some very rough syntax highlighting for HTML.
+	 * @class orion.syntax.HtmlGrammar
 	 */
-	function EventTarget() {
+	function HtmlGrammar() {
+		/**
+		 * Object containing the grammar rules.
+		 * @public
+		 * @type Object
+		 */
+		return {
+			"scopeName": "source.html",
+			"uuid": "3B5C76FB-EBB5-D930-F40C-047D082CE99B",
+			"patterns": [
+				{
+					"begin": "<!(doctype|DOCTYPE)",
+					"end": ">",
+					"contentName": "entity.name.tag.doctype.html",
+					"beginCaptures": {
+						"0": { "name": "entity.name.tag.doctype.html" }
+					},
+					"endCaptures": {
+						"0": { "name": "entity.name.tag.doctype.html" }
+					}
+				},
+				{
+					"begin": "<!--",
+					"end": "-->",
+					"beginCaptures": {
+						"0": { "name": "punctuation.definition.comment.html" }
+					},
+					"endCaptures": {
+						"0": { "name": "punctuation.definition.comment.html" }
+					},
+					"patterns": [
+						{
+							"match": "--",
+							"name": "invalid.illegal.badcomment.html"
+						}
+					],
+					"contentName": "comment.block.html"
+				},
+				{ // startDelimiter + tagName
+					"match": "<[A-Za-z0-9_\\-:]+(?= ?)",
+					"name": "entity.name.tag.html"
+				},
+				{ "include": "#attrName" },
+				{ "include": "#qString" },
+				{ "include": "#qqString" },
+				{ "include": "#entity" },
+				// TODO attrName, qString, qqString should be applied first while inside a tag
+				{ // startDelimiter + slash + tagName + endDelimiter
+					"match": "</[A-Za-z0-9_\\-:]+>",
+					"name": "entity.name.tag.html"
+				},
+				{ // end delimiter of open tag
+					"match": ">", 
+					"name": "entity.name.tag.html"
+				} ],
+			"repository": {
+				"attrName": { // attribute name
+					"match": "[A-Za-z\\-:]+(?=\\s*=\\s*['\"])",
+					"name": "entity.other.attribute.name.html"
+				},
+				"qqString": { // double quoted string
+					"match": "(\")[^\"]+(\")",
+					"name": "string.quoted.double.html"
+				},
+				"qString": { // single quoted string
+					"match": "(')[^']+(\')",
+					"name": "string.quoted.single.html"
+				},
+				"entity": {
+					"match": "&[A-Za-z0-9]+;",
+					"name": "constant.character.entity.html"
+				}
+			}
+		};
 	}
+
+	return {HtmlGrammar: HtmlGrammar};
+});
+/******************************************************************************* 
+ * @license
+ * Copyright (c) 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials are made 
+ * available under the terms of the Eclipse Public License v1.0 
+ * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
+ * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
+ * 
+ * Contributors: IBM Corporation - initial API and implementation 
+ ******************************************************************************/
+
+/*jslint regexp:false laxbreak:true*/
+/*global define */
+
+define("orion/editor/textMateStyler", ['orion/editor/regex'], function(mRegex) {
+
+var RegexUtil = {
+	// Rules to detect some unsupported Oniguruma features
+	unsupported: [
+		{regex: /\(\?[ims\-]:/, func: function(match) { return "option on/off for subexp"; }},
+		{regex: /\(\?<([=!])/, func: function(match) { return (match[1] === "=") ? "lookbehind" : "negative lookbehind"; }},
+		{regex: /\(\?>/, func: function(match) { return "atomic group"; }}
+	],
+	
 	/**
-	 * Adds in the event target interface into the specified object.
-	 *
-	 * @param {Object} object The object to add in the event target interface.
+	 * @param {String} str String giving a regular expression pattern from a TextMate grammar.
+	 * @param {String} [flags] [ismg]+
+	 * @returns {RegExp}
 	 */
-	EventTarget.addMixin = function(object) {
-		var proto = EventTarget.prototype;
-		for (var p in proto) {
-			if (proto.hasOwnProperty(p)) {
-				object[p] = proto[p];
-			}
+	toRegExp: function(str) {
+		function fail(feature, match) {
+			throw new Error("Unsupported regex feature \"" + feature + "\": \"" + match[0] + "\" at index: "
+					+ match.index + " in " + match.input);
 		}
-	};
-	EventTarget.prototype = /** @lends orion.textview.EventTarget.prototype */ {
-		/**
-		 * Adds an event listener to this event target.
-		 * 
-		 * @param {String} type The event type.
-		 * @param {Function|EventListener} listener The function or the EventListener that will be executed when the event happens. 
-		 * @param {Boolean} [useCapture=false] <code>true</code> if the listener should be trigged in the capture phase.
-		 * 
-		 * @see #removeEventListener
-		 */
-		addEventListener: function(type, listener, useCapture) {
-			if (!this._eventTypes) { this._eventTypes = {}; }
-			var state = this._eventTypes[type];
-			if (!state) {
-				state = this._eventTypes[type] = {level: 0, listeners: []};
-			}
-			var listeners = state.listeners;
-			listeners.push({listener: listener, useCapture: useCapture});
-		},
-		/**
-		 * Dispatches the given event to the listeners added to this event target.
-		 * @param {Event} evt The event to dispatch.
-		 */
-		dispatchEvent: function(evt) {
-			if (!this._eventTypes) { return; }
-			var type = evt.type;
-			var state = this._eventTypes[type];
-			if (state) {
-				var listeners = state.listeners;
-				try {
-					state.level++;
-					if (listeners) {
-						for (var i=0, len=listeners.length; i < len; i++) {
-							if (listeners[i]) {
-								var l = listeners[i].listener;
-								if (typeof l === "function") {
-									l.call(this, evt);
-								} else if (l.handleEvent && typeof l.handleEvent === "function") {
-									l.handleEvent(evt);
+		// Turns an extended regex pattern into a normal one
+		function normalize(/**String*/ str) {
+			var result = "";
+			var insideCharacterClass = false;
+			var len = str.length;
+			for (var i=0; i < len; ) {
+				var chr = str.charAt(i);
+				if (!insideCharacterClass && chr === "#") {
+					// skip to eol
+					while (i < len && chr !== "\r" && chr !== "\n") {
+						chr = str.charAt(++i);
+					}
+				} else if (!insideCharacterClass && /\s/.test(chr)) {
+					// skip whitespace
+					while (i < len && /\s/.test(chr)) { 
+						chr = str.charAt(++i);
+					}
+				} else if (chr === "\\") {
+					result += chr;
+					if (!/\s/.test(str.charAt(i+1))) {
+						result += str.charAt(i+1);
+						i += 1;
+					}
+					i += 1;
+				} else if (chr === "[") {
+					insideCharacterClass = true;
+					result += chr;
+					i += 1;
+				} else if (chr === "]") {
+					insideCharacterClass = false;
+					result += chr;
+					i += 1;
+				} else {
+					result += chr;
+					i += 1;
+				}
+			}
+			return result;
+		}
+		
+		var flags = "";
+		var i;
+		
+		// Handle global "x" flag (whitespace/comments)
+		str = RegexUtil.processGlobalFlag("x", str, function(subexp) {
+				return normalize(subexp);
+			});
+		
+		// Handle global "i" flag (case-insensitive)
+		str = RegexUtil.processGlobalFlag("i", str, function(subexp) {
+				flags += "i";
+				return subexp;
+			});
+		
+		// Check for remaining unsupported syntax
+		for (i=0; i < this.unsupported.length; i++) {
+			var match;
+			if ((match = this.unsupported[i].regex.exec(str))) {
+				fail(this.unsupported[i].func(match), match);
+			}
+		}
+		
+		return new RegExp(str, flags);
+	},
+	
+	/**
+	 * Checks if flag applies to entire pattern. If so, obtains replacement string by calling processor
+	 * on the unwrapped pattern. Handles 2 possible syntaxes: (?f)pat and (?f:pat)
+	 */
+	processGlobalFlag: function(/**String*/ flag, /**String*/ str, /**Function*/ processor) {
+		function getMatchingCloseParen(/*String*/pat, /*Number*/start) {
+			var depth = 0,
+			    len = pat.length,
+			    flagStop = -1;
+			for (var i=start; i < len && flagStop === -1; i++) {
+				switch (pat.charAt(i)) {
+					case "\\":
+						i++; // escape: skip next char
+						break;
+					case "(":
+						depth++;
+						break;
+					case ")":
+						depth--;
+						if (depth === 0) {
+							flagStop = i;
+						}
+						break;
+				}
+			}
+			return flagStop;
+		}
+		var flag1 = "(?" + flag + ")",
+		    flag2 = "(?" + flag + ":";
+		if (str.substring(0, flag1.length) === flag1) {
+			return processor(str.substring(flag1.length));
+		} else if (str.substring(0, flag2.length) === flag2) {
+			var flagStop = getMatchingCloseParen(str, 0);
+			if (flagStop < str.length-1) {
+				throw new Error("Only a " + flag2 + ") group that encloses the entire regex is supported in: " + str);
+			}
+			return processor(str.substring(flag2.length, flagStop));
+		}
+		return str;
+	},
+	
+	hasBackReference: function(/**RegExp*/ regex) {
+		return (/\\\d+/).test(regex.source);
+	},
+	
+	/** @returns {RegExp} A regex made by substituting any backreferences in <code>regex</code> for the value of the property
+	 * in <code>sub</code> with the same name as the backreferenced group number. */
+	getSubstitutedRegex: function(/**RegExp*/ regex, /**Object*/ sub, /**Boolean*/ escape) {
+		escape = (typeof escape === "undefined") ? true : false;
+		var exploded = regex.source.split(/(\\\d+)/g);
+		var array = [];
+		for (var i=0; i < exploded.length; i++) {
+			var term = exploded[i];
+			var backrefMatch = /\\(\d+)/.exec(term);
+			if (backrefMatch) {
+				var text = sub[backrefMatch[1]] || "";
+				array.push(escape ? mRegex.escape(text) : text);
+			} else {
+				array.push(term);
+			}
+		}
+		return new RegExp(array.join(""));
+	},
+	
+	/**
+	 * Builds a version of <code>regex</code> with every non-capturing term converted into a capturing group. This is a workaround
+	 * for JavaScript's lack of API to get the index at which a matched group begins in the input string.<p>
+	 * Using the "groupified" regex, we can sum the lengths of matches from <i>consuming groups</i> 1..n-1 to obtain the 
+	 * starting index of group n. (A consuming group is a capturing group that is not inside a lookahead assertion).</p>
+	 * Example: groupify(/(a+)x+(b+)/) === /(a+)(x+)(b+)/<br />
+	 * Example: groupify(/(?:x+(a+))b+/) === /(?:(x+)(a+))(b+)/
+	 * @param {RegExp} regex The regex to groupify.
+	 * @param {Object} [backRefOld2NewMap] Optional. If provided, the backreference numbers in regex will be updated using the 
+	 * properties of this object rather than the new group numbers of regex itself.
+	 * <ul><li>[0] {RegExp} The groupified version of the input regex.</li>
+	 * <li>[1] {Object} A map containing old-group to new-group info. Each property is a capturing group number of <code>regex</code>
+	 * and its value is the corresponding capturing group number of [0].</li>
+	 * <li>[2] {Object} A map indicating which capturing groups of [0] are also consuming groups. If a group number is found
+	 * as a property in this object, then it's a consuming group.</li></ul>
+	 */
+	groupify: function(regex, backRefOld2NewMap) {
+		var NON_CAPTURING = 1,
+		    CAPTURING = 2,
+		    LOOKAHEAD = 3,
+		    NEW_CAPTURING = 4;
+		var src = regex.source,
+		    len = src.length;
+		var groups = [],
+		    lookaheadDepth = 0,
+		    newGroups = [],
+		    oldGroupNumber = 1,
+		    newGroupNumber = 1;
+		var result = [],
+		    old2New = {},
+		    consuming = {};
+		for (var i=0; i < len; i++) {
+			var curGroup = groups[groups.length-1];
+			var chr = src.charAt(i);
+			switch (chr) {
+				case "(":
+					// If we're in new capturing group, close it since ( signals end-of-term
+					if (curGroup === NEW_CAPTURING) {
+						groups.pop();
+						result.push(")");
+						newGroups[newGroups.length-1].end = i;
+					}
+					var peek2 = (i + 2 < len) ? (src.charAt(i+1) + "" + src.charAt(i+2)) : null;
+					if (peek2 === "?:" || peek2 === "?=" || peek2 === "?!") {
+						// Found non-capturing group or lookahead assertion. Note that we preserve non-capturing groups
+						// as such, but any term inside them will become a new capturing group (unless it happens to
+						// also be inside a lookahead).
+						var groupType;
+						if (peek2 === "?:") {
+							groupType = NON_CAPTURING;
+						} else {
+							groupType = LOOKAHEAD;
+							lookaheadDepth++;
+						}
+						groups.push(groupType);
+						newGroups.push({ start: i, end: -1, type: groupType /*non capturing*/ });
+						result.push(chr);
+						result.push(peek2);
+						i += peek2.length;
+					} else {
+						groups.push(CAPTURING);
+						newGroups.push({ start: i, end: -1, type: CAPTURING, oldNum: oldGroupNumber, num: newGroupNumber });
+						result.push(chr);
+						if (lookaheadDepth === 0) {
+							consuming[newGroupNumber] = null;
+						}
+						old2New[oldGroupNumber] = newGroupNumber;
+						oldGroupNumber++;
+						newGroupNumber++;
+					}
+					break;
+				case ")":
+					var group = groups.pop();
+					if (group === LOOKAHEAD) { lookaheadDepth--; }
+					newGroups[newGroups.length-1].end = i;
+					result.push(chr);
+					break;
+				case "*":
+				case "+":
+				case "?":
+				case "}":
+					// Unary operator. If it's being applied to a capturing group, we need to add a new capturing group
+					// enclosing the pair
+					var op = chr;
+					var prev = src.charAt(i-1),
+					    prevIndex = i-1;
+					if (chr === "}") {
+						for (var j=i-1; src.charAt(j) !== "{" && j >= 0; j--) {}
+						prev = src.charAt(j-1);
+						prevIndex = j-1;
+						op = src.substring(j, i+1);
+					}
+					var lastGroup = newGroups[newGroups.length-1];
+					if (prev === ")" && (lastGroup.type === CAPTURING || lastGroup.type === NEW_CAPTURING)) {
+						// Shove in the new group's (, increment num/start in from [lastGroup.start .. end]
+						result.splice(lastGroup.start, 0, "(");
+						result.push(op);
+						result.push(")");
+						var newGroup = { start: lastGroup.start, end: result.length-1, type: NEW_CAPTURING, num: lastGroup.num };
+						for (var k=0; k < newGroups.length; k++) {
+							group = newGroups[k];
+							if (group.type === CAPTURING || group.type === NEW_CAPTURING) {
+								if (group.start >= lastGroup.start && group.end <= prevIndex) {
+									group.start += 1;
+									group.end += 1;
+									group.num = group.num + 1;
+									if (group.type === CAPTURING) {
+										old2New[group.oldNum] = group.num;
+									}
 								}
 							}
 						}
-					}
-				} finally {
-					state.level--;
-					if (state.compact && state.level === 0) {
-						for (var j=listeners.length - 1; j >= 0; j--) {
-							if (!listeners[j]) {
-								listeners.splice(j, 1);
+						newGroups.push(newGroup);
+						newGroupNumber++;
+						break;
+					} else {
+						// Fallthrough to default
+					}
+				default:
+					if (chr !== "|" && curGroup !== CAPTURING && curGroup !== NEW_CAPTURING) {
+						// Not in a capturing group, so make a new one to hold this term.
+						// Perf improvement: don't create the new group if we're inside a lookahead, since we don't 
+						// care about them (nothing inside a lookahead actually consumes input so we don't need it)
+						if (lookaheadDepth === 0) {
+							groups.push(NEW_CAPTURING);
+							newGroups.push({ start: i, end: -1, type: NEW_CAPTURING, num: newGroupNumber });
+							result.push("(");
+							consuming[newGroupNumber] = null;
+							newGroupNumber++;
+						}
+					}
+					result.push(chr);
+					if (chr === "\\") {
+						var peek = src.charAt(i+1);
+						// Eat next so following iteration doesn't think it's a real special character
+						result.push(peek);
+						i += 1;
+					}
+					break;
+			}
+		}
+		while (groups.length) {	
+			// Close any remaining new capturing groups
+			groups.pop();
+			result.push(")");
+		}
+		var newRegex = new RegExp(result.join(""));
+		
+		// Update backreferences so they refer to the new group numbers. Use backRefOld2NewMap if provided
+		var subst = {};
+		backRefOld2NewMap = backRefOld2NewMap || old2New;
+		for (var prop in backRefOld2NewMap) {
+			if (backRefOld2NewMap.hasOwnProperty(prop)) {
+				subst[prop] = "\\" + backRefOld2NewMap[prop];
+			}
+		}
+		newRegex = this.getSubstitutedRegex(newRegex, subst, false);
+		
+		return [newRegex, old2New, consuming];
+	},
+	
+	/** @returns {Boolean} True if the captures object assigns scope to a matching group other than "0". */
+	complexCaptures: function(capturesObj) {
+		if (!capturesObj) { return false; }
+		for (var prop in capturesObj) {
+			if (capturesObj.hasOwnProperty(prop)) {
+				if (prop !== "0") {
+					return true;
+				}
+			}
+		}
+		return false;
+	}
+};
+
+	/**
+	 * @name orion.editor.TextMateStyler
+	 * @class A styler that knows how to apply a subset of the TextMate grammar format to style a line.
+	 *
+	 * <h4>Styling from a grammar:</h4>
+	 * <p>Each scope name given in the grammar is converted to an array of CSS class names. For example 
+	 * a region of text with scope <code>keyword.control.php</code> will be assigned the CSS classes<br />
+	 * <code>keyword, keyword-control, keyword-control-php</code></p>
+	 *
+	 * <p>A CSS file can give rules matching any of these class names to provide generic or more specific styling.
+	 * For example,</p>
+	 * <p><code>.keyword { font-color: blue; }</code></p>
+	 * <p>colors all keywords blue, while</p>
+	 * <p><code>.keyword-control-php { font-weight: bold; }</code></p>
+	 * <p>bolds only PHP control keywords.</p>
+	 *
+	 * <p>This is useful when using grammars that adhere to TextMate's
+	 * <a href="http://manual.macromates.com/en/language_grammars.html#naming_conventions">scope name conventions</a>,
+	 * as a single CSS rule can provide consistent styling to similar constructs across different languages.</p>
+	 * 
+	 * <h4>Top-level grammar constructs:</h4>
+	 * <ul><li><code>patterns, repository</code> (with limitations, see "Other Features") are supported.</li>
+	 * <li><code>scopeName, firstLineMatch, foldingStartMarker, foldingStopMarker</code> are <b>not</b> supported.</li>
+	 * <li><code>fileTypes</code> is <b>not</b> supported. When using the Orion service registry, the "orion.edit.highlighter"
+	 * service serves a similar purpose.</li>
+	 * </ul>
+	 *
+	 * <h4>Regular expression constructs:</h4>
+	 * <ul>
+	 * <li><code>match</code> patterns are supported.</li>
+	 * <li><code>begin .. end</code> patterns are supported.</li>
+	 * <li>The "extended" regex forms <code>(?x)</code> and <code>(?x:...)</code> are supported, but <b>only</b> when they 
+	 * apply to the entire regex pattern.</li>
+	 * <li>Matching is done using native JavaScript <code>RegExp</code>s. As a result, many features of the Oniguruma regex
+	 * engine used by TextMate are <b>not</b> supported.
+	 * Unsupported features include:
+	 *   <ul><li>Named captures</li>
+	 *   <li>Setting flags inside subgroups (eg. <code>(?i:a)b</code>)</li>
+	 *   <li>Lookbehind and negative lookbehind</li>
+	 *   <li>Subexpression call</li>
+	 *   <li>etc.</li>
+	 *   </ul>
+	 * </li>
+	 * </ul>
+	 * 
+	 * <h4>Scope-assignment constructs:</h4>
+	 * <ul>
+	 * <li><code>captures, beginCaptures, endCaptures</code> are supported.</li>
+	 * <li><code>name</code> and <code>contentName</code> are supported.</li>
+	 * </ul>
+	 * 
+	 * <h4>Other features:</h4>
+	 * <ul>
+	 * <li><code>applyEndPatternLast</code> is supported.</li>
+	 * <li><code>include</code> is supported, but only when it references a rule in the current grammar's <code>repository</code>.
+	 * Including <code>$self</code>, <code>$base</code>, or <code>rule.from.another.grammar</code> is <b>not</b> supported.</li>
+	 * </ul>
+	 * 
+	 * @description Creates a new TextMateStyler.
+	 * @extends orion.editor.AbstractStyler
+	 * @param {orion.textview.TextView} textView The <code>TextView</code> to provide styling for.
+	 * @param {Object} grammar The TextMate grammar to use for styling the <code>TextView</code>, as a JavaScript object. You can
+	 * produce this object by running a PList-to-JavaScript conversion tool on a TextMate <code>.tmLanguage</code> file.
+	 * @param {Object[]} [externalGrammars] Additional grammar objects that will be used to resolve named rule references.
+	 */
+	function TextMateStyler(textView, grammar, externalGrammars) {
+		this.initialize(textView);
+		// Copy grammar object(s) since we will mutate them
+		this.grammar = this.clone(grammar);
+		this.externalGrammars = externalGrammars ? this.clone(externalGrammars) : [];
+		
+		this._styles = {}; /* key: {String} scopeName, value: {String[]} cssClassNames */
+		this._tree = null;
+		this._allGrammars = {}; /* key: {String} scopeName of grammar, value: {Object} grammar */
+		this.preprocess(this.grammar);
+	}
+	TextMateStyler.prototype = /** @lends orion.editor.TextMateStyler.prototype */ {
+		initialize: function(textView) {
+			this.textView = textView;
+			var self = this;
+			this._listener = {
+				onModelChanged: function(e) {
+					self.onModelChanged(e);
+				},
+				onDestroy: function(e) {
+					self.onDestroy(e);
+				},
+				onLineStyle: function(e) {
+					self.onLineStyle(e);
+				}
+			};
+			textView.addEventListener("ModelChanged", this._listener.onModelChanged);
+			textView.addEventListener("Destroy", this._listener.onDestroy);
+			textView.addEventListener("LineStyle", this._listener.onLineStyle);
+			textView.redrawLines();
+		},
+		onDestroy: function(/**eclipse.DestroyEvent*/ e) {
+			this.destroy();
+		},
+		destroy: function() {
+			if (this.textView) {
+				this.textView.removeEventListener("ModelChanged", this._listener.onModelChanged);
+				this.textView.removeEventListener("Destroy", this._listener.onDestroy);
+				this.textView.removeEventListener("LineStyle", this._listener.onLineStyle);
+				this.textView = null;
+			}
+			this.grammar = null;
+			this._styles = null;
+			this._tree = null;
+			this._listener = null;
+		},
+		/**
+		 * @private
+		 * @param obj {Object} A JSON-ish object.
+		 * @returns {Object} Deep copy of <code>obj</code>. Does not work on properties that are functions or RegExp instances.
+		 */
+		clone: function clone(obj) {
+			var c;
+			if (obj instanceof Array) {
+				c = new Array(obj.length);
+				for (var i=0; i < obj.length; i++) {
+					c[i] = clone(obj[i]);
+				}
+			} else {
+				c = {};
+				for (var prop in obj) {
+					if (Object.prototype.hasOwnProperty.call(obj, prop)) {
+						var value = obj[prop];
+						if (typeof value === "object" && value !== null) {
+							c[prop] = clone(value);
+						} else {
+							c[prop] = value;
+						}
+					}
+				}
+			}
+			return c;
+		},
+		/** @private */
+		preprocess: function(grammar) {
+			var stack = [grammar];
+			for (; stack.length !== 0; ) {
+				var rule = stack.pop();
+				if (rule._resolvedRule && rule._typedRule) {
+					continue;
+				}
+//					console.debug("Process " + (rule.include || rule.name));
+				
+				// Look up include'd rule, create typed *Rule instance
+				rule._resolvedRule = this._resolve(rule);
+				rule._typedRule = this._createTypedRule(rule);
+				
+				// Convert the scope names to styles and cache them for later
+				this.addStyles(rule.name);
+				this.addStyles(rule.contentName);
+				this.addStylesForCaptures(rule.captures);
+				this.addStylesForCaptures(rule.beginCaptures);
+				this.addStylesForCaptures(rule.endCaptures);
+				
+				if (rule._resolvedRule !== rule) {
+					// Add include target
+					stack.push(rule._resolvedRule);
+				}
+				if (rule.patterns) {
+					// Add subrules
+					for (var i=0; i < rule.patterns.length; i++) {
+						stack.push(rule.patterns[i]);
+					}
+				}
+			}
+		},
+		
+		/**
+		 * @private
+		 * Adds eclipse.Style objects for scope to our _styles cache.
+		 * @param {String} scope A scope name, like "constant.character.php".
+		 */
+		addStyles: function(scope) {
+			if (scope && !this._styles[scope]) {
+				this._styles[scope] = [];
+				var scopeArray = scope.split(".");
+				for (var i = 0; i < scopeArray.length; i++) {
+					this._styles[scope].push(scopeArray.slice(0, i + 1).join("-"));
+				}
+			}
+		},
+		/** @private */
+		addStylesForCaptures: function(/**Object*/ captures) {
+			for (var prop in captures) {
+				if (captures.hasOwnProperty(prop)) {
+					var scope = captures[prop].name;
+					this.addStyles(scope);
+				}
+			}
+		},
+		/**
+		 * A rule that contains subrules ("patterns" in TextMate parlance) but has no "begin" or "end".
+		 * Also handles top level of grammar.
+		 * @private
+		 */
+		ContainerRule: (function() {
+			function ContainerRule(/**Object*/ rule) {
+				this.rule = rule;
+				this.subrules = rule.patterns;
+			}
+			ContainerRule.prototype.valueOf = function() { return "aa"; };
+			return ContainerRule;
+		}()),
+		/**
+		 * A rule that is delimited by "begin" and "end" matches, which may be separated by any number of
+		 * lines. This type of rule may contain subrules, which apply only inside the begin .. end region.
+		 * @private
+		 */
+		BeginEndRule: (function() {
+			function BeginEndRule(/**Object*/ rule) {
+				this.rule = rule;
+				// TODO: the TextMate blog claims that "end" is optional.
+				this.beginRegex = RegexUtil.toRegExp(rule.begin);
+				this.endRegex = RegexUtil.toRegExp(rule.end);
+				this.subrules = rule.patterns || [];
+				
+				this.endRegexHasBackRef = RegexUtil.hasBackReference(this.endRegex);
+				
+				// Deal with non-0 captures
+				var complexCaptures = RegexUtil.complexCaptures(rule.captures);
+				var complexBeginEnd = RegexUtil.complexCaptures(rule.beginCaptures) || RegexUtil.complexCaptures(rule.endCaptures);
+				this.isComplex = complexCaptures || complexBeginEnd;
+				if (this.isComplex) {
+					var bg = RegexUtil.groupify(this.beginRegex);
+					this.beginRegex = bg[0];
+					this.beginOld2New = bg[1];
+					this.beginConsuming = bg[2];
+					
+					var eg = RegexUtil.groupify(this.endRegex, this.beginOld2New /*Update end's backrefs to begin's new group #s*/);
+					this.endRegex = eg[0];
+					this.endOld2New = eg[1];
+					this.endConsuming = eg[2];
+				}
+			}
+			BeginEndRule.prototype.valueOf = function() { return this.beginRegex; };
+			return BeginEndRule;
+		}()),
+		/**
+		 * A rule with a "match" pattern.
+		 * @private
+		 */
+		MatchRule: (function() {
+			function MatchRule(/**Object*/ rule) {
+				this.rule = rule;
+				this.matchRegex = RegexUtil.toRegExp(rule.match);
+				this.isComplex = RegexUtil.complexCaptures(rule.captures);
+				if (this.isComplex) {
+					var mg = RegexUtil.groupify(this.matchRegex);
+					this.matchRegex = mg[0];
+					this.matchOld2New = mg[1];
+					this.matchConsuming = mg[2];
+				}
+			}
+			MatchRule.prototype.valueOf = function() { return this.matchRegex; };
+			return MatchRule;
+		}()),
+		/**
+		 * @param {Object} rule A rule from the grammar.
+		 * @returns {MatchRule|BeginEndRule|ContainerRule}
+		 * @private
+		 */
+		_createTypedRule: function(rule) {
+			if (rule.match) {
+				return new this.MatchRule(rule);
+			} else if (rule.begin) {
+				return new this.BeginEndRule(rule);
+			} else {
+				return new this.ContainerRule(rule);
+			}
+		},
+		/**
+		 * Resolves a rule from the grammar (which may be an include) into the real rule that it points to.
+		 * @private
+		 */
+		_resolve: function(rule) {
+			var resolved = rule;
+			if (rule.include) {
+				if (rule.begin || rule.end || rule.match) {
+					throw new Error("Unexpected regex pattern in \"include\" rule " + rule.include);
+				}
+				var name = rule.include;
+				if (name.charAt(0) === "#") {
+					resolved = this.grammar.repository && this.grammar.repository[name.substring(1)];
+					if (!resolved) { throw new Error("Couldn't find included rule " + name + " in grammar repository"); }
+				} else if (name === "$self") {
+					resolved = this.grammar;
+				} else if (name === "$base") {
+					// $base is only relevant when including rules from foreign grammars
+					throw new Error("Include \"$base\" is not supported"); 
+				} else {
+					resolved = this._allGrammars[name];
+					if (!resolved) {
+						for (var i=0; i < this.externalGrammars.length; i++) {
+							var grammar = this.externalGrammars[i];
+							if (grammar.scopeName === name) {
+								this.preprocess(grammar);
+								this._allGrammars[name] = grammar;
+								resolved = grammar;
+								break;
 							}
 						}
-						if (listeners.length === 0) {
-							delete this._eventTypes[type];
+					}
+				}
+			}
+			return resolved;
+		},
+		/** @private */
+		ContainerNode: (function() {
+			function ContainerNode(parent, rule) {
+				this.parent = parent;
+				this.rule = rule;
+				this.children = [];
+				
+				this.start = null;
+				this.end = null;
+			}
+			ContainerNode.prototype.addChild = function(child) {
+				this.children.push(child);
+			};
+			ContainerNode.prototype.valueOf = function() {
+				var r = this.rule;
+				return "ContainerNode { " + (r.include || "") + " " + (r.name || "") + (r.comment || "") + "}";
+			};
+			return ContainerNode;
+		}()),
+		/** @private */
+		BeginEndNode: (function() {
+			function BeginEndNode(parent, rule, beginMatch) {
+				this.parent = parent;
+				this.rule = rule;
+				this.children = [];
+				
+				this.setStart(beginMatch);
+				this.end = null; // will be set eventually during parsing (may be EOF)
+				this.endMatch = null; // may remain null if we never match our "end" pattern
+				
+				// Build a new regex if the "end" regex has backrefs since they refer to matched groups of beginMatch
+				if (rule.endRegexHasBackRef) {
+					this.endRegexSubstituted = RegexUtil.getSubstitutedRegex(rule.endRegex, beginMatch);
+				} else {
+					this.endRegexSubstituted = null;
+				}
+			}
+			BeginEndNode.prototype.addChild = function(child) {
+				this.children.push(child);
+			};
+			/** @return {Number} This node's index in its parent's "children" list */
+			BeginEndNode.prototype.getIndexInParent = function(node) {
+				return this.parent ? this.parent.children.indexOf(this) : -1;
+			};
+			/** @param {RegExp.match} beginMatch */
+			BeginEndNode.prototype.setStart = function(beginMatch) {
+				this.start = beginMatch.index;
+				this.beginMatch = beginMatch;
+			};
+			/** @param {RegExp.match|Number} endMatchOrLastChar */
+			BeginEndNode.prototype.setEnd = function(endMatchOrLastChar) {
+				if (endMatchOrLastChar && typeof(endMatchOrLastChar) === "object") {
+					var endMatch = endMatchOrLastChar;
+					this.endMatch = endMatch;
+					this.end = endMatch.index + endMatch[0].length;
+				} else {
+					var lastChar = endMatchOrLastChar;
+					this.endMatch = null;
+					this.end = lastChar;
+				}
+			};
+			BeginEndNode.prototype.shiftStart = function(amount) {
+				this.start += amount;
+				this.beginMatch.index += amount;
+			};
+			BeginEndNode.prototype.shiftEnd = function(amount) {
+				this.end += amount;
+				if (this.endMatch) { this.endMatch.index += amount; }
+			};
+			BeginEndNode.prototype.valueOf = function() {
+				return "{" + this.rule.beginRegex + " range=" + this.start + ".." + this.end + "}";
+			};
+			return BeginEndNode;
+		}()),
+		/** Pushes rules onto stack such that rules[startFrom] is on top
+		 * @private
+		 */
+		push: function(/**Array*/ stack, /**Array*/ rules) {
+			if (!rules) { return; }
+			for (var i = rules.length; i > 0; ) {
+				stack.push(rules[--i]);
+			}
+		},
+		/** Executes <code>regex</code> on <code>text</code>, and returns the match object with its index 
+		 * offset by the given amount.
+		 * @returns {RegExp.match}
+		 * @private
+		 */
+		exec: function(/**RegExp*/ regex, /**String*/ text, /**Number*/ offset) {
+			var match = regex.exec(text);
+			if (match) { match.index += offset; }
+			regex.lastIndex = 0; // Just in case
+			return match;
+		},
+		/** @returns {Number} The position immediately following the match.
+		 * @private
+		 */
+		afterMatch: function(/**RegExp.match*/ match) {
+			return match.index + match[0].length;
+		},
+		/**
+		 * @returns {RegExp.match} If node is a BeginEndNode and its rule's "end" pattern matches the text.
+		 * @private
+		 */
+		getEndMatch: function(/**Node*/ node, /**String*/ text, /**Number*/ offset) {
+			if (node instanceof this.BeginEndNode) {
+				var rule = node.rule;
+				var endRegex = node.endRegexSubstituted || rule.endRegex;
+				if (!endRegex) { return null; }
+				return this.exec(endRegex, text, offset);
+			}
+			return null;
+		},
+		/** Called once when file is first loaded to build the parse tree. Tree is updated incrementally thereafter 
+		 * as buffer is modified.
+		 * @private
+		 */
+		initialParse: function() {
+			var last = this.textView.getModel().getCharCount();
+			// First time; make parse tree for whole buffer
+			var root = new this.ContainerNode(null, this.grammar._typedRule);
+			this._tree = root;
+			this.parse(this._tree, false, 0);
+		},
+		onModelChanged: function(/**eclipse.ModelChangedEvent*/ e) {
+			var addedCharCount = e.addedCharCount,
+			    addedLineCount = e.addedLineCount,
+			    removedCharCount = e.removedCharCount,
+			    removedLineCount = e.removedLineCount,
+			    start = e.start;
+			if (!this._tree) {
+				this.initialParse();
+			} else {
+				var model = this.textView.getModel();
+				var charCount = model.getCharCount();
+				
+				// For rs, we must rewind to the line preceding the line 'start' is on. We can't rely on start's
+				// line since it may've been changed in a way that would cause a new beginMatch at its lineStart.
+				var rs = model.getLineEnd(model.getLineAtOffset(start) - 1); // may be < 0
+				var fd = this.getFirstDamaged(rs, rs);
+				rs = rs === -1 ? 0 : rs;
+				var stoppedAt;
+				if (fd) {
+					// [rs, re] is the region we need to verify. If we find the structure of the tree
+					// has changed in that area, then we may need to reparse the rest of the file.
+					stoppedAt = this.parse(fd, true, rs, start, addedCharCount, removedCharCount);
+				} else {
+					// FIXME: fd == null ?
+					stoppedAt = charCount;
+				}
+				this.textView.redrawRange(rs, stoppedAt);
+			}
+		},
+		/** @returns {BeginEndNode|ContainerNode} The result of taking the first (smallest "start" value) 
+		 * node overlapping [start,end] and drilling down to get its deepest damaged descendant (if any).
+		 * @private
+		 */
+		getFirstDamaged: function(start, end) {
+			// If start === 0 we actually have to start from the root because there is no position
+			// we can rely on. (First index is damaged)
+			if (start < 0) {
+				return this._tree;
+			}
+			
+			var nodes = [this._tree];
+			var result = null;
+			while (nodes.length) {
+				var n = nodes.pop();
+				if (!n.parent /*n is root*/ || this.isDamaged(n, start, end)) {
+					// n is damaged by the edit, so go into its children
+					// Note: If a node is damaged, then some of its descendents MAY be damaged
+					// If a node is undamaged, then ALL of its descendents are undamaged
+					if (n instanceof this.BeginEndNode) {
+						result = n;
+					}
+					// Examine children[0] last
+					for (var i=0; i < n.children.length; i++) {
+						nodes.push(n.children[i]);
+					}
+				}
+			}
+			return result || this._tree;
+		},
+		/** @returns true If <code>n</code> overlaps the interval [start,end].
+		 * @private
+		 */
+		isDamaged: function(/**BeginEndNode*/ n, start, end) {
+			// Note strict > since [2,5] doesn't overlap [5,7]
+			return (n.start <= end && n.end > start);
+		},
+		/**
+		 * Builds tree from some of the buffer content
+		 *
+		 * TODO cleanup params
+		 * @param {BeginEndNode|ContainerNode} origNode The deepest node that overlaps [rs,rs], or the root.
+		 * @param {Boolean} repairing 
+		 * @param {Number} rs See _onModelChanged()
+		 * @param {Number} [editStart] Only used for repairing === true
+		 * @param {Number} [addedCharCount] Only used for repairing === true
+		 * @param {Number} [removedCharCount] Only used for repairing === true
+		 * @returns {Number} The end position that redrawRange should be called for.
+		 * @private
+		 */
+		parse: function(origNode, repairing, rs, editStart, addedCharCount, removedCharCount) {
+			var model = this.textView.getModel();
+			var lastLineStart = model.getLineStart(model.getLineCount() - 1);
+			var eof = model.getCharCount();
+			var initialExpected = this.getInitialExpected(origNode, rs);
+			
+			// re is best-case stopping point; if we detect change to tree, we must continue past it
+			var re = -1;
+			if (repairing) {
+				origNode.repaired = true;
+				origNode.endNeedsUpdate = true;
+				var lastChild = origNode.children[origNode.children.length-1];
+				var delta = addedCharCount - removedCharCount;
+				var lastChildLineEnd = lastChild ? model.getLineEnd(model.getLineAtOffset(lastChild.end + delta)) : -1;
+				var editLineEnd = model.getLineEnd(model.getLineAtOffset(editStart + removedCharCount));
+				re = Math.max(lastChildLineEnd, editLineEnd);
+			}
+			re = (re === -1) ? eof : re;
+			
+			var expected = initialExpected;
+			var node = origNode;
+			var matchedChildOrEnd = false;
+			var pos = rs;
+			var redrawEnd = -1;
+			while (node && (!repairing || (pos < re))) {
+				var matchInfo = this.getNextMatch(model, node, pos);
+				if (!matchInfo) {
+					// Go to next line, if any
+					pos = (pos >= lastLineStart) ? eof : model.getLineStart(model.getLineAtOffset(pos) + 1);
+				}
+				var match = matchInfo && matchInfo.match,
+				    rule = matchInfo && matchInfo.rule,
+				    isSub = matchInfo && matchInfo.isSub,
+				    isEnd = matchInfo && matchInfo.isEnd;
+				if (isSub) {
+					pos = this.afterMatch(match);
+					if (rule instanceof this.BeginEndRule) {
+						matchedChildOrEnd = true;
+						// Matched a child. Did we expect that?
+						if (repairing && rule === expected.rule && node === expected.parent) {
+							// Yes: matched expected child
+							var foundChild = expected;
+							foundChild.setStart(match);
+							// Note: the 'end' position for this node will either be matched, or fixed up by us post-loop
+							foundChild.repaired = true;
+							foundChild.endNeedsUpdate = true;
+							node = foundChild; // descend
+							expected = this.getNextExpected(expected, "begin");
+						} else {
+							if (repairing) {
+								// No: matched unexpected child.
+								this.prune(node, expected);
+								repairing = false;
+							}
+							
+							// Add the new child (will replace 'expected' in node's children list)
+							var subNode = new this.BeginEndNode(node, rule, match);
+							node.addChild(subNode);
+							node = subNode; // descend
 						}
-						state.compact = false;
-					}
-				}
-			}
-		},
-		/**
-		 * Returns whether there is a listener for the specified event type.
-		 * 
-		 * @param {String} type The event type
-		 * 
-		 * @see #addEventListener
-		 * @see #removeEventListener
-		 */
-		isListening: function(type) {
-			if (!this._eventTypes) { return false; }
-			return this._eventTypes[type] !== undefined;
-		},		
-		/**
-		 * Removes an event listener from the event target.
-		 * <p>
-		 * All the parameters must be the same ones used to add the listener.
-		 * </p>
-		 * 
-		 * @param {String} type The event type
-		 * @param {Function|EventListener} listener The function or the EventListener that will be executed when the event happens. 
-		 * @param {Boolean} [useCapture=false] <code>true</code> if the listener should be trigged in the capture phase.
-		 * 
-		 * @see #addEventListener
-		 */
-		removeEventListener: function(type, listener, useCapture){
-			if (!this._eventTypes) { return; }
-			var state = this._eventTypes[type];
-			if (state) {
-				var listeners = state.listeners;
-				for (var i=0, len=listeners.length; i < len; i++) {
-					var l = listeners[i];
-					if (l && l.listener === listener && l.useCapture === useCapture) {
-						if (state.level !== 0) {
-							listeners[i] = null;
-							state.compact = true;
+					} else {
+						// Matched a MatchRule; no changes to tree required
+					}
+				} else if (isEnd || pos === eof) {
+					if (node instanceof this.BeginEndNode) {
+						if (match) {
+							matchedChildOrEnd = true;
+							redrawEnd = Math.max(redrawEnd, node.end); // if end moved up, must still redraw to its old value
+							node.setEnd(match);
+							pos = this.afterMatch(match);
+							// Matched node's end. Did we expect that?
+							if (repairing && node === expected && node.parent === expected.parent) {
+								// Yes: found the expected end of node
+								node.repaired = true;
+								delete node.endNeedsUpdate;
+								expected = this.getNextExpected(expected, "end");
+							} else {
+								if (repairing) {
+									// No: found an unexpected end
+									this.prune(node, expected);
+									repairing = false;
+								}
+							}
 						} else {
-							listeners.splice(i, 1);
+							// Force-ending a BeginEndNode that runs until eof
+							node.setEnd(eof);
+							delete node.endNeedsUpdate;
 						}
+					}
+					node = node.parent; // ascend
+				}
+				
+				if (repairing && pos >= re && !matchedChildOrEnd) {
+					// Reached re without matching any begin/end => initialExpected itself was removed => repair fail
+					this.prune(origNode, initialExpected);
+					repairing = false;
+				}
+			} // end loop
+			// TODO: do this for every node we end?
+			this.removeUnrepairedChildren(origNode, repairing, rs);
+			
+			//console.debug("parsed " + (pos - rs) + " of " + model.getCharCount + "buf");
+			this.cleanup(repairing, origNode, rs, re, eof, addedCharCount, removedCharCount);
+			if (repairing) {
+				return Math.max(redrawEnd, pos);
+			} else {
+				return pos; // where we stopped reparsing
+			}
+		},
+		/** Helper for parse() in the repair case. To be called when ending a node, as any children that
+		 * lie in [rs,node.end] and were not repaired must've been deleted.
+		 * @private
+		 */
+		removeUnrepairedChildren: function(node, repairing, start) {
+			if (repairing) {
+				var children = node.children;
+				var removeFrom = -1;
+				for (var i=0; i < children.length; i++) {
+					var child = children[i];
+					if (!child.repaired && this.isDamaged(child, start, Number.MAX_VALUE /*end doesn't matter*/)) {
+						removeFrom = i;
 						break;
 					}
 				}
-				if (listeners.length === 0) {
-					delete this._eventTypes[type];
-				}
-			}
+				if (removeFrom !== -1) {
+					node.children.length = removeFrom;
+				}
+			}
+		},
+		/** Helper for parse() in the repair case
+		 * @private
+		 */
+		cleanup: function(repairing, origNode, rs, re, eof, addedCharCount, removedCharCount) {
+			var i, node, maybeRepairedNodes;
+			if (repairing) {
+				// The repair succeeded, so update stale begin/end indices by simple translation.
+				var delta = addedCharCount - removedCharCount;
+				// A repaired node's end can't exceed re, but it may exceed re-delta+1.
+				// TODO: find a way to guarantee disjoint intervals for repaired vs unrepaired, then stop using flag
+				var maybeUnrepairedNodes = this.getIntersecting(re-delta+1, eof);
+				maybeRepairedNodes = this.getIntersecting(rs, re);
+				// Handle unrepaired nodes. They are those intersecting [re-delta+1, eof] that don't have the flag
+				for (i=0; i < maybeUnrepairedNodes.length; i++) {
+					node = maybeUnrepairedNodes[i];
+					if (!node.repaired && node instanceof this.BeginEndNode) {
+						node.shiftEnd(delta);
+						node.shiftStart(delta);
+					}
+				}
+				// Translate 'end' index of repaired node whose 'end' was not matched in loop (>= re)
+				for (i=0; i < maybeRepairedNodes.length; i++) {
+					node = maybeRepairedNodes[i];
+					if (node.repaired && node.endNeedsUpdate) {
+						node.shiftEnd(delta);
+					}
+					delete node.endNeedsUpdate;
+					delete node.repaired;
+				}
+			} else {
+				// Clean up after ourself
+				maybeRepairedNodes = this.getIntersecting(rs, re);
+				for (i=0; i < maybeRepairedNodes.length; i++) {
+					delete maybeRepairedNodes[i].repaired;
+				}
+			}
+		},
+		/**
+		 * @param model {orion.textview.TextModel}
+		 * @param node {Node}
+		 * @param pos {Number}
+		 * @param [matchRulesOnly] {Boolean} Optional, if true only "match" subrules will be considered.
+		 * @returns {Object} A match info object with properties:
+		 * {Boolean} isEnd
+		 * {Boolean} isSub
+		 * {RegExp.match} match
+		 * {(Match|BeginEnd)Rule} rule
+		 * @private
+		 */
+		getNextMatch: function(model, node, pos, matchRulesOnly) {
+			var lineIndex = model.getLineAtOffset(pos);
+			var lineEnd = model.getLineEnd(lineIndex);
+			var line = model.getText(pos, lineEnd);
+
+			var stack = [],
+			    expandedContainers = [],
+			    subMatches = [],
+			    subrules = [];
+			this.push(stack, node.rule.subrules);
+			while (stack.length) {
+				var next = stack.length ? stack.pop() : null;
+				var subrule = next && next._resolvedRule._typedRule;
+				if (subrule instanceof this.ContainerRule && expandedContainers.indexOf(subrule) === -1) {
+					// Expand ContainerRule by pushing its subrules on
+					expandedContainers.push(subrule);
+					this.push(stack, subrule.subrules);
+					continue;
+				}
+				if (subrule && matchRulesOnly && !(subrule.matchRegex)) {
+					continue;
+				}
+				var subMatch = subrule && this.exec(subrule.matchRegex || subrule.beginRegex, line, pos);
+				if (subMatch) {
+					subMatches.push(subMatch);
+					subrules.push(subrule);
+				}
+			}
+
+			var bestSub = Number.MAX_VALUE,
+			    bestSubIndex = -1;
+			for (var i=0; i < subMatches.length; i++) {
+				var match = subMatches[i];
+				if (match.index < bestSub) {
+					bestSub = match.index;
+					bestSubIndex = i;
+				}
+			}
+			
+			if (!matchRulesOnly) {
+				// See if the "end" pattern of the active begin/end node matches.
+				// TODO: The active begin/end node may not be the same as the node that holds the subrules
+				var activeBENode = node;
+				var endMatch = this.getEndMatch(node, line, pos);
+				if (endMatch) {
+					var doEndLast = activeBENode.rule.applyEndPatternLast;
+					var endWins = bestSubIndex === -1 || (endMatch.index < bestSub) || (!doEndLast && endMatch.index === bestSub);
+					if (endWins) {
+						return {isEnd: true, rule: activeBENode.rule, match: endMatch};
+					}
+				}
+			}
+			return bestSubIndex === -1 ? null : {isSub: true, rule: subrules[bestSubIndex], match: subMatches[bestSubIndex]};
+		},
+		/**
+		 * Gets the node corresponding to the first match we expect to see in the repair.
+		 * @param {BeginEndNode|ContainerNode} node The node returned via getFirstDamaged(rs,rs) -- may be the root.
+		 * @param {Number} rs See _onModelChanged()
+		 * Note that because rs is a line end (or 0, a line start), it will intersect a beginMatch or 
+		 * endMatch either at their 0th character, or not at all. (begin/endMatches can't cross lines).
+		 * This is the only time we rely on the start/end values from the pre-change tree. After this 
+		 * we only look at node ordering, never use the old indices.
+		 * @returns {Node}
+		 * @private
+		 */
+		getInitialExpected: function(node, rs) {
+			// TODO: Kind of weird.. maybe ContainerNodes should have start & end set, like BeginEndNodes
+			var i, child;
+			if (node === this._tree) {
+				// get whichever of our children comes after rs
+				for (i=0; i < node.children.length; i++) {
+					child = node.children[i]; // BeginEndNode
+					if (child.start >= rs) {
+						return child;
+					}
+				}
+			} else if (node instanceof this.BeginEndNode) {
+				if (node.endMatch) {
+					// Which comes next after rs: our nodeEnd or one of our children?
+					var nodeEnd = node.endMatch.index;
+					for (i=0; i < node.children.length; i++) {
+						child = node.children[i]; // BeginEndNode
+						if (child.start >= rs) {
+							break;
+						}
+					}
+					if (child && child.start < nodeEnd) {
+						return child; // Expect child as the next match
+					}
+				} else {
+					// No endMatch => node goes until eof => it end should be the next match
+				}
+			}
+			return node; // We expect node to end, so it should be the next match
+		},
+		/**
+		 * Helper for repair() to tell us what kind of event we expect next.
+		 * @param {Node} expected Last value returned by this method.
+		 * @param {String} event "begin" if the last value of expected was matched as "begin",
+		 *  or "end" if it was matched as an end.
+		 * @returns {Node} The next expected node to match, or null.
+		 * @private
+		 */
+		getNextExpected: function(/**Node*/ expected, event) {
+			var node = expected;
+			if (event === "begin") {
+				var child = node.children[0];
+				if (child) {
+					return child;
+				} else {
+					return node;
+				}
+			} else if (event === "end") {
+				var parent = node.parent;
+				if (parent) {
+					var nextSibling = parent.children[parent.children.indexOf(node) + 1];
+					if (nextSibling) {
+						return nextSibling;
+					} else {
+						return parent;
+					}
+				}
+			}
+			return null;
+		},
+		/** Helper for parse() when repairing. Prunes out the unmatched nodes from the tree so we can continue parsing.
+		 * @private
+		 */
+		prune: function(/**BeginEndNode|ContainerNode*/ node, /**Node*/ expected) {
+			var expectedAChild = expected.parent === node;
+			if (expectedAChild) {
+				// Expected child wasn't matched; prune it and all siblings after it
+				node.children.length = expected.getIndexInParent();
+			} else if (node instanceof this.BeginEndNode) {
+				// Expected node to end but it didn't; set its end unknown and we'll match it eventually
+				node.endMatch = null;
+				node.end = null;
+			}
+			// Reparsing from node, so prune the successors outside of node's subtree
+			if (node.parent) {
+				node.parent.children.length = node.getIndexInParent() + 1;
+			}
+		},
+		onLineStyle: function(/**eclipse.LineStyleEvent*/ e) {
+			function byStart(r1, r2) {
+				return r1.start - r2.start;
+			}
+			
+			if (!this._tree) {
+				// In some cases it seems onLineStyle is called before onModelChanged, so we need to parse here
+				this.initialParse();
+			}
+			var lineStart = e.lineStart,
+			    model = this.textView.getModel(),
+			    lineEnd = model.getLineEnd(e.lineIndex);
+			
+			var rs = model.getLineEnd(model.getLineAtOffset(lineStart) - 1); // may be < 0
+			var node = this.getFirstDamaged(rs, rs);
+			
+			var scopes = this.getLineScope(model, node, lineStart, lineEnd);
+			e.ranges = this.toStyleRanges(scopes);
+			// Editor requires StyleRanges must be in ascending order by 'start', or else some will be ignored
+			e.ranges.sort(byStart);
+		},
+		/** Runs parse algorithm on [start, end] in the context of node, assigning scope as we find matches.
+		 * @private
+		 */
+		getLineScope: function(model, node, start, end) {
+			var pos = start;
+			var expected = this.getInitialExpected(node, start);
+			var scopes = [],
+			    gaps = [];
+			while (node && (pos < end)) {
+				var matchInfo = this.getNextMatch(model, node, pos);
+				if (!matchInfo) { 
+					break; // line is over
+				}
+				var match = matchInfo && matchInfo.match,
+				    rule = matchInfo && matchInfo.rule,
+				    isSub = matchInfo && matchInfo.isSub,
+				    isEnd = matchInfo && matchInfo.isEnd;
+				if (match.index !== pos) {
+					// gap [pos..match.index]
+					gaps.push({ start: pos, end: match.index, node: node});
+				}
+				if (isSub) {
+					pos = this.afterMatch(match);
+					if (rule instanceof this.BeginEndRule) {
+						// Matched a "begin", assign its scope and descend into it
+						this.addBeginScope(scopes, match, rule);
+						node = expected; // descend
+						expected = this.getNextExpected(expected, "begin");
+					} else {
+						// Matched a child MatchRule;
+						this.addMatchScope(scopes, match, rule);
+					}
+				} else if (isEnd) {
+					pos = this.afterMatch(match);
+					// Matched and "end", assign its end scope and go up
+					this.addEndScope(scopes, match, rule);
+					expected = this.getNextExpected(expected, "end");
+					node = node.parent; // ascend
+				}
+			}
+			if (pos < end) {
+				gaps.push({ start: pos, end: end, node: node });
+			}
+			var inherited = this.getInheritedLineScope(gaps, start, end);
+			return scopes.concat(inherited);
+		},
+		/** @private */
+		getInheritedLineScope: function(gaps, start, end) {
+			var scopes = [];
+			for (var i=0; i < gaps.length; i++) {
+				var gap = gaps[i];
+				var node = gap.node;
+				while (node) {
+					// if node defines a contentName or name, apply it
+					var rule = node.rule.rule;
+					var name = rule.name,
+					    contentName = rule.contentName;
+					// TODO: if both are given, we don't resolve the conflict. contentName always wins
+					var scope = contentName || name;
+					if (scope) {
+						this.addScopeRange(scopes, gap.start, gap.end, scope);
+						break;
+					}
+					node = node.parent;
+				}
+			}
+			return scopes;
+		},
+		/** @private */
+		addBeginScope: function(scopes, match, typedRule) {
+			var rule = typedRule.rule;
+			this.addCapturesScope(scopes, match, (rule.beginCaptures || rule.captures), typedRule.isComplex, typedRule.beginOld2New, typedRule.beginConsuming);
+		},
+		/** @private */
+		addEndScope: function(scopes, match, typedRule) {
+			var rule = typedRule.rule;
+			this.addCapturesScope(scopes, match, (rule.endCaptures || rule.captures), typedRule.isComplex, typedRule.endOld2New, typedRule.endConsuming);
+		},
+		/** @private */
+		addMatchScope: function(scopes, match, typedRule) {
+			var rule = typedRule.rule,
+			    name = rule.name,
+			    captures = rule.captures;
+			if (captures) {	
+				// captures takes priority over name
+				this.addCapturesScope(scopes, match, captures, typedRule.isComplex, typedRule.matchOld2New, typedRule.matchConsuming);
+			} else {
+				this.addScope(scopes, match, name);
+			}
+		},
+		/** @private */
+		addScope: function(scopes, match, name) {
+			if (!name) { return; }
+			scopes.push({start: match.index, end: this.afterMatch(match), scope: name });
+		},
+		/** @private */
+		addScopeRange: function(scopes, start, end, name) {
+			if (!name) { return; }
+			scopes.push({start: start, end: end, scope: name });
+		},
+		/** @private */
+		addCapturesScope: function(/**Array*/scopes, /*RegExp.match*/ match, /**Object*/captures, /**Boolean*/isComplex, /**Object*/old2New, /**Object*/consuming) {
+			if (!captures) { return; }
+			if (!isComplex) {
+				this.addScope(scopes, match, captures[0] && captures[0].name);
+			} else {
+				// apply scopes captures[1..n] to matching groups [1]..[n] of match
+				
+				// Sum up the lengths of preceding consuming groups to get the start offset for each matched group.
+				var newGroupStarts = {1: 0};
+				var sum = 0;
+				for (var num = 1; match[num] !== undefined; num++) {
+					if (consuming[num] !== undefined) {
+						sum += match[num].length;
+					}
+					if (match[num+1] !== undefined) {
+						newGroupStarts[num + 1] = sum;
+					}
+				}
+				// Map the group numbers referred to in captures object to the new group numbers, and get the actual matched range.
+				var start = match.index;
+				for (var oldGroupNum = 1; captures[oldGroupNum]; oldGroupNum++) {
+					var scope = captures[oldGroupNum].name;
+					var newGroupNum = old2New[oldGroupNum];
+					var groupStart = start + newGroupStarts[newGroupNum];
+					// Not every capturing group defined in regex need match every time the regex is run.
+					// eg. (a)|b matches "b" but group 1 is undefined
+					if (typeof match[newGroupNum] !== "undefined") {
+						var groupEnd = groupStart + match[newGroupNum].length;
+						this.addScopeRange(scopes, groupStart, groupEnd, scope);
+					}
+				}
+			}
+		},
+		/** @returns {Node[]} In depth-first order
+		 * @private
+		 */
+		getIntersecting: function(start, end) {
+			var result = [];
+			var nodes = this._tree ? [this._tree] : [];
+			while (nodes.length) {
+				var n = nodes.pop();
+				var visitChildren = false;
+				if (n instanceof this.ContainerNode) {
+					visitChildren = true;
+				} else if (this.isDamaged(n, start, end)) {
+					visitChildren = true;
+					result.push(n);
+				}
+				if (visitChildren) {
+					var len = n.children.length;
+//					for (var i=len-1; i >= 0; i--) {
+//						nodes.push(n.children[i]);
+//					}
+					for (var i=0; i < len; i++) {
+						nodes.push(n.children[i]);
+					}
+				}
+			}
+			return result.reverse();
+		},
+		/**
+		 * Applies the grammar to obtain the {@link eclipse.StyleRange[]} for the given line.
+		 * @returns eclipse.StyleRange[]
+		 * @private
+		 */
+		toStyleRanges: function(/**ScopeRange[]*/ scopeRanges) {
+			var styleRanges = [];
+			for (var i=0; i < scopeRanges.length; i++) {
+				var scopeRange = scopeRanges[i];
+				var classNames = this._styles[scopeRange.scope];
+				if (!classNames) { throw new Error("styles not found for " + scopeRange.scope); }
+				var classNamesString = classNames.join(" ");
+				styleRanges.push({start: scopeRange.start, end: scopeRange.end, style: {styleClass: classNamesString}});
+//				console.debug("{start " + styleRanges[i].start + ", end " + styleRanges[i].end + ", style: " + styleRanges[i].style.styleClass + "}");
+			}
+			return styleRanges;
 		}
 	};
-	return {EventTarget: EventTarget};
+	
+	return {
+		RegexUtil: RegexUtil,
+		TextMateStyler: TextMateStyler
+	};
 });
 /*******************************************************************************
  * @license
  * Copyright (c) 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials are made 
  * available under the terms of the Eclipse Public License v1.0 
  * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
  * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
@@ -285,801 +3621,22 @@ define("orion/editor/regex", [], functio
 /*******************************************************************************
  * @license
  * Copyright (c) 2010, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials are made 
  * available under the terms of the Eclipse Public License v1.0 
  * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
  * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
  * 
- * Contributors: 
- *		Felipe Heidrich (IBM Corporation) - initial API and implementation
- *		Silenio Quarti (IBM Corporation) - initial API and implementation
- ******************************************************************************/
-
-/*global window define */
-
-define("orion/textview/keyBinding", [], function() {
-	var isMac = window.navigator.platform.indexOf("Mac") !== -1;
-
-	/**
-	 * Constructs a new key binding with the given key code and modifiers.
-	 * 
-	 * @param {String|Number} keyCode the key code.
-	 * @param {Boolean} mod1 the primary modifier (usually Command on Mac and Control on other platforms).
-	 * @param {Boolean} mod2 the secondary modifier (usually Shift).
-	 * @param {Boolean} mod3 the third modifier (usually Alt).
-	 * @param {Boolean} mod4 the fourth modifier (usually Control on the Mac).
-	 * 
-	 * @class A KeyBinding represents of a key code and a modifier state that can be triggered by the user using the keyboard.
-	 * @name orion.textview.KeyBinding
-	 * 
-	 * @property {String|Number} keyCode The key code.
-	 * @property {Boolean} mod1 The primary modifier (usually Command on Mac and Control on other platforms).
-	 * @property {Boolean} mod2 The secondary modifier (usually Shift).
-	 * @property {Boolean} mod3 The third modifier (usually Alt).
-	 * @property {Boolean} mod4 The fourth modifier (usually Control on the Mac).
-	 *
-	 * @see orion.textview.TextView#setKeyBinding
-	 */
-	function KeyBinding (keyCode, mod1, mod2, mod3, mod4) {
-		if (typeof(keyCode) === "string") {
-			this.keyCode = keyCode.toUpperCase().charCodeAt(0);
-		} else {
-			this.keyCode = keyCode;
-		}
-		this.mod1 = mod1 !== undefined && mod1 !== null ? mod1 : false;
-		this.mod2 = mod2 !== undefined && mod2 !== null ? mod2 : false;
-		this.mod3 = mod3 !== undefined && mod3 !== null ? mod3 : false;
-		this.mod4 = mod4 !== undefined && mod4 !== null ? mod4 : false;
-	}
-	KeyBinding.prototype = /** @lends orion.textview.KeyBinding.prototype */ {
-		/**
-		 * Returns whether this key binding matches the given key event.
-		 * 
-		 * @param e the key event.
-		 * @returns {Boolean} <code>true</code> whether the key binding matches the key event.
-		 */
-		match: function (e) {
-			if (this.keyCode === e.keyCode) {
-				var mod1 = isMac ? e.metaKey : e.ctrlKey;
-				if (this.mod1 !== mod1) { return false; }
-				if (this.mod2 !== e.shiftKey) { return false; }
-				if (this.mod3 !== e.altKey) { return false; }
-				if (isMac && this.mod4 !== e.ctrlKey) { return false; }
-				return true;
-			}
-			return false;
-		},
-		/**
-		 * Returns whether this key binding is the same as the given parameter.
-		 * 
-		 * @param {orion.textview.KeyBinding} kb the key binding to compare with.
-		 * @returns {Boolean} whether or not the parameter and the receiver describe the same key binding.
-		 */
-		equals: function(kb) {
-			if (!kb) { return false; }
-			if (this.keyCode !== kb.keyCode) { return false; }
-			if (this.mod1 !== kb.mod1) { return false; }
-			if (this.mod2 !== kb.mod2) { return false; }
-			if (this.mod3 !== kb.mod3) { return false; }
-			if (this.mod4 !== kb.mod4) { return false; }
-			return true;
-		} 
-	};
-	return {KeyBinding: KeyBinding};
-});
-/*******************************************************************************
- * @license
- * Copyright (c) 2010, 2011 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials are made 
- * available under the terms of the Eclipse Public License v1.0 
- * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
- * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
- * 
- * Contributors: 
- *		Felipe Heidrich (IBM Corporation) - initial API and implementation
- *		Silenio Quarti (IBM Corporation) - initial API and implementation
- ******************************************************************************/
-
-/*global define */
-
-define("orion/textview/annotations", ['orion/textview/eventTarget'], function(mEventTarget) {
-	/**
-	 * @class This object represents a decoration attached to a range of text. Annotations are added to a
-	 * <code>AnnotationModel</code> which is attached to a <code>TextModel</code>.
-	 * <p>
-	 * <b>See:</b><br/>
-	 * {@link orion.textview.AnnotationModel}<br/>
-	 * {@link orion.textview.Ruler}<br/>
-	 * </p>		 
-	 * @name orion.textview.Annotation
-	 * 
-	 * @property {String} type The annotation type (for example, orion.annotation.error).
-	 * @property {Number} start The start offset of the annotation in the text model.
-	 * @property {Number} end The end offset of the annotation in the text model.
-	 * @property {String} html The HTML displayed for the annotation.
-	 * @property {String} title The text description for the annotation.
-	 * @property {orion.textview.Style} style The style information for the annotation used in the annotations ruler and tooltips.
-	 * @property {orion.textview.Style} overviewStyle The style information for the annotation used in the overview ruler.
-	 * @property {orion.textview.Style} rangeStyle The style information for the annotation used in the text view to decorate a range of text.
-	 * @property {orion.textview.Style} lineStyle The style information for the annotation used in the text view to decorate a line of text.
-	 */
-	/**
-	 * Constructs a new folding annotation.
-	 * 
-	 * @param {orion.textview.ProjectionTextModel} projectionModel The projection text model.
-	 * @param {String} type The annotation type.
-	 * @param {Number} start The start offset of the annotation in the text model.
-	 * @param {Number} end The end offset of the annotation in the text model.
-	 * @param {String} expandedHTML The HTML displayed for this annotation when it is expanded.
-	 * @param {orion.textview.Style} expandedStyle The style information for the annotation when it is expanded.
-	 * @param {String} collapsedHTML The HTML displayed for this annotation when it is collapsed.
-	 * @param {orion.textview.Style} collapsedStyle The style information for the annotation when it is collapsed.
-	 * 
-	 * @class This object represents a folding annotation.
-	 * @name orion.textview.FoldingAnnotation
-	 */
-	function FoldingAnnotation (projectionModel, type, start, end, expandedHTML, expandedStyle, collapsedHTML, collapsedStyle) {
-		this.type = type;
-		this.start = start;
-		this.end = end;
-		this._projectionModel = projectionModel;
-		this._expandedHTML = this.html = expandedHTML;
-		this._expandedStyle = this.style = expandedStyle;
-		this._collapsedHTML = collapsedHTML;
-		this._collapsedStyle = collapsedStyle;
-		this.expanded = true;
-	}
-	
-	FoldingAnnotation.prototype = /** @lends orion.textview.FoldingAnnotation.prototype */ {
-		/**
-		 * Collapses the annotation.
-		 */
-		collapse: function () {
-			if (!this.expanded) { return; }
-			this.expanded = false;
-			this.html = this._collapsedHTML;
-			this.style = this._collapsedStyle;
-			var projectionModel = this._projectionModel;
-			var baseModel = projectionModel.getBaseModel();
-			this._projection = {
-				start: baseModel.getLineStart(baseModel.getLineAtOffset(this.start) + 1),
-				end: baseModel.getLineEnd(baseModel.getLineAtOffset(this.end), true)
-			};
-			projectionModel.addProjection(this._projection);
-		},
-		/**
-		 * Expands the annotation.
-		 */
-		expand: function () {
-			if (this.expanded) { return; }
-			this.expanded = true;
-			this.html = this._expandedHTML;
-			this.style = this._expandedStyle;
-			this._projectionModel.removeProjection(this._projection);
-		}
-	};
-	
-	/** 
-	 * Constructs a new AnnotationTypeList object.
-	 * 
-	 * @class 
-	 * @name orion.textview.AnnotationTypeList
-	 */
-	function AnnotationTypeList () {
-	}
-	/**
-	 * Adds in the annotation type interface into the specified object.
-	 *
-	 * @param {Object} object The object to add in the annotation type interface.
-	 */
-	AnnotationTypeList.addMixin = function(object) {
-		var proto = AnnotationTypeList.prototype;
-		for (var p in proto) {
-			if (proto.hasOwnProperty(p)) {
-				object[p] = proto[p];
-			}
-		}
-	};	
-	AnnotationTypeList.prototype = /** @lends orion.textview.AnnotationTypeList.prototype */ {
-		/**
-		 * Adds an annotation type to the receiver.
-		 * <p>
-		 * Only annotations of the specified types will be shown by
-		 * the receiver.
-		 * </p>
-		 *
-		 * @param {Object} type the annotation type to be shown
-		 * 
-		 * @see #removeAnnotationType
-		 * @see #isAnnotationTypeVisible
-		 */
-		addAnnotationType: function(type) {
-			if (!this._annotationTypes) { this._annotationTypes = []; }
-			this._annotationTypes.push(type);
-		},
-		/**
-		 * Gets the annotation type priority.  The priority is determined by the
-		 * order the annotation type is added to the receiver.  Annotation types
-		 * added first have higher priority.
-		 * <p>
-		 * Returns <code>0</code> if the annotation type is not added.
-		 * </p>
-		 *
-		 * @param {Object} type the annotation type
-		 * 
-		 * @see #addAnnotationType
-		 * @see #removeAnnotationType
-		 * @see #isAnnotationTypeVisible
-		 */
-		getAnnotationTypePriority: function(type) {
-			if (this._annotationTypes) { 
-				for (var i = 0; i < this._annotationTypes.length; i++) {
-					if (this._annotationTypes[i] === type) {
-						return i + 1;
-					}
-				}
-			}
-			return 0;
-		},
-		/**
-		 * Returns an array of annotations in the specified annotation model for the given range of text sorted by type.
-		 *
-		 * @param {orion.textview.AnnotationModel} annotationModel the annotation model.
-		 * @param {Number} start the start offset of the range.
-		 * @param {Number} end the end offset of the range.
-		 * @return {orion.textview.Annotation[]} an annotation array.
-		 */
-		getAnnotationsByType: function(annotationModel, start, end) {
-			var iter = annotationModel.getAnnotations(start, end);
-			var annotation, annotations = [];
-			while (iter.hasNext()) {
-				annotation = iter.next();
-				var priority = this.getAnnotationTypePriority(annotation.type);
-				if (priority === 0) { continue; }
-				annotations.push(annotation);
-			}
-			var self = this;
-			annotations.sort(function(a, b) {
-				return self.getAnnotationTypePriority(a.type) - self.getAnnotationTypePriority(b.type);
-			});
-			return annotations;
-		},
-		/**
-		 * Returns whether the receiver shows annotations of the specified type.
-		 *
-		 * @param {Object} type the annotation type 
-		 * @returns {Boolean} whether the specified annotation type is shown
-		 * 
-		 * @see #addAnnotationType
-		 * @see #removeAnnotationType
-		 */
-		isAnnotationTypeVisible: function(type) {
-			return this.getAnnotationTypePriority(type) !== 0;
-		},
-		/**
-		 * Removes an annotation type from the receiver.
-		 *
-		 * @param {Object} type the annotation type to be removed
-		 * 
-		 * @see #addAnnotationType
-		 * @see #isAnnotationTypeVisible
-		 */
-		removeAnnotationType: function(type) {
-			if (!this._annotationTypes) { return; }
-			for (var i = 0; i < this._annotationTypes.length; i++) {
-				if (this._annotationTypes[i] === type) {
-					this._annotationTypes.splice(i, 1);
-					break;
-				}
-			}
-		}
-	};
-	
-	/**
-	 * Constructs an annotation model.
-	 * 
-	 * @param {textModel} textModel The text model.
-	 * 
-	 * @class This object manages annotations for a <code>TextModel</code>.
-	 * <p>
-	 * <b>See:</b><br/>
-	 * {@link orion.textview.Annotation}<br/>
-	 * {@link orion.textview.TextModel}<br/> 
-	 * </p>	
-	 * @name orion.textview.AnnotationModel
-	 * @borrows orion.textview.EventTarget#addEventListener as #addEventListener
-	 * @borrows orion.textview.EventTarget#removeEventListener as #removeEventListener
-	 * @borrows orion.textview.EventTarget#dispatchEvent as #dispatchEvent
-	 */
-	function AnnotationModel(textModel) {
-		this._annotations = [];
-		var self = this;
-		this._listener = {
-			onChanged: function(modelChangedEvent) {
-				self._onChanged(modelChangedEvent);
-			}
-		};
-		this.setTextModel(textModel);
-	}
-
-	AnnotationModel.prototype = /** @lends orion.textview.AnnotationModel.prototype */ {
-		/**
-		 * Adds an annotation to the annotation model. 
-		 * <p>The annotation model listeners are notified of this change.</p>
-		 * 
-		 * @param {orion.textview.Annotation} annotation the annotation to be added.
-		 * 
-		 * @see #removeAnnotation
-		 */
-		addAnnotation: function(annotation) {
-			if (!annotation) { return; }
-			var annotations = this._annotations;
-			var index = this._binarySearch(annotations, annotation.start);
-			annotations.splice(index, 0, annotation);
-			var e = {
-				type: "Changed",
-				added: [annotation],
-				removed: [],
-				changed: []
-			};
-			this.onChanged(e);
-		},
-		/**
-		 * Returns the text model. 
-		 * 
-		 * @return {orion.textview.TextModel} The text model.
-		 * 
-		 * @see #setTextModel
-		 */
-		getTextModel: function() {
-			return this._model;
-		},
-		/**
-		 * @class This object represents an annotation iterator.
-		 * <p>
-		 * <b>See:</b><br/>
-		 * {@link orion.textview.AnnotationModel#getAnnotations}<br/>
-		 * </p>		 
-		 * @name orion.textview.AnnotationIterator
-		 * 
-		 * @property {Function} hasNext Determines whether there are more annotations in the iterator.
-		 * @property {Function} next Returns the next annotation in the iterator.
-		 */		
-		/**
-		 * Returns an iterator of annotations for the given range of text.
-		 *
-		 * @param {Number} start the start offset of the range.
-		 * @param {Number} end the end offset of the range.
-		 * @return {orion.textview.AnnotationIterator} an annotation iterartor.
-		 */
-		getAnnotations: function(start, end) {
-			var annotations = this._annotations, current;
-			//TODO binary search does not work for range intersection when there are overlaping ranges, need interval search tree for this
-			var i = 0;
-			var skip = function() {
-				while (i < annotations.length) {
-					var a =  annotations[i++];
-					if ((start === a.start) || (start > a.start ? start < a.end : a.start < end)) {
-						return a;
-					}
-					if (a.start >= end) {
-						break;
-					}
-				}
-				return null;
-			};
-			current = skip();
-			return {
-				next: function() {
-					var result = current;
-					if (result) { current = skip(); }
-					return result;					
-				},
-				hasNext: function() {
-					return current !== null;
-				}
-			};
-		},
-		/**
-		 * Notifies the annotation model that the given annotation has been modified.
-		 * <p>The annotation model listeners are notified of this change.</p>
-		 * 
-		 * @param {orion.textview.Annotation} annotation the modified annotation.
-		 * 
-		 * @see #addAnnotation
-		 */
-		modifyAnnotation: function(annotation) {
-			if (!annotation) { return; }
-			var index = this._getAnnotationIndex(annotation);
-			if (index < 0) { return; }
-			var e = {
-				type: "Changed",
-				added: [],
-				removed: [],
-				changed: [annotation]
-			};
-			this.onChanged(e);
-		},
-		/**
-		 * Notifies all listeners that the annotation model has changed.
-		 *
-		 * @param {orion.textview.Annotation[]} added The list of annotation being added to the model.
-		 * @param {orion.textview.Annotation[]} changed The list of annotation modified in the model.
-		 * @param {orion.textview.Annotation[]} removed The list of annotation being removed from the model.
-		 * @param {ModelChangedEvent} textModelChangedEvent the text model changed event that trigger this change, can be null if the change was trigger by a method call (for example, {@link #addAnnotation}).
-		 */
-		onChanged: function(e) {
-			return this.dispatchEvent(e);
-		},
-		/**
-		 * Removes all annotations of the given <code>type</code>. All annotations
-		 * are removed if the type is not specified. 
-		 * <p>The annotation model listeners are notified of this change.  Only one changed event is generated.</p>
-		 * 
-		 * @param {Object} type the type of annotations to be removed.
-		 * 
-		 * @see #removeAnnotation
-		 */
-		removeAnnotations: function(type) {
-			var annotations = this._annotations;
-			var removed, i; 
-			if (type) {
-				removed = [];
-				for (i = annotations.length - 1; i >= 0; i--) {
-					var annotation = annotations[i];
-					if (annotation.type === type) {
-						annotations.splice(i, 1);
-					}
-					removed.splice(0, 0, annotation);
-				}
-			} else {
-				removed = annotations;
-				annotations = [];
-			}
-			var e = {
-				type: "Changed",
-				removed: removed,
-				added: [],
-				changed: []
-			};
-			this.onChanged(e);
-		},
-		/**
-		 * Removes an annotation from the annotation model. 
-		 * <p>The annotation model listeners are notified of this change.</p>
-		 * 
-		 * @param {orion.textview.Annotation} annotation the annotation to be removed.
-		 * 
-		 * @see #addAnnotation
-		 */
-		removeAnnotation: function(annotation) {
-			if (!annotation) { return; }
-			var index = this._getAnnotationIndex(annotation);
-			if (index < 0) { return; }
-			var e = {
-				type: "Changed",
-				removed: this._annotations.splice(index, 1),
-				added: [],
-				changed: []
-			};
-			this.onChanged(e);
-		},
-		/**
-		 * Removes and adds the specifed annotations to the annotation model. 
-		 * <p>The annotation model listeners are notified of this change.  Only one changed event is generated.</p>
-		 * 
-		 * @param {orion.textview.Annotation} remove the annotations to be removed.
-		 * @param {orion.textview.Annotation} add the annotations to be added.
-		 * 
-		 * @see #addAnnotation
-		 * @see #removeAnnotation
-		 */
-		replaceAnnotations: function(remove, add) {
-			var annotations = this._annotations, i, index, annotation, removed = [];
-			if (remove) {
-				for (i = remove.length - 1; i >= 0; i--) {
-					annotation = remove[i];
-					index = this._getAnnotationIndex(annotation);
-					if (index < 0) { continue; }
-					annotations.splice(index, 1);
-					removed.splice(0, 0, annotation);
-				}
-			}
-			if (!add) { add = []; }
-			for (i = 0; i < add.length; i++) {
-				annotation = add[i];
-				index = this._binarySearch(annotations, annotation.start);
-				annotations.splice(index, 0, annotation);
-			}
-			var e = {
-				type: "Changed",
-				removed: removed,
-				added: add,
-				changed: []
-			};
-			this.onChanged(e);
-		},
-		/**
-		 * Sets the text model of the annotation model.  The annotation
-		 * model listens for changes in the text model to update and remove
-		 * annotations that are affected by the change.
-		 * 
-		 * @param {orion.textview.TextModel} textModel the text model.
-		 * 
-		 * @see #getTextModel
-		 */
-		setTextModel: function(textModel) {
-			if (this._model) {
-				this._model.removeEventListener("Changed", this._listener.onChanged);
-			}
-			this._model = textModel;
-			if (this._model) {
-				this._model.addEventListener("Changed", this._listener.onChanged);
-			}
-		},
-		/** @ignore */
-		_binarySearch: function (array, offset) {
-			var high = array.length, low = -1, index;
-			while (high - low > 1) {
-				index = Math.floor((high + low) / 2);
-				if (offset <= array[index].start) {
-					high = index;
-				} else {
-					low = index;
-				}
-			}
-			return high;
-		},
-		/** @ignore */
-		_getAnnotationIndex: function(annotation) {
-			var annotations = this._annotations;
-			var index = this._binarySearch(annotations, annotation.start);
-			while (index < annotations.length && annotations[index].start === annotation.start) {
-				if (annotations[index] === annotation) {
-					return index;
-				}
-				index++;
-			}
-			return -1;
-		},
-		/** @ignore */
-		_onChanged: function(modelChangedEvent) {
-			var start = modelChangedEvent.start;
-			var addedCharCount = modelChangedEvent.addedCharCount;
-			var removedCharCount = modelChangedEvent.removedCharCount;
-			var annotations = this._annotations, end = start + removedCharCount;
-			//TODO binary search does not work for range intersection when there are overlaping ranges, need interval search tree for this
-			var startIndex = 0;
-			if (!(0 <= startIndex && startIndex < annotations.length)) { return; }
-			var e = {
-				type: "Changed",
-				added: [],
-				removed: [],
-				changed: [],
-				textModelChangedEvent: modelChangedEvent
-			};
-			var changeCount = addedCharCount - removedCharCount, i;
-			for (i = startIndex; i < annotations.length; i++) {
-				var annotation = annotations[i];
-				if (annotation.start >= end) {
-					annotation.start += changeCount;
-					annotation.end += changeCount;
-					e.changed.push(annotation);
-				} else if (annotation.end <= start) {
-					//nothing
-				} else if (annotation.start < start && end < annotation.end) {
-					annotation.end += changeCount;
-					e.changed.push(annotation);
-				} else {
-					annotations.splice(i, 1);
-					e.removed.push(annotation);
-					i--;
-				}
-			}
-			if (e.added.length > 0 || e.removed.length > 0 || e.changed.length > 0) {
-				this.onChanged(e);
-			}
-		}
-	};
-	mEventTarget.EventTarget.addMixin(AnnotationModel.prototype);
-
-	/**
-	 * Constructs a new styler for annotations.
-	 * 
-	 * @param {orion.textview.TextView} view The styler view.
-	 * @param {orion.textview.AnnotationModel} view The styler annotation model.
-	 * 
-	 * @class This object represents a styler for annotation attached to a text view.
-	 * @name orion.textview.AnnotationStyler
-	 * @borrows orion.textview.AnnotationTypeList#addAnnotationType as #addAnnotationType
-	 * @borrows orion.textview.AnnotationTypeList#getAnnotationTypePriority as #getAnnotationTypePriority
-	 * @borrows orion.textview.AnnotationTypeList#getAnnotationsByType as #getAnnotationsByType
-	 * @borrows orion.textview.AnnotationTypeList#isAnnotationTypeVisible as #isAnnotationTypeVisible
-	 * @borrows orion.textview.AnnotationTypeList#removeAnnotationType as #removeAnnotationType
-	 */
-	function AnnotationStyler (view, annotationModel) {
-		this._view = view;
-		this._annotationModel = annotationModel;
-		var self = this;
-		this._listener = {
-			onDestroy: function(e) {
-				self._onDestroy(e);
-			},
-			onLineStyle: function(e) {
-				self._onLineStyle(e);
-			},
-			onChanged: function(e) {
-				self._onAnnotationModelChanged(e);
-			}
-		};
-		view.addEventListener("Destroy", this._listener.onDestroy);
-		view.addEventListener("LineStyle", this._listener.onLineStyle);
-		annotationModel.addEventListener("Changed", this._listener.onChanged);
-	}
-	AnnotationStyler.prototype = /** @lends orion.textview.AnnotationStyler.prototype */ {
-		/**
-		 * Destroys the styler. 
-		 * <p>
-		 * Removes all listeners added by this styler.
-		 * </p>
-		 */
-		destroy: function() {
-			var view = this._view;
-			if (view) {
-				view.removeEventListener("Destroy", this._listener.onDestroy);
-				view.removeEventListener("LineStyle", this._listener.onLineStyle);
-				this.view = null;
-			}
-			var annotationModel = this._annotationModel;
-			if (annotationModel) {
-				annotationModel.removeEventListener("Changed", this._listener.onChanged);
-				annotationModel = null;
-			}
-		},
-		_mergeStyle: function(result, style) {
-			if (style) {
-				if (!result) { result = {}; }
-				if (result.styleClass && style.styleClass && result.styleClass !== style.styleClass) {
-					result.styleClass += " " + style.styleClass;
-				} else {
-					result.styleClass = style.styleClass;
-				}
-				var prop;
-				if (style.style) {
-					if (!result.style) { result.style  = {}; }
-					for (prop in style.style) {
-						if (!result.style[prop]) {
-							result.style[prop] = style.style[prop];
-						}
-					}
-				}
-				if (style.attributes) {
-					if (!result.attributes) { result.attributes  = {}; }
-					for (prop in style.attributes) {
-						if (!result.attributes[prop]) {
-							result.attributes[prop] = style.attributes[prop];
-						}
-					}
-				}
-			}
-			return result;
-		},
-		_mergeStyleRanges: function(ranges, styleRange) {
-			if (!ranges) { return; }
-			for (var i=0; i<ranges.length; i++) {
-				var range = ranges[i];
-				if (styleRange.end <= range.start) { break; }
-				if (styleRange.start >= range.end) { continue; }
-				var mergedStyle = this._mergeStyle({}, range.style);
-				mergedStyle = this._mergeStyle(mergedStyle, styleRange.style);
-				if (styleRange.start <= range.start && styleRange.end >= range.end) {
-					ranges[i] = {start: range.start, end: range.end, style: mergedStyle};
-				} else if (styleRange.start > range.start && styleRange.end < range.end) {
-					ranges.splice(i, 1,
-						{start: range.start, end: styleRange.start, style: range.style},
-						{start: styleRange.start, end: styleRange.end, style: mergedStyle},
-						{start: styleRange.end, end: range.end, style: range.style});
-					i += 2;
-				} else if (styleRange.start > range.start) {
-					ranges.splice(i, 1,
-						{start: range.start, end: styleRange.start, style: range.style},
-						{start: styleRange.start, end: range.end, style: mergedStyle});
-					i += 1;
-				} else if (styleRange.end < range.end) {
-					ranges.splice(i, 1,
-						{start: range.start, end: styleRange.end, style: mergedStyle},
-						{start: styleRange.end, end: range.end, style: range.style});
-					i += 1;
-				}
-			}
-		},
-		_onAnnotationModelChanged: function(e) {
-			if (e.textModelChangedEvent) {
-				return;
-			}
-			var view = this._view;
-			if (!view) { return; }
-			var self = this;
-			var model = view.getModel();
-			function redraw(changes) {
-				for (var i = 0; i < changes.length; i++) {
-					if (!self.isAnnotationTypeVisible(changes[i].type)) { continue; }
-					var start = changes[i].start;
-					var end = changes[i].end;
-					if (model.getBaseModel) {
-						start = model.mapOffset(start, true);
-						end = model.mapOffset(end, true);
-					}
-					if (start !== -1 && end !== -1) {
-						view.redrawRange(start, end);
-					}
-				}
-			}
-			redraw(e.added);
-			redraw(e.removed);
-			redraw(e.changed);
-		},
-		_onDestroy: function(e) {
-			this.destroy();
-		},
-		_onLineStyle: function (e) {
-			var annotationModel = this._annotationModel;
-			var viewModel = this._view.getModel();
-			var baseModel = annotationModel.getTextModel();
-			var start = e.lineStart;
-			var end = e.lineStart + e.lineText.length;
-			if (baseModel !== viewModel) {
-				start = viewModel.mapOffset(start);
-				end = viewModel.mapOffset(end);
-			}
-			var annotations = annotationModel.getAnnotations(start, end);
-			while (annotations.hasNext()) {
-				var annotation = annotations.next();
-				if (!this.isAnnotationTypeVisible(annotation.type)) { continue; }
-				if (annotation.rangeStyle) {
-					var annotationStart = annotation.start;
-					var annotationEnd = annotation.end;
-					if (baseModel !== viewModel) {
-						annotationStart = viewModel.mapOffset(annotationStart, true);
-						annotationEnd = viewModel.mapOffset(annotationEnd, true);
-					}
-					this._mergeStyleRanges(e.ranges, {start: annotationStart, end: annotationEnd, style: annotation.rangeStyle});
-				}
-				if (annotation.lineStyle) {
-					e.style = this._mergeStyle({}, e.style);
-					e.style = this._mergeStyle(e.style, annotation.lineStyle);
-				}
-			}
-		}
-	};
-	AnnotationTypeList.addMixin(AnnotationStyler.prototype);
-	
-	return {
-		FoldingAnnotation: FoldingAnnotation,
-		AnnotationTypeList: AnnotationTypeList,
-		AnnotationModel: AnnotationModel,
-		AnnotationStyler: AnnotationStyler
-	};
-});
-/*******************************************************************************
- * @license
- * Copyright (c) 2010, 2011 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials are made 
- * available under the terms of the Eclipse Public License v1.0 
- * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
- * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
- * 
  * Contributors: IBM Corporation - initial API and implementation
  ******************************************************************************/
 
 /*global define setTimeout clearTimeout setInterval clearInterval Node */
 
-define("orion/textview/rulers", ['orion/textview/annotations', 'orion/textview/tooltip'], function(mAnnotations, mTooltip) {
+define("orion/textview/rulers", ['i18n!orion/textview/nls/messages', 'orion/textview/annotations', 'orion/textview/tooltip', 'orion/textview/i18nUtil'], function(messages, mAnnotations, mTooltip, i18nUtil) {
 
 	/**
 	 * Constructs a new ruler. 
 	 * <p>
 	 * The default implementation does not implement all the methods in the interface
 	 * and is useful only for objects implementing rulers.
 	 * <p/>
 	 * 
@@ -1383,18 +3940,16 @@ define("orion/textview/rulers", ['orion/
 				rect.y = view.getLocationAtOffset(model.getLineStart(lineIndex)).y;
 			}
 			view.convert(rect, "document", "page");
 			info.x = rect.x;
 			info.y = rect.y;
 			if (info.anchor === "right") {
 				info.x += rect.width;
 			}
-			info.maxWidth = rect.width;
-			info.maxHeight = rect.height - (rect.y - view._parent.getBoundingClientRect().top);
 			return info;
 		},
 		/** @ignore */
 		_getTooltipContents: function(lineIndex, annotations) {
 			return annotations;
 		},
 		/** @ignore */
 		_onAnnotationModelChanged: function(e) {
@@ -1612,17 +4167,17 @@ define("orion/textview/rulers", ['orion/
 	OverviewRuler.prototype._getTooltipContents = function(lineIndex, annotations) {
 		if (annotations.length === 0) {
 			var model = this._view.getModel();
 			var mapLine = lineIndex;
 			if (model.getBaseModel) {
 				var lineStart = model.getLineStart(mapLine);
 				mapLine = model.getBaseModel().getLineAtOffset(model.mapOffset(lineStart));
 			}
-			return "Line: " + (mapLine + 1);
+			return i18nUtil.formatMessage(messages.line, mapLine + 1);
 		}
 		return Ruler.prototype._getTooltipContents.call(this, lineIndex, annotations);
 	};
 	/** @ignore */
 	OverviewRuler.prototype._mergeAnnotation = function(previousAnnotation, annotation, annotationLineIndex, annotationLineCount) {
 		if (annotationLineIndex !== 0) { return undefined; }
 		var result = previousAnnotation;
 		if (!result) {
@@ -1662,24 +4217,25 @@ define("orion/textview/rulers", ['orion/
 		if (!annotationModel) { return; }
 		var view = this._view;
 		var model = view.getModel();
 		var start = model.getLineStart(lineIndex);
 		var end = model.getLineEnd(lineIndex, true);
 		if (model.getBaseModel) {
 			start = model.mapOffset(start);
 			end = model.mapOffset(end);
+			model = model.getBaseModel();
 		}
 		var annotation, iter = annotationModel.getAnnotations(start, end);
 		while (!annotation && iter.hasNext()) {
 			var a = iter.next();
 			if (!this.isAnnotationTypeVisible(a.type)) { continue; }
 			annotation = a;
 		}
-		if (annotation) {
+		if (annotation && model.getLineAtOffset(annotation.start) === model.getLineAtOffset(start)) {
 			var tooltip = mTooltip.Tooltip.getTooltip(this._view);
 			if (tooltip) {
 				tooltip.setTarget(null);
 			}
 			if (annotation.expanded) {
 				annotation.collapse();
 			} else {
 				annotation.expand();
@@ -1730,1680 +4286,280 @@ define("orion/textview/rulers", ['orion/
 	return {
 		Ruler: Ruler,
 		AnnotationRuler: AnnotationRuler,
 		LineNumberRuler: LineNumberRuler,
 		OverviewRuler: OverviewRuler,
 		FoldingRuler: FoldingRuler
 	};
 });
-/*******************************************************************************
+/*******************************************************************************
  * @license
- * Copyright (c) 2010, 2011 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials are made 
- * available under the terms of the Eclipse Public License v1.0 
- * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
- * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
- * 
- * Contributors: IBM Corporation - initial API and implementation
- ******************************************************************************/
-
-/*global define */
-
-define("orion/textview/undoStack", [], function() {
-
-	/** 
-	 * Constructs a new Change object.
-	 * 
-	 * @class 
-	 * @name orion.textview.Change
-	 * @private
-	 */
-	function Change(offset, text, previousText) {
-		this.offset = offset;
-		this.text = text;
-		this.previousText = previousText;
-	}
-	Change.prototype = {
-		/** @ignore */
-		undo: function (view, select) {
-			this._doUndoRedo(this.offset, this.previousText, this.text, view, select);
-		},
-		/** @ignore */
-		redo: function (view, select) {
-			this._doUndoRedo(this.offset, this.text, this.previousText, view, select);
-		},
-		_doUndoRedo: function(offset, text, previousText, view, select) {
-			var model = view.getModel();
-			/* 
-			* TODO UndoStack should be changing the text in the base model.
-			* This is code needs to change when modifications in the base
-			* model are supported properly by the projection model.
-			*/
-			if (model.mapOffset && view.annotationModel) {
-				var mapOffset = model.mapOffset(offset, true);
-				if (mapOffset < 0) {
-					var annotationModel = view.annotationModel;
-					var iter = annotationModel.getAnnotations(offset, offset + 1);
-					while (iter.hasNext()) {
-						var annotation = iter.next();
-						if (annotation.type === "orion.annotation.folding") {
-							annotation.expand();
-							mapOffset = model.mapOffset(offset, true);
-							break;
-						}
-					}
-				}
-				if (mapOffset < 0) { return; }
-				offset = mapOffset;
-			}
-			view.setText(text, offset, offset + previousText.length);
-			if (select) {
-				view.setSelection(offset, offset + text.length);
-			}
-		}
-	};
-
-	/** 
-	 * Constructs a new CompoundChange object.
-	 * 
-	 * @class 
-	 * @name orion.textview.CompoundChange
-	 * @private
-	 */
-	function CompoundChange () {
-		this.changes = [];
-	}
-	CompoundChange.prototype = {
-		/** @ignore */
-		add: function (change) {
-			this.changes.push(change);
-		},
-		/** @ignore */
-		end: function (view) {
-			this.endSelection = view.getSelection();
-			this.endCaret = view.getCaretOffset();
-		},
-		/** @ignore */
-		undo: function (view, select) {
-			for (var i=this.changes.length - 1; i >= 0; i--) {
-				this.changes[i].undo(view, false);
-			}
-			if (select) {
-				var start = this.startSelection.start;
-				var end = this.startSelection.end;
-				view.setSelection(this.startCaret ? start : end, this.startCaret ? end : start);
-			}
-		},
-		/** @ignore */
-		redo: function (view, select) {
-			for (var i = 0; i < this.changes.length; i++) {
-				this.changes[i].redo(view, false);
-			}
-			if (select) {
-				var start = this.endSelection.start;
-				var end = this.endSelection.end;
-				view.setSelection(this.endCaret ? start : end, this.endCaret ? end : start);
-			}
-		},
-		/** @ignore */
-		start: function (view) {
-			this.startSelection = view.getSelection();
-			this.startCaret = view.getCaretOffset();
-		}
-	};
-
-	/**
-	 * Constructs a new UndoStack on a text view.
-	 *
-	 * @param {orion.textview.TextView} view the text view for the undo stack.
-	 * @param {Number} [size=100] the size for the undo stack.
-	 *
-	 * @name orion.textview.UndoStack
-	 * @class The UndoStack is used to record the history of a text model associated to an view. Every
-	 * change to the model is added to stack, allowing the application to undo and redo these changes.
-	 *
-	 * <p>
-	 * <b>See:</b><br/>
-	 * {@link orion.textview.TextView}<br/>
-	 * </p>
-	 */
-	function UndoStack (view, size) {
-		this.view = view;
-		this.size = size !== undefined ? size : 100;
-		this.reset();
-		var model = view.getModel();
-		if (model.getBaseModel) {
-			model = model.getBaseModel();
-		}
-		this.model = model;
-		var self = this;
-		this._listener = {
-			onChanging: function(e) {
-				self._onChanging(e);
-			},
-			onDestroy: function(e) {
-				self._onDestroy(e);
-			}
-		};
-		model.addEventListener("Changing", this._listener.onChanging);
-		view.addEventListener("Destroy", this._listener.onDestroy);
-	}
-	UndoStack.prototype = /** @lends orion.textview.UndoStack.prototype */ {
-		/**
-		 * Adds a change to the stack.
-		 * 
-		 * @param change the change to add.
-		 * @param {Number} change.offset the offset of the change
-		 * @param {String} change.text the new text of the change
-		 * @param {String} change.previousText the previous text of the change
-		 */
-		add: function (change) {
-			if (this.compoundChange) {
-				this.compoundChange.add(change);
-			} else {
-				var length = this.stack.length;
-				this.stack.splice(this.index, length-this.index, change);
-				this.index++;
-				if (this.stack.length > this.size) {
-					this.stack.shift();
-					this.index--;
-					this.cleanIndex--;
-				}
-			}
-		},
-		/** 
-		 * Marks the current state of the stack as clean.
-		 *
-		 * <p>
-		 * This function is typically called when the content of view associated with the stack is saved.
-		 * </p>
-		 *
-		 * @see #isClean
-		 */
-		markClean: function() {
-			this.endCompoundChange();
-			this._commitUndo();
-			this.cleanIndex = this.index;
-		},
-		/**
-		 * Returns true if current state of stack is the same
-		 * as the state when markClean() was called.
-		 *
-		 * <p>
-		 * For example, the application calls markClean(), then calls undo() four times and redo() four times.
-		 * At this point isClean() returns true.  
-		 * </p>
-		 * <p>
-		 * This function is typically called to determine if the content of the view associated with the stack
-		 * has changed since the last time it was saved.
-		 * </p>
-		 *
-		 * @return {Boolean} returns if the state is the same as the state when markClean() was called.
-		 *
-		 * @see #markClean
-		 */
-		isClean: function() {
-			return this.cleanIndex === this.getSize().undo;
-		},
-		/**
-		 * Returns true if there is at least one change to undo.
-		 *
-		 * @return {Boolean} returns true if there is at least one change to undo.
-		 *
-		 * @see #canRedo
-		 * @see #undo
-		 */
-		canUndo: function() {
-			return this.getSize().undo > 0;
-		},
-		/**
-		 * Returns true if there is at least one change to redo.
-		 *
-		 * @return {Boolean} returns true if there is at least one change to redo.
-		 *
-		 * @see #canUndo
-		 * @see #redo
-		 */
-		canRedo: function() {
-			return this.getSize().redo > 0;
-		},
-		/**
-		 * Finishes a compound change.
-		 *
-		 * @see #startCompoundChange
-		 */
-		endCompoundChange: function() {
-			if (this.compoundChange) {
-				this.compoundChange.end(this.view);
-			}
-			this.compoundChange = undefined;
-		},
-		/**
-		 * Returns the sizes of the stack.
-		 *
-		 * @return {object} a object where object.undo is the number of changes that can be un-done, 
-		 *  and object.redo is the number of changes that can be re-done.
-		 *
-		 * @see #canUndo
-		 * @see #canRedo
-		 */
-		getSize: function() {
-			var index = this.index;
-			var length = this.stack.length;
-			if (this._undoStart !== undefined) {
-				index++;
-			}
-			return {undo: index, redo: (length - index)};
-		},
-		/**
-		 * Undo the last change in the stack.
-		 *
-		 * @return {Boolean} returns true if a change was un-done.
-		 *
-		 * @see #redo
-		 * @see #canUndo
-		 */
-		undo: function() {
-			this._commitUndo();
-			if (this.index <= 0) {
-				return false;
-			}
-			var change = this.stack[--this.index];
-			this._ignoreUndo = true;
-			change.undo(this.view, true);
-			this._ignoreUndo = false;
-			return true;
-		},
-		/**
-		 * Redo the last change in the stack.
-		 *
-		 * @return {Boolean} returns true if a change was re-done.
-		 *
-		 * @see #undo
-		 * @see #canRedo
-		 */
-		redo: function() {
-			this._commitUndo();
-			if (this.index >= this.stack.length) {
-				return false;
-			}
-			var change = this.stack[this.index++];
-			this._ignoreUndo = true;
-			change.redo(this.view, true);
-			this._ignoreUndo = false;
-			return true;
-		},
-		/**
-		 * Reset the stack to its original state. All changes in the stack are thrown away.
-		 */
-		reset: function() {
-			this.index = this.cleanIndex = 0;
-			this.stack = [];
-			this._undoStart = undefined;
-			this._undoText = "";
-			this._undoType = 0;
-			this._ignoreUndo = false;
-			this._compoundChange = undefined;
-		},
-		/**
-		 * Starts a compound change. 
-		 * <p>
-		 * All changes added to stack from the time startCompoundChange() is called
-		 * to the time that endCompoundChange() is called are compound on one change that can be un-done or re-done
-		 * with one single call to undo() or redo().
-		 * </p>
-		 *
-		 * @see #endCompoundChange
-		 */
-		startCompoundChange: function() {
-			this._commitUndo();
-			var change = new CompoundChange();
-			this.add(change);
-			this.compoundChange = change;
-			this.compoundChange.start(this.view);
-		},
-		_commitUndo: function () {
-			if (this._undoStart !== undefined) {
-				if (this._undoType === -1) {
-					this.add(new Change(this._undoStart, "", this._undoText, ""));
-				} else {
-					this.add(new Change(this._undoStart, this._undoText, ""));
-				}
-				this._undoStart = undefined;
-				this._undoText = "";
-				this._undoType = 0;
-			}
-		},
-		_onDestroy: function(evt) {
-			this.model.removeEventListener("Changing", this._listener.onChanging);
-			this.view.removeEventListener("Destroy", this._listener.onDestroy);
-		},
-		_onChanging: function(e) {
-			var newText = e.text;
-			var start = e.start;
-			var removedCharCount = e.removedCharCount;
-			var addedCharCount = e.addedCharCount;
-			if (this._ignoreUndo) {
-				return;
-			}
-			if (this._undoStart !== undefined && 
-				!((addedCharCount === 1 && removedCharCount === 0 && this._undoType === 1 && start === this._undoStart + this._undoText.length) ||
-					(addedCharCount === 0 && removedCharCount === 1 && this._undoType === -1 && (((start + 1) === this._undoStart) || (start === this._undoStart)))))
-			{
-				this._commitUndo();
-			}
-			if (!this.compoundChange) {
-				if (addedCharCount === 1 && removedCharCount === 0) {
-					if (this._undoStart === undefined) {
-						this._undoStart = start;
-					}
-					this._undoText = this._undoText + newText;
-					this._undoType = 1;
-					return;
-				} else if (addedCharCount === 0 && removedCharCount === 1) {
-					var deleting = this._undoText.length > 0 && this._undoStart === start;
-					this._undoStart = start;
-					this._undoType = -1;
-					if (deleting) {
-						this._undoText = this._undoText + this.model.getText(start, start + removedCharCount);
-					} else {
-						this._undoText = this.model.getText(start, start + removedCharCount) + this._undoText;
-					}
-					return;
-				}
-			}
-			this.add(new Change(start, newText, this.model.getText(start, start + removedCharCount)));
-		}
-	};
-	
-	return {
-		UndoStack: UndoStack
-	};
-});
-/*******************************************************************************
- * @license
- * Copyright (c) 2010, 2011 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials are made 
- * available under the terms of the Eclipse Public License v1.0 
- * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
- * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
- * 
- * Contributors: 
- *		Felipe Heidrich (IBM Corporation) - initial API and implementation
- *		Silenio Quarti (IBM Corporation) - initial API and implementation
- ******************************************************************************/
- 
-/*global define window*/
-
-define("orion/textview/textModel", ['orion/textview/eventTarget'], function(mEventTarget) {
-	var isWindows = window.navigator.platform.indexOf("Win") !== -1;
-
-	/**
-	 * Constructs a new TextModel with the given text and default line delimiter.
-	 *
-	 * @param {String} [text=""] the text that the model will store
-	 * @param {String} [lineDelimiter=platform delimiter] the line delimiter used when inserting new lines to the model.
-	 *
-	 * @name orion.textview.TextModel
-	 * @class The TextModel is an interface that provides text for the view. Applications may
-	 * implement the TextModel interface to provide a custom store for the view content. The
-	 * view interacts with its text model in order to access and update the text that is being
-	 * displayed and edited in the view. This is the default implementation.
-	 * <p>
-	 * <b>See:</b><br/>
-	 * {@link orion.textview.TextView}<br/>
-	 * {@link orion.textview.TextView#setModel}
-	 * </p>
-	 * @borrows orion.textview.EventTarget#addEventListener as #addEventListener
-	 * @borrows orion.textview.EventTarget#removeEventListener as #removeEventListener
-	 * @borrows orion.textview.EventTarget#dispatchEvent as #dispatchEvent
-	 */
-	function TextModel(text, lineDelimiter) {
-		this._lastLineIndex = -1;
-		this._text = [""];
-		this._lineOffsets = [0];
-		this.setText(text);
-		this.setLineDelimiter(lineDelimiter);
-	}
-
-	TextModel.prototype = /** @lends orion.textview.TextModel.prototype */ {
-		/**
-		 * Returns the number of characters in the model.
-		 *
-		 * @returns {Number} the number of characters in the model.
-		 */
-		getCharCount: function() {
-			var count = 0;
-			for (var i = 0; i<this._text.length; i++) {
-				count += this._text[i].length;
-			}
-			return count;
-		},
-		/**
-		 * Returns the text of the line at the given index.
-		 * <p>
-		 * The valid indices are 0 to line count exclusive.  Returns <code>null</code> 
-		 * if the index is out of range. 
-		 * </p>
-		 *
-		 * @param {Number} lineIndex the zero based index of the line.
-		 * @param {Boolean} [includeDelimiter=false] whether or not to include the line delimiter. 
-		 * @returns {String} the line text or <code>null</code> if out of range.
-		 *
-		 * @see #getLineAtOffset
-		 */
-		getLine: function(lineIndex, includeDelimiter) {
-			var lineCount = this.getLineCount();
-			if (!(0 <= lineIndex && lineIndex < lineCount)) {
-				return null;
-			}
-			var start = this._lineOffsets[lineIndex];
-			if (lineIndex + 1 < lineCount) {
-				var text = this.getText(start, this._lineOffsets[lineIndex + 1]);
-				if (includeDelimiter) {
-					return text;
-				}
-				var end = text.length, c;
-				while (((c = text.charCodeAt(end - 1)) === 10) || (c === 13)) {
-					end--;
-				}
-				return text.substring(0, end);
-			} else {
-				return this.getText(start); 
-			}
-		},
-		/**
-		 * Returns the line index at the given character offset.
-		 * <p>
-		 * The valid offsets are 0 to char count inclusive. The line index for
-		 * char count is <code>line count - 1</code>. Returns <code>-1</code> if
-		 * the offset is out of range.
-		 * </p>
-		 *
-		 * @param {Number} offset a character offset.
-		 * @returns {Number} the zero based line index or <code>-1</code> if out of range.
-		 */
-		getLineAtOffset: function(offset) {
-			var charCount = this.getCharCount();
-			if (!(0 <= offset && offset <= charCount)) {
-				return -1;
-			}
-			var lineCount = this.getLineCount();
-			if (offset === charCount) {
-				return lineCount - 1; 
-			}
-			var lineStart, lineEnd;
-			var index = this._lastLineIndex;
-			if (0 <= index && index < lineCount) {
-				lineStart = this._lineOffsets[index];
-				lineEnd = index + 1 < lineCount ? this._lineOffsets[index + 1] : charCount;
-				if (lineStart <= offset && offset < lineEnd) {
-					return index;
-				}
-			}
-			var high = lineCount;
-			var low = -1;
-			while (high - low > 1) {
-				index = Math.floor((high + low) / 2);
-				lineStart = this._lineOffsets[index];
-				lineEnd = index + 1 < lineCount ? this._lineOffsets[index + 1] : charCount;
-				if (offset <= lineStart) {
-					high = index;
-				} else if (offset < lineEnd) {
-					high = index;
-					break;
-				} else {
-					low = index;
-				}
-			}
-			this._lastLineIndex = high;
-			return high;
-		},
-		/**
-		 * Returns the number of lines in the model.
-		 * <p>
-		 * The model always has at least one line.
-		 * </p>
-		 *
-		 * @returns {Number} the number of lines.
-		 */
-		getLineCount: function() {
-			return this._lineOffsets.length;
-		},
-		/**
-		 * Returns the line delimiter that is used by the view
-		 * when inserting new lines. New lines entered using key strokes 
-		 * and paste operations use this line delimiter.
-		 *
-		 * @return {String} the line delimiter that is used by the view when inserting new lines.
-		 */
-		getLineDelimiter: function() {
-			return this._lineDelimiter;
-		},
-		/**
-		 * Returns the end character offset for the given line. 
-		 * <p>
-		 * The end offset is not inclusive. This means that when the line delimiter is included, the 
-		 * offset is either the start offset of the next line or char count. When the line delimiter is
-		 * not included, the offset is the offset of the line delimiter.
-		 * </p>
-		 * <p>
-		 * The valid indices are 0 to line count exclusive.  Returns <code>-1</code> 
-		 * if the index is out of range. 
-		 * </p>
-		 *
-		 * @param {Number} lineIndex the zero based index of the line.
-		 * @param {Boolean} [includeDelimiter=false] whether or not to include the line delimiter. 
-		 * @return {Number} the line end offset or <code>-1</code> if out of range.
-		 *
-		 * @see #getLineStart
-		 */
-		getLineEnd: function(lineIndex, includeDelimiter) {
-			var lineCount = this.getLineCount();
-			if (!(0 <= lineIndex && lineIndex < lineCount)) {
-				return -1;
-			}
-			if (lineIndex + 1 < lineCount) {
-				var end = this._lineOffsets[lineIndex + 1];
-				if (includeDelimiter) {
-					return end;
-				}
-				var text = this.getText(Math.max(this._lineOffsets[lineIndex], end - 2), end);
-				var i = text.length, c;
-				while (((c = text.charCodeAt(i - 1)) === 10) || (c === 13)) {
-					i--;
-				}
-				return end - (text.length - i);
-			} else {
-				return this.getCharCount();
-			}
-		},
-		/**
-		 * Returns the start character offset for the given line.
-		 * <p>
-		 * The valid indices are 0 to line count exclusive.  Returns <code>-1</code> 
-		 * if the index is out of range. 
-		 * </p>
-		 *
-		 * @param {Number} lineIndex the zero based index of the line.
-		 * @return {Number} the line start offset or <code>-1</code> if out of range.
-		 *
-		 * @see #getLineEnd
-		 */
-		getLineStart: function(lineIndex) {
-			if (!(0 <= lineIndex && lineIndex < this.getLineCount())) {
-				return -1;
-			}
-			return this._lineOffsets[lineIndex];
-		},
-		/**
-		 * Returns the text for the given range.
-		 * <p>
-		 * The end offset is not inclusive. This means that character at the end offset
-		 * is not included in the returned text.
-		 * </p>
-		 *
-		 * @param {Number} [start=0] the zero based start offset of text range.
-		 * @param {Number} [end=char count] the zero based end offset of text range.
-		 *
-		 * @see #setText
-		 */
-		getText: function(start, end) {
-			if (start === undefined) { start = 0; }
-			if (end === undefined) { end = this.getCharCount(); }
-			if (start === end) { return ""; }
-			var offset = 0, chunk = 0, length;
-			while (chunk<this._text.length) {
-				length = this._text[chunk].length; 
-				if (start <= offset + length) { break; }
-				offset += length;
-				chunk++;
-			}
-			var firstOffset = offset;
-			var firstChunk = chunk;
-			while (chunk<this._text.length) {
-				length = this._text[chunk].length; 
-				if (end <= offset + length) { break; }
-				offset += length;
-				chunk++;
-			}
-			var lastOffset = offset;
-			var lastChunk = chunk;
-			if (firstChunk === lastChunk) {
-				return this._text[firstChunk].substring(start - firstOffset, end - lastOffset);
-			}
-			var beforeText = this._text[firstChunk].substring(start - firstOffset);
-			var afterText = this._text[lastChunk].substring(0, end - lastOffset);
-			return beforeText + this._text.slice(firstChunk+1, lastChunk).join("") + afterText; 
-		},
-		/**
-		 * Notifies all listeners that the text is about to change.
-		 * <p>
-		 * This notification is intended to be used only by the view. Application clients should
-		 * use {@link orion.textview.TextView#event:onModelChanging}.
-		 * </p>
-		 * <p>
-		 * NOTE: This method is not meant to called directly by application code. It is called internally by the TextModel
-		 * as part of the implementation of {@link #setText}. This method is included in the public API for documentation
-		 * purposes and to allow integration with other toolkit frameworks.
-		 * </p>
-		 *
-		 * @param {orion.textview.ModelChangingEvent} modelChangingEvent the changing event
-		 */
-		onChanging: function(modelChangingEvent) {
-			return this.dispatchEvent(modelChangingEvent);
-		},
-		/**
-		 * Notifies all listeners that the text has changed.
-		 * <p>
-		 * This notification is intended to be used only by the view. Application clients should
-		 * use {@link orion.textview.TextView#event:onModelChanged}.
-		 * </p>
-		 * <p>
-		 * NOTE: This method is not meant to called directly by application code. It is called internally by the TextModel
-		 * as part of the implementation of {@link #setText}. This method is included in the public API for documentation
-		 * purposes and to allow integration with other toolkit frameworks.
-		 * </p>
-		 *
-		 * @param {orion.textview.ModelChangedEvent} modelChangedEvent the changed event
-		 */
-		onChanged: function(modelChangedEvent) {
-			return this.dispatchEvent(modelChangedEvent);
-		},
-		/**
-		 * Sets the line delimiter that is used by the view
-		 * when new lines are inserted in the model due to key
-		 * strokes  and paste operations.
-		 * <p>
-		 * If lineDelimiter is "auto", the delimiter is computed to be
-		 * the first delimiter found the in the current text. If lineDelimiter
-		 * is undefined or if there are no delimiters in the current text, the
-		 * platform delimiter is used.
-		 * </p>
-		 *
-		 * @param {String} lineDelimiter the line delimiter that is used by the view when inserting new lines.
-		 */
-		setLineDelimiter: function(lineDelimiter) {
-			if (lineDelimiter === "auto") {
-				lineDelimiter = undefined;
-				if (this.getLineCount() > 1) {
-					lineDelimiter = this.getText(this.getLineEnd(0), this.getLineEnd(0, true));
-				}
-			}
-			this._lineDelimiter = lineDelimiter ? lineDelimiter : (isWindows ? "\r\n" : "\n"); 
-		},
-		/**
-		 * Replaces the text in the given range with the given text.
-		 * <p>
-		 * The end offset is not inclusive. This means that the character at the 
-		 * end offset is not replaced.
-		 * </p>
-		 * <p>
-		 * The text model must notify the listeners before and after the
-		 * the text is changed by calling {@link #onChanging} and {@link #onChanged}
-		 * respectively. 
-		 * </p>
-		 *
-		 * @param {String} [text=""] the new text.
-		 * @param {Number} [start=0] the zero based start offset of text range.
-		 * @param {Number} [end=char count] the zero based end offset of text range.
-		 *
-		 * @see #getText
-		 */
-		setText: function(text, start, end) {
-			if (text === undefined) { text = ""; }
-			if (start === undefined) { start = 0; }
-			if (end === undefined) { end = this.getCharCount(); }
-			if (start === end && text === "") { return; }
-			var startLine = this.getLineAtOffset(start);
-			var endLine = this.getLineAtOffset(end);
-			var eventStart = start;
-			var removedCharCount = end - start;
-			var removedLineCount = endLine - startLine;
-			var addedCharCount = text.length;
-			var addedLineCount = 0;
-			var lineCount = this.getLineCount();
-			
-			var cr = 0, lf = 0, index = 0;
-			var newLineOffsets = [];
-			while (true) {
-				if (cr !== -1 && cr <= index) { cr = text.indexOf("\r", index); }
-				if (lf !== -1 && lf <= index) { lf = text.indexOf("\n", index); }
-				if (lf === -1 && cr === -1) { break; }
-				if (cr !== -1 && lf !== -1) {
-					if (cr + 1 === lf) {
-						index = lf + 1;
-					} else {
-						index = (cr < lf ? cr : lf) + 1;
-					}
-				} else if (cr !== -1) {
-					index = cr + 1;
-				} else {
-					index = lf + 1;
-				}
-				newLineOffsets.push(start + index);
-				addedLineCount++;
-			}
-		
-			var modelChangingEvent = {
-				type: "Changing",
-				text: text,
-				start: eventStart,
-				removedCharCount: removedCharCount,
-				addedCharCount: addedCharCount,
-				removedLineCount: removedLineCount,
-				addedLineCount: addedLineCount
-			};
-			this.onChanging(modelChangingEvent);
-			
-			//TODO this should be done the loops below to avoid getText()
-			if (newLineOffsets.length === 0) {
-				var startLineOffset = this.getLineStart(startLine), endLineOffset;
-				if (endLine + 1 < lineCount) {
-					endLineOffset = this.getLineStart(endLine + 1);
-				} else {
-					endLineOffset = this.getCharCount();
-				}
-				if (start !== startLineOffset) {
-					text = this.getText(startLineOffset, start) + text;
-					start = startLineOffset;
-				}
-				if (end !== endLineOffset) {
-					text = text + this.getText(end, endLineOffset);
-					end = endLineOffset;
-				}
-			}
-			
-			var changeCount = addedCharCount - removedCharCount;
-			for (var j = startLine + removedLineCount + 1; j < lineCount; j++) {
-				this._lineOffsets[j] += changeCount;
-			}
-			var args = [startLine + 1, removedLineCount].concat(newLineOffsets);
-			Array.prototype.splice.apply(this._lineOffsets, args);
-			
-			var offset = 0, chunk = 0, length;
-			while (chunk<this._text.length) {
-				length = this._text[chunk].length; 
-				if (start <= offset + length) { break; }
-				offset += length;
-				chunk++;
-			}
-			var firstOffset = offset;
-			var firstChunk = chunk;
-			while (chunk<this._text.length) {
-				length = this._text[chunk].length; 
-				if (end <= offset + length) { break; }
-				offset += length;
-				chunk++;
-			}
-			var lastOffset = offset;
-			var lastChunk = chunk;
-			var firstText = this._text[firstChunk];
-			var lastText = this._text[lastChunk];
-			var beforeText = firstText.substring(0, start - firstOffset);
-			var afterText = lastText.substring(end - lastOffset);
-			var params = [firstChunk, lastChunk - firstChunk + 1];
-			if (beforeText) { params.push(beforeText); }
-			if (text) { params.push(text); }
-			if (afterText) { params.push(afterText); }
-			Array.prototype.splice.apply(this._text, params);
-			if (this._text.length === 0) { this._text = [""]; }
-			
-			var modelChangedEvent = {
-				type: "Changed",
-				start: eventStart,
-				removedCharCount: removedCharCount,
-				addedCharCount: addedCharCount,
-				removedLineCount: removedLineCount,
-				addedLineCount: addedLineCount
-			};
-			this.onChanged(modelChangedEvent);
-		}
-	};
-	mEventTarget.EventTarget.addMixin(TextModel.prototype);
-	
-	return {TextModel: TextModel};
-});/*******************************************************************************
- * @license
- * Copyright (c) 2010, 2011 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials are made 
- * available under the terms of the Eclipse Public License v1.0 
- * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
- * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
- * 
- * Contributors: 
- *		Felipe Heidrich (IBM Corporation) - initial API and implementation
- *		Silenio Quarti (IBM Corporation) - initial API and implementation
- ******************************************************************************/
-
-/*global define */
-
-define("orion/textview/projectionTextModel", ['orion/textview/textModel', 'orion/textview/eventTarget'], function(mTextModel, mEventTarget) {
-
-	/**
-	 * @class This object represents a projection range. A projection specifies a
-	 * range of text and the replacement text. The range of text is relative to the
-	 * base text model associated to a projection model.
-	 * <p>
-	 * <b>See:</b><br/>
-	 * {@link orion.textview.ProjectionTextModel}<br/>
-	 * {@link orion.textview.ProjectionTextModel#addProjection}<br/>
-	 * </p>		 
-	 * @name orion.textview.Projection
-	 * 
-	 * @property {Number} start The start offset of the projection range. 
-	 * @property {Number} end The end offset of the projection range. This offset is exclusive.
-	 * @property {String|orion.textview.TextModel} [text=""] The projection text to be inserted
-	 */
-	/**
-	 * Constructs a new <code>ProjectionTextModel</code> based on the specified <code>TextModel</code>.
-	 *
-	 * @param {orion.textview.TextModel} baseModel The base text model.
-	 *
-	 * @name orion.textview.ProjectionTextModel
-	 * @class The <code>ProjectionTextModel</code> represents a projection of its base text
-	 * model. Projection ranges can be added to the projection text model to hide and/or insert
-	 * ranges to the base text model.
-	 * <p>
-	 * The contents of the projection text model is modified when changes occur in the base model,
-	 * projection model or by calls to {@link #addProjection} and {@link #removeProjection}.
-	 * </p>
-	 * <p>
-	 * <b>See:</b><br/>
-	 * {@link orion.textview.TextView}<br/>
-	 * {@link orion.textview.TextModel}
-	 * {@link orion.textview.TextView#setModel}
-	 * </p>
-	 * @borrows orion.textview.EventTarget#addEventListener as #addEventListener
-	 * @borrows orion.textview.EventTarget#removeEventListener as #removeEventListener
-	 * @borrows orion.textview.EventTarget#dispatchEvent as #dispatchEvent
-	 */
-	function ProjectionTextModel(baseModel) {
-		this._model = baseModel;	/* Base Model */
-		this._projections = [];
-	}
-
-	ProjectionTextModel.prototype = /** @lends orion.textview.ProjectionTextModel.prototype */ {
-		/**
-		 * Adds a projection range to the model.
-		 * <p>
-		 * The model must notify the listeners before and after the the text is
-		 * changed by calling {@link #onChanging} and {@link #onChanged} respectively. 
-		 * </p>
-		 * @param {orion.textview.Projection} projection The projection range to be added.
-		 * 
-		 * @see #removeProjection
-		 */
-		addProjection: function(projection) {
-			if (!projection) {return;}
-			//start and end can't overlap any exist projection
-			var model = this._model, projections = this._projections;
-			projection._lineIndex = model.getLineAtOffset(projection.start);
-			projection._lineCount = model.getLineAtOffset(projection.end) - projection._lineIndex;
-			var text = projection.text;
-			if (!text) { text = ""; }
-			if (typeof text === "string") {
-				projection._model = new mTextModel.TextModel(text, model.getLineDelimiter());
-			} else {
-				projection._model = text;
-			}
-			var eventStart = this.mapOffset(projection.start, true);
-			var removedCharCount = projection.end - projection.start;
-			var removedLineCount = projection._lineCount;
-			var addedCharCount = projection._model.getCharCount();
-			var addedLineCount = projection._model.getLineCount() - 1;
-			var modelChangingEvent = {
-				type: "Changing",
-				text: projection._model.getText(),
-				start: eventStart,
-				removedCharCount: removedCharCount,
-				addedCharCount: addedCharCount,
-				removedLineCount: removedLineCount,
-				addedLineCount: addedLineCount
-			};
-			this.onChanging(modelChangingEvent);
-			var index = this._binarySearch(projections, projection.start);
-			projections.splice(index, 0, projection);
-			var modelChangedEvent = {
-				type: "Changed",
-				start: eventStart,
-				removedCharCount: removedCharCount,
-				addedCharCount: addedCharCount,
-				removedLineCount: removedLineCount,
-				addedLineCount: addedLineCount
-			};
-			this.onChanged(modelChangedEvent);
-		},
-		/**
-		 * Returns all projection ranges of this model.
-		 * 
-		 * @return {orion.textview.Projection[]} The projection ranges.
-		 * 
-		 * @see #addProjection
-		 */
-		getProjections: function() {
-			return this._projections.slice(0);
-		},
-		/**
-		 * Gets the base text model.
-		 *
-		 * @return {orion.textview.TextModel} The base text model.
-		 */
-		getBaseModel: function() {
-			return this._model;
-		},
-		/**
-		 * Maps offsets between the projection model and its base model.
-		 *
-		 * @param {Number} offset The offset to be mapped.
-		 * @param {Boolean} [baseOffset=false] <code>true</code> if <code>offset</code> is in base model and
-		 *	should be mapped to the projection model.
-		 * @return {Number} The mapped offset
-		 */
-		mapOffset: function(offset, baseOffset) {
-			var projections = this._projections, delta = 0, i, projection;
-			if (baseOffset) {
-				for (i = 0; i < projections.length; i++) {
-					projection = projections[i];
-					if (projection.start > offset) { break; }
-					if (projection.end > offset) { return -1; }
-					delta += projection._model.getCharCount() - (projection.end - projection.start);
-				}
-				return offset + delta;
-			}
-			for (i = 0; i < projections.length; i++) {
-				projection = projections[i];
-				if (projection.start > offset - delta) { break; }
-				var charCount = projection._model.getCharCount();
-				if (projection.start + charCount > offset - delta) {
-					return -1;
-				}
-				delta += charCount - (projection.end - projection.start);
-			}
-			return offset - delta;
-		},
-		/**
-		 * Removes a projection range from the model.
-		 * <p>
-		 * The model must notify the listeners before and after the the text is
-		 * changed by calling {@link #onChanging} and {@link #onChanged} respectively. 
-		 * </p>
-		 * 
-		 * @param {orion.textview.Projection} projection The projection range to be removed.
-		 * 
-		 * @see #addProjection
-		 */
-		removeProjection: function(projection) {
-			//TODO remove listeners from model
-			var i, delta = 0;
-			for (i = 0; i < this._projections.length; i++) {
-				var p = this._projections[i];
-				if (p === projection) {
-					projection = p;
-					break;
-				}
-				delta += p._model.getCharCount() - (p.end - p.start);
-			}
-			if (i < this._projections.length) {
-				var model = this._model;
-				var eventStart = projection.start + delta;
-				var addedCharCount = projection.end - projection.start;
-				var addedLineCount = projection._lineCount;
-				var removedCharCount = projection._model.getCharCount();
-				var removedLineCount = projection._model.getLineCount() - 1;
-				var modelChangingEvent = {
-					type: "Changing",
-					text: model.getText(projection.start, projection.end),
-					start: eventStart,
-					removedCharCount: removedCharCount,
-					addedCharCount: addedCharCount,
-					removedLineCount: removedLineCount,
-					addedLineCount: addedLineCount
-				};
-				this.onChanging(modelChangingEvent);
-				this._projections.splice(i, 1);
-				var modelChangedEvent = {
-					type: "Changed",
-					start: eventStart,
-					removedCharCount: removedCharCount,
-					addedCharCount: addedCharCount,
-					removedLineCount: removedLineCount,
-					addedLineCount: addedLineCount
-				};
-				this.onChanged(modelChangedEvent);
-			}
-		},
-		/** @ignore */
-		_binarySearch: function (array, offset) {
-			var high = array.length, low = -1, index;
-			while (high - low > 1) {
-				index = Math.floor((high + low) / 2);
-				if (offset <= array[index].start) {
-					high = index;
-				} else {
-					low = index;
-				}
-			}
-			return high;
-		},
-		/**
-		 * @see orion.textview.TextModel#getCharCount
-		 */
-		getCharCount: function() {
-			var count = this._model.getCharCount(), projections = this._projections;
-			for (var i = 0; i < projections.length; i++) {
-				var projection = projections[i];
-				count += projection._model.getCharCount() - (projection.end - projection.start);
-			}
-			return count;
-		},
-		/**
-		 * @see orion.textview.TextModel#getLine
-		 */
-		getLine: function(lineIndex, includeDelimiter) {
-			if (lineIndex < 0) { return null; }
-			var model = this._model, projections = this._projections;
-			var delta = 0, result = [], offset = 0, i, lineCount, projection;
-			for (i = 0; i < projections.length; i++) {
-				projection = projections[i];
-				if (projection._lineIndex >= lineIndex - delta) { break; }
-				lineCount = projection._model.getLineCount() - 1;
-				if (projection._lineIndex + lineCount >= lineIndex - delta) {
-					var projectionLineIndex = lineIndex - (projection._lineIndex + delta);
-					if (projectionLineIndex < lineCount) {
-						return projection._model.getLine(projectionLineIndex, includeDelimiter);
-					} else {
-						result.push(projection._model.getLine(lineCount));
-					}
-				}
-				offset = projection.end;
-				delta += lineCount - projection._lineCount;
-			}
-			offset = Math.max(offset, model.getLineStart(lineIndex - delta));
-			for (; i < projections.length; i++) {
-				projection = projections[i];
-				if (projection._lineIndex > lineIndex - delta) { break; }
-				result.push(model.getText(offset, projection.start));
-				lineCount = projection._model.getLineCount() - 1;
-				if (projection._lineIndex + lineCount > lineIndex - delta) {
-					result.push(projection._model.getLine(0, includeDelimiter));
-					return result.join("");
-				}
-				result.push(projection._model.getText());
-				offset = projection.end;
-				delta += lineCount - projection._lineCount;
-			}
-			var end = model.getLineEnd(lineIndex - delta, includeDelimiter);
-			if (offset < end) {
-				result.push(model.getText(offset, end));
-			}
-			return result.join("");
-		},
-		/**
-		 * @see orion.textview.TextModel#getLineAtOffset
-		 */
-		getLineAtOffset: function(offset) {
-			var model = this._model, projections = this._projections;
-			var delta = 0, lineDelta = 0;
-			for (var i = 0; i < projections.length; i++) {
-				var projection = projections[i];
-				if (projection.start > offset - delta) { break; }
-				var charCount = projection._model.getCharCount();
-				if (projection.start + charCount > offset - delta) {
-					var projectionOffset = offset - (projection.start + delta);
-					lineDelta += projection._model.getLineAtOffset(projectionOffset);
-					delta += projectionOffset;
-					break;
-				}
-				lineDelta += projection._model.getLineCount() - 1 - projection._lineCount;
-				delta += charCount - (projection.end - projection.start);
-			}
-			return model.getLineAtOffset(offset - delta) + lineDelta;
-		},
-		/**
-		 * @see orion.textview.TextModel#getLineCount
-		 */
-		getLineCount: function() {
-			var model = this._model, projections = this._projections;
-			var count = model.getLineCount();
-			for (var i = 0; i < projections.length; i++) {
-				var projection = projections[i];
-				count += projection._model.getLineCount() - 1 - projection._lineCount;
-			}
-			return count;
-		},
-		/**
-		 * @see orion.textview.TextModel#getLineDelimiter
-		 */
-		getLineDelimiter: function() {
-			return this._model.getLineDelimiter();
-		},
-		/**
-		 * @see orion.textview.TextModel#getLineEnd
-		 */
-		getLineEnd: function(lineIndex, includeDelimiter) {
-			if (lineIndex < 0) { return -1; }
-			var model = this._model, projections = this._projections;
-			var delta = 0, offsetDelta = 0;
-			for (var i = 0; i < projections.length; i++) {
-				var projection = projections[i];
-				if (projection._lineIndex > lineIndex - delta) { break; }
-				var lineCount = projection._model.getLineCount() - 1;
-				if (projection._lineIndex + lineCount > lineIndex - delta) {
-					var projectionLineIndex = lineIndex - (projection._lineIndex + delta);
-					return projection._model.getLineEnd (projectionLineIndex, includeDelimiter) + projection.start + offsetDelta;
-				}
-				offsetDelta += projection._model.getCharCount() - (projection.end - projection.start);
-				delta += lineCount - projection._lineCount;
-			}
-			return model.getLineEnd(lineIndex - delta, includeDelimiter) + offsetDelta;
-		},
-		/**
-		 * @see orion.textview.TextModel#getLineStart
-		 */
-		getLineStart: function(lineIndex) {
-			if (lineIndex < 0) { return -1; }
-			var model = this._model, projections = this._projections;
-			var delta = 0, offsetDelta = 0;
-			for (var i = 0; i < projections.length; i++) {
-				var projection = projections[i];
-				if (projection._lineIndex >= lineIndex - delta) { break; }
-				var lineCount = projection._model.getLineCount() - 1;
-				if (projection._lineIndex + lineCount >= lineIndex - delta) {
-					var projectionLineIndex = lineIndex - (projection._lineIndex + delta);
-					return projection._model.getLineStart (projectionLineIndex) + projection.start + offsetDelta;
-				}
-				offsetDelta += projection._model.getCharCount() - (projection.end - projection.start);
-				delta += lineCount - projection._lineCount;
-			}
-			return model.getLineStart(lineIndex - delta) + offsetDelta;
-		},
-		/**
-		 * @see orion.textview.TextModel#getText
-		 */
-		getText: function(start, end) {
-			if (start === undefined) { start = 0; }
-			var model = this._model, projections = this._projections;
-			var delta = 0, result = [], i, projection, charCount;
-			for (i = 0; i < projections.length; i++) {
-				projection = projections[i];
-				if (projection.start > start - delta) { break; }
-				charCount = projection._model.getCharCount();
-				if (projection.start + charCount > start - delta) {
-					if (end !== undefined && projection.start + charCount > end - delta) {
-						return projection._model.getText(start - (projection.start + delta), end - (projection.start + delta));
-					} else {
-						result.push(projection._model.getText(start - (projection.start + delta)));
-						start = projection.end + delta + charCount - (projection.end - projection.start);
-					}
-				}
-				delta += charCount - (projection.end - projection.start);
-			}
-			var offset = start - delta;
-			if (end !== undefined) {
-				for (; i < projections.length; i++) {
-					projection = projections[i];
-					if (projection.start > end - delta) { break; }
-					result.push(model.getText(offset, projection.start));
-					charCount = projection._model.getCharCount();
-					if (projection.start + charCount > end - delta) {
-						result.push(projection._model.getText(0, end - (projection.start + delta)));
-						return result.join("");
-					}
-					result.push(projection._model.getText());
-					offset = projection.end;
-					delta += charCount - (projection.end - projection.start);
-				}
-				result.push(model.getText(offset, end - delta));
-			} else {
-				for (; i < projections.length; i++) {
-					projection = projections[i];
-					result.push(model.getText(offset, projection.start));
-					result.push(projection._model.getText());
-					offset = projection.end;
-				}
-				result.push(model.getText(offset));
-			}
-			return result.join("");
-		},
-		/** @ignore */
-		_onChanging: function(text, start, removedCharCount, addedCharCount, removedLineCount, addedLineCount) {
-			var model = this._model, projections = this._projections, i, projection, delta = 0, lineDelta;
-			var end = start + removedCharCount;
-			for (; i < projections.length; i++) {
-				projection = projections[i];
-				if (projection.start > start) { break; }
-				delta += projection._model.getCharCount() - (projection.end - projection.start);
-			}
-			/*TODO add stuff saved by setText*/
-			var mapStart = start + delta, rangeStart = i;
-			for (; i < projections.length; i++) {
-				projection = projections[i];
-				if (projection.start > end) { break; }
-				delta += projection._model.getCharCount() - (projection.end - projection.start);
-				lineDelta += projection._model.getLineCount() - 1 - projection._lineCount;
-			}
-			/*TODO add stuff saved by setText*/
-			var mapEnd = end + delta, rangeEnd = i;
-			this.onChanging(mapStart, mapEnd - mapStart, addedCharCount/*TODO add stuff saved by setText*/, removedLineCount + lineDelta/*TODO add stuff saved by setText*/, addedLineCount/*TODO add stuff saved by setText*/);
-			projections.splice(projections, rangeEnd - rangeStart);
-			var count = text.length - (mapEnd - mapStart);
-			for (; i < projections.length; i++) {
-				projection = projections[i];
-				projection.start += count;
-				projection.end += count;
-				projection._lineIndex = model.getLineAtOffset(projection.start);
-			}
-		},
-		/**
-		 * @see orion.textview.TextModel#onChanging
-		 */
-		onChanging: function(modelChangingEvent) {
-			return this.dispatchEvent(modelChangingEvent);
-		},
-		/**
-		 * @see orion.textview.TextModel#onChanged
-		 */
-		onChanged: function(modelChangedEvent) {
-			return this.dispatchEvent(modelChangedEvent);
-		},
-		/**
-		 * @see orion.textview.TextModel#setLineDelimiter
-		 */
-		setLineDelimiter: function(lineDelimiter) {
-			this._model.setLineDelimiter(lineDelimiter);
-		},
-		/**
-		 * @see orion.textview.TextModel#setText
-		 */
-		setText: function(text, start, end) {
-			if (text === undefined) { text = ""; }
-			if (start === undefined) { start = 0; }
-			var eventStart = start, eventEnd = end;
-			var model = this._model, projections = this._projections;
-			var delta = 0, lineDelta = 0, i, projection, charCount, startProjection, endProjection, startLineDelta = 0;
-			for (i = 0; i < projections.length; i++) {
-				projection = projections[i];
-				if (projection.start > start - delta) { break; }
-				charCount = projection._model.getCharCount();
-				if (projection.start + charCount > start - delta) {
-					if (end !== undefined && projection.start + charCount > end - delta) {
-						projection._model.setText(text, start - (projection.start + delta), end - (projection.start + delta));
-						//TODO events - special case
-						return;
-					} else {
-						startLineDelta = projection._model.getLineCount() - 1 - projection._model.getLineAtOffset(start - (projection.start + delta));
-						startProjection = {
-							projection: projection,
-							start: start - (projection.start + delta)
-						};
-						start = projection.end + delta + charCount - (projection.end - projection.start);
-					}
-				}
-				lineDelta += projection._model.getLineCount() - 1 - projection._lineCount;
-				delta += charCount - (projection.end - projection.start);
-			}
-			var mapStart = start - delta, rangeStart = i, startLine = model.getLineAtOffset(mapStart) + lineDelta - startLineDelta;
-			if (end !== undefined) {
-				for (; i < projections.length; i++) {
-					projection = projections[i];
-					if (projection.start > end - delta) { break; }
-					charCount = projection._model.getCharCount();
-					if (projection.start + charCount > end - delta) {
-						lineDelta += projection._model.getLineAtOffset(end - (projection.start + delta));
-						charCount = end - (projection.start + delta);
-						end = projection.end + delta;
-						endProjection = {
-							projection: projection,
-							end: charCount
-						};
-						break;
-					}
-					lineDelta += projection._model.getLineCount() - 1 - projection._lineCount;
-					delta += charCount - (projection.end - projection.start);
-				}
-			} else {
-				for (; i < projections.length; i++) {
-					projection = projections[i];
-					lineDelta += projection._model.getLineCount() - 1 - projection._lineCount;
-					delta += projection._model.getCharCount() - (projection.end - projection.start);
-				}
-				end = eventEnd = model.getCharCount() + delta;
-			}
-			var mapEnd = end - delta, rangeEnd = i, endLine = model.getLineAtOffset(mapEnd) + lineDelta;
-			
-			//events
-			var removedCharCount = eventEnd - eventStart;
-			var removedLineCount = endLine - startLine;
-			var addedCharCount = text.length;
-			var addedLineCount = 0;
-			var cr = 0, lf = 0, index = 0;
-			while (true) {
-				if (cr !== -1 && cr <= index) { cr = text.indexOf("\r", index); }
-				if (lf !== -1 && lf <= index) { lf = text.indexOf("\n", index); }
-				if (lf === -1 && cr === -1) { break; }
-				if (cr !== -1 && lf !== -1) {
-					if (cr + 1 === lf) {
-						index = lf + 1;
-					} else {
-						index = (cr < lf ? cr : lf) + 1;
-					}
-				} else if (cr !== -1) {
-					index = cr + 1;
-				} else {
-					index = lf + 1;
-				}
-				addedLineCount++;
-			}
-			
-			var modelChangingEvent = {
-				type: "Changing",
-				text: text,
-				start: eventStart,
-				removedCharCount: removedCharCount,
-				addedCharCount: addedCharCount,
-				removedLineCount: removedLineCount,
-				addedLineCount: addedLineCount
-			};
-			this.onChanging(modelChangingEvent);
-			
-//			var changeLineCount = model.getLineAtOffset(mapEnd) - model.getLineAtOffset(mapStart) + addedLineCount;
-			model.setText(text, mapStart, mapEnd);
-			if (startProjection) {
-				projection = startProjection.projection;
-				projection._model.setText("", startProjection.start);
-			}		
-			if (endProjection) {
-				projection = endProjection.projection;
-				projection._model.setText("", 0, endProjection.end);
-				projection.start = projection.end;
-				projection._lineCount = 0;
-			}
-			projections.splice(rangeStart, rangeEnd - rangeStart);
-			var changeCount = text.length - (mapEnd - mapStart);
-			for (i = rangeEnd; i < projections.length; i++) {
-				projection = projections[i];
-				projection.start += changeCount;
-				projection.end += changeCount;
-//				if (projection._lineIndex + changeLineCount !== model.getLineAtOffset(projection.start)) {
-//					log("here");
-//				}
-				projection._lineIndex = model.getLineAtOffset(projection.start);
-//				projection._lineIndex += changeLineCount;
-			}
-			
-			var modelChangedEvent = {
-				type: "Changed",
-				start: eventStart,
-				removedCharCount: removedCharCount,
-				addedCharCount: addedCharCount,
-				removedLineCount: removedLineCount,
-				addedLineCount: addedLineCount
-			};
-			this.onChanged(modelChangedEvent);
-		}
-	};
-	mEventTarget.EventTarget.addMixin(ProjectionTextModel.prototype);
-
-	return {ProjectionTextModel: ProjectionTextModel};
-});
-/*******************************************************************************
- * @license
- * Copyright (c) 2010, 2011 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials are made 
- * available under the terms of the Eclipse Public License v1.0 
- * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
- * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
- * 
- * Contributors: IBM Corporation - initial API and implementation
- ******************************************************************************/
-
-/*global define setTimeout clearTimeout setInterval clearInterval Node */
-
-define("orion/textview/tooltip", ['orion/textview/textView', 'orion/textview/textModel', 'orion/textview/projectionTextModel'], function(mTextView, mTextModel, mProjectionTextModel) {
-
-	/** @private */
-	function Tooltip (view) {
-		this._view = view;
-		//TODO add API to get the parent of the view
-		this._create(view._parent.ownerDocument);
-		view.addEventListener("Destroy", this, this.destroy);
-	}
-	Tooltip.getTooltip = function(view) {
-		if (!view._tooltip) {
-			 view._tooltip = new Tooltip(view);
-		}
-		return view._tooltip;
-	};
-	Tooltip.prototype = /** @lends orion.textview.Tooltip.prototype */ {
-		_create: function(document) {
-			if (this._domNode) { return; }
-			this._document = document;
-			var domNode = this._domNode = document.createElement("DIV");
-			domNode.className = "viewTooltip";
-			var viewParent = this._viewParent = document.createElement("DIV");
-			domNode.appendChild(viewParent);
-			var htmlParent = this._htmlParent = document.createElement("DIV");
-			domNode.appendChild(htmlParent);
-			document.body.appendChild(domNode);
-			this.hide();
-		},
-		destroy: function() {
-			if (!this._domNode) { return; }
-			if (this._contentsView) {
-				this._contentsView.destroy();
-				this._contentsView = null;
-				this._emptyModel = null;
-			}
-			var parent = this._domNode.parentNode;
-			if (parent) { parent.removeChild(this._domNode); }
-			this._domNode = null;
-		},
-		hide: function() {
-			if (this._contentsView) {
-				this._contentsView.setModel(this._emptyModel);
-			}
-			if (this._viewParent) {
-				this._viewParent.style.left = "-10000px";
-				this._viewParent.style.position = "fixed";
-				this._viewParent.style.visibility = "hidden";
-			}
-			if (this._htmlParent) {
-				this._htmlParent.style.left = "-10000px";
-				this._htmlParent.style.position = "fixed";
-				this._htmlParent.style.visibility = "hidden";
-				this._htmlParent.innerHTML = "";
-			}
-			if (this._domNode) {
-				this._domNode.style.visibility = "hidden";
-			}
-			if (this._showTimeout) {
-				clearTimeout(this._showTimeout);
-				this._showTimeout = null;
-			}
-			if (this._hideTimeout) {
-				clearTimeout(this._hideTimeout);
-				this._hideTimeout = null;
-			}
-			if (this._fadeTimeout) {
-				clearInterval(this._fadeTimeout);
-				this._fadeTimeout = null;
-			}
-		},
-		isVisible: function() {
-			return this._domNode && this._domNode.style.visibility === "visible";
-		},
-		setTarget: function(target) {
-			if (this.target === target) { return; }
-			this._target = target;
-			this.hide();
-			if (target) {
-				var self = this;
-				self._showTimeout = setTimeout(function() {
+ * Copyright (c) 2010, 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials are made 
+ * available under the terms of the Eclipse Public License v1.0 
+ * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
+ * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ ******************************************************************************/
+
+/*global define setTimeout clearTimeout setInterval clearInterval Node */
+
+define("orion/textview/tooltip", ['i18n!orion/textview/nls/messages', 'orion/textview/textView', 'orion/textview/textModel', 'orion/textview/projectionTextModel'], function(messages, mTextView, mTextModel, mProjectionTextModel) {
+
+	/** @private */
+	function Tooltip (view) {
+		this._view = view;
+		this._create(view.getOptions("parent").ownerDocument);
+		view.addEventListener("Destroy", this, this.destroy);
+	}
+	Tooltip.getTooltip = function(view) {
+		if (!view._tooltip) {
+			 view._tooltip = new Tooltip(view);
+		}
+		return view._tooltip;
+	};
+	Tooltip.prototype = /** @lends orion.textview.Tooltip.prototype */ {
+		_create: function(document) {
+			if (this._tooltipDiv) { return; }
+			var tooltipDiv = this._tooltipDiv = document.createElement("DIV");
+			tooltipDiv.className = "textviewTooltip";
+			tooltipDiv.setAttribute("aria-live", "assertive");
+			tooltipDiv.setAttribute("aria-atomic", "true");
+			var tooltipContents = this._tooltipContents = document.createElement("DIV");
+			tooltipDiv.appendChild(tooltipContents);
+			document.body.appendChild(tooltipDiv);
+			this.hide();
+		},
+		destroy: function() {
+			if (!this._tooltipDiv) { return; }
+			this.hide();
+			var parent = this._tooltipDiv.parentNode;
+			if (parent) { parent.removeChild(this._tooltipDiv); }
+			this._tooltipDiv = null;
+		},
+		hide: function() {
+			if (this._contentsView) {
+				this._contentsView.destroy();
+				this._contentsView = null;
+			}
+			if (this._tooltipContents) {
+				this._tooltipContents.innerHTML = "";
+			}
+			if (this._tooltipDiv) {
+				this._tooltipDiv.style.visibility = "hidden";
+			}
+			if (this._showTimeout) {
+				clearTimeout(this._showTimeout);
+				this._showTimeout = null;
+			}
+			if (this._hideTimeout) {
+				clearTimeout(this._hideTimeout);
+				this._hideTimeout = null;
+			}
+			if (this._fadeTimeout) {
+				clearInterval(this._fadeTimeout);
+				this._fadeTimeout = null;
+			}
+		},
+		isVisible: function() {
+			return this._tooltipDiv && this._tooltipDiv.style.visibility === "visible";
+		},
+		setTarget: function(target, delay) {
+			if (this.target === target) { return; }
+			this._target = target;
+			this.hide();
+			if (target) {
+				var self = this;
+				if(delay === 0) {
 					self.show(true);
-				}, 1000);
-			}
-		},
-		show: function(autoHide) {
-			if (!this._target) { return; }
-			var info = this._target.getTooltipInfo();
-			if (!info) { return; }
-			var domNode = this._domNode;
-			domNode.style.left = domNode.style.right = domNode.style.width = domNode.style.height = "auto";
-			var contents = info.contents, contentsDiv;
-			if (contents instanceof Array) {
-				contents = this._getAnnotationContents(contents);
-			}
-			if (typeof contents === "string") {
-				(contentsDiv = this._htmlParent).innerHTML = contents;
-			} else if (contents instanceof Node) {
-				(contentsDiv = this._htmlParent).appendChild(contents);
-			} else if (contents instanceof mProjectionTextModel.ProjectionTextModel) {
-				if (!this._contentsView) {
-					this._emptyModel = new mTextModel.TextModel("");
-					//TODO need hook into setup.js (or editor.js) to create a text view (and styler)
-					var newView = this._contentsView = new mTextView.TextView({
-						model: this._emptyModel,
-						parent: this._viewParent,
-						tabSize: 4,
-						sync: true,
-						stylesheet: ["/orion/textview/tooltip.css", "/orion/textview/rulers.css",
-							"/examples/textview/textstyler.css", "/css/default-theme.css"]
-					});
-					//TODO this is need to avoid IE from getting focus
-					newView._clientDiv.contentEditable = false;
-					//TODO need to find a better way of sharing the styler for multiple views
-					var view = this._view;
-					var listener = {
-						onLineStyle: function(e) {
-							view.onLineStyle(e);
-						}
-					};
-					newView.addEventListener("LineStyle", listener.onLineStyle);
-				}
-				var contentsView = this._contentsView;
-				contentsView.setModel(contents);
-				var size = contentsView.computeSize();
-				contentsDiv = this._viewParent;
-				//TODO always make the width larger than the size of the scrollbar to avoid bug in updatePage
-				contentsDiv.style.width = (size.width + 20) + "px";
-				contentsDiv.style.height = size.height + "px";
-			} else {
-				return;
-			}
-			contentsDiv.style.left = "auto";
-			contentsDiv.style.position = "static";
-			contentsDiv.style.visibility = "visible";
-			var left = parseInt(this._getNodeStyle(domNode, "padding-left", "0"), 10);
-			left += parseInt(this._getNodeStyle(domNode, "border-left-width", "0"), 10);
-			if (info.anchor === "right") {
-				var right = parseInt(this._getNodeStyle(domNode, "padding-right", "0"), 10);
-				right += parseInt(this._getNodeStyle(domNode, "border-right-width", "0"), 10);
-				domNode.style.right = (domNode.ownerDocument.body.getBoundingClientRect().right - info.x + left + right) + "px";
-			} else {
-				domNode.style.left = (info.x - left) + "px";
-			}
-			var top = parseInt(this._getNodeStyle(domNode, "padding-top", "0"), 10);
-			top += parseInt(this._getNodeStyle(domNode, "border-top-width", "0"), 10);
-			domNode.style.top = (info.y - top) + "px";
-			domNode.style.maxWidth = info.maxWidth + "px";
-			domNode.style.maxHeight = info.maxHeight + "px";
-			domNode.style.opacity = "1";
-			domNode.style.visibility = "visible";
-			if (autoHide) {
-				var self = this;
-				self._hideTimeout = setTimeout(function() {
-					var opacity = parseFloat(self._getNodeStyle(domNode, "opacity", "1"));
-					self._fadeTimeout = setInterval(function() {
-						if (domNode.style.visibility === "visible" && opacity > 0) {
-							opacity -= 0.1;
-							domNode.style.opacity = opacity;
-							return;
-						}
-						self.hide();
-					}, 50);
-				}, 5000);
-			}
-		},
-		_getAnnotationContents: function(annotations) {
-			if (annotations.length === 0) {
-				return null;
-			}
-			var model = this._view.getModel(), annotation;
-			var baseModel = model.getBaseModel ? model.getBaseModel() : model;
-			function getText(start, end) {
-				var textStart = baseModel.getLineStart(baseModel.getLineAtOffset(start));
-				var textEnd = baseModel.getLineEnd(baseModel.getLineAtOffset(end), true);
-				return baseModel.getText(textStart, textEnd);
-			}
-			var title;
-			if (annotations.length === 1) {
-				annotation = annotations[0];
-				if (annotation.title) {
-					title = annotation.title.replace(/</g, "&lt;").replace(/>/g, "&gt;");
-					return "<div>" + annotation.html + "&nbsp;<span style='vertical-align:middle;'>" + title + "</span><div>";
-				} else {
-					var newModel = new mProjectionTextModel.ProjectionTextModel(baseModel);
-					var lineStart = baseModel.getLineStart(baseModel.getLineAtOffset(annotation.start));
-					newModel.addProjection({start: annotation.end, end: newModel.getCharCount()});
-					newModel.addProjection({start: 0, end: lineStart});
-					return newModel;
-				}
-			} else {
-				var tooltipHTML = "<div><em>Multiple annotations:</em></div>";
-				for (var i = 0; i < annotations.length; i++) {
-					annotation = annotations[i];
-					title = annotation.title;
-					if (!title) {
-						title = getText(annotation.start, annotation.end);
-					}
-					title = title.replace(/</g, "&lt;").replace(/>/g, "&gt;");
-					tooltipHTML += "<div>" + annotation.html + "&nbsp;<span style='vertical-align:middle;'>" + title + "</span><div>";
-				}
-				return tooltipHTML;
-			}
-		},
-		_getNodeStyle: function(node, prop, defaultValue) {
-			var value;
-			if (node) {
-				value = node.style[prop];
-				if (!value) {
-					if (node.currentStyle) {
-						var index = 0, p = prop;
-						while ((index = p.indexOf("-", index)) !== -1) {
-							p = p.substring(0, index) + p.substring(index + 1, index + 2).toUpperCase() + p.substring(index + 2);
-						}
-						value = node.currentStyle[p];
-					} else {
-						var css = node.ownerDocument.defaultView.getComputedStyle(node, null);
-						value = css ? css.getPropertyValue(prop) : null;
-					}
-				}
-			}
-			return value || defaultValue;
-		}
-	};
-	return {Tooltip: Tooltip};
-});
+				}
+				else {
+					self._showTimeout = setTimeout(function() {
+						self.show(true);
+					}, delay ? delay : 500);
+				}
+			}
+		},
+		show: function(autoHide) {
+			if (!this._target) { return; }
+			var info = this._target.getTooltipInfo();
+			if (!info) { return; }
+			var tooltipDiv = this._tooltipDiv, tooltipContents = this._tooltipContents;
+			tooltipDiv.style.left = tooltipDiv.style.right = tooltipDiv.style.width = tooltipDiv.style.height = 
+				tooltipContents.style.width = tooltipContents.style.height = "auto";
+			var contents = info.contents;
+			if (contents instanceof Array) {
+				contents = this._getAnnotationContents(contents);
+			}
+			if (typeof contents === "string") {
+				tooltipContents.innerHTML = contents;
+			} else if (this._isNode(contents)) {
+				tooltipContents.appendChild(contents);
+			} else if (contents instanceof mProjectionTextModel.ProjectionTextModel) {
+				var view = this._view;
+				var options = view.getOptions();
+				options.parent = tooltipContents;
+				var tooltipTheme = "tooltip";
+				var theme = options.themeClass;
+				if (theme) {
+					theme = theme.replace(tooltipTheme, "");
+					if (theme) { theme = " " + theme; }
+					theme = tooltipTheme + theme;
+				} else {
+					theme = tooltipTheme;
+				}
+				options.themeClass = theme;
+				var contentsView = this._contentsView = new mTextView.TextView(options);
+				//TODO this is need to avoid Firefox from getting focus
+				contentsView._clientDiv.contentEditable = false;
+				//TODO need to find a better way of sharing the styler for multiple views
+				var listener = {
+					onLineStyle: function(e) {
+						view.onLineStyle(e);
+					}
+				};
+				contentsView.addEventListener("LineStyle", listener.onLineStyle);
+				contentsView.setModel(contents);
+				var size = contentsView.computeSize();
+				tooltipContents.style.width = (size.width + 20) + "px";
+				tooltipContents.style.height = size.height + "px";
+				contentsView.resize();
+			} else {
+				return;
+			}
+			var documentElement = tooltipDiv.ownerDocument.documentElement;
+			if (info.anchor === "right") {
+				var right = documentElement.clientWidth - info.x;
+				tooltipDiv.style.right = right + "px";
+				tooltipDiv.style.maxWidth = (documentElement.clientWidth - right - 10) + "px";
+			} else {
+				var left = parseInt(this._getNodeStyle(tooltipDiv, "padding-left", "0"), 10);
+				left += parseInt(this._getNodeStyle(tooltipDiv, "border-left-width", "0"), 10);
+				left = info.x - left;
+				tooltipDiv.style.left = left + "px";
+				tooltipDiv.style.maxWidth = (documentElement.clientWidth - left - 10) + "px";
+			}
+			var top = parseInt(this._getNodeStyle(tooltipDiv, "padding-top", "0"), 10);
+			top += parseInt(this._getNodeStyle(tooltipDiv, "border-top-width", "0"), 10);
+			top = info.y - top;
+			tooltipDiv.style.top = top + "px";
+			tooltipDiv.style.maxHeight = (documentElement.clientHeight - top - 10) + "px";
+			tooltipDiv.style.opacity = "1";
+			tooltipDiv.style.visibility = "visible";
+			if (autoHide) {
+				var self = this;
+				self._hideTimeout = setTimeout(function() {
+					var opacity = parseFloat(self._getNodeStyle(tooltipDiv, "opacity", "1"));
+					self._fadeTimeout = setInterval(function() {
+						if (tooltipDiv.style.visibility === "visible" && opacity > 0) {
+							opacity -= 0.1;
+							tooltipDiv.style.opacity = opacity;
+							return;
+						}
+						self.hide();
+					}, 50);
+				}, 5000);
+			}
+		},
+		_getAnnotationContents: function(annotations) {
+			if (annotations.length === 0) {
+				return null;
+			}
+			var model = this._view.getModel(), annotation;
+			var baseModel = model.getBaseModel ? model.getBaseModel() : model;
+			function getText(start, end) {
+				var textStart = baseModel.getLineStart(baseModel.getLineAtOffset(start));
+				var textEnd = baseModel.getLineEnd(baseModel.getLineAtOffset(end), true);
+				return baseModel.getText(textStart, textEnd);
+			}
+			function getAnnotationHTML(annotation) {
+				var title = annotation.title;
+				if (title === "") { return null; }
+				var result = "<div>";
+				if (annotation.html) {
+					result += annotation.html + "&nbsp;";
+				}
+				if (!title) {
+					title = getText(annotation.start, annotation.end);
+				}
+				title = title.replace(/</g, "&lt;").replace(/>/g, "&gt;");
+				result += "<span style='vertical-align:middle;'>" + title + "</span><div>";
+				return result;
+			}
+			if (annotations.length === 1) {
+				annotation = annotations[0];
+				if (annotation.title !== undefined) {
+					return getAnnotationHTML(annotation);
+				} else {
+					var newModel = new mProjectionTextModel.ProjectionTextModel(baseModel);
+					var lineStart = baseModel.getLineStart(baseModel.getLineAtOffset(annotation.start));
+					var charCount = baseModel.getCharCount();
+					if (annotation.end !== charCount) {
+						newModel.addProjection({start: annotation.end, end: charCount});
+					}
+					if (lineStart > 0) {
+						newModel.addProjection({start: 0, end: lineStart});
+					}
+					return newModel;
+				}
+			} else {
+				var tooltipHTML = "<div><em>" + messages.multipleAnnotations + "</em></div>";
+				for (var i = 0; i < annotations.length; i++) {
+					annotation = annotations[i];
+					var html = getAnnotationHTML(annotation);
+					if (html) {
+						tooltipHTML += html;
+					}
+				}
+				return tooltipHTML;
+			}
+		},
+		_getNodeStyle: function(node, prop, defaultValue) {
+			var value;
+			if (node) {
+				value = node.style[prop];
+				if (!value) {
+					if (node.currentStyle) {
+						var index = 0, p = prop;
+						while ((index = p.indexOf("-", index)) !== -1) {
+							p = p.substring(0, index) + p.substring(index + 1, index + 2).toUpperCase() + p.substring(index + 2);
+						}
+						value = node.currentStyle[p];
+					} else {
+						var css = node.ownerDocument.defaultView.getComputedStyle(node, null);
+						value = css ? css.getPropertyValue(prop) : null;
+					}
+				}
+			}
+			return value || defaultValue;
+		},
+		_isNode: function (obj) {
+			return typeof Node === "object" ? obj instanceof Node :
+				obj && typeof obj === "object" && typeof obj.nodeType === "number" && typeof obj.nodeName === "string";
+		}
+	};
+	return {Tooltip: Tooltip};
+});
 /*******************************************************************************
  * @license
  * Copyright (c) 2010, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials are made 
  * available under the terms of the Eclipse Public License v1.0 
  * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
  * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
  * 
  * Contributors: 
  *		Felipe Heidrich (IBM Corporation) - initial API and implementation
  *		Silenio Quarti (IBM Corporation) - initial API and implementation
  *		Mihai Sucan (Mozilla Foundation) - fix for Bug#334583 Bug#348471 Bug#349485 Bug#350595 Bug#360726 Bug#361180 Bug#362835 Bug#362428 Bug#362286 Bug#354270 Bug#361474 Bug#363945 Bug#366312 Bug#370584
  ******************************************************************************/
 
-/*global window document navigator setTimeout clearTimeout XMLHttpRequest define DOMException */
+/*global window document navigator setTimeout clearTimeout setInterval clearInterval define */
 
 define("orion/textview/textView", ['orion/textview/textModel', 'orion/textview/keyBinding', 'orion/textview/eventTarget'], function(mTextModel, mKeyBinding, mEventTarget) {
 
 	/** @private */
 	function addHandler(node, type, handler, capture) {
 		if (typeof node.addEventListener === "function") {
 			node.addEventListener(type, handler, capture === true);
 		} else {
@@ -3430,16 +4586,17 @@ define("orion/textview/textView", ['orio
 	var isWebkit = userAgent.indexOf("WebKit") !== -1;
 	var isPad = userAgent.indexOf("iPad") !== -1;
 	var isMac = navigator.platform.indexOf("Mac") !== -1;
 	var isWindows = navigator.platform.indexOf("Win") !== -1;
 	var isLinux = navigator.platform.indexOf("Linux") !== -1;
 	var isW3CEvents = typeof window.document.documentElement.addEventListener === "function";
 	var isRangeRects = (!isIE || isIE >= 9) && typeof window.document.createRange().getBoundingClientRect === "function";
 	var platformDelimiter = isWindows ? "\r\n" : "\n";
+	var scrollButtonHeight = isPad ? 0 : 17;
 	
 	/** 
 	 * Constructs a new Selection object.
 	 * 
 	 * @class A Selection represents a range of selected text in the view.
 	 * @name orion.textview.Selection
 	 */
 	function Selection (start, end, caret) {
@@ -3517,19 +4674,18 @@ define("orion/textview/textView", ['orio
 	 * {@link orion.textview.TextView#getOptions}	 
 	 * </p>		 
 	 * @name orion.textview.TextViewOptions
 	 *
 	 * @property {String|DOMElement} parent the parent element for the view, it can be either a DOM element or an ID for a DOM element.
 	 * @property {orion.textview.TextModel} [model] the text model for the view. If it is not set the view creates an empty {@link orion.textview.TextModel}.
 	 * @property {Boolean} [readonly=false] whether or not the view is read-only.
 	 * @property {Boolean} [fullSelection=true] whether or not the view is in full selection mode.
-	 * @property {Boolean} [sync=false] whether or not the view creation should be synchronous (if possible).
+	 * @property {Boolean} [tabMode=true] whether or not the tab keypress is consumed by the view.
 	 * @property {Boolean} [expandTab=false] whether or not the tab key inserts white spaces.
-	 * @property {String|String[]} [stylesheet] one or more stylesheet for the view. Each stylesheet can be either a URI or a string containing the CSS rules.
 	 * @property {String} [themeClass] the CSS class for the view theming.
 	 * @property {Number} [tabSize] The number of spaces in a tab.
 	 */
 	/**
 	 * Constructs a new text view.
 	 * 
 	 * @param {orion.textview.TextViewOptions} options the view options.
 	 * 
@@ -3540,24 +4696,40 @@ define("orion/textview/textView", ['orio
 	 * @borrows orion.textview.EventTarget#dispatchEvent as #dispatchEvent
 	 */
 	function TextView (options) {
 		this._init(options);
 	}
 	
 	TextView.prototype = /** @lends orion.textview.TextView.prototype */ {
 		/**
-		 * Adds a ruler to the text view.
+		 * Adds a ruler to the text view at the specified position.
+		 * <p>
+		 * The position is relative to the ruler location.
+		 * </p>
 		 *
 		 * @param {orion.textview.Ruler} ruler the ruler.
-		 */
-		addRuler: function (ruler) {
-			this._rulers.push(ruler);
+		 * @param {Number} [index=length] the ruler index.
+		 */
+		addRuler: function (ruler, index) {
 			ruler.setView(this);
-			this._createRuler(ruler);
+			var rulers = this._rulers;
+			if (index !== undefined) {
+				var i, sideIndex;
+				for (i = 0, sideIndex=0; i < rulers.length && sideIndex < index; i++) {
+					if (ruler.getLocation() === rulers[i].getLocation()) {
+						sideIndex++;
+					}
+				}
+				rulers.splice(sideIndex, 0, ruler);
+				index = sideIndex;
+			} else {
+				rulers.push(ruler);
+			}
+			this._createRuler(ruler, index);
 			this._updatePage();
 		},
 		computeSize: function() {
 			var w = 0, h = 0;
 			var model = this._model, clientDiv = this._clientDiv;
 			if (!clientDiv) { return {width: w, height: h}; }
 			var clientWidth = clientDiv.style.width;
 			/*
@@ -3567,42 +4739,40 @@ define("orion/textview/textView", ['orio
 			* is to set the width of the client div to a larger number
 			* before computing the lines width.  Note that this value is
 			* reset to the appropriate value further down.
 			*/
 			if (isWebkit) {
 				clientDiv.style.width = (0x7FFFF).toString() + "px";
 			}
 			var lineCount = model.getLineCount();
-			var document = this._frameDocument;
 			for (var lineIndex=0; lineIndex<lineCount; lineIndex++) {
 				var child = this._getLineNode(lineIndex), dummy = null;
 				if (!child || child.lineChanged || child.lineRemoved) {
 					child = dummy = this._createLine(clientDiv, null, document, lineIndex, model);
 				}
 				var rect = this._getLineBoundingClientRect(child);
 				w = Math.max(w, rect.right - rect.left);
 				h += rect.bottom - rect.top;
 				if (dummy) { clientDiv.removeChild(dummy); }
 			}
 			if (isWebkit) {
 				clientDiv.style.width = clientWidth;
 			}
 			var viewPadding = this._getViewPadding();
-			w += viewPadding.right - viewPadding.left;
-			h += viewPadding.bottom - viewPadding.top;
+			w += viewPadding.right + viewPadding.left;
+			h += viewPadding.bottom + viewPadding.top;
 			return {width: w, height: h};
 		},
 		/**
 		 * Converts the given rectangle from one coordinate spaces to another.
 		 * <p>The supported coordinate spaces are:
 		 * <ul>
 		 *   <li>"document" - relative to document, the origin is the top-left corner of first line</li>
 		 *   <li>"page" - relative to html page that contains the text view</li>
-		 *   <li>"view" - relative to text view, the origin is the top-left corner of the view container</li>
 		 * </ul>
 		 * </p>
 		 * <p>All methods in the view that take or return a position are in the document coordinate space.</p>
 		 *
 		 * @param rect the rectangle to convert.
 		 * @param rect.x the x of the rectangle.
 		 * @param rect.y the y of the rectangle.
 		 * @param rect.width the width of the rectangle.
@@ -3614,54 +4784,33 @@ define("orion/textview/textView", ['orio
 		 * @see #getOffsetAtLocation
 		 * @see #getTopPixel
 		 * @see #setTopPixel
 		 */
 		convert: function(rect, from, to) {
 			if (!this._clientDiv) { return; }
 			var scroll = this._getScroll();
 			var viewPad = this._getViewPadding();
-			var frame = this._frame.getBoundingClientRect();
 			var viewRect = this._viewDiv.getBoundingClientRect();
-			switch(from) {
-				case "document":
-					if (rect.x !== undefined) {
-						rect.x += - scroll.x + viewRect.left + viewPad.left;
-					}
-					if (rect.y !== undefined) {
-						rect.y += - scroll.y + viewRect.top + viewPad.top;
-					}
-					break;
-				case "page":
-					if (rect.x !== undefined) {
-						rect.x += - frame.left;
-					}
-					if (rect.y !== undefined) {
-						rect.y += - frame.top;
-					}
-					break;
+			if (from === "document") {
+				if (rect.x !== undefined) {
+					rect.x += - scroll.x + viewRect.left + viewPad.left;
+				}
+				if (rect.y !== undefined) {
+					rect.y += - scroll.y + viewRect.top + viewPad.top;
+				}
 			}
 			//At this point rect is in the widget coordinate space
-			switch (to) {
-				case "document":
-					if (rect.x !== undefined) {
-						rect.x += scroll.x - viewRect.left - viewPad.left;
-					}
-					if (rect.y !== undefined) {
-						rect.y += scroll.y - viewRect.top - viewPad.top;
-					}
-					break;
-				case "page":
-					if (rect.x !== undefined) {
-						rect.x += frame.left;
-					}
-					if (rect.y !== undefined) {
-						rect.y += frame.top;
-					}
-					break;
+			if (to === "document") {
+				if (rect.x !== undefined) {
+					rect.x += scroll.x - viewRect.left - viewPad.left;
+				}
+				if (rect.y !== undefined) {
+					rect.y += scroll.y - viewRect.top - viewPad.top;
+				}
 			}
 			return rect;
 		},
 		/**
 		 * Destroys the text view. 
 		 * <p>
 		 * Removes the view from the page and frees all resources created by the view.
 		 * Calling this function causes the "Destroy" event to be fire so that all components
@@ -3672,28 +4821,22 @@ define("orion/textview/textView", ['orio
 		 */
 		destroy: function() {
 			/* Destroy rulers*/
 			for (var i=0; i< this._rulers.length; i++) {
 				this._rulers[i].setView(null);
 			}
 			this.rulers = null;
 			
-			/*
-			* Note that when the frame is removed, the unload event is trigged
-			* and the view contents and handlers is released properly by
-			* destroyView().
-			*/
-			this._destroyFrame();
+			this._destroyView();
 
 			var e = {type: "Destroy"};
 			this.onDestroy(e);
 
 			this._parent = null;
-			this._parentDocument = null;
 			this._model = null;
 			this._selection = null;
 			this._doubleClickSelection = null;
 			this._keyBindings = null;
 			this._actions = null;
 		},
 		/**
 		 * Gives focus to the text view.
@@ -3703,22 +4846,18 @@ define("orion/textview/textView", ['orio
 			/*
 			* Feature in Chrome. When focus is called in the clientDiv without
 			* setting selection the browser will set the selection to the first dom 
 			* element, which can be above the client area. When this happen the 
 			* browser also scrolls the window to show that element.
 			* The fix is to call _updateDOMSelection() before calling focus().
 			*/
 			this._updateDOMSelection();
-			if (isPad) {
-				this._textArea.focus();
-			} else {
-				if (isOpera) { this._clientDiv.blur(); }
-				this._clientDiv.focus();
-			}
+			if (isOpera) { this._clientDiv.blur(); }
+			this._clientDiv.focus();
 			/*
 			* Feature in Safari. When focus is called the browser selects the clientDiv
 			* itself. The fix is to call _updateDOMSelection() after calling focus().
 			*/
 			this._updateDOMSelection();
 		},
 		/**
 		 * Check if the text view has focus.
@@ -4022,17 +5161,17 @@ define("orion/textview/textView", ['orio
 		 *
 		 * @see #getLocationAtOffset
 		 */
 		getOffsetAtLocation: function(x, y) {
 			if (!this._clientDiv) { return 0; }
 			var scroll = this._getScroll();
 			var viewRect = this._viewDiv.getBoundingClientRect();
 			var viewPad = this._getViewPadding();
-			var lineIndex = this._getYToLine(y - scroll.y);
+			var lineIndex = this._getYToLine(y - scroll.y + viewRect.top + viewPad.top);
 			x += -scroll.x + viewRect.left + viewPad.left;
 			var offset = this._getXToOffset(lineIndex, x);
 			return offset;
 		},
 		/**
 		 * Get the view rulers.
 		 *
 		 * @returns the view rulers
@@ -4138,24 +5277,21 @@ define("orion/textview/textView", ['orio
 					}
 					if (a.defaultHandler) { return a.defaultHandler(); }
 					return false;
 				}
 			}
 			return false;
 		},
 		/**
-		* Returns if the view is loaded.
-		* <p>
-		* @returns {Boolean} <code>true</code> if the view is loaded.
-		*
-		* @see #onLoad
+		* Returns if the view is destroyed.
+		* @returns {Boolean} <code>true</code> if the view is destroyed.
 		*/
-		isLoaded: function () {
-			return !!this._clientDiv;
+		isDestroyed: function () {
+			return !this._clientDiv;
 		},
 		/** 
 		 * @class This is the event sent when the user right clicks or otherwise invokes the context menu of the view. 
 		 * <p> 
 		 * <b>See:</b><br/> 
 		 * {@link orion.textview.TextView}<br/> 
 		 * {@link orion.textview.TextView#event:onContextMenu} 
 		 * </p> 
@@ -4265,34 +5401,16 @@ define("orion/textview/textView", ['orio
 		 *
 		 * @event
 		 * @param {orion.textview.LineStyleEvent} lineStyleEvent the event
 		 */
 		onLineStyle: function(lineStyleEvent) {
 			return this.dispatchEvent(lineStyleEvent);
 		},
 		/**
-		 * @class This is the event sent when the text view has loaded its contents.
-		 * <p>
-		 * <b>See:</b><br/>
-		 * {@link orion.textview.TextView}<br/>
-		 * {@link orion.textview.TextView#event:onLoad}
-		 * </p>		 
-		 * @name orion.textview.LoadEvent
-		 */
-		/**
-		 * This event is sent when the text view has loaded its contents.
-		 *
-		 * @event
-		 * @param {orion.textview.LoadEvent} loadEvent the event
-		 */
-		onLoad: function(loadEvent) {
-			return this.dispatchEvent(loadEvent);
-		},
-		/**
 		 * @class This is the event sent when the text in the model has changed.
 		 * <p>
 		 * <b>See:</b><br/>
 		 * {@link orion.textview.TextView}<br/>
 		 * {@link orion.textview.TextView#event:onModelChanged}<br/>
 		 * {@link orion.textview.TextModel#onChanged}
 		 * </p>
 		 * @name orion.textview.ModelChangedEvent
@@ -4443,34 +5561,16 @@ define("orion/textview/textView", ['orio
 		 *
 		 * @event
 		 * @param {orion.textview.VerifyEvent} verifyEvent the event
 		 */
 		onVerify: function(verifyEvent) {
 			return this.dispatchEvent(verifyEvent);
 		},
 		/**
-		 * @class This is the event sent when the text view has unloaded its contents.
-		 * <p>
-		 * <b>See:</b><br/>
-		 * {@link orion.textview.TextView}<br/>
-		 * {@link orion.textview.TextView#event:onLoad}
-		 * </p>		 
-		 * @name orion.textview.UnloadEvent
-		 */
-		/**
-		 * This event is sent when the text view has unloaded its contents.
-		 *
-		 * @event
-		 * @param {orion.textview.UnloadEvent} unloadEvent the event
-		 */
-		onUnload: function(unloadEvent) {
-			return this.dispatchEvent(unloadEvent);
-		},
-		/**
 		 * @class This is the event sent when the text view is focused.
 		 * <p>
 		 * <b>See:</b><br/>
 		 * {@link orion.textview.TextView}<br/>
 		 * {@link orion.textview.TextView#event:onFocus}<br/>
 		 * </p>
 		 * @name orion.textview.FocusEvent
 		 */
@@ -4604,16 +5704,20 @@ define("orion/textview/textView", ['orio
 					rulers.splice(i, 1);
 					ruler.setView(null);
 					this._destroyRuler(ruler);
 					this._updatePage();
 					break;
 				}
 			}
 		},
+		resize: function() {
+			if (!this._clientDiv) { return; }
+			this._handleResize(null);
+		},
 		/**
 		 * Associates an application defined handler to an action name.
 		 * <p>
 		 * If the action name is a predefined action, the given handler executes before
 		 * the default action handler.  If the given handler returns <code>true</code>, the
 		 * default action handler is not called.
 		 * </p>
 		 *
@@ -4786,52 +5890,28 @@ define("orion/textview/textView", ['orio
 		 * Sets the view options for the view.
 		 *
 		 * @param {orion.textview.TextViewOptions} options the view options.
 		 * 
 		 * @see #getOptions
 		 */
 		setOptions: function (options) {
 			var defaultOptions = this._defaultOptions();
-			var recreate = false, option, created = this._clientDiv;
-			if (created) {
-				for (option in options) {
-					if (options.hasOwnProperty(option)) {
-						if (defaultOptions[option].recreate) {
-							recreate = true;
-							break;
-						}
-					}
-				}
-			}
-			var changed = false;
-			for (option in options) {
+			for (var option in options) {
 				if (options.hasOwnProperty(option)) {
 					var newValue = options[option], oldValue = this["_" + option];
 					if (this._compare(oldValue, newValue)) { continue; }
-					changed = true;
-					if (!recreate) {
-						var update = defaultOptions[option].update;
-						if (created && update) {
-							if (update.call(this, newValue)) {
-								recreate = true;
-							}
-							continue;
-						}
+					var update = defaultOptions[option] ? defaultOptions[option].update : null;
+					if (update) {
+						update.call(this, newValue);
+						continue;
 					}
 					this["_" + option] = this._clone(newValue);
 				}
 			}
-			if (changed) {
-				if (recreate) {
-					var oldParent = this._frame.parentNode;
-					oldParent.removeChild(this._frame);
-					this._parent.appendChild(this._frame);
-				}
-			}
 		},
 		/**
 		 * Sets the text view selection.
 		 * <p>
 		 * The selection is defined by a start and end character offset relative to the
 		 * document. The character at end offset is not included in the selection.
 		 * </p>
 		 * <p>
@@ -4955,54 +6035,63 @@ define("orion/textview/textView", ['orio
 		 * @returns true if the view was scrolled. 
 		 *
 		 * @see #getSelection
 		 * @see #setSelection
 		 */
 		showSelection: function() {
 			return this._showCaret(true);
 		},
+		update: function(styleChanged, sync) {
+			if (!this._clientDiv) { return; }
+			if (styleChanged) {
+				this._updateStyle();
+			}
+			if (sync === undefined || sync) {
+				this._updatePage();
+			} else {
+				this._queueUpdatePage();
+			}
+		},
 		
 		/**************************************** Event handlers *********************************/
-		_handleBodyMouseDown: function (e) {
+		_handleRootMouseDown: function (e) {
 			if (!e) { e = window.event; }
 			if (isFirefox && e.which === 1) {
 				this._clientDiv.contentEditable = false;
 				(this._overlayDiv || this._clientDiv).draggable = true;
 				this._ignoreBlur = true;
 			}
 			
-			/*
-			 * Prevent clicks outside of the view from taking focus 
-			 * away the view. Note that in Firefox and Opera clicking on the 
-			 * scrollbar also take focus from the view. Other browsers
-			 * do not have this problem and stopping the click over the 
-			 * scrollbar for them causes mouse capture problems.
-			 */
-			var topNode = isOpera || (isFirefox && !this._overlayDiv) ? this._clientDiv : this._overlayDiv || this._viewDiv;
-			
+			/* Prevent clicks outside of the client div from taking focus away. */
+			var topNode = this._overlayDiv || this._clientDiv;
+			/* Use view div on IE 8 otherwise it is not possible to scroll. */
+			if (isIE < 9) { topNode = this._viewDiv; }
 			var temp = e.target ? e.target : e.srcElement;
 			while (temp) {
 				if (topNode === temp) {
 					return;
 				}
 				temp = temp.parentNode;
 			}
 			if (e.preventDefault) { e.preventDefault(); }
 			if (e.stopPropagation){ e.stopPropagation(); }
 			if (!isW3CEvents) {
-				/* In IE 8 is not possible to prevent the default handler from running
-				*  during mouse down event using usual API. The workaround is to use
-				*  setCapture/releaseCapture. 
+				/*
+				* In IE 8 is not possible to prevent the default handler from running
+				* during mouse down event using usual API. The workaround is to give
+				* focus back to the client div.
 				*/ 
-				topNode.setCapture();
-				setTimeout(function() { topNode.releaseCapture(); }, 0);
-			}
-		},
-		_handleBodyMouseUp: function (e) {
+				var self = this;
+				setTimeout(function() {
+					self._clientDiv.focus();
+				}, 0);
+			}
+		},
+		_handleRootMouseUp: function (e) {
 			if (!e) { e = window.event; }
 			if (isFirefox && e.which === 1) {
 				this._clientDiv.contentEditable = true;
 				(this._overlayDiv || this._clientDiv).draggable = false;
 				
 				/*
 				* Bug in Firefox.  For some reason, Firefox stops showing the caret
 				* in some cases. For example when the user cancels a drag operation 
@@ -5020,45 +6109,45 @@ define("orion/textview/textView", ['orio
 			this._hasFocus = false;
 			/*
 			* Bug in IE 8 and earlier. For some reason when text is deselected
 			* the overflow selection at the end of some lines does not get redrawn.
 			* The fix is to create a DOM element in the body to force a redraw.
 			*/
 			if (isIE < 9) {
 				if (!this._getSelection().isEmpty()) {
-					var document = this._frameDocument;
 					var child = document.createElement("DIV");
-					var body = document.body;
-					body.appendChild(child);
-					body.removeChild(child);
+					var rootDiv = this._rootDiv;
+					rootDiv.appendChild(child);
+					rootDiv.removeChild(child);
 				}
 			}
 			if (isFirefox || isIE) {
 				if (this._selDiv1) {
-					var color = isIE ? "transparent" : "#AFAFAF";
+					var color = "transparent";
 					this._selDiv1.style.background = color;
 					this._selDiv2.style.background = color;
 					this._selDiv3.style.background = color;
+					if (window.getSelection) {
+						var sel = window.getSelection();
+						if (sel.rangeCount > 0) { sel.removeAllRanges(); }
+					}
 				}
 			}
 			if (!this._ignoreFocus) {
 				this.onBlur({type: "Blur"});
 			}
 		},
 		_handleContextMenu: function (e) {
 			if (!e) { e = window.event; }
-			if (isFirefox && this._lastMouseButton === 3) {
+			if (isIE && this._lastMouseButton === 3) {
 				// We need to update the DOM selection, because on
 				// right-click the caret moves to the mouse location.
-				// See bug 366312.
-				var timeDiff = e.timeStamp - this._lastMouseTime;
-				if (timeDiff <= this._clickTime) {
-					this._updateDOMSelection();
-				}
+				// See bug 366312 and 376508.
+				this._updateDOMSelection();
 			}
 			if (this.isListening("ContextMenu")) {
 				var evt = this._createMouseEvent("ContextMenu", e);
 				evt.screenX = e.screenX;
 				evt.screenY = e.screenY;
 				this.onContextMenu(evt);
 			}
 			if (e.preventDefault) { e.preventDefault(); }
@@ -5074,35 +6163,16 @@ define("orion/textview/textView", ['orio
 		},
 		_handleCut: function (e) {
 			if (!e) { e = window.event; }
 			if (this._doCut(e)) {
 				if (e.preventDefault) { e.preventDefault(); }
 				return false;
 			}
 		},
-		_handleDOMAttrModified: function (e) {
-			if (!e) { e = window.event; }
-			var ancestor = false;
-			var parent = this._parent;
-			while (parent) {
-				if (parent === e.target) {
-					ancestor = true;
-					break;
-				}
-				parent = parent.parentNode;
-			}
-			if (!ancestor) { return; }
-			var state = this._getVisible();
-			if (state === "visible") {
-				this._createView();
-			} else if (state === "hidden") {
-				this._destroyView();
-			}
-		},
 		_handleDataModified: function(e) {
 			this._startIME();
 		},
 		_handleDblclick: function (e) {
 			if (!e) { e = window.event; }
 			var time = e.timeStamp ? e.timeStamp : new Date().getTime();
 			this._lastMouseTime = time;
 			if (this._clickCount !== 2) {
@@ -5208,53 +6278,39 @@ define("orion/textview/textView", ['orio
 			* the DOM. Note that preventing the event on some user agents (i.e. IE)
 			* indicates that the operation is cancelled. This causes the dropEffect to 
 			* be set to none  in the dragend event causing the implementor to not execute
 			* the code responsible by the move effect.
 			*/
 			if (e.preventDefault) { e.preventDefault(); }
 			return false;
 		},
-		_handleDocFocus: function (e) {
-			if (!e) { e = window.event; }
-			this._clientDiv.focus();
-		},
 		_handleFocus: function (e) {
 			if (!e) { e = window.event; }
 			this._hasFocus = true;
-			/*
-			* Feature in IE.  The selection is not restored when the
-			* view gets focus and the caret is always placed at the
-			* beginning of the document.  The fix is to update the DOM
-			* selection during the focus event.
-			*/
-			if (isIE) {
+			if (isPad && this._lastTouchOffset !== undefined) {
+				this.setCaretOffset(this._lastTouchOffset, true);
+				this._lastTouchOffset = undefined;
+			} else {
 				this._updateDOMSelection();
 			}
 			if (isFirefox || isIE) {
 				if (this._selDiv1) {
 					var color = this._hightlightRGB;
 					this._selDiv1.style.background = color;
 					this._selDiv2.style.background = color;
 					this._selDiv3.style.background = color;
 				}
 			}
 			if (!this._ignoreFocus) {
 				this.onFocus({type: "Focus"});
 			}
 		},
 		_handleKeyDown: function (e) {
 			if (!e) { e = window.event; }
-			if (isPad) {
-				if (e.keyCode === 8) {
-					this._doBackspace({});
-					e.preventDefault();
-				}
-				return;
-			}
 			switch (e.keyCode) {
 				case 16: /* Shift */
 				case 17: /* Control */
 				case 18: /* Alt */
 				case 91: /* Command */
 					break;
 				default:
 					this._setLinksVisible(false);
@@ -5297,16 +6353,17 @@ define("orion/textview/textView", ['orio
 			if (((isMac || isLinux) && isFirefox < 4) || isOpera) {
 				this._keyDownEvent = e;
 				return true;
 			}
 			
 			if (this._doAction(e)) {
 				if (e.preventDefault) {
 					e.preventDefault(); 
+					e.stopPropagation(); 
 				} else {
 					e.cancelBubble = true;
 					e.returnValue = false;
 					e.keyCode = 0;
 				}
 				return false;
 			}
 		},
@@ -5380,25 +6437,19 @@ define("orion/textview/textView", ['orio
 		_handleLinkClick: function (e) {
 			if (!e) { e = window.event; }
 			var ctrlKey = isMac ? e.metaKey : e.ctrlKey;
 			if (!ctrlKey) {
 				if (e.preventDefault) { e.preventDefault(); }
 				return false;
 			}
 		},
-		_handleLoad: function (e) {
-			var state = this._getVisible();
-			if (state === "visible" || (state === "hidden" && isWebkit)) {
-				this._createView();
-			}
-		},
 		_handleMouse: function (e) {
 			var result = true;
-			var target = this._frameWindow;
+			var target = window;
 			if (isIE || (isFirefox && !this._overlayDiv)) { target = this._clientDiv; }
 			if (this._overlayDiv) {
 				if (this._hasFocus) {
 					this._ignoreFocus = true;
 				}
 				var self = this;
 				setTimeout(function () {
 					self.focus();
@@ -5466,47 +6517,48 @@ define("orion/textview/textView", ['orio
 
 			if (button === 1) {
 				this._isMouseDown = true;
 				if (sameButton && timeDiff <= this._clickTime && deltaX <= this._clickDist && deltaY <= this._clickDist) {
 					this._clickCount++;
 				} else {
 					this._clickCount = 1;
 				}
-				if (this._handleMouse(e) && (isOpera || isChrome || (isFirefox && !this._overlayDiv))) {
+				if (this._handleMouse(e) && (isIE >= 9 || isOpera || isChrome || (isFirefox && !this._overlayDiv))) {
 					if (!this._hasFocus) {
 						this.focus();
 					}
 					e.preventDefault();
 				}
 			}
+			if (isFirefox && this._lastMouseButton === 3) {
+				// We need to update the DOM selection, because on
+				// right-click the caret moves to the mouse location.
+				// See bug 366312 and 376508.
+				this._updateDOMSelection();
+			}
 		},
 		_handleMouseOver: function (e) {
 			if (!e) { e = window.event; }
 			if (this.isListening("MouseOver")) {
 				this.onMouseOver(this._createMouseEvent("MouseOver", e));
 			}
 		},
 		_handleMouseOut: function (e) {
 			if (!e) { e = window.event; }
 			if (this.isListening("MouseOut")) {
 				this.onMouseOut(this._createMouseEvent("MouseOut", e));
 			}
 		},
 		_handleMouseMove: function (e) {
 			if (!e) { e = window.event; }
+			var inClient = this._isClientDiv(e);
 			if (this.isListening("MouseMove")) {
-				var topNode = this._overlayDiv || this._clientDiv;
-				var temp = e.target ? e.target : e.srcElement;
-				while (temp) {
-					if (topNode === temp) {
-						this.onMouseMove(this._createMouseEvent("MouseMove", e));
-						break;
-					}
-					temp = temp.parentNode;
+				if (inClient){
+					this.onMouseMove(this._createMouseEvent("MouseMove", e));
 				}
 			}
 			if (this._dropTarget) {
 				return;
 			}
 			/*
 			* Bug in IE9. IE sends one mouse event when the user changes the text by
 			* pasting or undo.  These operations usually happen with the Ctrl key
@@ -5536,34 +6588,27 @@ define("orion/textview/textView", ['orio
 			* a mouse down event from mouse move when the button is still down and isMouseDown
 			* flag is not set.
 			*/
 			if (!isW3CEvents) {
 				if (e.button === 0) {
 					this._setGrab(null);
 					return true;
 				}
-				if (!this._isMouseDown && e.button === 1 && (this._clickCount & 1) !== 0) {
+				if (!this._isMouseDown && e.button === 1 && (this._clickCount & 1) !== 0 && inClient) {
 					this._clickCount = 2;
 					return this._handleMouse(e, this._clickCount);
 				}
 			}
 			if (!this._isMouseDown || this._dragOffset !== -1) {
 				return;
 			}
 			
 			var x = e.clientX;
 			var y = e.clientY;
-			if (isChrome) {
-				if (e.currentTarget !== this._frameWindow) {
-					var rect = this._frame.getBoundingClientRect();
-					x -= rect.left;
-					y -= rect.top;
-				}
-			}
 			var viewPad = this._getViewPadding();
 			var viewRect = this._viewDiv.getBoundingClientRect();
 			var width = this._getClientWidth (), height = this._getClientHeight();
 			var leftEdge = viewRect.left + viewPad.left;
 			var topEdge = viewRect.top + viewPad.top;
 			var rightEdge = viewRect.left + viewPad.left + width;
 			var bottomEdge = viewRect.top + viewPad.top + height;
 			var model = this._model;
@@ -5574,52 +6619,54 @@ define("orion/textview/textView", ['orio
 				this._doAutoScroll("down", x, y - bottomEdge);
 			} else if (x < leftEdge) {
 				this._doAutoScroll("left", x - leftEdge, y);
 			} else if (x > rightEdge) {
 				this._doAutoScroll("right", x - rightEdge, y);
 			} else {
 				this._endAutoScroll();
 				this._setSelectionTo(x, y, true);
-				/*
-				* Feature in IE. IE does redraw the selection background right
-				* away after the selection changes because of mouse move events.
-				* The fix is to call getBoundingClientRect() on the
-				* body element to force the selection to be redraw. Some how
-				* calling this method forces a redraw.
-				*/
-				if (isIE) {
-					var body = this._frameDocument.body;
-					body.getBoundingClientRect();
-				}
-			}
+			}
+		},
+		_isClientDiv: function(e) {
+			var topNode = this._overlayDiv || this._clientDiv;
+			var temp = e.target ? e.target : e.srcElement;
+			while (temp) {
+				if (topNode === temp) {
+					return true;
+				}
+				temp = temp.parentNode;
+			}
+			return false;
 		},
 		_createMouseEvent: function(type, e) {
 			var scroll = this._getScroll();
 			var viewRect = this._viewDiv.getBoundingClientRect();
 			var viewPad = this._getViewPadding();
 			var x = e.clientX + scroll.x - viewRect.left - viewPad.left;
-			var y = e.clientY + scroll.y - viewRect.top;
+			var y = e.clientY + scroll.y - viewRect.top - viewPad.top;
 			return {
 				type: type,
 				event: e,
 				x: x,
 				y: y
 			};
 		},
 		_handleMouseUp: function (e) {
 			if (!e) { e = window.event; }
+			var left = e.which ? e.button === 0 : e.button === 1;
 			if (this.isListening("MouseUp")) {
-				this.onMouseUp(this._createMouseEvent("MouseUp", e));
+				if (this._isClientDiv(e) || (left && this._isMouseDown)) {
+					this.onMouseUp(this._createMouseEvent("MouseUp", e));
+				}
 			}
 			if (this._linksVisible) {
 				return;
 			}
-			var left = e.which ? e.button === 0 : e.button === 1;
-			if (left) {
+			if (left && this._isMouseDown) {
 				if (this._dragOffset !== -1) {
 					var selection = this._getSelection();
 					selection.extend(this._dragOffset);
 					selection.collapse();
 					this._setSelection(selection, true, true);
 					this._dragOffset = -1;
 				}
 				this._isMouseDown = false;
@@ -5652,17 +6699,19 @@ define("orion/textview/textView", ['orio
 				}
 			}
 		},
 		_handleMouseWheel: function (e) {
 			if (!e) { e = window.event; }
 			var lineHeight = this._getLineHeight();
 			var pixelX = 0, pixelY = 0;
 			// Note: On the Mac the correct behaviour is to scroll by pixel.
-			if (isFirefox) {
+			if (isIE || isOpera) {
+				pixelY = (-e.wheelDelta / 40) * lineHeight;
+			} else if (isFirefox) {
 				var pixel;
 				if (isMac) {
 					pixel = e.detail * 3;
 				} else {
 					var limit = 256;
 					pixel = Math.max(-limit, Math.min(limit, e.detail)) * lineHeight;
 				}
 				if (e.axis === e.HORIZONTAL_AXIS) {
@@ -5741,22 +6790,21 @@ define("orion/textview/textView", ['orio
 					}, 0);
 				}
 				if (e.preventDefault) { e.preventDefault(); }
 				return false;
 			}
 		},
 		_handleResize: function (e) {
 			if (!e) { e = window.event; }
-			var element = this._frameDocument.documentElement;
-			var newWidth = element.clientWidth;
-			var newHeight = element.clientHeight;
-			if (this._frameWidth !== newWidth || this._frameHeight !== newHeight) {
-				this._frameWidth = newWidth;
-				this._frameHeight = newHeight;
+			var newWidth = this._parent.clientWidth;
+			var newHeight = this._parent.clientHeight;
+			if (this._parentWidth !== newWidth || this._parentHeight !== newHeight) {
+				this._parentWidth = newWidth;
+				this._parentHeight = newHeight;
 				/*
 				* Feature in IE7. For some reason, sometimes Internet Explorer 7 
 				* returns incorrect values for element.getBoundingClientRect() when 
 				* inside a resize handler. The fix is to queue the work.
 				*/
 				if (isIE < 9) {
 					this._queueUpdatePage();
 				} else {
@@ -5772,22 +6820,22 @@ define("orion/textview/textView", ['orio
 			while (element && !element._ruler) {
 				if (lineIndex === undefined && element.lineIndex !== undefined) {
 					lineIndex = element.lineIndex;
 				}
 				element = element.parentNode;
 			}
 			var ruler = element ? element._ruler : null;
 			if (lineIndex === undefined && ruler && ruler.getOverview() === "document") {
-				var buttonHeight = isPad ? 0 : 17;
 				var clientHeight = this._getClientHeight ();
 				var lineCount = this._model.getLineCount ();
 				var viewPad = this._getViewPadding();
-				var trackHeight = clientHeight + viewPad.top + viewPad.bottom - 2 * buttonHeight;
-				lineIndex = Math.floor((e.clientY - buttonHeight) * lineCount / trackHeight);
+				var viewRect = this._viewDiv.getBoundingClientRect();
+				var trackHeight = clientHeight + viewPad.top + viewPad.bottom - 2 * scrollButtonHeight;
+				lineIndex = Math.floor(((e.clientY - viewRect.top) - scrollButtonHeight) * lineCount / trackHeight);
 				if (!(0 <= lineIndex && lineIndex < lineCount)) {
 					lineIndex = undefined;
 				}
 			}
 			if (ruler) {
 				switch (e.type) {
 					case "click":
 						if (ruler.onClick) { ruler.onClick(lineIndex, e); }
@@ -5826,215 +6874,138 @@ define("orion/textview/textView", ['orio
 		},
 		_handleSelectStart: function (e) {
 			if (!e) { e = window.event; }
 			if (this._ignoreSelect) {
 				if (e && e.preventDefault) { e.preventDefault(); }
 				return false;
 			}
 		},
-		_handleUnload: function (e) {
-			if (!e) { e = window.event; }
-			this._destroyView();
-		},
-		_handleInput: function (e) {
-			var textArea = this._textArea;
-			this._doContent(textArea.value);
-			textArea.selectionStart = textArea.selectionEnd = 0;
-			textArea.value = "";
-			e.preventDefault();
-		},
-		_handleTextInput: function (e) {
-			this._doContent(e.data);
-			e.preventDefault();
-		},
-		_touchConvert: function (touch) {
-			var rect = this._frame.getBoundingClientRect();
-			var body = this._parentDocument.body;
-			return {left: touch.clientX - rect.left - body.scrollLeft, top: touch.clientY - rect.top - body.scrollTop};
-		},
-		_handleTextAreaClick: function (e) {
-			var pt = this._touchConvert(e);	
-			this._clickCount = 1;
-			this._ignoreDOMSelection = false;
-			this._setSelectionTo(pt.left, pt.top, false);
-			var textArea = this._textArea;
-			textArea.focus();
+		_getModelOffset: function(node, offset) {
+			if (!node) { return; }
+			var lineNode;
+			if (node.tagName === "DIV") {
+				lineNode = node;
+			} else {
+				lineNode = node.parentNode.parentNode;
+			}
+			var lineOffset = 0;
+			var lineIndex = lineNode.lineIndex;
+			if (node.tagName !== "DIV") {
+				var child = lineNode.firstChild;
+				while (child) {
+					var textNode = child.firstChild;
+					if (textNode === node) {
+						if (child.ignoreChars) { lineOffset -= child.ignoreChars; }
+						lineOffset += offset;
+						break;
+					}
+					if (child.ignoreChars) { lineOffset -= child.ignoreChars; }
+					lineOffset += textNode.data.length;
+					child = child.nextSibling;
+				}
+			}
+			return Math.max(0, lineOffset) + this._model.getLineStart(lineIndex);
+		},
+		_handleSelectionChange: function (e) {
+			var selection = window.getSelection();
+			var start = this._getModelOffset(selection.anchorNode, selection.anchorOffset);
+			var end = this._getModelOffset(selection.focusNode, selection.focusOffset);
+			if (start === undefined || end === undefined) {
+			    return;
+			}
+			this._setSelection(new Selection(start, end), false, false, false);
 		},
 		_handleTouchStart: function (e) {
-			var touches = e.touches, touch, pt, sel;
-			this._touchMoved = false;
-			this._touchStartScroll = undefined;
-			if (touches.length === 1) {
-				touch = touches[0];
-				var pageX = touch.pageX;
-				var pageY = touch.pageY;
-				this._touchStartX = pageX;
-				this._touchStartY = pageY;
-				this._touchStartTime = e.timeStamp;
-				this._touchStartScroll = this._getScroll();
-				sel = this._getSelection();
-				pt = this._touchConvert(touches[0]);
-				this._touchGesture = "none";
-				if (!sel.isEmpty()) {
-					if (this._hitOffset(sel.end, pt.left, pt.top)) {
-						this._touchGesture = "extendEnd";
-					} else if (this._hitOffset(sel.start, pt.left, pt.top)) {
-						this._touchGesture = "extendStart";
-					}
-				}
-				if (this._touchGesture === "none") {
-					var textArea = this._textArea;
-					textArea.value = "";
-					textArea.style.left = "-1000px";
-					textArea.style.top = "-1000px";
-					textArea.style.width = "3000px";
-					textArea.style.height = "3000px";
-				}
-			} else if (touches.length === 2) {
-				this._touchGesture = "select";
-				if (this._touchTimeout) {
-					clearTimeout(this._touchTimeout);
-					this._touchTimeout = null;
-				}
-				pt = this._touchConvert(touches[0]);
-				var offset1 = this._getXToOffset(this._getYToLine(pt.top), pt.left);
-				pt = this._touchConvert(touches[1]);
-				var offset2 = this._getXToOffset(this._getYToLine(pt.top), pt.left);
-				sel = this._getSelection();
-				sel.setCaret(offset1);
-				sel.extend(offset2);
-				this._setSelection(sel, true, true);
-			}
-			//Cannot prevent to show magnifier
-//			e.preventDefault();
-		},
-		_handleTouchMove: function (e) {
-			this._touchMoved = true;
-			var touches = e.touches, pt, sel;
+			if (this._touchScrollTimer) {
+				this._vScrollDiv.style.display = "none";
+				this._hScrollDiv.style.display = "none";
+				clearInterval(this._touchScrollTimer);
+				this._touchScrollTimer = null;
+			}
+			var touches = e.touches;
 			if (touches.length === 1) {
 				var touch = touches[0];
-				var pageX = touch.pageX;
-				var pageY = touch.pageY;
-				var deltaX = this._touchStartX - pageX;
-				var deltaY = this._touchStartY - pageY;
-				pt = this._touchConvert(touch);
-				sel = this._getSelection();
-				if (this._touchGesture === "none") {
-					if ((e.timeStamp - this._touchStartTime) < 200 && (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)) {
-						this._touchGesture = "scroll";
-					} else {
-						this._touchGesture = "caret";
-					}
-				}
-				if (this._touchGesture === "select") {
-					if (this._hitOffset(sel.end, pt.left, pt.top)) {
-						this._touchGesture = "extendEnd";
-					} else if (this._hitOffset(sel.start, pt.left, pt.top)) {
-						this._touchGesture = "extendStart";
-					} else {
-						this._touchGesture = "caret";
-					}
-				}
-				switch (this._touchGesture) {
-					case "scroll":
-						this._touchStartX = pageX;
-						this._touchStartY = pageY;
-						this._scrollView(deltaX, deltaY);
-						break;
-					case "extendStart":
-					case "extendEnd":
-						this._clickCount = 1;
-						var lineIndex = this._getYToLine(pt.top);
-						var offset = this._getXToOffset(lineIndex, pt.left);
-						sel.setCaret(this._touchGesture === "extendStart" ? sel.end : sel.start);
-						sel.extend(offset);
-						if (offset >= sel.end && this._touchGesture === "extendStart") {
-							this._touchGesture = "extendEnd";
+				this._touchStartX = touch.clientX;
+				this._touchStartY = touch.clientY;
+				this._lastTouchOffset = this._getXToOffset(this._getYToLine(touch.clientY), touch.clientX);
+				this._touchStartTime = e.timeStamp;
+				this._touching = true;
+			}
+		},
+		_handleTouchMove: function (e) {
+			var touches = e.touches;
+			if (touches.length === 1) {
+				var touch = touches[0];
+				this._touchCurrentX = touch.clientX;
+				this._touchCurrentY = touch.clientY;
+				var interval = 10;
+				if (!this._touchScrollTimer && (e.timeStamp - this._touchStartTime) < (interval*20)) {
+					this._vScrollDiv.style.display = "block";
+					this._hScrollDiv.style.display = "block";
+					var self = this;
+					this._touchScrollTimer = setInterval(function() {
+						var deltaX = 0, deltaY = 0;
+						if (self._touching) {
+							deltaX = self._touchStartX - self._touchCurrentX;
+							deltaY = self._touchStartY - self._touchCurrentY;
+							self._touchSpeedX = deltaX / interval;
+							self._touchSpeedY = deltaY / interval;
+							self._touchStartX = self._touchCurrentX;
+							self._touchStartY = self._touchCurrentY;
+						} else {
+							if (Math.abs(self._touchSpeedX) < 0.1 && Math.abs(self._touchSpeedY) < 0.1) {
+								self._vScrollDiv.style.display = "none";
+								self._hScrollDiv.style.display = "none";
+								clearInterval(self._touchScrollTimer);
+								self._touchScrollTimer = null;
+								return;
+							} else {
+								deltaX = self._touchSpeedX * interval;
+								deltaY = self._touchSpeedY * interval;
+								self._touchSpeedX *= 0.95;
+								self._touchSpeedY *= 0.95;
+							}
 						}
-						if (offset <= sel.start && this._touchGesture === "extendEnd") {
-							this._touchGesture = "extendStart";
-						}
-						this._setSelection(sel, true, true);
-						break;
-					case "caret":
-						this._setSelectionTo(pt.left, pt.top, false);
-						break;
-				}
-			} else if (touches.length === 2) {
-				pt = this._touchConvert(touches[0]);
-				var offset1 = this._getXToOffset(this._getYToLine(pt.top), pt.left);
-				pt = this._touchConvert(touches[1]);
-				var offset2 = this._getXToOffset(this._getYToLine(pt.top), pt.left);
-				sel = this._getSelection();
-				sel.setCaret(offset1);
-				sel.extend(offset2);
-				this._setSelection(sel, true, true);
-			}
-			e.preventDefault();
+						self._scrollView(deltaX, deltaY);
+					}, interval);
+				}
+				if (this._touchScrollTimer) {
+					e.preventDefault();
+				}
+			}
 		},
 		_handleTouchEnd: function (e) {
-			var self = this;
-			if (!this._touchMoved) {
-				if (e.touches.length === 0 && e.changedTouches.length === 1) {
-					var touch = e.changedTouches[0];
-					var pt = this._touchConvert(touch);
-					var textArea = this._textArea;
-					textArea.value = "";
-					textArea.style.left = "-1000px";
-					textArea.style.top = "-1000px";
-					textArea.style.width = "3000px";
-					textArea.style.height = "3000px";
-					setTimeout(function() {
-						self._clickCount = 1;
-						self._ignoreDOMSelection = false;
-						self._setSelectionTo(pt.left, pt.top, false);
-					}, 300);
-				}
-			}
-			if (e.touches.length === 0) {
-				setTimeout(function() {
-					var selection = self._getSelection();
-					var text = self._model.getText(selection.start, selection.end);
-					var textArea = self._textArea;
-					textArea.value = text;
-					textArea.selectionStart = 0;
-					textArea.selectionEnd = text.length;
-					if (!selection.isEmpty()) {
-						var touchRect = self._touchDiv.getBoundingClientRect();
-						var bounds = self._getOffsetBounds(selection.start);
-						textArea.style.left = (touchRect.width / 2) + "px";
-						textArea.style.top = ((bounds.top > 40 ? bounds.top - 30 : bounds.top + 30)) + "px";
-					}
-				}, 0);
-			}
-//				e.preventDefault();
+			var touches = e.touches;
+			if (touches.length === 0) {
+				this._touching = false;
+			}
 		},
 
 		/************************************ Actions ******************************************/
 		_doAction: function (e) {
 			var keyBindings = this._keyBindings;
 			for (var i = 0; i < keyBindings.length; i++) {
 				var kb = keyBindings[i];
 				if (kb.keyBinding.match(e)) {
 					if (kb.name) {
 						var actions = this._actions;
 						for (var j = 0; j < actions.length; j++) {
 							var a = actions[j];
 							if (a.name === kb.name) {
 								if (a.userHandler) {
 									if (!a.userHandler()) {
 										if (a.defaultHandler) {
-											a.defaultHandler();
+											return typeof(a.defaultHandler()) === "boolean";
 										} else {
 											return false;
 										}
 									}
 								} else if (a.defaultHandler) {
-									a.defaultHandler();
+									return typeof(a.defaultHandler()) === "boolean";
 								}
 								break;
 							}
 						}
 					}
 					return true;
 				}
 			}
@@ -6179,47 +7150,57 @@ define("orion/textview/textView", ['orio
 			this._setSelection(selection, true);
 			return true;
 		},
 		_doLineDown: function (args) {
 			var model = this._model;
 			var selection = this._getSelection();
 			var caret = selection.getCaret();
 			var lineIndex = model.getLineAtOffset(caret);
+			var x = this._columnX;
+			var scrollX = this._getScroll().x;
+			if (x === -1 || args.wholeLine || (args.select && isIE)) {
+				var offset = args.wholeLine ? model.getLineEnd(lineIndex + 1) : caret;
+				x = this._getOffsetToX(offset) + scrollX;
+			}
 			if (lineIndex + 1 < model.getLineCount()) {
-				var scrollX = this._getScroll().x;
-				var x = this._columnX;
-				if (x === -1 || args.wholeLine || (args.select && isIE)) {
-					var offset = args.wholeLine ? model.getLineEnd(lineIndex + 1) : caret;
-					x = this._getOffsetToX(offset) + scrollX;
-				}
 				selection.extend(this._getXToOffset(lineIndex + 1, x - scrollX));
 				if (!args.select) { selection.collapse(); }
 				this._setSelection(selection, true, true);
-				this._columnX = x;
-			}
+			} else {
+				if (args.select) {
+					selection.extend(model.getCharCount());
+					this._setSelection(selection, true, true);
+				}
+			}
+			this._columnX = x;
 			return true;
 		},
 		_doLineUp: function (args) {
 			var model = this._model;
 			var selection = this._getSelection();
 			var caret = selection.getCaret();
 			var lineIndex = model.getLineAtOffset(caret);
+			var x = this._columnX;
+			var scrollX = this._getScroll().x;
+			if (x === -1 || args.wholeLine || (args.select && isIE)) {
+				var offset = args.wholeLine ? model.getLineStart(lineIndex - 1) : caret;
+				x = this._getOffsetToX(offset) + scrollX;
+			}
 			if (lineIndex > 0) {
-				var scrollX = this._getScroll().x;
-				var x = this._columnX;
-				if (x === -1 || args.wholeLine || (args.select && isIE)) {
-					var offset = args.wholeLine ? model.getLineStart(lineIndex - 1) : caret;
-					x = this._getOffsetToX(offset) + scrollX;
-				}
 				selection.extend(this._getXToOffset(lineIndex - 1, x - scrollX));
 				if (!args.select) { selection.collapse(); }
 				this._setSelection(selection, true, true);
-				this._columnX = x;
-			}
+			} else {
+				if (args.select) {
+					selection.extend(0);
+					this._setSelection(selection, true, true);
+				}
+			}
+			this._columnX = x;
 			return true;
 		},
 		_doPageDown: function (args) {
 			var model = this._model;
 			var selection = this._getSelection();
 			var caret = selection.getCaret();
 			var caretLine = model.getLineAtOffset(caret);
 			var lineCount = model.getLineCount();
@@ -6315,32 +7296,42 @@ define("orion/textview/textView", ['orio
 			var model = this._model;
 			var selection = this._getSelection();
 			selection.setCaret(0);
 			selection.extend(model.getCharCount());
 			this._setSelection(selection, false);
 			return true;
 		},
 		_doTab: function (args) {
+			if(!this._tabMode) { return; }
 			var text = "\t";
 			if (this._expandTab) {
 				var model = this._model;
 				var caret = this._getSelection().getCaret();
 				var lineIndex = model.getLineAtOffset(caret);
 				var lineStart = model.getLineStart(lineIndex);
 				var spaces = this._tabSize - ((caret - lineStart) % this._tabSize);
 				text = (new Array(spaces + 1)).join(" ");
 			}
 			this._doContent(text);
 			return true;
 		},
+		_doShiftTab: function (args) {
+			if(!this._tabMode) { return; }
+			return true;
+		},
+		_doTabMode: function (args) {
+			this._tabMode = !this._tabMode;
+			return true;
+		},
 		
 		/************************************ Internals ******************************************/
 		_applyStyle: function(style, node, reset) {
 			if (reset) {
+				node.className = "";
 				var attrs = node.attributes;
 				for (var i= attrs.length; i-->0;) {
 					if (attrs[i].specified) {
 						node.removeAttributeNode(attrs[i]); 
 					}
 				}
 			}
 			if (!style) {
@@ -6382,21 +7373,26 @@ define("orion/textview/textView", ['orio
 			selection.extend(this._getXToOffset(line, x));
 			this._setSelection(selection, true);
 		},
 		_autoScrollTimer: function () {
 			this._autoScroll();
 			var self = this;
 			this._autoScrollTimerID = setTimeout(function () {self._autoScrollTimer();}, this._AUTO_SCROLL_RATE);
 		},
-		_calculateLineHeight: function() {
+		_calculateMetrics: function() {
 			var parent = this._clientDiv;
-			var document = this._frameDocument;
 			var c = " ";
 			var line = document.createElement("DIV");
+			line.style.lineHeight = "normal";
+			var model = this._model;
+			var lineText = model.getLine(0);
+			var e = {type:"LineStyle", textView: this, 0: 0, lineText: lineText, lineStart: 0};
+			this.onLineStyle(e);
+			this._applyStyle(e.style, line);
 			line.style.position = "fixed";
 			line.style.left = "-1000px";
 			var span1 = document.createElement("SPAN");
 			span1.appendChild(document.createTextNode(c));
 			line.appendChild(span1);
 			var span2 = document.createElement("SPAN");
 			span2.style.fontStyle = "italic";
 			span2.appendChild(document.createTextNode(c));
@@ -6416,17 +7412,17 @@ define("orion/textview/textView", ['orio
 			var spanRect2 = span2.getBoundingClientRect();
 			var spanRect3 = span3.getBoundingClientRect();
 			var spanRect4 = span4.getBoundingClientRect();
 			var h1 = spanRect1.bottom - spanRect1.top;
 			var h2 = spanRect2.bottom - spanRect2.top;
 			var h3 = spanRect3.bottom - spanRect3.top;
 			var h4 = spanRect4.bottom - spanRect4.top;
 			var fontStyle = 0;
-			var lineHeight = lineRect.bottom - lineRect.top;
+			var lineHeight = Math.max(1, lineRect.bottom - lineRect.top);
 			if (h2 > h1) {
 				fontStyle = 1;
 			}
 			if (h3 > h2) {
 				fontStyle = 2;
 			}
 			if (h4 > h3) {
 				fontStyle = 3;
@@ -6436,22 +7432,21 @@ define("orion/textview/textView", ['orio
 				style = {style: {}};
 				if ((fontStyle & 1) !== 0) {
 					style.style.fontStyle = "italic";
 				}
 				if ((fontStyle & 2) !== 0) {
 					style.style.fontWeight = "bold";
 				}
 			}
-			this._largestFontStyle = style;
+			var trim = this._getLineTrim(line);
 			parent.removeChild(line);
-			return lineHeight;
+			return {lineHeight: lineHeight, largestFontStyle: style, lineTrim: trim, viewPadding: this._calculatePadding()};
 		},
 		_calculatePadding: function() {
-			var document = this._frameDocument;
 			var parent = this._clientDiv;
 			var pad = this._getPadding(this._viewDiv);
 			var div1 = document.createElement("DIV");
 			div1.style.position = "fixed";
 			div1.style.left = "-1000px";
 			div1.style.paddingLeft = pad.left + "px";
 			div1.style.paddingTop = pad.top + "px";
 			div1.style.paddingRight = pad.right + "px";
@@ -6651,19 +7646,21 @@ define("orion/textview/textView", ['orio
 			//Misc
 			bindings.push({name: "deletePrevious",		keyBinding: new KeyBinding(8), predefined: true});
 			bindings.push({name: "deletePrevious",		keyBinding: new KeyBinding(8, null, true), predefined: true});
 			bindings.push({name: "deleteNext",		keyBinding: new KeyBinding(46), predefined: true});
 			bindings.push({name: "deleteWordPrevious",	keyBinding: new KeyBinding(8, true), predefined: true});
 			bindings.push({name: "deleteWordPrevious",	keyBinding: new KeyBinding(8, true, true), predefined: true});
 			bindings.push({name: "deleteWordNext",		keyBinding: new KeyBinding(46, true), predefined: true});
 			bindings.push({name: "tab",			keyBinding: new KeyBinding(9), predefined: true});
+			bindings.push({name: "shiftTab",			keyBinding: new KeyBinding(9, null, true), predefined: true});
 			bindings.push({name: "enter",			keyBinding: new KeyBinding(13), predefined: true});
 			bindings.push({name: "enter",			keyBinding: new KeyBinding(13, null, true), predefined: true});
 			bindings.push({name: "selectAll",		keyBinding: new KeyBinding('a', true), predefined: true});
+			bindings.push({name: "toggleTabMode",	keyBinding: new KeyBinding('m', true), predefined: true});
 			if (isMac) {
 				bindings.push({name: "deleteNext",		keyBinding: new KeyBinding(46, null, true), predefined: true});
 				bindings.push({name: "deleteWordPrevious",	keyBinding: new KeyBinding(8, null, null, true), predefined: true});
 				bindings.push({name: "deleteWordNext",		keyBinding: new KeyBinding(46, null, null, true), predefined: true});
 			}
 				
 			/*
 			* Feature in IE/Chrome: prevent ctrl+'u', ctrl+'i', and ctrl+'b' from applying styles to the text.
@@ -6744,33 +7741,38 @@ define("orion/textview/textView", ['orio
 
 				{name: "deletePrevious",	defaultHandler: function() {return self._doBackspace({unit:"character"});}},
 				{name: "deleteNext",		defaultHandler: function() {return self._doDelete({unit:"character"});}},
 				{name: "deleteWordPrevious",	defaultHandler: function() {return self._doBackspace({unit:"word"});}},
 				{name: "deleteWordNext",	defaultHandler: function() {return self._doDelete({unit:"word"});}},
 				{name: "deleteLineStart",	defaultHandler: function() {return self._doBackspace({unit: "line"});}},
 				{name: "deleteLineEnd",	defaultHandler: function() {return self._doDelete({unit: "line"});}},
 				{name: "tab",			defaultHandler: function() {return self._doTab();}},
+				{name: "shiftTab",			defaultHandler: function() {return self._doShiftTab();}},
 				{name: "enter",			defaultHandler: function() {return self._doEnter();}},
 				{name: "enterNoCursor",	defaultHandler: function() {return self._doEnter({noCursor:true});}},
 				{name: "selectAll",		defaultHandler: function() {return self._doSelectAll();}},
 				{name: "copy",			defaultHandler: function() {return self._doCopy();}},
 				{name: "cut",			defaultHandler: function() {return self._doCut();}},
-				{name: "paste",			defaultHandler: function() {return self._doPaste();}}
+				{name: "paste",			defaultHandler: function() {return self._doPaste();}},
+				
+				{name: "toggleTabMode",			defaultHandler: function() {return self._doTabMode();}}
 			];
 		},
 		_createLine: function(parent, div, document, lineIndex, model) {
 			var lineText = model.getLine(lineIndex);
 			var lineStart = model.getLineStart(lineIndex);
 			var e = {type:"LineStyle", textView: this, lineIndex: lineIndex, lineText: lineText, lineStart: lineStart};
 			this.onLineStyle(e);
 			var lineDiv = div || document.createElement("DIV");
 			if (!div || !this._compare(div.viewStyle, e.style)) {
 				this._applyStyle(e.style, lineDiv, div);
+				if (div) { div._trim = null; }
 				lineDiv.viewStyle = e.style;
+				lineDiv.setAttribute("role", "presentation");
 			}
 			lineDiv.lineIndex = lineIndex;
 			var ranges = [];
 			var data = {tabOffset: 0, ranges: ranges};
 			this._createRanges(e.ranges, lineText, 0, lineText.length, lineStart, data);
 			
 			/*
 			* A trailing span with a whitespace is added for three different reasons:
@@ -6794,17 +7796,17 @@ define("orion/textview/textView", ['orio
 				* Feature in WekKit. Adding a regular white space to the line will
 				* cause the longest line in the view to wrap even though "pre" is set.
 				* The fix is to use the zero-width non-joiner character (\u200C) instead.
 				* Note: To not use \uFEFF because in old version of Chrome this character 
 				* shows a glyph;
 				*/
 				c = "\u200C";
 			}
-			ranges.push({text: c, style: this._largestFontStyle, ignoreChars: 1});
+			ranges.push({text: c, style: this._metrics.largestFontStyle, ignoreChars: 1});
 			
 			var range, span, style, oldSpan, oldStyle, text, oldText, end = 0, oldEnd = 0, next;
 			var changeCount, changeStart;
 			if (div) {
 				var modelChangedEvent = div.modelChangedEvent;
 				if (modelChangedEvent) {
 					if (modelChangedEvent.removedLineCount === 0 && modelChangedEvent.addedLineCount === 0) {
 						changeStart = modelChangedEvent.start - lineStart;
@@ -6941,422 +7943,214 @@ define("orion/textview/textView", ['orio
 				addHandler(child, "click", function(e) { return self._handleLinkClick(e); }, false);
 			}
 			child.viewStyle = style;
 			if (ignoreChars) {
 				child.ignoreChars = ignoreChars;
 			}
 			return child;
 		},
-		_createRuler: function(ruler) {
+		_createRuler: function(ruler, index) {
 			if (!this._clientDiv) { return; }
-			var document = this._frameDocument;
-			var body = document.body;
 			var side = ruler.getLocation();
 			var rulerParent = side === "left" ? this._leftDiv : this._rightDiv;
-			if (!rulerParent) {
-				rulerParent = document.createElement("DIV");
-				rulerParent.style.overflow = "hidden";
-				rulerParent.style.MozUserSelect = "none";
-				rulerParent.style.WebkitUserSelect = "none";
-				if (isIE) {
-					rulerParent.attachEvent("onselectstart", function() {return false;});
-				}
-				rulerParent.style.position = "absolute";
-				rulerParent.style.top = "0px";
-				rulerParent.style.cursor = "default";
-				body.appendChild(rulerParent);
-				if (side === "left") {
-					this._leftDiv = rulerParent;
-					rulerParent.className = "viewLeftRuler";
-				} else {
-					this._rightDiv = rulerParent;
-					rulerParent.className = "viewRightRuler";
-				}
-				var table = document.createElement("TABLE");
-				rulerParent.appendChild(table);
-				table.cellPadding = "0px";
-				table.cellSpacing = "0px";
-				table.border = "0px";
-				table.insertRow(0);
-				var self = this;
-				addHandler(rulerParent, "click", function(e) { self._handleRulerEvent(e); });
-				addHandler(rulerParent, "dblclick", function(e) { self._handleRulerEvent(e); });
-				addHandler(rulerParent, "mousemove", function(e) { self._handleRulerEvent(e); });
-				addHandler(rulerParent, "mouseover", function(e) { self._handleRulerEvent(e); });
-				addHandler(rulerParent, "mouseout", function(e) { self._handleRulerEvent(e); });
-			}
 			var div = document.createElement("DIV");
 			div._ruler = ruler;
 			div.rulerChanged = true;
 			div.style.position = "relative";
 			var row = rulerParent.firstChild.rows[0];
-			var index = row.cells.length;
+			var length = row.cells.length;
+			index = index === undefined || index < 0 || index > length ? length : index;
 			var cell = row.insertCell(index);
 			cell.vAlign = "top";
 			cell.appendChild(div);
 		},
-		_createFrame: function() {
-			if (this.frame) { return; }
+		_createView: function() {
+			if (this._clientDiv) { return; }
 			var parent = this._parent;
 			while (parent.hasChildNodes()) { parent.removeChild(parent.lastChild); }
-			var parentDocument = parent.ownerDocument;
-			this._parentDocument = parentDocument;
-			var frame = parentDocument.createElement("IFRAME");
-			this._frame = frame;
-			frame.frameBorder = "0px";//for IE, needs to be set before the frame is added to the parent
-			frame.style.border = "0px";
-			frame.style.width = "100%";
-			frame.style.height = "100%";
-			frame.scrolling = "no";
-			var self = this;
-			/*
-			* Note that it is not possible to create the contents of the frame if the
-			* parent is not connected to the document.  Only create it when the load
-			* event is trigged.
-			*/
-			this._loadHandler = function(e) {
-				self._handleLoad(e);
-			};
-			addHandler(frame, "load", this._loadHandler, !!isFirefox);
-			if (!isWebkit) {
-				/*
-				* Feature in IE and Firefox.  It is not possible to get the style of an
-				* element if it is not layed out because one of the ancestor has
-				* style.display = none.  This means that the view cannot be created in this
-				* situations, since no measuring can be performed.  The fix is to listen
-				* for DOMAttrModified and create or destroy the view when the style.display
-				* attribute changes.
-				*/
-				addHandler(parentDocument, "DOMAttrModified", this._attrModifiedHandler = function(e) {
-					self._handleDOMAttrModified(e);
-				});
-			}
-			parent.appendChild(frame);
-			/* create synchronously if possible */
-			if (this._sync) {
-				this._handleLoad();
-			}
-		},
-		_getFrameHTML: function() {
-			var html = [];
-			html.push("<!DOCTYPE html>");
-			html.push("<html>");
-			html.push("<head>");
-			if (isIE < 9) {
-				html.push("<meta http-equiv='X-UA-Compatible' content='IE=EmulateIE7'/>");
-			}
-			html.push("<style>");
-			html.push(".viewContainer {font-family: monospace; font-size: 10pt;}");
-			html.push(".view {padding: 1px 2px;}");
-			html.push(".viewContent {}");
-			html.push("</style>");
-			if (this._stylesheet) {
-				var stylesheet = typeof(this._stylesheet) === "string" ? [this._stylesheet] : this._stylesheet;
-				for (var i = 0; i < stylesheet.length; i++) {
-					var sheet = stylesheet[i];
-					var isLink = this._isLinkURL(sheet);
-					if (isLink && this._sync) {
-						try {
-							var objXml = new XMLHttpRequest();
-							if (objXml.overrideMimeType) {
-								objXml.overrideMimeType("text/css");
-							}
-							objXml.open("GET", sheet, false);
-							objXml.send(null);
-							sheet = objXml.responseText;
-							isLink = false;
-						} catch (e) {}
-					}
-					if (isLink) {
-						html.push("<link rel='stylesheet' type='text/css' ");
-						/*
-						* Bug in IE7. The window load event is not sent unless a load handler is added to the link node.
-						*/
-						if (isIE < 9) {
-							html.push("onload='window' ");
-						}
-						html.push("href='");
-						html.push(sheet);
-						html.push("'></link>");
-					} else {
-						html.push("<style>");
-						html.push(sheet);
-						html.push("</style>");
-					}
-				}
-			}
-			/*
-			* Feature in WebKit.  In WebKit, window load will not wait for the style sheets
-			* to be loaded unless there is script element after the style sheet link elements.
-			*/
-			html.push("<script>");
-			html.push("var waitForStyleSheets = true;");
-			html.push("</script>");
-			html.push("</head>");
-			html.push("<body spellcheck='false'></body>");
-			html.push("</html>");
-			return html.join("");
-		},
-		_createView: function() {
-			if (this._frameDocument) { return; }
-			var frameWindow = this._frameWindow = this._frame.contentWindow;
-			var frameDocument = this._frameDocument = frameWindow.document;
-			var self = this;
-			function write() {
-				frameDocument.open("text/html", "replace");
-				frameDocument.write(self._getFrameHTML());
-				frameDocument.close();
-				self._windowLoadHandler = function(e) {
-					/*
-					* Bug in Safari.  Safari sends the window load event before the
-					* style sheets are loaded. The fix is to defer creation of the
-					* contents until the document readyState changes to complete.
-					*/
-					if (self._isDocumentReady()) {
-						self._createContent();
-					}
-				};
-				addHandler(frameWindow, "load", self._windowLoadHandler);
-			}
-			write();
-			if (this._sync) {
-				this._createContent();
-			} else {
-				/*
-				* Bug in Webkit. Webkit does not send the load event for the iframe window when the main page
-				* loads as a result of backward or forward navigation.
-				* The fix is to use a timer to create the content only when the document is ready.
-				*/
-				this._createViewTimer = function() {
-					if (self._clientDiv) { return; }
-					if (self._isDocumentReady()) {
-						self._createContent();
-					} else {
-						setTimeout(self._createViewTimer, 10);
-					}
-				};
-				setTimeout(this._createViewTimer, 10);
-			}
-		},
-		_isDocumentReady: function() {
-			var frameDocument = this._frameDocument;
-			if (!frameDocument) { return false; }
-			if (frameDocument.readyState === "complete") {
-				return true;
-			} else if (frameDocument.readyState === "interactive" && isFirefox) {
-				/*
-				* Bug in Firefox. Firefox does not change the document ready state to complete 
-				* all the time. The fix is to wait for the ready state to be "interactive" and check that 
-				* all css rules are initialized.
-				*/
-				var styleSheets = frameDocument.styleSheets;
-				var styleSheetCount = 1;
-				if (this._stylesheet) {
-					styleSheetCount += typeof(this._stylesheet) === "string" ? 1 : this._stylesheet.length;
-				}
-				if (styleSheetCount === styleSheets.length) {
-					var index = 0;
-					while (index < styleSheets.length) {
-						var count = 0;
-						try {
-							count = styleSheets.item(index).cssRules.length;
-						} catch (ex) {
-							/*
-							* Feature in Firefox. To determine if a stylesheet is loaded the number of css rules is used, if the 
-							* stylesheet is not loaded this operation will throw an invalid access error. When a stylesheet from
-							* a different domain is loaded, accessing the css rules will result in a security exception. In this
-							* case count is set to 1 to indicate the stylesheet is loaded.
-							*/
-							if (ex.code !== DOMException.INVALID_ACCESS_ERR) {
-								count = 1;
-							}
-						}
-						if (count === 0) { break; }
-						index++;
-					}
-					return index === styleSheets.length;
-				}	
-			}
-			return false;
-		},
-		_createContent: function() {
-			if (this._clientDiv) { return; }
-			var parent = this._parent;
-			var parentDocument = this._parentDocument;
-			var frameDocument = this._frameDocument;
-			var body = frameDocument.body;
-			this._setThemeClass(this._themeClass, true);
-			body.style.margin = "0px";
-			body.style.borderWidth = "0px";
-			body.style.padding = "0px";
+
+			var rootDiv = document.createElement("DIV");
+			this._rootDiv = rootDiv;
+			rootDiv.tabIndex = -1;
+			rootDiv.style.position = "absolute";
+			rootDiv.style.overflow = "hidden";
+			rootDiv.setAttribute("role", "application");
+			parent.appendChild(rootDiv);
 			
-			var textArea;
-			if (isPad) {
-				var touchDiv = parentDocument.createElement("DIV");
-				this._touchDiv = touchDiv;
-				touchDiv.style.position = "absolute";
-				touchDiv.style.border = "0px";
-				touchDiv.style.padding = "0px";
-				touchDiv.style.margin = "0px";
-				touchDiv.style.zIndex = "2";
-				touchDiv.style.overflow = "hidden";
-				touchDiv.style.background="transparent";
-				touchDiv.style.WebkitUserSelect = "none";
-				parent.appendChild(touchDiv);
-
-				textArea = parentDocument.createElement("TEXTAREA");
-				this._textArea = textArea;
-				textArea.style.position = "absolute";
-				textArea.style.whiteSpace = "pre";
-				textArea.style.left = "-1000px";
-				textArea.tabIndex = 1;
-				textArea.autocapitalize = "off";
-				textArea.autocorrect = "off";
-				textArea.className = "viewContainer";
-				textArea.style.background = "transparent";
-				textArea.style.color = "transparent";
-				textArea.style.border = "0px";
-				textArea.style.padding = "0px";
-				textArea.style.margin = "0px";
-				textArea.style.borderRadius = "0px";
-				textArea.style.WebkitAppearance = "none";
-				textArea.style.WebkitTapHighlightColor = "transparent";
-				touchDiv.appendChild(textArea);
-			}
-			if (isFirefox) {
-				var clipboardDiv = frameDocument.createElement("DIV");
-				this._clipboardDiv = clipboardDiv;
-				clipboardDiv.style.position = "fixed";
-				clipboardDiv.style.whiteSpace = "pre";
-				clipboardDiv.style.left = "-1000px";
-				body.appendChild(clipboardDiv);
-			}
-
-			var viewDiv = frameDocument.createElement("DIV");
-			viewDiv.className = "view";
+			var leftDiv = document.createElement("DIV");
+			leftDiv.className = "textviewLeftRuler";
+			this._leftDiv = leftDiv;
+			leftDiv.tabIndex = -1;
+			leftDiv.style.overflow = "hidden";
+			leftDiv.style.MozUserSelect = "none";
+			leftDiv.style.WebkitUserSelect = "none";
+			leftDiv.style.position = "absolute";
+			leftDiv.style.cursor = "default";
+			leftDiv.setAttribute("aria-hidden", "true");
+			var table = document.createElement("TABLE");
+			leftDiv.appendChild(table);
+			table.cellPadding = "0px";
+			table.cellSpacing = "0px";
+			table.border = "0px";
+			table.insertRow(0);
+			rootDiv.appendChild(leftDiv);
+
+			var viewDiv = document.createElement("DIV");
+			viewDiv.className = "textview";
 			this._viewDiv = viewDiv;
-			viewDiv.id = "viewDiv";
 			viewDiv.tabIndex = -1;
 			viewDiv.style.overflow = "auto";
 			viewDiv.style.position = "absolute";
 			viewDiv.style.top = "0px";
 			viewDiv.style.borderWidth = "0px";
 			viewDiv.style.margin = "0px";
 			viewDiv.style.outline = "none";
-			body.appendChild(viewDiv);
+			rootDiv.appendChild(viewDiv);
+			
+			var rightDiv = document.createElement("DIV");
+			rightDiv.className = "textviewRightRuler";
+			this._rightDiv = rightDiv;
+			rightDiv.tabIndex = -1;
+			rightDiv.style.overflow = "hidden";
+			rightDiv.style.MozUserSelect = "none";
+			rightDiv.style.WebkitUserSelect = "none";
+			rightDiv.style.position = "absolute";
+			rightDiv.style.cursor = "default";
+			rightDiv.setAttribute("aria-hidden", "true");
+			table = document.createElement("TABLE");
+			rightDiv.appendChild(table);
+			table.cellPadding = "0px";
+			table.cellSpacing = "0px";
+			table.border = "0px";
+			table.insertRow(0);
+			rootDiv.appendChild(rightDiv);
 				
-			var scrollDiv = frameDocument.createElement("DIV");
+			var scrollDiv = document.createElement("DIV");
 			this._scrollDiv = scrollDiv;
-			scrollDiv.id = "scrollDiv";
 			scrollDiv.style.margin = "0px";
 			scrollDiv.style.borderWidth = "0px";
 			scrollDiv.style.padding = "0px";
 			viewDiv.appendChild(scrollDiv);
 			
 			if (isFirefox) {
-				var clipDiv = frameDocument.createElement("DIV");
+				var clipboardDiv = document.createElement("DIV");
+				this._clipboardDiv = clipboardDiv;
+				clipboardDiv.style.position = "fixed";
+				clipboardDiv.style.whiteSpace = "pre";
+				clipboardDiv.style.left = "-1000px";
+				rootDiv.appendChild(clipboardDiv);
+			
+				var clipDiv = document.createElement("DIV");
 				this._clipDiv = clipDiv;
-				clipDiv.id = "clipDiv";
-				clipDiv.style.position = "fixed";
+				clipDiv.style.position = "absolute";
 				clipDiv.style.overflow = "hidden";
 				clipDiv.style.margin = "0px";
 				clipDiv.style.borderWidth = "0px";
 				clipDiv.style.padding = "0px";
-				scrollDiv.appendChild(clipDiv);
+				rootDiv.appendChild(clipDiv);
 				
-				var clipScrollDiv = frameDocument.createElement("DIV");
+				var clipScrollDiv = document.createElement("DIV");
 				this._clipScrollDiv = clipScrollDiv;
-				clipScrollDiv.id = "clipScrollDiv";
 				clipScrollDiv.style.position = "absolute";
 				clipScrollDiv.style.height = "1px";
 				clipScrollDiv.style.top = "-1000px";
 				clipDiv.appendChild(clipScrollDiv);
 			}
 			
 			this._setFullSelection(this._fullSelection, true);
 
-			var clientDiv = frameDocument.createElement("DIV");
-			clientDiv.className = "viewContent";
+			var clientDiv = document.createElement("DIV");
+			clientDiv.className = "textviewContent";
 			this._clientDiv = clientDiv;
-			clientDiv.id = "clientDiv";
 			clientDiv.style.whiteSpace = "pre";
-			clientDiv.style.position = this._clipDiv ? "absolute" : "fixed";
+			clientDiv.style.position = "absolute";
 			clientDiv.style.borderWidth = "0px";
 			clientDiv.style.margin = "0px";
 			clientDiv.style.padding = "0px";
 			clientDiv.style.outline = "none";
 			clientDiv.style.zIndex = "1";
+			clientDiv.style.WebkitUserSelect = "text";
+			clientDiv.setAttribute("spellcheck", "false");
 			if (isPad) {
 				clientDiv.style.WebkitTapHighlightColor = "transparent";
 			}
-			(this._clipDiv || scrollDiv).appendChild(clientDiv);
+			(this._clipDiv || rootDiv).appendChild(clientDiv);
+			
+			if (isPad) {
+				var vScrollDiv = document.createElement("DIV");
+				this._vScrollDiv = vScrollDiv;
+				vScrollDiv.style.position = "absolute";
+				vScrollDiv.style.borderWidth = "1px";
+				vScrollDiv.style.borderColor = "white";
+				vScrollDiv.style.borderStyle = "solid";
+				vScrollDiv.style.borderRadius = "4px";
+				vScrollDiv.style.backgroundColor = "black";
+				vScrollDiv.style.opacity = "0.5";
+				vScrollDiv.style.margin = "0px";
+				vScrollDiv.style.padding = "0px";
+				vScrollDiv.style.outline = "none";
+				vScrollDiv.style.zIndex = "3";
+				vScrollDiv.style.width = "8px";
+				vScrollDiv.style.display = "none";
+				rootDiv.appendChild(vScrollDiv);
+				var hScrollDiv = document.createElement("DIV");
+				this._hScrollDiv = hScrollDiv;
+				hScrollDiv.style.position = "absolute";
+				hScrollDiv.style.borderWidth = "1px";
+				hScrollDiv.style.borderColor = "white";
+				hScrollDiv.style.borderStyle = "solid";
+				hScrollDiv.style.borderRadius = "4px";
+				hScrollDiv.style.backgroundColor = "black";
+				hScrollDiv.style.opacity = "0.5";
+				hScrollDiv.style.margin = "0px";
+				hScrollDiv.style.padding = "0px";
+				hScrollDiv.style.outline = "none";
+				hScrollDiv.style.zIndex = "3";
+				hScrollDiv.style.height = "8px";
+				hScrollDiv.style.display = "none";
+				rootDiv.appendChild(hScrollDiv);
+			}
 
 			if (isFirefox && !clientDiv.setCapture) {
-				var overlayDiv = frameDocument.createElement("DIV");
+				var overlayDiv = document.createElement("DIV");
 				this._overlayDiv = overlayDiv;
-				overlayDiv.id = "overlayDiv";
 				overlayDiv.style.position = clientDiv.style.position;
 				overlayDiv.style.borderWidth = clientDiv.style.borderWidth;
 				overlayDiv.style.margin = clientDiv.style.margin;
 				overlayDiv.style.padding = clientDiv.style.padding;
 				overlayDiv.style.cursor = "text";
 				overlayDiv.style.zIndex = "2";
-				(this._clipDiv || scrollDiv).appendChild(overlayDiv);
-			}
-			if (!isPad) {
-				clientDiv.contentEditable = "true";
-			}
-			this._lineHeight = this._calculateLineHeight();
-			this._viewPadding = this._calculatePadding();
-			if (isIE) {
-				body.style.lineHeight = this._lineHeight + "px";
-			}
+				(this._clipDiv || rootDiv).appendChild(overlayDiv);
+			}
+			clientDiv.contentEditable = "true";
+			clientDiv.setAttribute("role", "textbox");
+			clientDiv.setAttribute("aria-multiline", "true");
+			this._setReadOnly(this._readonly);
+			this._setThemeClass(this._themeClass, true);
 			this._setTabSize(this._tabSize, true);
 			this._hookEvents();
 			var rulers = this._rulers;
 			for (var i=0; i<rulers.length; i++) {
 				this._createRuler(rulers[i]);
 			}
 			this._updatePage();
-			var h = this._hScroll, v = this._vScroll;
-			this._vScroll = this._hScroll = 0;
-			if (h > 0 || v > 0) {
-				viewDiv.scrollLeft = h;
-				viewDiv.scrollTop = v;
-			}
-			this.onLoad({type: "Load"});
 		},
 		_defaultOptions: function() {
 			return {
-				parent: {value: undefined, recreate: true, update: null},
-				model: {value: undefined, recreate: false, update: this.setModel},
-				readonly: {value: false, recreate: false, update: null},
-				fullSelection: {value: true, recreate: false, update: this._setFullSelection},
-				tabSize: {value: 8, recreate: false, update: this._setTabSize},
-				expandTab: {value: false, recreate: false, update: null},
-				stylesheet: {value: [], recreate: false, update: this._setStyleSheet},
-				themeClass: {value: undefined, recreate: false, update: this._setThemeClass},
-				sync: {value: false, recreate: false, update: null}
+				parent: {value: undefined, update: null},
+				model: {value: undefined, update: this.setModel},
+				readonly: {value: false, update: this._setReadOnly},
+				fullSelection: {value: true, update: this._setFullSelection},
+				tabMode: { value: true, update: null },
+				tabSize: {value: 8, update: this._setTabSize},
+				expandTab: {value: false, update: null},
+				themeClass: {value: undefined, update: this._setThemeClass}
 			};
 		},
-		_destroyFrame: function() {
-			var frame = this._frame;
-			if (!frame) { return; }
-			if (this._loadHandler) {
-				removeHandler(frame, "load", this._loadHandler, !!isFirefox);
-				this._loadHandler = null;
-			}
-			if (this._attrModifiedHandler) {
-				removeHandler(this._parentDocument, "DOMAttrModified", this._attrModifiedHandler);
-				this._attrModifiedHandler = null;
-			}
-			frame.parentNode.removeChild(frame);
-			this._frame = null;
-		},
 		_destroyRuler: function(ruler) {
 			var side = ruler.getLocation();
 			var rulerParent = side === "left" ? this._leftDiv : this._rightDiv;
 			if (rulerParent) {
 				var row = rulerParent.firstChild.rows[0];
 				var cells = row.cells;
 				for (var index = 0; index < cells.length; index++) {
 					var cell = cells[index];
@@ -7367,55 +8161,47 @@ define("orion/textview/textView", ['orio
 				row.deleteCell(index);
 			}
 		},
 		_destroyView: function() {
 			var clientDiv = this._clientDiv;
 			if (!clientDiv) { return; }
 			this._setGrab(null);
 			this._unhookEvents();
-			if (this._windowLoadHandler) {
-				removeHandler(this._frameWindow, "load", this._windowLoadHandler);
-				this._windowLoadHandler = null;
-			}
 
 			/* Destroy timers */
 			if (this._autoScrollTimerID) {
 				clearTimeout(this._autoScrollTimerID);
 				this._autoScrollTimerID = null;
 			}
 			if (this._updateTimer) {
 				clearTimeout(this._updateTimer);
 				this._updateTimer = null;
 			}
+			
+			var rootDiv = this._rootDiv;
+			rootDiv.parentNode.removeChild(rootDiv);
 
 			/* Destroy DOM */
-			var parent = this._frameDocument.body;
-			while (parent.hasChildNodes()) { parent.removeChild(parent.lastChild); }
-			if (this._touchDiv) {
-				this._parent.removeChild(this._touchDiv);
-				this._touchDiv = null;
-			}
 			this._selDiv1 = null;
 			this._selDiv2 = null;
 			this._selDiv3 = null;
-			this._insertedSelRule = false;
-			this._textArea = null;
 			this._clipboardDiv = null;
+			this._rootDiv = null;
 			this._scrollDiv = null;
 			this._viewDiv = null;
 			this._clipDiv = null;
 			this._clipScrollDiv = null;
 			this._clientDiv = null;
 			this._overlayDiv = null;
 			this._leftDiv = null;
 			this._rightDiv = null;
-			this._frameDocument = null;
-			this._frameWindow = null;
-			this.onUnload({type: "Unload"});
+			this._vScrollDiv = null;
+			this._hScrollDiv = null;
+			this._insertedSelRule = false;
 		},
 		_doAutoScroll: function (direction, x, y) {
 			this._autoScrollDir = direction;
 			this._autoScrollX = x;
 			this._autoScrollY = y;
 			if (!this._autoScrollTimerID) {
 				this._autoScrollTimer();
 			}
@@ -7442,19 +8228,39 @@ define("orion/textview/textView", ['orio
 			/* This is the only case the view access the base model, alternatively the view could use a event to application to customize the text */
 			if (model.getBaseModel) {
 				start = model.mapOffset(start);
 				end = model.mapOffset(end);
 				model = model.getBaseModel();
 			}
 			return model.getText(start, end);
 		},
+		_getBorder: function (node) {
+			var left,top,right,bottom;
+			if (window.getComputedStyle) {
+				var style = window.getComputedStyle(node, null);
+				left = style.getPropertyValue("border-left-width");
+				top = style.getPropertyValue("border-top-width");
+				right = style.getPropertyValue("border-right-width");
+				bottom = style.getPropertyValue("border-bottom-width");
+			} else if (node.currentStyle) {
+				left = node.currentStyle.borderLeftWidth;
+				top = node.currentStyle.borderTopWidth;
+				right = node.currentStyle.borderRightWidth;
+				bottom = node.currentStyle.borderBottomWidth;
+			}
+			return {
+				left: parseInt(left, 10) || 0,
+				top: parseInt(top, 10) || 0,
+				right: parseInt(right, 10) || 0,
+				bottom: parseInt(bottom, 10) || 0
+			};
+		},
 		_getBoundsAtOffset: function (offset) {
 			var model = this._model;
-			var document = this._frameDocument;
 			var clientDiv = this._clientDiv;
 			var lineIndex = model.getLineAtOffset(offset);
 			var dummy;
 			var child = this._getLineNode(lineIndex);
 			if (!child) {
 				child = dummy = this._createLine(clientDiv, null, document, lineIndex, model);
 			}
 			var result = null;
@@ -7530,45 +8336,38 @@ define("orion/textview/textView", ['orio
 				var rect = child.getBoundingClientRect();
 				var clientRect = this._clientDiv.getBoundingClientRect();
 				if (rect.bottom > clientRect.bottom) {
 					child = this._getLinePrevious(child) || child;
 				}
 			}
 			return child.lineIndex;
 		},
-		_getFrameHeight: function() {
-			return this._frameDocument.documentElement.clientHeight;
-		},
-		_getFrameWidth: function() {
-			return this._frameDocument.documentElement.clientWidth;
-		},
 		_getClientHeight: function() {
 			var viewPad = this._getViewPadding();
 			return Math.max(0, this._viewDiv.clientHeight - viewPad.top - viewPad.bottom);
 		},
 		_getClientWidth: function() {
 			var viewPad = this._getViewPadding();
 			return Math.max(0, this._viewDiv.clientWidth - viewPad.left - viewPad.right);
 		},
 		_getClipboardText: function (event, handler) {
 			var delimiter = this._model.getLineDelimiter();
 			var clipboadText, text;
-			if (this._frameWindow.clipboardData) {
+			if (window.clipboardData) {
 				//IE
 				clipboadText = [];
-				text = this._frameWindow.clipboardData.getData("Text");
+				text = window.clipboardData.getData("Text");
 				this._convertDelimiter(text, function(t) {clipboadText.push(t);}, function() {clipboadText.push(delimiter);});
 				text = clipboadText.join("");
 				if (handler) { handler(text); }
 				return text;
 			}
 			if (isFirefox) {
 				this._ignoreFocus = true;
-				var document = this._frameDocument;
 				var clipboardDiv = this._clipboardDiv;
 				clipboardDiv.innerHTML = "<pre contenteditable=''></pre>";
 				clipboardDiv.firstChild.focus();
 				var self = this;
 				var _getText = function() {
 					var noteText = self._getTextFromElement(clipboardDiv);
 					clipboardDiv.innerHTML = "";
 					clipboadText = [];
@@ -7685,33 +8484,52 @@ define("orion/textview/textView", ['orio
 			for (i = 0; i < oldRanges.length; i++) {
 				selection.addRange(oldRanges[i]);
 			}
 
 			this._ignoreSelect = false;
 			return text;
 		},
 		_getViewPadding: function() {
-			return this._viewPadding;
-		},
-		_getLineBoundingClientRect: function (child) {
+			return this._metrics.viewPadding;
+		},
+		_getLineTrim: function(line) {
+			var trim = line._trim;
+			if (!trim) {
+				trim = this._getPadding(line);
+				var border = this._getBorder(line);
+				trim.left += border.left;
+				trim.top += border.top;
+				trim.right += border.right;
+				trim.bottom += border.bottom;
+				line._trim = trim;
+			}
+			return trim;
+		},
+		_getLineBoundingClientRect: function (child, noTrim) {
 			var rect = child.getBoundingClientRect();
+			rect = {left: rect.left, top: rect.top, right: rect.left, bottom: rect.bottom};
 			var lastChild = child.lastChild;
 			//Remove any artificial trailing whitespace in the line
 			while (lastChild && lastChild.ignoreChars === lastChild.firstChild.length) {
 				lastChild = lastChild.previousSibling;
 			}
-			if (!lastChild) {
-				return {left: rect.left, top: rect.top, right: rect.left, bottom: rect.bottom};
-			}
-			var lastRect = lastChild.getBoundingClientRect();
-			return {left: rect.left, top: rect.top, right: lastRect.right, bottom: rect.bottom};
+			if (lastChild) {
+				var lastRect = lastChild.getBoundingClientRect();
+				rect.right = lastRect.right + this._getLineTrim(child).right;
+			}
+			if (noTrim) {
+				var padding = this._getLineTrim(child);
+				rect.left = rect.left + padding.left;
+				rect.right = rect.right - padding.right;
+			}
+			return rect;
 		},
 		_getLineHeight: function() {
-			return this._lineHeight;
+			return this._metrics.lineHeight;
 		},
 		_getLineNode: function (lineIndex) {
 			var clientDiv = this._clientDiv;
 			var child = clientDiv.firstChild;
 			while (child) {
 				if (lineIndex === child.lineIndex) {
 					return child;
 				}
@@ -7814,17 +8632,16 @@ define("orion/textview/textView", ['orio
 						offsetInLine--;
 					}
 				}
 				return lineStart + offsetInLine;
 			}
 			return offset + direction;
 		},
 		_getOffset_IE: function (offset, unit, direction) {
-			var document = this._frameDocument;
 			var model = this._model;
 			var lineIndex = model.getLineAtOffset(offset);
 			var clientDiv = this._clientDiv;
 			var dummy;
 			var child = this._getLineNode(lineIndex);
 			if (!child) {
 				child = dummy = this._createLine(clientDiv, null, document, lineIndex, model);
 			}
@@ -7867,33 +8684,33 @@ define("orion/textview/textView", ['orio
 			if (dummy) { clientDiv.removeChild(dummy); }
 			return result;
 		},
 		_getOffsetToX: function (offset) {
 			return this._getBoundsAtOffset(offset).left;
 		},
 		_getPadding: function (node) {
 			var left,top,right,bottom;
-			if (node.currentStyle) {
+			if (window.getComputedStyle) {
+				var style = window.getComputedStyle(node, null);
+				left = style.getPropertyValue("padding-left");
+				top = style.getPropertyValue("padding-top");
+				right = style.getPropertyValue("padding-right");
+				bottom = style.getPropertyValue("padding-bottom");
+			} else if (node.currentStyle) {
 				left = node.currentStyle.paddingLeft;
 				top = node.currentStyle.paddingTop;
 				right = node.currentStyle.paddingRight;
 				bottom = node.currentStyle.paddingBottom;
-			} else if (this._frameWindow.getComputedStyle) {
-				var style = this._frameWindow.getComputedStyle(node, null);
-				left = style.getPropertyValue("padding-left");
-				top = style.getPropertyValue("padding-top");
-				right = style.getPropertyValue("padding-right");
-				bottom = style.getPropertyValue("padding-bottom");
 			}
 			return {
-					left: parseInt(left, 10), 
-					top: parseInt(top, 10),
-					right: parseInt(right, 10),
-					bottom: parseInt(bottom, 10)
+				left: parseInt(left, 10) || 0, 
+				top: parseInt(top, 10) || 0,
+				right: parseInt(right, 10) || 0,
+				bottom: parseInt(bottom, 10) || 0
 			};
 		},
 		_getScroll: function() {
 			var viewDiv = this._viewDiv;
 			return {x: viewDiv.scrollLeft, y: viewDiv.scrollTop};
 		},
 		_getSelection: function () {
 			return this._selection.clone();
@@ -7912,38 +8729,37 @@ define("orion/textview/textView", ['orio
 		},
 		_getXToOffset: function (lineIndex, x) {
 			var model = this._model;
 			var lineStart = model.getLineStart(lineIndex);
 			var lineEnd = model.getLineEnd(lineIndex);
 			if (lineStart === lineEnd) {
 				return lineStart;
 			}
-			var document = this._frameDocument;
 			var clientDiv = this._clientDiv;
 			var dummy;
 			var child = this._getLineNode(lineIndex);
 			if (!child) {
 				child = dummy = this._createLine(clientDiv, null, document, lineIndex, model);
 			}
-			var lineRect = this._getLineBoundingClientRect(child);
+			var lineRect = this._getLineBoundingClientRect(child, true);
 			if (x < lineRect.left) { x = lineRect.left; }
 			if (x > lineRect.right) { x = lineRect.right; }
 			/*
 			* Bug in IE 8 and earlier. The coordinates of getClientRects() are relative to
 			* the browser window.  The fix is to convert to the frame window before using it. 
 			*/
 			var deltaX = 0, rects;
 			if (isIE < 9) {
 				rects = child.getClientRects();
 				var minLeft = rects[0].left;
 				for (var i=1; i<rects.length; i++) {
 					minLeft = Math.min(rects[i].left, minLeft);
 				}
-				deltaX = minLeft - lineRect.left;
+				deltaX = minLeft - lineRect.left - this._getLineTrim(child).left;
 			}
 			var scrollX = this._getScroll().x;
 			function _getClientRects(element) {
 				var rects, newRects, i, r;
 				if (!element._rectsCache) {
 					rects = element.getClientRects();
 					newRects = [rects.length];
 					for (i = 0; i<rects.length; i++) {
@@ -8077,148 +8893,103 @@ define("orion/textview/textView", ['orio
 			var viewPad = this._getViewPadding();
 			var viewRect = this._viewDiv.getBoundingClientRect();
 			y -= viewRect.top + viewPad.top;
 			var lineHeight = this._getLineHeight();
 			var lineIndex = Math.floor((y + this._getScroll().y) / lineHeight);
 			var lineCount = this._model.getLineCount();
 			return Math.max(0, Math.min(lineCount - 1, lineIndex));
 		},
-		_getOffsetBounds: function(offset) {
-			var model = this._model;
-			var lineIndex = model.getLineAtOffset(offset);
-			var lineHeight = this._getLineHeight();
-			var scroll = this._getScroll();
-			var viewPad = this._getViewPadding();
-			var viewRect = this._viewDiv.getBoundingClientRect();
-			var bounds = this._getBoundsAtOffset(offset);
-			var left = bounds.left;
-			var right = bounds.right;
-			var top = (lineIndex * lineHeight) - scroll.y + viewRect.top + viewPad.top;
-			var bottom = top + lineHeight;
-			return {left: left, top: top, right: right, bottom: bottom};
-		},
-		_getVisible: function() {
-			var temp = this._parent;
-			var parentDocument = temp.ownerDocument;
-			while (temp !== parentDocument) {
-				var hidden;
-				if (isIE < 9) {
-					hidden = temp.currentStyle && temp.currentStyle.display === "none";
-				} else {
-					var tempStyle = parentDocument.defaultView.getComputedStyle(temp, null);
-					hidden = tempStyle && tempStyle.getPropertyValue("display") === "none";
-				}
-				if (hidden) { return "hidden"; }
-				temp =  temp.parentNode;
-				if (!temp) { return "disconnected"; }
-			}
-			return "visible";
-		},
-		_hitOffset: function (offset, x, y) {
-			var bounds = this._getOffsetBounds(offset);
-			var left = bounds.left;
-			var right = bounds.right;
-			var top = bounds.top;
-			var bottom = bounds.bottom;
-			var area = 20;
-			left -= area;
-			top -= area;
-			right += area;
-			bottom += area;
-			return (left <= x && x <= right && top <= y && y <= bottom);
-		},
 		_hookEvents: function() {
 			var self = this;
 			this._modelListener = {
 				/** @private */
 				onChanging: function(modelChangingEvent) {
 					self._onModelChanging(modelChangingEvent);
 				},
 				/** @private */
 				onChanged: function(modelChangedEvent) {
 					self._onModelChanged(modelChangedEvent);
 				}
 			};
 			this._model.addEventListener("Changing", this._modelListener.onChanging);
 			this._model.addEventListener("Changed", this._modelListener.onChanged);
 			
-			var clientDiv = this._clientDiv;
-			var viewDiv = this._viewDiv;
-			var body = this._frameDocument.body; 
 			var handlers = this._handlers = [];
-			var resizeNode = isIE < 9 ? this._frame : this._frameWindow;
-			var focusNode = isPad ? this._textArea : (isIE ||  isFirefox ? this._clientDiv: this._frameWindow);
-			handlers.push({target: this._frameWindow, type: "unload", handler: function(e) { return self._handleUnload(e);}});
-			handlers.push({target: resizeNode, type: "resize", handler: function(e) { return self._handleResize(e);}});
-			handlers.push({target: focusNode, type: "blur", handler: function(e) { return self._handleBlur(e);}});
-			handlers.push({target: focusNode, type: "focus", handler: function(e) { return self._handleFocus(e);}});
+			var clientDiv = this._clientDiv, viewDiv = this._viewDiv, rootDiv = this._rootDiv;
+			var topNode = this._overlayDiv || clientDiv;
+			var grabNode = isIE ? document : window;
+			handlers.push({target: window, type: "resize", handler: function(e) { return self._handleResize(e);}});
+			handlers.push({target: clientDiv, type: "blur", handler: function(e) { return self._handleBlur(e);}});
+			handlers.push({target: clientDiv, type: "focus", handler: function(e) { return self._handleFocus(e);}});
+			handlers.push({target: viewDiv, type: "focus", handler: function(e) { clientDiv.focus(); }});
 			handlers.push({target: viewDiv, type: "scroll", handler: function(e) { return self._handleScroll(e);}});
+			handlers.push({target: clientDiv, type: "keydown", handler: function(e) { return self._handleKeyDown(e);}});
+			handlers.push({target: clientDiv, type: "keypress", handler: function(e) { return self._handleKeyPress(e);}});
+			handlers.push({target: clientDiv, type: "keyup", handler: function(e) { return self._handleKeyUp(e);}});
+			handlers.push({target: clientDiv, type: "selectstart", handler: function(e) { return self._handleSelectStart(e);}});
+			handlers.push({target: clientDiv, type: "contextmenu", handler: function(e) { return self._handleContextMenu(e);}});
+			handlers.push({target: clientDiv, type: "copy", handler: function(e) { return self._handleCopy(e);}});
+			handlers.push({target: clientDiv, type: "cut", handler: function(e) { return self._handleCut(e);}});
+			handlers.push({target: clientDiv, type: "paste", handler: function(e) { return self._handlePaste(e);}});
 			if (isPad) {
-				var touchDiv = this._touchDiv;
-				var textArea = this._textArea;
-				handlers.push({target: textArea, type: "keydown", handler: function(e) { return self._handleKeyDown(e);}});
-				handlers.push({target: textArea, type: "input", handler: function(e) { return self._handleInput(e); }});
-				handlers.push({target: textArea, type: "textInput", handler: function(e) { return self._handleTextInput(e); }});
-				handlers.push({target: textArea, type: "click", handler: function(e) { return self._handleTextAreaClick(e); }});
-				handlers.push({target: touchDiv, type: "touchstart", handler: function(e) { return self._handleTouchStart(e); }});
-				handlers.push({target: touchDiv, type: "touchmove", handler: function(e) { return self._handleTouchMove(e); }});
-				handlers.push({target: touchDiv, type: "touchend", handler: function(e) { return self._handleTouchEnd(e); }});
+				handlers.push({target: document, type: "selectionchange", handler: function(e) { return self._handleSelectionChange(e); }});
+				handlers.push({target: clientDiv, type: "touchstart", handler: function(e) { return self._handleTouchStart(e); }});
+				handlers.push({target: clientDiv, type: "touchmove", handler: function(e) { return self._handleTouchMove(e); }});
+				handlers.push({target: clientDiv, type: "touchend", handler: function(e) { return self._handleTouchEnd(e); }});
 			} else {
-				var topNode = this._overlayDiv || this._clientDiv;
-				var grabNode = isIE ? clientDiv : this._frameWindow;
-				handlers.push({target: clientDiv, type: "keydown", handler: function(e) { return self._handleKeyDown(e);}});
-				handlers.push({target: clientDiv, type: "keypress", handler: function(e) { return self._handleKeyPress(e);}});
-				handlers.push({target: clientDiv, type: "keyup", handler: function(e) { return self._handleKeyUp(e);}});
-				handlers.push({target: clientDiv, type: "selectstart", handler: function(e) { return self._handleSelectStart(e);}});
-				handlers.push({target: clientDiv, type: "contextmenu", handler: function(e) { return self._handleContextMenu(e);}});
-				handlers.push({target: clientDiv, type: "copy", handler: function(e) { return self._handleCopy(e);}});
-				handlers.push({target: clientDiv, type: "cut", handler: function(e) { return self._handleCut(e);}});
-				handlers.push({target: clientDiv, type: "paste", handler: function(e) { return self._handlePaste(e);}});
 				handlers.push({target: clientDiv, type: "mousedown", handler: function(e) { return self._handleMouseDown(e);}});
 				handlers.push({target: clientDiv, type: "mouseover", handler: function(e) { return self._handleMouseOver(e);}});
 				handlers.push({target: clientDiv, type: "mouseout", handler: function(e) { return self._handleMouseOut(e);}});
 				handlers.push({target: grabNode, type: "mouseup", handler: function(e) { return self._handleMouseUp(e);}});
 				handlers.push({target: grabNode, type: "mousemove", handler: function(e) { return self._handleMouseMove(e);}});
-				handlers.push({target: body, type: "mousedown", handler: function(e) { return self._handleBodyMouseDown(e);}});
-				handlers.push({target: body, type: "mouseup", handler: function(e) { return self._handleBodyMouseUp(e);}});
+				handlers.push({target: rootDiv, type: "mousedown", handler: function(e) { return self._handleRootMouseDown(e);}});
+				handlers.push({target: rootDiv, type: "mouseup", handler: function(e) { return self._handleRootMouseUp(e);}});
 				handlers.push({target: topNode, type: "dragstart", handler: function(e) { return self._handleDragStart(e);}});
 				handlers.push({target: topNode, type: "drag", handler: function(e) { return self._handleDrag(e);}});
 				handlers.push({target: topNode, type: "dragend", handler: function(e) { return self._handleDragEnd(e);}});
 				handlers.push({target: topNode, type: "dragenter", handler: function(e) { return self._handleDragEnter(e);}});
 				handlers.push({target: topNode, type: "dragover", handler: function(e) { return self._handleDragOver(e);}});
 				handlers.push({target: topNode, type: "dragleave", handler: function(e) { return self._handleDragLeave(e);}});
 				handlers.push({target: topNode, type: "drop", handler: function(e) { return self._handleDrop(e);}});
-				if (isChrome) {
-					handlers.push({target: this._parentDocument, type: "mousemove", handler: function(e) { return self._handleMouseMove(e);}});
-					handlers.push({target: this._parentDocument, type: "mouseup", handler: function(e) { return self._handleMouseUp(e);}});
-				}
-				if (isIE) {
-					handlers.push({target: this._frameDocument, type: "activate", handler: function(e) { return self._handleDocFocus(e); }});
-				}
-				if (isFirefox) {
-					handlers.push({target: this._frameDocument, type: "focus", handler: function(e) { return self._handleDocFocus(e); }});
-				}
-				if (!isIE && !isOpera) {
-					var wheelEvent = isFirefox ? "DOMMouseScroll" : "mousewheel";
-					handlers.push({target: this._viewDiv, type: wheelEvent, handler: function(e) { return self._handleMouseWheel(e); }});
-				}
+				handlers.push({target: this._clientDiv, type: isFirefox ? "DOMMouseScroll" : "mousewheel", handler: function(e) { return self._handleMouseWheel(e); }});
 				if (isFirefox && !isWindows) {
 					handlers.push({target: this._clientDiv, type: "DOMCharacterDataModified", handler: function (e) { return self._handleDataModified(e); }});
 				}
 				if (this._overlayDiv) {
 					handlers.push({target: this._overlayDiv, type: "mousedown", handler: function(e) { return self._handleMouseDown(e);}});
 					handlers.push({target: this._overlayDiv, type: "mouseover", handler: function(e) { return self._handleMouseOver(e);}});
 					handlers.push({target: this._overlayDiv, type: "mouseout", handler: function(e) { return self._handleMouseOut(e);}});
 					handlers.push({target: this._overlayDiv, type: "contextmenu", handler: function(e) { return self._handleContextMenu(e); }});
 				}
 				if (!isW3CEvents) {
 					handlers.push({target: this._clientDiv, type: "dblclick", handler: function(e) { return self._handleDblclick(e); }});
 				}
 			}
+
+			var leftDiv = this._leftDiv, rightDiv = this._rightDiv;
+			if (isIE) {
+				handlers.push({target: leftDiv, type: "selectstart", handler: function() {return false;}});
+			}
+			handlers.push({target: leftDiv, type: isFirefox ? "DOMMouseScroll" : "mousewheel", handler: function(e) { return self._handleMouseWheel(e); }});
+			handlers.push({target: leftDiv, type: "click", handler: function(e) { self._handleRulerEvent(e); }});
+			handlers.push({target: leftDiv, type: "dblclick", handler: function(e) { self._handleRulerEvent(e); }});
+			handlers.push({target: leftDiv, type: "mousemove", handler: function(e) { self._handleRulerEvent(e); }});
+			handlers.push({target: leftDiv, type: "mouseover", handler: function(e) { self._handleRulerEvent(e); }});
+			handlers.push({target: leftDiv, type: "mouseout", handler: function(e) { self._handleRulerEvent(e); }});
+			if (isIE) {
+				handlers.push({target: rightDiv, type: "selectstart", handler: function() {return false;}});
+			}
+			handlers.push({target: rightDiv, type: isFirefox ? "DOMMouseScroll" : "mousewheel", handler: function(e) { return self._handleMouseWheel(e); }});
+			handlers.push({target: rightDiv, type: "click", handler: function(e) { self._handleRulerEvent(e); }});
+			handlers.push({target: rightDiv, type: "dblclick", handler: function(e) { self._handleRulerEvent(e); }});
+			handlers.push({target: rightDiv, type: "mousemove", handler: function(e) { self._handleRulerEvent(e); }});
+			handlers.push({target: rightDiv, type: "mouseover", handler: function(e) { self._handleRulerEvent(e); }});
+			handlers.push({target: rightDiv, type: "mouseout", handler: function(e) { self._handleRulerEvent(e); }});
+			
 			for (var i=0; i<handlers.length; i++) {
 				var h = handlers[i];
 				addHandler(h.target, h.type, h.handler, h.capture);
 			}
 		},
 		_init: function(options) {
 			var parent = options.parent;
 			if (typeof(parent) === "string") {
@@ -8242,16 +9013,17 @@ define("orion/textview/textView", ['orio
 			this._rulers = [];
 			this._selection = new Selection (0, 0, false);
 			this._linksVisible = false;
 			this._redrawCount = 0;
 			this._maxLineWidth = 0;
 			this._maxLineIndex = -1;
 			this._ignoreSelect = true;
 			this._ignoreFocus = false;
+			this._hasFocus = false;
 			this._columnX = -1;
 			this._dragOffset = -1;
 
 			/* Auto scroll */
 			this._autoScrollX = null;
 			this._autoScrollY = null;
 			this._autoScrollTimerID = null;
 			this._AUTO_SCROLL_RATE = 50;
@@ -8273,17 +9045,17 @@ define("orion/textview/textView", ['orio
 			this._hScroll = 0;
 			this._vScroll = 0;
 
 			/* IME */
 			this._imeOffset = -1;
 			
 			/* Create elements */
 			this._createActions();
-			this._createFrame();
+			this._createView();
 		},
 		_isLinkURL: function(string) {
 			return string.toLowerCase().lastIndexOf(".css") === string.length - 4;
 		},
 		_modifyContent: function(e, updateCaret) {
 			if (this._readonly && !e._code) {
 				return;
 			}
@@ -8364,16 +9136,26 @@ define("orion/textview/textView", ['orio
 		_queueUpdatePage: function() {
 			if (this._updateTimer) { return; }
 			var self = this;
 			this._updateTimer = setTimeout(function() { 
 				self._updateTimer = null;
 				self._updatePage();
 			}, 0);
 		},
+		_resetLineWidth: function() {
+			var clientDiv = this._clientDiv;
+			if (clientDiv) {
+				var child = clientDiv.firstChild;
+				while (child) {
+					child.lineWidth = undefined;
+					child = child.nextSibling;
+				}
+			}
+		},
 		_reset: function() {
 			this._maxLineIndex = -1;
 			this._maxLineWidth = 0;
 			this._columnX = -1;
 			this._topChild = null;
 			this._bottomChild = null;
 			this._partialY = 0;
 			this._setSelection(new Selection (0, 0, false), false, false);
@@ -8399,47 +9181,16 @@ define("orion/textview/textView", ['orio
 					if (hasFocus) { clientDiv.blur(); }
 					clientDiv.contentEditable = false;
 					clientDiv.contentEditable = true;
 					if (hasFocus) { clientDiv.focus(); }
 					this._ignoreFocus = false;
 				}
 			}
 		},
-		_resizeTouchDiv: function() {
-			var viewRect = this._viewDiv.getBoundingClientRect();
-			var parentRect = this._frame.getBoundingClientRect();
-			var temp = this._frame;
-			while (temp) {
-				if (temp.style && temp.style.top) { break; }
-				temp = temp.parentNode;
-			}
-			var parentTop = parentRect.top;
-			if (temp) {
-				parentTop -= temp.getBoundingClientRect().top;
-			} else {
-				parentTop += this._parentDocument.body.scrollTop;
-			}
-			temp = this._frame;
-			while (temp) {
-				if (temp.style && temp.style.left) { break; }
-				temp = temp.parentNode;
-			}
-			var parentLeft = parentRect.left;
-			if (temp) {
-				parentLeft -= temp.getBoundingClientRect().left;
-			} else {
-				parentLeft += this._parentDocument.body.scrollLeft;
-			}
-			var touchDiv = this._touchDiv;
-			touchDiv.style.left = (parentLeft + viewRect.left) + "px";
-			touchDiv.style.top = (parentTop + viewRect.top) + "px";
-			touchDiv.style.width = viewRect.width + "px";
-			touchDiv.style.height = viewRect.height + "px";
-		},
 		_scrollView: function (pixelX, pixelY) {
 			/*
 			* Always set _ensureCaretVisible to false so that the view does not scroll
 			* to show the caret when scrollView is not called from showCaret().
 			*/
 			this._ensureCaretVisible = false;
 			
 			/*
@@ -8452,26 +9203,24 @@ define("orion/textview/textView", ['orio
 			* PageDown/PageUp key, but it will not redraw again until the key is released.
 			*/
 			var viewDiv = this._viewDiv;
 			if (pixelX) { viewDiv.scrollLeft += pixelX; }
 			if (pixelY) { viewDiv.scrollTop += pixelY; }
 		},
 		_setClipboardText: function (text, event) {
 			var clipboardText;
-			if (this._frameWindow.clipboardData) {
+			if (window.clipboardData) {
 				//IE
 				clipboardText = [];
 				this._convertDelimiter(text, function(t) {clipboardText.push(t);}, function() {clipboardText.push(platformDelimiter);});
-				return this._frameWindow.clipboardData.setData("Text", clipboardText.join(""));
+				return window.clipboardData.setData("Text", clipboardText.join(""));
 			}
 			/* Feature in Chrome, clipboardData.setData is no-op on Chrome even though it returns true */
 			if (isChrome || isFirefox || !event) {
-				var window = this._frameWindow;
-				var document = this._frameDocument;
 				var child = document.createElement("PRE");
 				child.style.position = "fixed";
 				child.style.left = "-1000px";
 				this._convertDelimiter(text, 
 					function(t) {
 						child.appendChild(document.createTextNode(t));
 					}, 
 					function() {
@@ -8517,18 +9266,16 @@ define("orion/textview/textView", ['orio
 			if (event && event.clipboardData) {
 				//webkit
 				clipboardText = [];
 				this._convertDelimiter(text, function(t) {clipboardText.push(t);}, function() {clipboardText.push(platformDelimiter);});
 				return event.clipboardData.setData("text/plain", clipboardText.join("")); 
 			}
 		},
 		_setDOMSelection: function (startNode, startOffset, endNode, endOffset) {
-			var window = this._frameWindow;
-			var document = this._frameDocument;
 			var startLineNode, startLineOffset, endLineNode, endLineOffset;
 			var offset = 0;
 			var lineChild = startNode.firstChild;
 			var node, nodeLength, model = this._model;
 			var startLineEnd = model.getLine(startNode.lineIndex).length;
 			while (lineChild) {
 				node = lineChild.firstChild;
 				nodeLength = node.length;
@@ -8563,17 +9310,16 @@ define("orion/textview/textView", ['orio
 					}
 					break;
 				}
 				offset += nodeLength;
 				lineChild = lineChild.nextSibling;
 			}
 			
 			this._setDOMFullSelection(startNode, startOffset, startLineEnd, endNode, endOffset, endLineEnd);
-			if (isPad) { return; }
 
 			var range;
 			if (window.getSelection) {
 				//W3C
 				range = document.createRange();
 				range.setStart(startLineNode, startLineOffset);
 				range.setEnd(endLineNode, endLineOffset);
 				var sel = window.getSelection();
@@ -8602,128 +9348,99 @@ define("orion/textview/textView", ['orio
 				endRange.moveStart("character", endLineOffset);
 				range.setEndPoint("EndToStart", endRange);
 				this._ignoreSelect = false;
 				range.select();
 				this._ignoreSelect = true;
 			}
 		},
 		_setDOMFullSelection: function(startNode, startOffset, startLineEnd, endNode, endOffset, endLineEnd) {
+			if (!this._selDiv1) { return; }
+			var selDiv = this._selDiv1;
+			selDiv.style.width = "0px";
+			selDiv.style.height = "0px";
+			selDiv = this._selDiv2;
+			selDiv.style.width = "0px";
+			selDiv.style.height = "0px";
+			selDiv = this._selDiv3;
+			selDiv.style.width = "0px";
+			selDiv.style.height = "0px";
+			if (startNode === endNode && startOffset === endOffset) { return; }
 			var model = this._model;
-			if (this._selDiv1) {
-				var startLineBounds, l;
-				startLineBounds = this._getLineBoundingClientRect(startNode);
-				if (startOffset === 0) {
-					l = startLineBounds.left;
+			var viewPad = this._getViewPadding();
+			var clientRect = this._clientDiv.getBoundingClientRect();
+			var viewRect = this._viewDiv.getBoundingClientRect();
+			var left = viewRect.left + viewPad.left;
+			var right = clientRect.right;
+			var top = viewRect.top + viewPad.top;
+			var bottom = clientRect.bottom;
+			var hd = 0, vd = 0;
+			if (this._clipDiv) {
+				var clipRect = this._clipDiv.getBoundingClientRect();
+				hd = clipRect.left - this._clipDiv.scrollLeft;
+				vd = clipRect.top;
+			} else {
+				var rootpRect = this._rootDiv.getBoundingClientRect();
+				hd = rootpRect.left;
+				vd = rootpRect.top;
+			}
+			var startLineBounds, l;
+			startLineBounds = this._getLineBoundingClientRect(startNode);
+			if (startOffset === 0) {
+				l = startLineBounds.left;
+			} else {
+				if (startOffset >= startLineEnd) {
+					l = startLineBounds.right;
 				} else {
-					if (startOffset >= startLineEnd) {
-						l = startLineBounds.right;
-					} else {
-						this._ignoreDOMSelection = true;
-						l = this._getBoundsAtOffset(model.getLineStart(startNode.lineIndex) + startOffset).left;
-						this._ignoreDOMSelection = false;
-					}
-				}
-				var textArea = this._textArea;
-				if (textArea && isPad) {
-					textArea.selectionStart = textArea.selectionEnd = 0;
-					var rect = this._frame.getBoundingClientRect();
-					var touchRect = this._touchDiv.getBoundingClientRect();
-					var viewBounds = this._viewDiv.getBoundingClientRect();
-					if (!(viewBounds.left <= l && l <= viewBounds.left + viewBounds.width &&
-						viewBounds.top <= startLineBounds.top && startLineBounds.top <= viewBounds.top + viewBounds.height) ||
-						!(startNode === endNode && startOffset === endOffset))
-					{
-						textArea.style.left = "-1000px";
-					} else {
-						textArea.style.left = (l - 4 + rect.left - touchRect.left) + "px";
-					}
-					textArea.style.top = (startLineBounds.top + rect.top - touchRect.top) + "px";
-					textArea.style.width = "6px";
-					textArea.style.height = (startLineBounds.bottom - startLineBounds.top) + "px";
-				}
-			
-				var selDiv = this._selDiv1;
-				selDiv.style.width = "0px";
-				selDiv.style.height = "0px";
-				selDiv = this._selDiv2;
-				selDiv.style.width = "0px";
-				selDiv.style.height = "0px";
-				selDiv = this._selDiv3;
-				selDiv.style.width = "0px";
-				selDiv.style.height = "0px";
-				if (!(startNode === endNode && startOffset === endOffset)) {
-					var handleWidth = isPad ? 2 : 0;
-					var handleBorder = handleWidth + "px blue solid";
-					var viewPad = this._getViewPadding();
-					var clientRect = this._clientDiv.getBoundingClientRect();
-					var viewRect = this._viewDiv.getBoundingClientRect();
-					var left = viewRect.left + viewPad.left;
-					var right = clientRect.right;
-					var top = viewRect.top + viewPad.top;
-					var bottom = clientRect.bottom;
-					var hd = 0, vd = 0;
-					if (this._clipDiv) {
-						var clipRect = this._clipDiv.getBoundingClientRect();
-						hd = clipRect.left - this._clipDiv.scrollLeft;
-						vd = clipRect.top;
-					}
-					var r;
-					var endLineBounds = this._getLineBoundingClientRect(endNode);
-					if (endOffset === 0) {
-						r = endLineBounds.left;
-					} else {
-						if (endOffset >= endLineEnd) {
-							r = endLineBounds.right;
-						} else {
-							this._ignoreDOMSelection = true;
-							r = this._getBoundsAtOffset(model.getLineStart(endNode.lineIndex) + endOffset).left;
-							this._ignoreDOMSelection = false;
-						}
-					}
-					var sel1Div = this._selDiv1;
-					var sel1Left = Math.min(right, Math.max(left, l));
-					var sel1Top = Math.min(bottom, Math.max(top, startLineBounds.top));
-					var sel1Right = right;
-					var sel1Bottom = Math.min(bottom, Math.max(top, startLineBounds.bottom));
-					sel1Div.style.left = (sel1Left - hd) + "px";
-					sel1Div.style.top = (sel1Top - vd) + "px";
-					sel1Div.style.width = Math.max(0, sel1Right - sel1Left) + "px";
-					sel1Div.style.height = Math.max(0, sel1Bottom - sel1Top) + (isPad ? 1 : 0) + "px";
-					if (isPad) {
-						sel1Div.style.borderLeft = handleBorder;
-						sel1Div.style.borderRight = "0px";
-					}
-					if (startNode === endNode) {
-						sel1Right = Math.min(r, right);
-						sel1Div.style.width = Math.max(0, sel1Right - sel1Left - handleWidth * 2) + "px";
-						if (isPad) {
-							sel1Div.style.borderRight = handleBorder;
-						}
-					} else {
-						var sel3Left = left;
-						var sel3Top = Math.min(bottom, Math.max(top, endLineBounds.top));
-						var sel3Right = Math.min(right, Math.max(left, r));
-						var sel3Bottom = Math.min(bottom, Math.max(top, endLineBounds.bottom));
-						var sel3Div = this._selDiv3;
-						sel3Div.style.left = (sel3Left - hd) + "px";
-						sel3Div.style.top = (sel3Top - vd) + "px";
-						sel3Div.style.width = Math.max(0, sel3Right - sel3Left - handleWidth) + "px";
-						sel3Div.style.height = Math.max(0, sel3Bottom - sel3Top) + "px";
-						if (isPad) {
-							sel3Div.style.borderRight = handleBorder;
-						}
-						if (sel3Top - sel1Bottom > 0) {
-							var sel2Div = this._selDiv2;
-							sel2Div.style.left = (left - hd)  + "px";
-							sel2Div.style.top = (sel1Bottom - vd) + "px";
-							sel2Div.style.width = Math.max(0, right - left) + "px";
-							sel2Div.style.height = Math.max(0, sel3Top - sel1Bottom) + (isPad ? 1 : 0) + "px";
-						}
-					}
+					this._ignoreDOMSelection = true;
+					l = this._getBoundsAtOffset(model.getLineStart(startNode.lineIndex) + startOffset).left;
+					this._ignoreDOMSelection = false;
+				}
+			}
+			var r;
+			var endLineBounds = this._getLineBoundingClientRect(endNode);
+			if (endOffset === 0) {
+				r = endLineBounds.left;
+			} else {
+				if (endOffset >= endLineEnd) {
+					r = endLineBounds.right;
+				} else {
+					this._ignoreDOMSelection = true;
+					r = this._getBoundsAtOffset(model.getLineStart(endNode.lineIndex) + endOffset).left;
+					this._ignoreDOMSelection = false;
+				}
+			}
+			var sel1Div = this._selDiv1;
+			var sel1Left = Math.min(right, Math.max(left, l));
+			var sel1Top = Math.min(bottom, Math.max(top, startLineBounds.top));
+			var sel1Right = right;
+			var sel1Bottom = Math.min(bottom, Math.max(top, startLineBounds.bottom));
+			sel1Div.style.left = (sel1Left - hd) + "px";
+			sel1Div.style.top = (sel1Top - vd) + "px";
+			sel1Div.style.width = Math.max(0, sel1Right - sel1Left) + "px";
+			sel1Div.style.height = Math.max(0, sel1Bottom - sel1Top) + "px";
+			if (startNode === endNode) {
+				sel1Right = Math.min(r, right);
+				sel1Div.style.width = Math.max(0, sel1Right - sel1Left) + "px";
+			} else {
+				var sel3Left = left;
+				var sel3Top = Math.min(bottom, Math.max(top, endLineBounds.top));
+				var sel3Right = Math.min(right, Math.max(left, r));
+				var sel3Bottom = Math.min(bottom, Math.max(top, endLineBounds.bottom));
+				var sel3Div = this._selDiv3;
+				sel3Div.style.left = (sel3Left - hd) + "px";
+				sel3Div.style.top = (sel3Top - vd) + "px";
+				sel3Div.style.width = Math.max(0, sel3Right - sel3Left) + "px";
+				sel3Div.style.height = Math.max(0, sel3Bottom - sel3Top) + "px";
+				if (sel3Top - sel1Bottom > 0) {
+					var sel2Div = this._selDiv2;
+					sel2Div.style.left = (left - hd)  + "px";
+					sel2Div.style.top = (sel1Bottom - vd) + "px";
+					sel2Div.style.width = Math.max(0, right - left) + "px";
+					sel2Div.style.height = Math.max(0, sel3Top - sel1Bottom) + "px";
 				}
 			}
 		},
 		_setGrab: function (target) {
 			if (target === this._grabControl) { return; }
 			if (target) {
 				if (target.setCapture) { target.setCapture(); }
 				this._grabControl = target;
@@ -8747,17 +9464,16 @@ define("orion/textview/textView", ['orio
 			var clientDiv = this._clientDiv;
 			clientDiv.contentEditable = !visible;
 			if (this._hadFocus && !visible) {
 				clientDiv.focus();
 			}
 			if (this._overlayDiv) {
 				this._overlayDiv.style.zIndex = visible ? "-1" : "1";
 			}
-			var document = this._frameDocument;
 			var line = this._getLineNext();
 			while (line) {
 				if (line.hasLink) {
 					var lineChild = line.firstChild;
 					while (lineChild) {
 						var next = lineChild.nextSibling;
 						var style = lineChild.viewStyle;
 						if (style && style.tagName === "A") {
@@ -8847,218 +9563,141 @@ define("orion/textview/textView", ['orio
 					}
 				}
 				selection.setCaret(start);
 				selection.extend(end);
 			} 
 			this._setSelection(selection, true, true);
 			return true;
 		},
-		_setStyleSheet: function(stylesheet) {
-			var oldstylesheet = this._stylesheet;
-			if (!(oldstylesheet instanceof Array)) {
-				oldstylesheet = [oldstylesheet];
-			}
-			this._stylesheet = stylesheet;
-			if (!(stylesheet instanceof Array)) {
-				stylesheet = [stylesheet];
-			}
-			var document = this._frameDocument;
-			var documentStylesheet = document.styleSheets;
-			var head = document.getElementsByTagName("head")[0];
-			var changed = false;
-			var i = 0, sheet, oldsheet, documentSheet, ownerNode, styleNode, textNode;
-			while (i < stylesheet.length) {
-				if (i >= oldstylesheet.length) { break; }
-				sheet = stylesheet[i];
-				oldsheet = oldstylesheet[i];
-				if (sheet !== oldsheet) {
-					if (this._isLinkURL(sheet)) {
-						return true;
-					} else {
-						documentSheet = documentStylesheet[i+1];
-						ownerNode = documentSheet.ownerNode;
-						styleNode = document.createElement('STYLE');
-						textNode = document.createTextNode(sheet);
-						styleNode.appendChild(textNode);
-						head.replaceChild(styleNode, ownerNode);
-						changed = true;
-					}
-				}
-				i++;
-			}
-			if (i < oldstylesheet.length) {
-				while (i < oldstylesheet.length) {
-					sheet = oldstylesheet[i];
-					if (this._isLinkURL(sheet)) {
-						return true;
-					} else {
-						documentSheet = documentStylesheet[i+1];
-						ownerNode = documentSheet.ownerNode;
-						head.removeChild(ownerNode);
-						changed = true;
-					}
-					i++;
-				}
-			} else {
-				while (i < stylesheet.length) {
-					sheet = stylesheet[i];
-					if (this._isLinkURL(sheet)) {
-						return true;
-					} else {
-						styleNode = document.createElement('STYLE');
-						textNode = document.createTextNode(sheet);
-						styleNode.appendChild(textNode);
-						head.appendChild(styleNode);
-						changed = true;
-					}
-					i++;
-				}
-			}
-			if (changed) {
-				this._updateStyle();
-			}
-			return false;
-		},
 		_setFullSelection: function(fullSelection, init) {
 			this._fullSelection = fullSelection;
-			
-			/* 
-			* Bug in IE 8. For some reason, during scrolling IE does not reflow the elements
-			* that are used to compute the location for the selection divs. This causes the
-			* divs to be placed at the wrong location. The fix is to disabled full selection for IE8.
-			*/
-			if (isIE < 9) {
-				this._fullSelection = false;
-			}
 			if (isWebkit) {
 				this._fullSelection = true;
 			}
-			var parent = this._clipDiv || this._scrollDiv;
+			var parent = this._clipDiv || this._rootDiv;
 			if (!parent) {
 				return;
 			}
-			if (!isPad && !this._fullSelection) {
+			if (!this._fullSelection) {
 				if (this._selDiv1) {
 					parent.removeChild(this._selDiv1);
 					this._selDiv1 = null;
 				}
 				if (this._selDiv2) {
 					parent.removeChild(this._selDiv2);
 					this._selDiv2 = null;
 				}
 				if (this._selDiv3) {
 					parent.removeChild(this._selDiv3);
 					this._selDiv3 = null;
 				}
 				return;
 			}
 			
-			if (!this._selDiv1 && (isPad || (this._fullSelection && !isWebkit))) {
-				var frameDocument = this._frameDocument;
+			if (!this._selDiv1 && (this._fullSelection && !isWebkit)) {
 				this._hightlightRGB = "Highlight";
-				var selDiv1 = frameDocument.createElement("DIV");
+				var selDiv1 = document.createElement("DIV");
 				this._selDiv1 = selDiv1;
-				selDiv1.id = "selDiv1";
-				selDiv1.style.position = this._clipDiv ? "absolute" : "fixed";
+				selDiv1.style.position = "absolute";
 				selDiv1.style.borderWidth = "0px";
 				selDiv1.style.margin = "0px";
 				selDiv1.style.padding = "0px";
 				selDiv1.style.outline = "none";
 				selDiv1.style.background = this._hightlightRGB;
 				selDiv1.style.width = "0px";
 				selDiv1.style.height = "0px";
 				selDiv1.style.zIndex = "0";
 				parent.appendChild(selDiv1);
-				var selDiv2 = frameDocument.createElement("DIV");
+				var selDiv2 = document.createElement("DIV");
 				this._selDiv2 = selDiv2;
-				selDiv2.id = "selDiv2";
-				selDiv2.style.position = this._clipDiv ? "absolute" : "fixed";
+				selDiv2.style.position = "absolute";
 				selDiv2.style.borderWidth = "0px";
 				selDiv2.style.margin = "0px";
 				selDiv2.style.padding = "0px";
 				selDiv2.style.outline = "none";
 				selDiv2.style.background = this._hightlightRGB;
 				selDiv2.style.width = "0px";
 				selDiv2.style.height = "0px";
 				selDiv2.style.zIndex = "0";
 				parent.appendChild(selDiv2);
-				var selDiv3 = frameDocument.createElement("DIV");
+				var selDiv3 = document.createElement("DIV");
 				this._selDiv3 = selDiv3;
-				selDiv3.id = "selDiv3";
-				selDiv3.style.position = this._clipDiv ? "absolute" : "fixed";
+				selDiv3.style.position = "absolute";
 				selDiv3.style.borderWidth = "0px";
 				selDiv3.style.margin = "0px";
 				selDiv3.style.padding = "0px";
 				selDiv3.style.outline = "none";
 				selDiv3.style.background = this._hightlightRGB;
 				selDiv3.style.width = "0px";
 				selDiv3.style.height = "0px";
 				selDiv3.style.zIndex = "0";
 				parent.appendChild(selDiv3);
 				
 				/*
 				* Bug in Firefox. The Highlight color is mapped to list selection
 				* background instead of the text selection background.  The fix
 				* is to map known colors using a table or fallback to light blue.
 				*/
 				if (isFirefox && isMac) {
-					var style = this._frameWindow.getComputedStyle(selDiv3, null);
+					var style = window.getComputedStyle(selDiv3, null);
 					var rgb = style.getPropertyValue("background-color");
 					switch (rgb) {
 						case "rgb(119, 141, 168)": rgb = "rgb(199, 208, 218)"; break;
 						case "rgb(127, 127, 127)": rgb = "rgb(198, 198, 198)"; break;
 						case "rgb(255, 193, 31)": rgb = "rgb(250, 236, 115)"; break;
 						case "rgb(243, 70, 72)": rgb = "rgb(255, 176, 139)"; break;
 						case "rgb(255, 138, 34)": rgb = "rgb(255, 209, 129)"; break;
 						case "rgb(102, 197, 71)": rgb = "rgb(194, 249, 144)"; break;
 						case "rgb(140, 78, 184)": rgb = "rgb(232, 184, 255)"; break;
 						default: rgb = "rgb(180, 213, 255)"; break;
 					}
 					this._hightlightRGB = rgb;
 					selDiv1.style.background = rgb;
 					selDiv2.style.background = rgb;
 					selDiv3.style.background = rgb;
 					if (!this._insertedSelRule) {
-						var styleSheet = frameDocument.styleSheets[0];
-						styleSheet.insertRule("::-moz-selection {background: " + rgb + "; }", 0);
+						var stylesheet = document.createElement("STYLE");
+						var head = document.getElementsByTagName("HEAD")[0] || document.documentElement;
+						stylesheet.appendChild(document.createTextNode("::-moz-selection {background: " + rgb + "; }"));
+						head.insertBefore(stylesheet, head.firstChild);
 						this._insertedSelRule = true;
 					}
 				}
 				if (!init) {
 					this._updateDOMSelection();
 				}
 			}
 		},
+		_setReadOnly: function (readOnly) {
+			this._readonly = readOnly;
+			this._clientDiv.setAttribute("aria-readonly", readOnly ? "true" : "false");
+		},
 		_setTabSize: function (tabSize, init) {
 			this._tabSize = tabSize;
 			this._customTabSize = undefined;
 			var clientDiv = this._clientDiv;
 			if (isOpera) {
 				if (clientDiv) { clientDiv.style.OTabSize = this._tabSize+""; }
 			} else if (isFirefox >= 4) {
 				if (clientDiv) {  clientDiv.style.MozTabSize = this._tabSize+""; }
 			} else if (this._tabSize !== 8) {
 				this._customTabSize = this._tabSize;
-				if (!init) {
-					this.redrawLines();
-				}
+			}
+			if (!init) {
+				this.redrawLines();
+				this._resetLineWidth();
 			}
 		},
 		_setThemeClass: function (themeClass, init) {
 			this._themeClass = themeClass;
-			var document = this._frameDocument;
-			if (document) {
-				var viewContainerClass = "viewContainer";
-				if (this._themeClass) { viewContainerClass += " " + this._themeClass; }
-				document.body.className = viewContainerClass;
-				if (!init) {
-					this._updateStyle();
-				}
-			}
+			var viewContainerClass = "textviewContainer";
+			if (this._themeClass) { viewContainerClass += " " + this._themeClass; }
+			this._rootDiv.className = viewContainerClass;
+			this._updateStyle(init);
 		},
 		_showCaret: function (allSelection, pageScroll) {
 			if (!this._clientDiv) { return; }
 			var model = this._model;
 			var selection = this._getSelection();
 			var scroll = this._getScroll();
 			var caret = selection.getCaret();
 			var start = selection.start;
@@ -9160,17 +9799,17 @@ define("orion/textview/textView", ['orio
 			for (var i=0; i<this._handlers.length; i++) {
 				var h = this._handlers[i];
 				removeHandler(h.target, h.type, h.handler);
 			}
 			this._handlers = null;
 		},
 		_updateDOMSelection: function () {
 			if (this._ignoreDOMSelection) { return; }
-			if (!this._clientDiv) { return; }
+			if (!this._clientDiv || !this._hasFocus) { return; }
 			var selection = this._getSelection();
 			var model = this._model;
 			var startLine = model.getLineAtOffset(selection.start);
 			var endLine = model.getLineAtOffset(selection.end);
 			var firstNode = this._getLineNext();
 			/*
 			* Bug in Firefox. For some reason, after a update page sometimes the 
 			* firstChild returns null incorrectly. The fix is to ignore show selection.
@@ -9224,25 +9863,26 @@ define("orion/textview/textView", ['orio
 			var scrollWidth, scrollHeight = lineCount * lineHeight;
 			var leftWidth, clientWidth, clientHeight;
 			if (hScrollOnly) {
 				clientWidth = this._getClientWidth();
 				clientHeight = this._getClientHeight();
 				leftWidth = this._leftDiv ? this._leftDiv.scrollWidth : 0;
 				scrollWidth = Math.max(this._maxLineWidth, clientWidth);
 			} else {
-				var document = this._frameDocument;
-				var frameWidth = this._getFrameWidth();
-				var frameHeight = this._getFrameHeight();
-				document.body.style.width = frameWidth + "px";
-				document.body.style.height = frameHeight + "px";
+				var parent = this._parent;
+				var rootDiv = this._rootDiv;
+				var parentWidth = parent.clientWidth;
+				var parentHeight = parent.clientHeight;
+				rootDiv.style.width = parentWidth + "px";
+				rootDiv.style.height = parentHeight + "px";
 
 				/* Update view height in order to have client height computed */
 				var viewDiv = this._viewDiv;
-				viewDiv.style.height = Math.max(0, (frameHeight - viewPad.top - viewPad.bottom)) + "px";
+				viewDiv.style.height = Math.max(0, (parentHeight - viewPad.top - viewPad.bottom)) + "px";
 				clientHeight = this._getClientHeight();
 				var linesPerPage = Math.floor((clientHeight + partialY) / lineHeight);
 				var bottomIndex = Math.min(topIndex + linesPerPage, lineCount - 1);
 				var lineEnd = Math.min(bottomIndex + 1, lineCount - 1);
 				
 				var lineIndex, lineWidth;
 				var child = clientDiv.firstChild;
 				while (child) {
@@ -9291,17 +9931,17 @@ define("orion/textview/textView", ['orio
 				}
 	
 				var rect;
 				child = this._getLineNext();
 				while (child) {
 					lineWidth = child.lineWidth;
 					if (lineWidth === undefined) {
 						rect = this._getLineBoundingClientRect(child);
-						lineWidth = child.lineWidth = rect.right - rect.left;
+						lineWidth = child.lineWidth = Math.ceil(rect.right - rect.left);
 					}
 					if (lineWidth >= this._maxLineWidth) {
 						this._maxLineWidth = lineWidth;
 						this._maxLineIndex = child.lineIndex;
 					}
 					if (child.lineIndex === topIndex) { this._topChild = child; }
 					if (child.lineIndex === bottomIndex) { this._bottomChild = child; }
 					if (this._checkMaxLineIndex === child.lineIndex) { this._checkMaxLineIndex = -1; }
@@ -9324,19 +9964,19 @@ define("orion/textview/textView", ['orio
 	
 				// Update rulers
 				this._updateRuler(this._leftDiv, topIndex, bottomIndex);
 				this._updateRuler(this._rightDiv, topIndex, bottomIndex);
 				
 				leftWidth = this._leftDiv ? this._leftDiv.scrollWidth : 0;
 				var rightWidth = this._rightDiv ? this._rightDiv.scrollWidth : 0;
 				viewDiv.style.left = leftWidth + "px";
-				viewDiv.style.width = Math.max(0, frameWidth - leftWidth - rightWidth - viewPad.left - viewPad.right) + "px";
+				viewDiv.style.width = Math.max(0, parentWidth - leftWidth - rightWidth - viewPad.left - viewPad.right) + "px";
 				if (this._rightDiv) {
-					this._rightDiv.style.left = (frameWidth - rightWidth) + "px"; 
+					this._rightDiv.style.left = (parentWidth - rightWidth) + "px"; 
 				}
 				/* Need to set the height first in order for the width to consider the vertical scrollbar */
 				var scrollDiv = this._scrollDiv;
 				scrollDiv.style.height = scrollHeight + "px";
 				/*
 				* TODO if frameHeightWithoutHScrollbar < scrollHeight  < frameHeightWithHScrollbar and the horizontal bar is visible, 
 				* then the clientWidth is wrong because the vertical scrollbar is showing. To correct code should hide both scrollbars 
 				* at this point.
@@ -9354,16 +9994,30 @@ define("orion/textview/textView", ['orio
 					this._clipScrollDiv.style.width = width + "px";
 				}
 				/* Get the left scroll after setting the width of the scrollDiv as this can change the horizontal scroll offset. */
 				scroll = this._getScroll();
 				var rulerHeight = clientHeight + viewPad.top + viewPad.bottom;
 				this._updateRulerSize(this._leftDiv, rulerHeight);
 				this._updateRulerSize(this._rightDiv, rulerHeight);
 			}
+			if (this._vScrollDiv) {
+				var trackHeight = clientHeight - 8;
+				var thumbHeight = Math.max(15, Math.ceil(Math.min(1, trackHeight / (scrollHeight + viewPad.top + viewPad.bottom)) * trackHeight));
+				this._vScrollDiv.style.left = (leftWidth + clientWidth - 8) + "px";
+				this._vScrollDiv.style.top = Math.floor(Math.max(0, (scroll.y * trackHeight / scrollHeight))) + "px";
+				this._vScrollDiv.style.height = thumbHeight + "px";
+			}
+			if (this._hScrollDiv) {
+				var trackWidth = clientWidth - 8;
+				var thumbWidth = Math.max(15, Math.ceil(Math.min(1, trackWidth / (this._maxLineWidth + viewPad.left + viewPad.right)) * trackWidth));
+				this._hScrollDiv.style.left = leftWidth + Math.floor(Math.max(0, Math.floor(scroll.x * trackWidth / this._maxLineWidth))) + "px";
+				this._hScrollDiv.style.top = (clientHeight - 9) + "px";
+				this._hScrollDiv.style.width = thumbWidth + "px";
+			}
 			var left = scroll.x;	
 			var clipDiv = this._clipDiv;
 			var overlayDiv = this._overlayDiv;
 			var clipLeft, clipTop;
 			if (clipDiv) {
 				clipDiv.scrollLeft = left;			
 				clipLeft = leftWidth + viewPad.left;
 				clipTop = viewPad.top;
@@ -9438,20 +10092,16 @@ define("orion/textview/textView", ['orio
 			var ensureCaretVisible = this._ensureCaretVisible;
 			this._ensureCaretVisible = false;
 			if (clientHeight !== this._getClientHeight()) {
 				this._updatePage();
 				if (ensureCaretVisible) {
 					this._showCaret();
 				}
 			}
-			if (isPad) {
-				var self = this;
-				setTimeout(function() {self._resizeTouchDiv();}, 0);
-			}
 		},
 		_updateRulerSize: function (divRuler, rulerHeight) {
 			if (!divRuler) { return; }
 			var partialY = this._partialY;
 			var lineHeight = this._getLineHeight();
 			var cells = divRuler.firstChild.rows[0].cells;
 			for (var i = 0; i < cells.length; i++) {
 				var div = cells[i].firstChild;
@@ -9462,32 +10112,31 @@ define("orion/textview/textView", ['orio
 				div = div.nextSibling;
 			}
 			divRuler.style.height = rulerHeight + "px";
 		},
 		_updateRuler: function (divRuler, topIndex, bottomIndex) {
 			if (!divRuler) { return; }
 			var cells = divRuler.firstChild.rows[0].cells;
 			var lineHeight = this._getLineHeight();
-			var parentDocument = this._frameDocument;
 			var viewPad = this._getViewPadding();
 			for (var i = 0; i < cells.length; i++) {
 				var div = cells[i].firstChild;
 				var ruler = div._ruler;
 				if (div.rulerChanged) {
 					this._applyStyle(ruler.getRulerStyle(), div);
 				}
 				
 				var widthDiv;
 				var child = div.firstChild;
 				if (child) {
 					widthDiv = child;
 					child = child.nextSibling;
 				} else {
-					widthDiv = parentDocument.createElement("DIV");
+					widthDiv = document.createElement("DIV");
 					widthDiv.style.visibility = "hidden";
 					div.appendChild(widthDiv);
 				}
 				var lineIndex, annotation;
 				if (div.rulerChanged) {
 					if (widthDiv) {
 						lineIndex = -1;
 						annotation = ruler.getWidestAnnotation();
@@ -9509,102 +10158,104 @@ define("orion/textview/textView", ['orio
 						lineIndex = child.lineIndex;
 						var nextChild = child.nextSibling;
 						if (!(topIndex <= lineIndex && lineIndex <= bottomIndex) || child.lineChanged) {
 							div.removeChild(child);
 						}
 						child = nextChild;
 					}
 					child = div.firstChild.nextSibling;
-					frag = parentDocument.createDocumentFragment();
+					frag = document.createDocumentFragment();
 					for (lineIndex=topIndex; lineIndex<=bottomIndex; lineIndex++) {
 						if (!child || child.lineIndex > lineIndex) {
-							lineDiv = parentDocument.createElement("DIV");
+							lineDiv = document.createElement("DIV");
 							annotation = annotations[lineIndex];
 							if (annotation) {
 								this._applyStyle(annotation.style, lineDiv);
 								if (annotation.html) {
 									lineDiv.innerHTML = annotation.html;
 								}
 								lineDiv.annotation = annotation;
 							}
 							lineDiv.lineIndex = lineIndex;
 							lineDiv.style.height = lineHeight + "px";
 							frag.appendChild(lineDiv);
 						} else {
 							if (frag.firstChild) {
 								div.insertBefore(frag, child);
-								frag = parentDocument.createDocumentFragment();
+								frag = document.createDocumentFragment();
 							}
 							if (child) {
 								child = child.nextSibling;
 							}
 						}
 					}
 					if (frag.firstChild) { div.insertBefore(frag, child); }
 				} else {
-					var buttonHeight = isPad ? 0 : 17;
 					var clientHeight = this._getClientHeight ();
 					var lineCount = this._model.getLineCount ();
 					var contentHeight = lineHeight * lineCount;
-					var trackHeight = clientHeight + viewPad.top + viewPad.bottom - 2 * buttonHeight;
+					var trackHeight = clientHeight + viewPad.top + viewPad.bottom - 2 * scrollButtonHeight;
 					var divHeight;
 					if (contentHeight < trackHeight) {
 						divHeight = lineHeight;
 					} else {
 						divHeight = trackHeight / lineCount;
 					}
 					if (div.rulerChanged) {
 						var count = div.childNodes.length;
 						while (count > 1) {
 							div.removeChild(div.lastChild);
 							count--;
 						}
 						annotations = ruler.getAnnotations(0, lineCount);
-						frag = parentDocument.createDocumentFragment();
+						frag = document.createDocumentFragment();
 						for (var prop in annotations) {
 							lineIndex = prop >>> 0;
 							if (lineIndex < 0) { continue; }
-							lineDiv = parentDocument.createElement("DIV");
+							lineDiv = document.createElement("DIV");
 							annotation = annotations[prop];
 							this._applyStyle(annotation.style, lineDiv);
 							lineDiv.style.position = "absolute";
-							lineDiv.style.top = buttonHeight + lineHeight + Math.floor(lineIndex * divHeight) + "px";
+							lineDiv.style.top = scrollButtonHeight + lineHeight + Math.floor(lineIndex * divHeight) + "px";
 							if (annotation.html) {
 								lineDiv.innerHTML = annotation.html;
 							}
 							lineDiv.annotation = annotation;
 							lineDiv.lineIndex = lineIndex;
 							frag.appendChild(lineDiv);
 						}
 						div.appendChild(frag);
 					} else if (div._oldTrackHeight !== trackHeight) {
 						lineDiv = div.firstChild ? div.firstChild.nextSibling : null;
 						while (lineDiv) {
-							lineDiv.style.top = buttonHeight + lineHeight + Math.floor(lineDiv.lineIndex * divHeight) + "px";
+							lineDiv.style.top = scrollButtonHeight + lineHeight + Math.floor(lineDiv.lineIndex * divHeight) + "px";
 							lineDiv = lineDiv.nextSibling;
 						}
 					}
 					div._oldTrackHeight = trackHeight;
 				}
 				div.rulerChanged = false;
 				div = div.nextSibling;
 			}
 		},
-		_updateStyle: function () {
-			var document = this._frameDocument;
+		_updateStyle: function (init) {
+			if (!init && isIE) {
+				this._rootDiv.style.lineHeight = "normal";
+			}
+			var metrics = this._metrics = this._calculateMetrics();
 			if (isIE) {
-				document.body.style.lineHeight = "normal";
-			}
-			this._lineHeight = this._calculateLineHeight();
-			this._viewPadding = this._calculatePadding();
-			if (isIE) {
-				document.body.style.lineHeight = this._lineHeight + "px";
-			}
-			this.redraw();
+				this._rootDiv.style.lineHeight = (metrics.lineHeight - (metrics.lineTrim.top + metrics.lineTrim.bottom)) + "px";
+			} else {
+				this._rootDiv.style.lineHeight = "normal";
+			}
+			if (!init) {
+				this.redraw();
+				this._resetLineWidth();
+			}
 		}
 	};//end prototype
 	mEventTarget.EventTarget.addMixin(TextView.prototype);
 	
 	return {TextView: TextView};
 });
 
 /*******************************************************************************
@@ -9615,16 +10266,1255 @@ define("orion/textview/textView", ['orio
  * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
  * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
  * 
  * Contributors: 
  *		Felipe Heidrich (IBM Corporation) - initial API and implementation
  *		Silenio Quarti (IBM Corporation) - initial API and implementation
  ******************************************************************************/
  
+/*global define window*/
+
+define("orion/textview/textModel", ['orion/textview/eventTarget'], function(mEventTarget) {
+	var isWindows = window.navigator.platform.indexOf("Win") !== -1;
+
+	/**
+	 * Constructs a new TextModel with the given text and default line delimiter.
+	 *
+	 * @param {String} [text=""] the text that the model will store
+	 * @param {String} [lineDelimiter=platform delimiter] the line delimiter used when inserting new lines to the model.
+	 *
+	 * @name orion.textview.TextModel
+	 * @class The TextModel is an interface that provides text for the view. Applications may
+	 * implement the TextModel interface to provide a custom store for the view content. The
+	 * view interacts with its text model in order to access and update the text that is being
+	 * displayed and edited in the view. This is the default implementation.
+	 * <p>
+	 * <b>See:</b><br/>
+	 * {@link orion.textview.TextView}<br/>
+	 * {@link orion.textview.TextView#setModel}
+	 * </p>
+	 * @borrows orion.textview.EventTarget#addEventListener as #addEventListener
+	 * @borrows orion.textview.EventTarget#removeEventListener as #removeEventListener
+	 * @borrows orion.textview.EventTarget#dispatchEvent as #dispatchEvent
+	 */
+	function TextModel(text, lineDelimiter) {
+		this._lastLineIndex = -1;
+		this._text = [""];
+		this._lineOffsets = [0];
+		this.setText(text);
+		this.setLineDelimiter(lineDelimiter);
+	}
+
+	TextModel.prototype = /** @lends orion.textview.TextModel.prototype */ {
+		/**
+		 * @class This object describes the options to use while finding occurrences of a string in a text model.
+		 * @name orion.textview.FindOptions
+		 *
+		 * @property {String} string the search string to be found.
+		 * @property {Boolean} [regex=false] whether or not the search string is a regular expression.
+		 * @property {Boolean} [wrap=false] whether or not to wrap search.
+		 * @property {Boolean} [wholeWord=false] whether or not to search only whole words.
+		 * @property {Boolean} [caseInsensitive=false] whether or not search is case insensitive.
+		 * @property {Boolean} [reverse=false] whether or not to search backwards.
+		 * @property {Number} [start=0] The start offset to start searching
+		 * @property {Number} [end=charCount] The end offset of the search. Used to search in a given range.
+		 */
+		/**
+		 * @class This object represents a find occurrences iterator.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link orion.textview.TextModel#find}<br/>
+		 * </p>		 
+		 * @name orion.textview.FindIterator
+		 * 
+		 * @property {Function} hasNext Determines whether there are more occurrences in the iterator.
+		 * @property {Function} next Returns the next matched range {start,end} in the iterator.
+		 */	
+		/**
+		 * Finds occurrences of a string in the text model.
+		 *
+		 * @param {orion.textview.FindOptions} options the search options
+		 * @return {orion.textview.FindIterator} the find occurrences iterator.
+		 */
+		find: function(options) {
+			if (this._text.length > 1) {
+				this._text = [this._text.join("")];
+			}
+			var string = options.string;
+			var regex = options.regex;
+			var pattern = string;
+			if (!regex && string) {
+				pattern = string.replace(/([\\$\^*\/+?\.\(\)|{}\[\]])/g, "\\$&");
+			}
+			var current = null, skip;
+			if (pattern) {
+				var reverse = options.reverse;
+				var wrap = options.wrap;
+				var wholeWord = options.wholeWord;
+				var caseInsensitive = options.caseInsensitive;
+				var start = options.start || 0;
+				var end = options.end;
+				var isRange = options.end !== undefined;
+				var flags = "";
+				if (flags.indexOf("g") === -1) { flags += "g"; }
+				if (caseInsensitive) {
+					if (flags.indexOf("i") === -1) { flags += "i"; }
+				}
+				if (wholeWord) {
+					pattern = "\\b" + pattern + "\\b";
+				}
+				var text = this._text[0], result, lastIndex, offset = 0;
+				if (isRange) {
+					text = text.substring(start, end);
+					offset = start;
+				}
+				var re = new RegExp(pattern, flags);
+				if (reverse) {
+					skip = function() {
+						var match = null;
+						re.lastIndex = 0;
+						while (true) {
+							lastIndex = re.lastIndex;
+							result = re.exec(text);
+							if (lastIndex === re.lastIndex) {
+								return null;
+							}
+							if (result) {
+								if (result.index < start) {
+									match = {start: result.index + offset, end: re.lastIndex + offset};
+								} else {
+									if (!wrap || match) {
+										break;
+									}
+									start = text.length;
+									match = {start: result.index + offset, end: re.lastIndex + offset};
+								}
+							} else {
+								break;
+							}
+						}
+						if (match) { start = match.start; }
+						return match;
+					};
+				} else {
+					if (!isRange) {
+						re.lastIndex = start;
+					}
+					skip = function() {
+						while (true) {
+							lastIndex = re.lastIndex;
+							result = re.exec(text);
+							if (lastIndex === re.lastIndex) {
+								return null;
+							}
+							if (result) {
+								return {start: result.index + offset, end: re.lastIndex + offset};
+							}
+							if (lastIndex !== 0) {
+								if (wrap) {
+									continue;
+								}
+							}
+							break;
+						}
+						return null;
+					};
+				}
+				current = skip();
+			}
+			return {
+				next: function() {
+					var result = current;
+					if (result) { current = skip(); }
+					return result;					
+				},
+				hasNext: function() {
+					return current !== null;
+				}
+			};
+		},
+		/**
+		 * Returns the number of characters in the model.
+		 *
+		 * @returns {Number} the number of characters in the model.
+		 */
+		getCharCount: function() {
+			var count = 0;
+			for (var i = 0; i<this._text.length; i++) {
+				count += this._text[i].length;
+			}
+			return count;
+		},
+		/**
+		 * Returns the text of the line at the given index.
+		 * <p>
+		 * The valid indices are 0 to line count exclusive.  Returns <code>null</code> 
+		 * if the index is out of range. 
+		 * </p>
+		 *
+		 * @param {Number} lineIndex the zero based index of the line.
+		 * @param {Boolean} [includeDelimiter=false] whether or not to include the line delimiter. 
+		 * @returns {String} the line text or <code>null</code> if out of range.
+		 *
+		 * @see #getLineAtOffset
+		 */
+		getLine: function(lineIndex, includeDelimiter) {
+			var lineCount = this.getLineCount();
+			if (!(0 <= lineIndex && lineIndex < lineCount)) {
+				return null;
+			}
+			var start = this._lineOffsets[lineIndex];
+			if (lineIndex + 1 < lineCount) {
+				var text = this.getText(start, this._lineOffsets[lineIndex + 1]);
+				if (includeDelimiter) {
+					return text;
+				}
+				var end = text.length, c;
+				while (((c = text.charCodeAt(end - 1)) === 10) || (c === 13)) {
+					end--;
+				}
+				return text.substring(0, end);
+			} else {
+				return this.getText(start); 
+			}
+		},
+		/**
+		 * Returns the line index at the given character offset.
+		 * <p>
+		 * The valid offsets are 0 to char count inclusive. The line index for
+		 * char count is <code>line count - 1</code>. Returns <code>-1</code> if
+		 * the offset is out of range.
+		 * </p>
+		 *
+		 * @param {Number} offset a character offset.
+		 * @returns {Number} the zero based line index or <code>-1</code> if out of range.
+		 */
+		getLineAtOffset: function(offset) {
+			var charCount = this.getCharCount();
+			if (!(0 <= offset && offset <= charCount)) {
+				return -1;
+			}
+			var lineCount = this.getLineCount();
+			if (offset === charCount) {
+				return lineCount - 1; 
+			}
+			var lineStart, lineEnd;
+			var index = this._lastLineIndex;
+			if (0 <= index && index < lineCount) {
+				lineStart = this._lineOffsets[index];
+				lineEnd = index + 1 < lineCount ? this._lineOffsets[index + 1] : charCount;
+				if (lineStart <= offset && offset < lineEnd) {
+					return index;
+				}
+			}
+			var high = lineCount;
+			var low = -1;
+			while (high - low > 1) {
+				index = Math.floor((high + low) / 2);
+				lineStart = this._lineOffsets[index];
+				lineEnd = index + 1 < lineCount ? this._lineOffsets[index + 1] : charCount;
+				if (offset <= lineStart) {
+					high = index;
+				} else if (offset < lineEnd) {
+					high = index;
+					break;
+				} else {
+					low = index;
+				}
+			}
+			this._lastLineIndex = high;
+			return high;
+		},
+		/**
+		 * Returns the number of lines in the model.
+		 * <p>
+		 * The model always has at least one line.
+		 * </p>
+		 *
+		 * @returns {Number} the number of lines.
+		 */
+		getLineCount: function() {
+			return this._lineOffsets.length;
+		},
+		/**
+		 * Returns the line delimiter that is used by the view
+		 * when inserting new lines. New lines entered using key strokes 
+		 * and paste operations use this line delimiter.
+		 *
+		 * @return {String} the line delimiter that is used by the view when inserting new lines.
+		 */
+		getLineDelimiter: function() {
+			return this._lineDelimiter;
+		},
+		/**
+		 * Returns the end character offset for the given line. 
+		 * <p>
+		 * The end offset is not inclusive. This means that when the line delimiter is included, the 
+		 * offset is either the start offset of the next line or char count. When the line delimiter is
+		 * not included, the offset is the offset of the line delimiter.
+		 * </p>
+		 * <p>
+		 * The valid indices are 0 to line count exclusive.  Returns <code>-1</code> 
+		 * if the index is out of range. 
+		 * </p>
+		 *
+		 * @param {Number} lineIndex the zero based index of the line.
+		 * @param {Boolean} [includeDelimiter=false] whether or not to include the line delimiter. 
+		 * @return {Number} the line end offset or <code>-1</code> if out of range.
+		 *
+		 * @see #getLineStart
+		 */
+		getLineEnd: function(lineIndex, includeDelimiter) {
+			var lineCount = this.getLineCount();
+			if (!(0 <= lineIndex && lineIndex < lineCount)) {
+				return -1;
+			}
+			if (lineIndex + 1 < lineCount) {
+				var end = this._lineOffsets[lineIndex + 1];
+				if (includeDelimiter) {
+					return end;
+				}
+				var text = this.getText(Math.max(this._lineOffsets[lineIndex], end - 2), end);
+				var i = text.length, c;
+				while (((c = text.charCodeAt(i - 1)) === 10) || (c === 13)) {
+					i--;
+				}
+				return end - (text.length - i);
+			} else {
+				return this.getCharCount();
+			}
+		},
+		/**
+		 * Returns the start character offset for the given line.
+		 * <p>
+		 * The valid indices are 0 to line count exclusive.  Returns <code>-1</code> 
+		 * if the index is out of range. 
+		 * </p>
+		 *
+		 * @param {Number} lineIndex the zero based index of the line.
+		 * @return {Number} the line start offset or <code>-1</code> if out of range.
+		 *
+		 * @see #getLineEnd
+		 */
+		getLineStart: function(lineIndex) {
+			if (!(0 <= lineIndex && lineIndex < this.getLineCount())) {
+				return -1;
+			}
+			return this._lineOffsets[lineIndex];
+		},
+		/**
+		 * Returns the text for the given range.
+		 * <p>
+		 * The end offset is not inclusive. This means that character at the end offset
+		 * is not included in the returned text.
+		 * </p>
+		 *
+		 * @param {Number} [start=0] the zero based start offset of text range.
+		 * @param {Number} [end=char count] the zero based end offset of text range.
+		 *
+		 * @see #setText
+		 */
+		getText: function(start, end) {
+			if (start === undefined) { start = 0; }
+			if (end === undefined) { end = this.getCharCount(); }
+			if (start === end) { return ""; }
+			var offset = 0, chunk = 0, length;
+			while (chunk<this._text.length) {
+				length = this._text[chunk].length; 
+				if (start <= offset + length) { break; }
+				offset += length;
+				chunk++;
+			}
+			var firstOffset = offset;
+			var firstChunk = chunk;
+			while (chunk<this._text.length) {
+				length = this._text[chunk].length; 
+				if (end <= offset + length) { break; }
+				offset += length;
+				chunk++;
+			}
+			var lastOffset = offset;
+			var lastChunk = chunk;
+			if (firstChunk === lastChunk) {
+				return this._text[firstChunk].substring(start - firstOffset, end - lastOffset);
+			}
+			var beforeText = this._text[firstChunk].substring(start - firstOffset);
+			var afterText = this._text[lastChunk].substring(0, end - lastOffset);
+			return beforeText + this._text.slice(firstChunk+1, lastChunk).join("") + afterText; 
+		},
+		/**
+		 * Notifies all listeners that the text is about to change.
+		 * <p>
+		 * This notification is intended to be used only by the view. Application clients should
+		 * use {@link orion.textview.TextView#event:onModelChanging}.
+		 * </p>
+		 * <p>
+		 * NOTE: This method is not meant to called directly by application code. It is called internally by the TextModel
+		 * as part of the implementation of {@link #setText}. This method is included in the public API for documentation
+		 * purposes and to allow integration with other toolkit frameworks.
+		 * </p>
+		 *
+		 * @param {orion.textview.ModelChangingEvent} modelChangingEvent the changing event
+		 */
+		onChanging: function(modelChangingEvent) {
+			return this.dispatchEvent(modelChangingEvent);
+		},
+		/**
+		 * Notifies all listeners that the text has changed.
+		 * <p>
+		 * This notification is intended to be used only by the view. Application clients should
+		 * use {@link orion.textview.TextView#event:onModelChanged}.
+		 * </p>
+		 * <p>
+		 * NOTE: This method is not meant to called directly by application code. It is called internally by the TextModel
+		 * as part of the implementation of {@link #setText}. This method is included in the public API for documentation
+		 * purposes and to allow integration with other toolkit frameworks.
+		 * </p>
+		 *
+		 * @param {orion.textview.ModelChangedEvent} modelChangedEvent the changed event
+		 */
+		onChanged: function(modelChangedEvent) {
+			return this.dispatchEvent(modelChangedEvent);
+		},
+		/**
+		 * Sets the line delimiter that is used by the view
+		 * when new lines are inserted in the model due to key
+		 * strokes  and paste operations.
+		 * <p>
+		 * If lineDelimiter is "auto", the delimiter is computed to be
+		 * the first delimiter found the in the current text. If lineDelimiter
+		 * is undefined or if there are no delimiters in the current text, the
+		 * platform delimiter is used.
+		 * </p>
+		 *
+		 * @param {String} lineDelimiter the line delimiter that is used by the view when inserting new lines.
+		 */
+		setLineDelimiter: function(lineDelimiter) {
+			if (lineDelimiter === "auto") {
+				lineDelimiter = undefined;
+				if (this.getLineCount() > 1) {
+					lineDelimiter = this.getText(this.getLineEnd(0), this.getLineEnd(0, true));
+				}
+			}
+			this._lineDelimiter = lineDelimiter ? lineDelimiter : (isWindows ? "\r\n" : "\n"); 
+		},
+		/**
+		 * Replaces the text in the given range with the given text.
+		 * <p>
+		 * The end offset is not inclusive. This means that the character at the 
+		 * end offset is not replaced.
+		 * </p>
+		 * <p>
+		 * The text model must notify the listeners before and after the
+		 * the text is changed by calling {@link #onChanging} and {@link #onChanged}
+		 * respectively. 
+		 * </p>
+		 *
+		 * @param {String} [text=""] the new text.
+		 * @param {Number} [start=0] the zero based start offset of text range.
+		 * @param {Number} [end=char count] the zero based end offset of text range.
+		 *
+		 * @see #getText
+		 */
+		setText: function(text, start, end) {
+			if (text === undefined) { text = ""; }
+			if (start === undefined) { start = 0; }
+			if (end === undefined) { end = this.getCharCount(); }
+			if (start === end && text === "") { return; }
+			var startLine = this.getLineAtOffset(start);
+			var endLine = this.getLineAtOffset(end);
+			var eventStart = start;
+			var removedCharCount = end - start;
+			var removedLineCount = endLine - startLine;
+			var addedCharCount = text.length;
+			var addedLineCount = 0;
+			var lineCount = this.getLineCount();
+			
+			var cr = 0, lf = 0, index = 0;
+			var newLineOffsets = [];
+			while (true) {
+				if (cr !== -1 && cr <= index) { cr = text.indexOf("\r", index); }
+				if (lf !== -1 && lf <= index) { lf = text.indexOf("\n", index); }
+				if (lf === -1 && cr === -1) { break; }
+				if (cr !== -1 && lf !== -1) {
+					if (cr + 1 === lf) {
+						index = lf + 1;
+					} else {
+						index = (cr < lf ? cr : lf) + 1;
+					}
+				} else if (cr !== -1) {
+					index = cr + 1;
+				} else {
+					index = lf + 1;
+				}
+				newLineOffsets.push(start + index);
+				addedLineCount++;
+			}
+		
+			var modelChangingEvent = {
+				type: "Changing",
+				text: text,
+				start: eventStart,
+				removedCharCount: removedCharCount,
+				addedCharCount: addedCharCount,
+				removedLineCount: removedLineCount,
+				addedLineCount: addedLineCount
+			};
+			this.onChanging(modelChangingEvent);
+			
+			//TODO this should be done the loops below to avoid getText()
+			if (newLineOffsets.length === 0) {
+				var startLineOffset = this.getLineStart(startLine), endLineOffset;
+				if (endLine + 1 < lineCount) {
+					endLineOffset = this.getLineStart(endLine + 1);
+				} else {
+					endLineOffset = this.getCharCount();
+				}
+				if (start !== startLineOffset) {
+					text = this.getText(startLineOffset, start) + text;
+					start = startLineOffset;
+				}
+				if (end !== endLineOffset) {
+					text = text + this.getText(end, endLineOffset);
+					end = endLineOffset;
+				}
+			}
+			
+			var changeCount = addedCharCount - removedCharCount;
+			for (var j = startLine + removedLineCount + 1; j < lineCount; j++) {
+				this._lineOffsets[j] += changeCount;
+			}
+			var args = [startLine + 1, removedLineCount].concat(newLineOffsets);
+			Array.prototype.splice.apply(this._lineOffsets, args);
+			
+			var offset = 0, chunk = 0, length;
+			while (chunk<this._text.length) {
+				length = this._text[chunk].length; 
+				if (start <= offset + length) { break; }
+				offset += length;
+				chunk++;
+			}
+			var firstOffset = offset;
+			var firstChunk = chunk;
+			while (chunk<this._text.length) {
+				length = this._text[chunk].length; 
+				if (end <= offset + length) { break; }
+				offset += length;
+				chunk++;
+			}
+			var lastOffset = offset;
+			var lastChunk = chunk;
+			var firstText = this._text[firstChunk];
+			var lastText = this._text[lastChunk];
+			var beforeText = firstText.substring(0, start - firstOffset);
+			var afterText = lastText.substring(end - lastOffset);
+			var params = [firstChunk, lastChunk - firstChunk + 1];
+			if (beforeText) { params.push(beforeText); }
+			if (text) { params.push(text); }
+			if (afterText) { params.push(afterText); }
+			Array.prototype.splice.apply(this._text, params);
+			if (this._text.length === 0) { this._text = [""]; }
+			
+			var modelChangedEvent = {
+				type: "Changed",
+				start: eventStart,
+				removedCharCount: removedCharCount,
+				addedCharCount: addedCharCount,
+				removedLineCount: removedLineCount,
+				addedLineCount: addedLineCount
+			};
+			this.onChanged(modelChangedEvent);
+		}
+	};
+	mEventTarget.EventTarget.addMixin(TextModel.prototype);
+	
+	return {TextModel: TextModel};
+});/*******************************************************************************
+ * @license
+ * Copyright (c) 2010, 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials are made 
+ * available under the terms of the Eclipse Public License v1.0 
+ * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
+ * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
+ * 
+ * Contributors: 
+ *		Felipe Heidrich (IBM Corporation) - initial API and implementation
+ *		Silenio Quarti (IBM Corporation) - initial API and implementation
+ ******************************************************************************/
+
+/*global window define */
+
+define("orion/textview/keyBinding", [], function() {
+	var isMac = window.navigator.platform.indexOf("Mac") !== -1;
+
+	/**
+	 * Constructs a new key binding with the given key code and modifiers.
+	 * 
+	 * @param {String|Number} keyCode the key code.
+	 * @param {Boolean} mod1 the primary modifier (usually Command on Mac and Control on other platforms).
+	 * @param {Boolean} mod2 the secondary modifier (usually Shift).
+	 * @param {Boolean} mod3 the third modifier (usually Alt).
+	 * @param {Boolean} mod4 the fourth modifier (usually Control on the Mac).
+	 * 
+	 * @class A KeyBinding represents of a key code and a modifier state that can be triggered by the user using the keyboard.
+	 * @name orion.textview.KeyBinding
+	 * 
+	 * @property {String|Number} keyCode The key code.
+	 * @property {Boolean} mod1 The primary modifier (usually Command on Mac and Control on other platforms).
+	 * @property {Boolean} mod2 The secondary modifier (usually Shift).
+	 * @property {Boolean} mod3 The third modifier (usually Alt).
+	 * @property {Boolean} mod4 The fourth modifier (usually Control on the Mac).
+	 *
+	 * @see orion.textview.TextView#setKeyBinding
+	 */
+	function KeyBinding (keyCode, mod1, mod2, mod3, mod4) {
+		if (typeof(keyCode) === "string") {
+			this.keyCode = keyCode.toUpperCase().charCodeAt(0);
+		} else {
+			this.keyCode = keyCode;
+		}
+		this.mod1 = mod1 !== undefined && mod1 !== null ? mod1 : false;
+		this.mod2 = mod2 !== undefined && mod2 !== null ? mod2 : false;
+		this.mod3 = mod3 !== undefined && mod3 !== null ? mod3 : false;
+		this.mod4 = mod4 !== undefined && mod4 !== null ? mod4 : false;
+	}
+	KeyBinding.prototype = /** @lends orion.textview.KeyBinding.prototype */ {
+		/**
+		 * Returns whether this key binding matches the given key event.
+		 * 
+		 * @param e the key event.
+		 * @returns {Boolean} <code>true</code> whether the key binding matches the key event.
+		 */
+		match: function (e) {
+			if (this.keyCode === e.keyCode) {
+				var mod1 = isMac ? e.metaKey : e.ctrlKey;
+				if (this.mod1 !== mod1) { return false; }
+				if (this.mod2 !== e.shiftKey) { return false; }
+				if (this.mod3 !== e.altKey) { return false; }
+				if (isMac && this.mod4 !== e.ctrlKey) { return false; }
+				return true;
+			}
+			return false;
+		},
+		/**
+		 * Returns whether this key binding is the same as the given parameter.
+		 * 
+		 * @param {orion.textview.KeyBinding} kb the key binding to compare with.
+		 * @returns {Boolean} whether or not the parameter and the receiver describe the same key binding.
+		 */
+		equals: function(kb) {
+			if (!kb) { return false; }
+			if (this.keyCode !== kb.keyCode) { return false; }
+			if (this.mod1 !== kb.mod1) { return false; }
+			if (this.mod2 !== kb.mod2) { return false; }
+			if (this.mod3 !== kb.mod3) { return false; }
+			if (this.mod4 !== kb.mod4) { return false; }
+			return true;
+		} 
+	};
+	return {KeyBinding: KeyBinding};
+});
+/*******************************************************************************
+ * @license
+ * Copyright (c) 2010, 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials are made 
+ * available under the terms of the Eclipse Public License v1.0 
+ * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
+ * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
+ * 
+ * Contributors: 
+ *		Felipe Heidrich (IBM Corporation) - initial API and implementation
+ *		Silenio Quarti (IBM Corporation) - initial API and implementation
+ ******************************************************************************/
+
+/*global define */
+
+define("orion/textview/projectionTextModel", ['orion/textview/textModel', 'orion/textview/eventTarget'], function(mTextModel, mEventTarget) {
+
+	/**
+	 * @class This object represents a projection range. A projection specifies a
+	 * range of text and the replacement text. The range of text is relative to the
+	 * base text model associated to a projection model.
+	 * <p>
+	 * <b>See:</b><br/>
+	 * {@link orion.textview.ProjectionTextModel}<br/>
+	 * {@link orion.textview.ProjectionTextModel#addProjection}<br/>
+	 * </p>		 
+	 * @name orion.textview.Projection
+	 * 
+	 * @property {Number} start The start offset of the projection range. 
+	 * @property {Number} end The end offset of the projection range. This offset is exclusive.
+	 * @property {String|orion.textview.TextModel} [text=""] The projection text to be inserted
+	 */
+	/**
+	 * Constructs a new <code>ProjectionTextModel</code> based on the specified <code>TextModel</code>.
+	 *
+	 * @param {orion.textview.TextModel} baseModel The base text model.
+	 *
+	 * @name orion.textview.ProjectionTextModel
+	 * @class The <code>ProjectionTextModel</code> represents a projection of its base text
+	 * model. Projection ranges can be added to the projection text model to hide and/or insert
+	 * ranges to the base text model.
+	 * <p>
+	 * The contents of the projection text model is modified when changes occur in the base model,
+	 * projection model or by calls to {@link #addProjection} and {@link #removeProjection}.
+	 * </p>
+	 * <p>
+	 * <b>See:</b><br/>
+	 * {@link orion.textview.TextView}<br/>
+	 * {@link orion.textview.TextModel}
+	 * {@link orion.textview.TextView#setModel}
+	 * </p>
+	 * @borrows orion.textview.EventTarget#addEventListener as #addEventListener
+	 * @borrows orion.textview.EventTarget#removeEventListener as #removeEventListener
+	 * @borrows orion.textview.EventTarget#dispatchEvent as #dispatchEvent
+	 */
+	function ProjectionTextModel(baseModel) {
+		this._model = baseModel;	/* Base Model */
+		this._projections = [];
+	}
+
+	ProjectionTextModel.prototype = /** @lends orion.textview.ProjectionTextModel.prototype */ {
+		/**
+		 * Adds a projection range to the model.
+		 * <p>
+		 * The model must notify the listeners before and after the the text is
+		 * changed by calling {@link #onChanging} and {@link #onChanged} respectively. 
+		 * </p>
+		 * @param {orion.textview.Projection} projection The projection range to be added.
+		 * 
+		 * @see #removeProjection
+		 */
+		addProjection: function(projection) {
+			if (!projection) {return;}
+			//start and end can't overlap any exist projection
+			var model = this._model, projections = this._projections;
+			projection._lineIndex = model.getLineAtOffset(projection.start);
+			projection._lineCount = model.getLineAtOffset(projection.end) - projection._lineIndex;
+			var text = projection.text;
+			if (!text) { text = ""; }
+			if (typeof text === "string") {
+				projection._model = new mTextModel.TextModel(text, model.getLineDelimiter());
+			} else {
+				projection._model = text;
+			}
+			var eventStart = this.mapOffset(projection.start, true);
+			var removedCharCount = projection.end - projection.start;
+			var removedLineCount = projection._lineCount;
+			var addedCharCount = projection._model.getCharCount();
+			var addedLineCount = projection._model.getLineCount() - 1;
+			var modelChangingEvent = {
+				type: "Changing",
+				text: projection._model.getText(),
+				start: eventStart,
+				removedCharCount: removedCharCount,
+				addedCharCount: addedCharCount,
+				removedLineCount: removedLineCount,
+				addedLineCount: addedLineCount
+			};
+			this.onChanging(modelChangingEvent);
+			var index = this._binarySearch(projections, projection.start);
+			projections.splice(index, 0, projection);
+			var modelChangedEvent = {
+				type: "Changed",
+				start: eventStart,
+				removedCharCount: removedCharCount,
+				addedCharCount: addedCharCount,
+				removedLineCount: removedLineCount,
+				addedLineCount: addedLineCount
+			};
+			this.onChanged(modelChangedEvent);
+		},
+		/**
+		 * Returns all projection ranges of this model.
+		 * 
+		 * @return {orion.textview.Projection[]} The projection ranges.
+		 * 
+		 * @see #addProjection
+		 */
+		getProjections: function() {
+			return this._projections.slice(0);
+		},
+		/**
+		 * Gets the base text model.
+		 *
+		 * @return {orion.textview.TextModel} The base text model.
+		 */
+		getBaseModel: function() {
+			return this._model;
+		},
+		/**
+		 * Maps offsets between the projection model and its base model.
+		 *
+		 * @param {Number} offset The offset to be mapped.
+		 * @param {Boolean} [baseOffset=false] <code>true</code> if <code>offset</code> is in base model and
+		 *	should be mapped to the projection model.
+		 * @return {Number} The mapped offset
+		 */
+		mapOffset: function(offset, baseOffset) {
+			var projections = this._projections, delta = 0, i, projection;
+			if (baseOffset) {
+				for (i = 0; i < projections.length; i++) {
+					projection = projections[i];
+					if (projection.start > offset) { break; }
+					if (projection.end > offset) { return -1; }
+					delta += projection._model.getCharCount() - (projection.end - projection.start);
+				}
+				return offset + delta;
+			}
+			for (i = 0; i < projections.length; i++) {
+				projection = projections[i];
+				if (projection.start > offset - delta) { break; }
+				var charCount = projection._model.getCharCount();
+				if (projection.start + charCount > offset - delta) {
+					return -1;
+				}
+				delta += charCount - (projection.end - projection.start);
+			}
+			return offset - delta;
+		},
+		/**
+		 * Removes a projection range from the model.
+		 * <p>
+		 * The model must notify the listeners before and after the the text is
+		 * changed by calling {@link #onChanging} and {@link #onChanged} respectively. 
+		 * </p>
+		 * 
+		 * @param {orion.textview.Projection} projection The projection range to be removed.
+		 * 
+		 * @see #addProjection
+		 */
+		removeProjection: function(projection) {
+			//TODO remove listeners from model
+			var i, delta = 0;
+			for (i = 0; i < this._projections.length; i++) {
+				var p = this._projections[i];
+				if (p === projection) {
+					projection = p;
+					break;
+				}
+				delta += p._model.getCharCount() - (p.end - p.start);
+			}
+			if (i < this._projections.length) {
+				var model = this._model;
+				var eventStart = projection.start + delta;
+				var addedCharCount = projection.end - projection.start;
+				var addedLineCount = projection._lineCount;
+				var removedCharCount = projection._model.getCharCount();
+				var removedLineCount = projection._model.getLineCount() - 1;
+				var modelChangingEvent = {
+					type: "Changing",
+					text: model.getText(projection.start, projection.end),
+					start: eventStart,
+					removedCharCount: removedCharCount,
+					addedCharCount: addedCharCount,
+					removedLineCount: removedLineCount,
+					addedLineCount: addedLineCount
+				};
+				this.onChanging(modelChangingEvent);
+				this._projections.splice(i, 1);
+				var modelChangedEvent = {
+					type: "Changed",
+					start: eventStart,
+					removedCharCount: removedCharCount,
+					addedCharCount: addedCharCount,
+					removedLineCount: removedLineCount,
+					addedLineCount: addedLineCount
+				};
+				this.onChanged(modelChangedEvent);
+			}
+		},
+		/** @ignore */
+		_binarySearch: function (array, offset) {
+			var high = array.length, low = -1, index;
+			while (high - low > 1) {
+				index = Math.floor((high + low) / 2);
+				if (offset <= array[index].start) {
+					high = index;
+				} else {
+					low = index;
+				}
+			}
+			return high;
+		},
+		/**
+		 * @see orion.textview.TextModel#getCharCount
+		 */
+		getCharCount: function() {
+			var count = this._model.getCharCount(), projections = this._projections;
+			for (var i = 0; i < projections.length; i++) {
+				var projection = projections[i];
+				count += projection._model.getCharCount() - (projection.end - projection.start);
+			}
+			return count;
+		},
+		/**
+		 * @see orion.textview.TextModel#getLine
+		 */
+		getLine: function(lineIndex, includeDelimiter) {
+			if (lineIndex < 0) { return null; }
+			var model = this._model, projections = this._projections;
+			var delta = 0, result = [], offset = 0, i, lineCount, projection;
+			for (i = 0; i < projections.length; i++) {
+				projection = projections[i];
+				if (projection._lineIndex >= lineIndex - delta) { break; }
+				lineCount = projection._model.getLineCount() - 1;
+				if (projection._lineIndex + lineCount >= lineIndex - delta) {
+					var projectionLineIndex = lineIndex - (projection._lineIndex + delta);
+					if (projectionLineIndex < lineCount) {
+						return projection._model.getLine(projectionLineIndex, includeDelimiter);
+					} else {
+						result.push(projection._model.getLine(lineCount));
+					}
+				}
+				offset = projection.end;
+				delta += lineCount - projection._lineCount;
+			}
+			offset = Math.max(offset, model.getLineStart(lineIndex - delta));
+			for (; i < projections.length; i++) {
+				projection = projections[i];
+				if (projection._lineIndex > lineIndex - delta) { break; }
+				result.push(model.getText(offset, projection.start));
+				lineCount = projection._model.getLineCount() - 1;
+				if (projection._lineIndex + lineCount > lineIndex - delta) {
+					result.push(projection._model.getLine(0, includeDelimiter));
+					return result.join("");
+				}
+				result.push(projection._model.getText());
+				offset = projection.end;
+				delta += lineCount - projection._lineCount;
+			}
+			var end = model.getLineEnd(lineIndex - delta, includeDelimiter);
+			if (offset < end) {
+				result.push(model.getText(offset, end));
+			}
+			return result.join("");
+		},
+		/**
+		 * @see orion.textview.TextModel#getLineAtOffset
+		 */
+		getLineAtOffset: function(offset) {
+			var model = this._model, projections = this._projections;
+			var delta = 0, lineDelta = 0;
+			for (var i = 0; i < projections.length; i++) {
+				var projection = projections[i];
+				if (projection.start > offset - delta) { break; }
+				var charCount = projection._model.getCharCount();
+				if (projection.start + charCount > offset - delta) {
+					var projectionOffset = offset - (projection.start + delta);
+					lineDelta += projection._model.getLineAtOffset(projectionOffset);
+					delta += projectionOffset;
+					break;
+				}
+				lineDelta += projection._model.getLineCount() - 1 - projection._lineCount;
+				delta += charCount - (projection.end - projection.start);
+			}
+			return model.getLineAtOffset(offset - delta) + lineDelta;
+		},
+		/**
+		 * @see orion.textview.TextModel#getLineCount
+		 */
+		getLineCount: function() {
+			var model = this._model, projections = this._projections;
+			var count = model.getLineCount();
+			for (var i = 0; i < projections.length; i++) {
+				var projection = projections[i];
+				count += projection._model.getLineCount() - 1 - projection._lineCount;
+			}
+			return count;
+		},
+		/**
+		 * @see orion.textview.TextModel#getLineDelimiter
+		 */
+		getLineDelimiter: function() {
+			return this._model.getLineDelimiter();
+		},
+		/**
+		 * @see orion.textview.TextModel#getLineEnd
+		 */
+		getLineEnd: function(lineIndex, includeDelimiter) {
+			if (lineIndex < 0) { return -1; }
+			var model = this._model, projections = this._projections;
+			var delta = 0, offsetDelta = 0;
+			for (var i = 0; i < projections.length; i++) {
+				var projection = projections[i];
+				if (projection._lineIndex > lineIndex - delta) { break; }
+				var lineCount = projection._model.getLineCount() - 1;
+				if (projection._lineIndex + lineCount > lineIndex - delta) {
+					var projectionLineIndex = lineIndex - (projection._lineIndex + delta);
+					return projection._model.getLineEnd (projectionLineIndex, includeDelimiter) + projection.start + offsetDelta;
+				}
+				offsetDelta += projection._model.getCharCount() - (projection.end - projection.start);
+				delta += lineCount - projection._lineCount;
+			}
+			return model.getLineEnd(lineIndex - delta, includeDelimiter) + offsetDelta;
+		},
+		/**
+		 * @see orion.textview.TextModel#getLineStart
+		 */
+		getLineStart: function(lineIndex) {
+			if (lineIndex < 0) { return -1; }
+			var model = this._model, projections = this._projections;
+			var delta = 0, offsetDelta = 0;
+			for (var i = 0; i < projections.length; i++) {
+				var projection = projections[i];
+				if (projection._lineIndex >= lineIndex - delta) { break; }
+				var lineCount = projection._model.getLineCount() - 1;
+				if (projection._lineIndex + lineCount >= lineIndex - delta) {
+					var projectionLineIndex = lineIndex - (projection._lineIndex + delta);
+					return projection._model.getLineStart (projectionLineIndex) + projection.start + offsetDelta;
+				}
+				offsetDelta += projection._model.getCharCount() - (projection.end - projection.start);
+				delta += lineCount - projection._lineCount;
+			}
+			return model.getLineStart(lineIndex - delta) + offsetDelta;
+		},
+		/**
+		 * @see orion.textview.TextModel#getText
+		 */
+		getText: function(start, end) {
+			if (start === undefined) { start = 0; }
+			var model = this._model, projections = this._projections;
+			var delta = 0, result = [], i, projection, charCount;
+			for (i = 0; i < projections.length; i++) {
+				projection = projections[i];
+				if (projection.start > start - delta) { break; }
+				charCount = projection._model.getCharCount();
+				if (projection.start + charCount > start - delta) {
+					if (end !== undefined && projection.start + charCount > end - delta) {
+						return projection._model.getText(start - (projection.start + delta), end - (projection.start + delta));
+					} else {
+						result.push(projection._model.getText(start - (projection.start + delta)));
+						start = projection.end + delta + charCount - (projection.end - projection.start);
+					}
+				}
+				delta += charCount - (projection.end - projection.start);
+			}
+			var offset = start - delta;
+			if (end !== undefined) {
+				for (; i < projections.length; i++) {
+					projection = projections[i];
+					if (projection.start > end - delta) { break; }
+					result.push(model.getText(offset, projection.start));
+					charCount = projection._model.getCharCount();
+					if (projection.start + charCount > end - delta) {
+						result.push(projection._model.getText(0, end - (projection.start + delta)));
+						return result.join("");
+					}
+					result.push(projection._model.getText());
+					offset = projection.end;
+					delta += charCount - (projection.end - projection.start);
+				}
+				result.push(model.getText(offset, end - delta));
+			} else {
+				for (; i < projections.length; i++) {
+					projection = projections[i];
+					result.push(model.getText(offset, projection.start));
+					result.push(projection._model.getText());
+					offset = projection.end;
+				}
+				result.push(model.getText(offset));
+			}
+			return result.join("");
+		},
+		/** @ignore */
+		_onChanging: function(text, start, removedCharCount, addedCharCount, removedLineCount, addedLineCount) {
+			var model = this._model, projections = this._projections, i, projection, delta = 0, lineDelta;
+			var end = start + removedCharCount;
+			for (; i < projections.length; i++) {
+				projection = projections[i];
+				if (projection.start > start) { break; }
+				delta += projection._model.getCharCount() - (projection.end - projection.start);
+			}
+			/*TODO add stuff saved by setText*/
+			var mapStart = start + delta, rangeStart = i;
+			for (; i < projections.length; i++) {
+				projection = projections[i];
+				if (projection.start > end) { break; }
+				delta += projection._model.getCharCount() - (projection.end - projection.start);
+				lineDelta += projection._model.getLineCount() - 1 - projection._lineCount;
+			}
+			/*TODO add stuff saved by setText*/
+			var mapEnd = end + delta, rangeEnd = i;
+			this.onChanging(mapStart, mapEnd - mapStart, addedCharCount/*TODO add stuff saved by setText*/, removedLineCount + lineDelta/*TODO add stuff saved by setText*/, addedLineCount/*TODO add stuff saved by setText*/);
+			projections.splice(projections, rangeEnd - rangeStart);
+			var count = text.length - (mapEnd - mapStart);
+			for (; i < projections.length; i++) {
+				projection = projections[i];
+				projection.start += count;
+				projection.end += count;
+				projection._lineIndex = model.getLineAtOffset(projection.start);
+			}
+		},
+		/**
+		 * @see orion.textview.TextModel#onChanging
+		 */
+		onChanging: function(modelChangingEvent) {
+			return this.dispatchEvent(modelChangingEvent);
+		},
+		/**
+		 * @see orion.textview.TextModel#onChanged
+		 */
+		onChanged: function(modelChangedEvent) {
+			return this.dispatchEvent(modelChangedEvent);
+		},
+		/**
+		 * @see orion.textview.TextModel#setLineDelimiter
+		 */
+		setLineDelimiter: function(lineDelimiter) {
+			this._model.setLineDelimiter(lineDelimiter);
+		},
+		/**
+		 * @see orion.textview.TextModel#setText
+		 */
+		setText: function(text, start, end) {
+			if (text === undefined) { text = ""; }
+			if (start === undefined) { start = 0; }
+			var eventStart = start, eventEnd = end;
+			var model = this._model, projections = this._projections;
+			var delta = 0, lineDelta = 0, i, projection, charCount, startProjection, endProjection, startLineDelta = 0;
+			for (i = 0; i < projections.length; i++) {
+				projection = projections[i];
+				if (projection.start > start - delta) { break; }
+				charCount = projection._model.getCharCount();
+				if (projection.start + charCount > start - delta) {
+					if (end !== undefined && projection.start + charCount > end - delta) {
+						projection._model.setText(text, start - (projection.start + delta), end - (projection.start + delta));
+						//TODO events - special case
+						return;
+					} else {
+						startLineDelta = projection._model.getLineCount() - 1 - projection._model.getLineAtOffset(start - (projection.start + delta));
+						startProjection = {
+							projection: projection,
+							start: start - (projection.start + delta)
+						};
+						start = projection.end + delta + charCount - (projection.end - projection.start);
+					}
+				}
+				lineDelta += projection._model.getLineCount() - 1 - projection._lineCount;
+				delta += charCount - (projection.end - projection.start);
+			}
+			var mapStart = start - delta, rangeStart = i, startLine = model.getLineAtOffset(mapStart) + lineDelta - startLineDelta;
+			if (end !== undefined) {
+				for (; i < projections.length; i++) {
+					projection = projections[i];
+					if (projection.start > end - delta) { break; }
+					charCount = projection._model.getCharCount();
+					if (projection.start + charCount > end - delta) {
+						lineDelta += projection._model.getLineAtOffset(end - (projection.start + delta));
+						charCount = end - (projection.start + delta);
+						end = projection.end + delta;
+						endProjection = {
+							projection: projection,
+							end: charCount
+						};
+						break;
+					}
+					lineDelta += projection._model.getLineCount() - 1 - projection._lineCount;
+					delta += charCount - (projection.end - projection.start);
+				}
+			} else {
+				for (; i < projections.length; i++) {
+					projection = projections[i];
+					lineDelta += projection._model.getLineCount() - 1 - projection._lineCount;
+					delta += projection._model.getCharCount() - (projection.end - projection.start);
+				}
+				end = eventEnd = model.getCharCount() + delta;
+			}
+			var mapEnd = end - delta, rangeEnd = i, endLine = model.getLineAtOffset(mapEnd) + lineDelta;
+			
+			//events
+			var removedCharCount = eventEnd - eventStart;
+			var removedLineCount = endLine - startLine;
+			var addedCharCount = text.length;
+			var addedLineCount = 0;
+			var cr = 0, lf = 0, index = 0;
+			while (true) {
+				if (cr !== -1 && cr <= index) { cr = text.indexOf("\r", index); }
+				if (lf !== -1 && lf <= index) { lf = text.indexOf("\n", index); }
+				if (lf === -1 && cr === -1) { break; }
+				if (cr !== -1 && lf !== -1) {
+					if (cr + 1 === lf) {
+						index = lf + 1;
+					} else {
+						index = (cr < lf ? cr : lf) + 1;
+					}
+				} else if (cr !== -1) {
+					index = cr + 1;
+				} else {
+					index = lf + 1;
+				}
+				addedLineCount++;
+			}
+			
+			var modelChangingEvent = {
+				type: "Changing",
+				text: text,
+				start: eventStart,
+				removedCharCount: removedCharCount,
+				addedCharCount: addedCharCount,
+				removedLineCount: removedLineCount,
+				addedLineCount: addedLineCount
+			};
+			this.onChanging(modelChangingEvent);
+			
+//			var changeLineCount = model.getLineAtOffset(mapEnd) - model.getLineAtOffset(mapStart) + addedLineCount;
+			model.setText(text, mapStart, mapEnd);
+			if (startProjection) {
+				projection = startProjection.projection;
+				projection._model.setText("", startProjection.start);
+			}		
+			if (endProjection) {
+				projection = endProjection.projection;
+				projection._model.setText("", 0, endProjection.end);
+				projection.start = projection.end;
+				projection._lineCount = 0;
+			}
+			projections.splice(rangeStart, rangeEnd - rangeStart);
+			var changeCount = text.length - (mapEnd - mapStart);
+			for (i = rangeEnd; i < projections.length; i++) {
+				projection = projections[i];
+				projection.start += changeCount;
+				projection.end += changeCount;
+//				if (projection._lineIndex + changeLineCount !== model.getLineAtOffset(projection.start)) {
+//					log("here");
+//				}
+				projection._lineIndex = model.getLineAtOffset(projection.start);
+//				projection._lineIndex += changeLineCount;
+			}
+			
+			var modelChangedEvent = {
+				type: "Changed",
+				start: eventStart,
+				removedCharCount: removedCharCount,
+				addedCharCount: addedCharCount,
+				removedLineCount: removedLineCount,
+				addedLineCount: addedLineCount
+			};
+			this.onChanged(modelChangedEvent);
+		}
+	};
+	mEventTarget.EventTarget.addMixin(ProjectionTextModel.prototype);
+
+	return {ProjectionTextModel: ProjectionTextModel};
+});
+/*******************************************************************************
+ * @license
+ * Copyright (c) 2010, 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials are made 
+ * available under the terms of the Eclipse Public License v1.0 
+ * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
+ * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
+ * 
+ * Contributors: 
+ *		Felipe Heidrich (IBM Corporation) - initial API and implementation
+ *		Silenio Quarti (IBM Corporation) - initial API and implementation
+ ******************************************************************************/
+ 
 /*global define */
 
 define("orion/textview/textDND", [], function() {
 
 	function TextDND(view, undoStack) {
 		this._view = view;
 		this._undoStack = undoStack;
 		this._dragSelection = null;
@@ -9740,2564 +11630,395 @@ define("orion/textview/textDND", [], fun
 					view.setText(text, offset, offset);
 					view.setSelection(offset, offset + text.length);
 				}
 			}
 		}
 	};
 
 	return {TextDND: TextDND};
-});/******************************************************************************* 
- * @license
- * Copyright (c) 2011 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials are made 
- * available under the terms of the Eclipse Public License v1.0 
- * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
- * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
- * 
- * Contributors: IBM Corporation - initial API and implementation 
- ******************************************************************************/
-
-/*jslint */
-/*global define */
-
-define("orion/editor/htmlGrammar", [], function() {
-
-	/**
-	 * Provides a grammar that can do some very rough syntax highlighting for HTML.
-	 * @class orion.syntax.HtmlGrammar
-	 */
-	function HtmlGrammar() {
-		/**
-		 * Object containing the grammar rules.
-		 * @public
-		 * @type Object
-		 */
-		return {
-			"name": "HTML",
-			"scopeName": "source.html",
-			"uuid": "3B5C76FB-EBB5-D930-F40C-047D082CE99B",
-			"patterns": [
-				// TODO unicode?
-				{
-					"match": "<!(doctype|DOCTYPE)[^>]+>",
-					"name": "entity.name.tag.doctype.html"
-				},
-				{
-					"begin": "<!--",
-					"end": "-->",
-					"beginCaptures": {
-						"0": { "name": "punctuation.definition.comment.html" }
-					},
-					"endCaptures": {
-						"0": { "name": "punctuation.definition.comment.html" }
-					},
-					"patterns": [
-						{
-							"match": "--",
-							"name": "invalid.illegal.badcomment.html"
-						}
-					],
-					"contentName": "comment.block.html"
-				},
-				{ // startDelimiter + tagName
-					"match": "<[A-Za-z0-9_\\-:]+(?= ?)",
-					"name": "entity.name.tag.html"
-				},
-				{ "include": "#attrName" },
-				{ "include": "#qString" },
-				{ "include": "#qqString" },
-				// TODO attrName, qString, qqString should be applied first while inside a tag
-				{ // startDelimiter + slash + tagName + endDelimiter
-					"match": "</[A-Za-z0-9_\\-:]+>",
-					"name": "entity.name.tag.html"
-				},
-				{ // end delimiter of open tag
-					"match": ">", 
-					"name": "entity.name.tag.html"
-				} ],
-			"repository": {
-				"attrName": { // attribute name
-					"match": "[A-Za-z\\-:]+(?=\\s*=\\s*['\"])",
-					"name": "entity.other.attribute.name.html"
-				},
-				"qqString": { // double quoted string
-					"match": "(\")[^\"]+(\")",
-					"name": "string.quoted.double.html"
-				},
-				"qString": { // single quoted string
-					"match": "(')[^']+(\')",
-					"name": "string.quoted.single.html"
-				}
-			}
-		};
-	}
-
-	return {HtmlGrammar: HtmlGrammar};
-});
-/******************************************************************************* 
- * @license
- * Copyright (c) 2011 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials are made 
- * available under the terms of the Eclipse Public License v1.0 
- * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
- * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
- * 
- * Contributors: IBM Corporation - initial API and implementation 
- ******************************************************************************/
-
-/*jslint regexp:false laxbreak:true*/
-/*global define */
-
-define("orion/editor/textMateStyler", ['orion/editor/regex'], function(mRegex) {
-
-var RegexUtil = {
-	// Rules to detect some unsupported Oniguruma features
-	unsupported: [
-		{regex: /\(\?[ims\-]:/, func: function(match) { return "option on/off for subexp"; }},
-		{regex: /\(\?<([=!])/, func: function(match) { return (match[1] === "=") ? "lookbehind" : "negative lookbehind"; }},
-		{regex: /\(\?>/, func: function(match) { return "atomic group"; }}
-	],
-	
-	/**
-	 * @param {String} str String giving a regular expression pattern from a TextMate grammar.
-	 * @param {String} [flags] [ismg]+
-	 * @returns {RegExp}
-	 */
-	toRegExp: function(str) {
-		function fail(feature, match) {
-			throw new Error("Unsupported regex feature \"" + feature + "\": \"" + match[0] + "\" at index: "
-					+ match.index + " in " + match.input);
-		}
-		// Turns an extended regex pattern into a normal one
-		function normalize(/**String*/ str) {
-			var result = "";
-			var insideCharacterClass = false;
-			var len = str.length;
-			for (var i=0; i < len; ) {
-				var chr = str[i];
-				if (!insideCharacterClass && chr === "#") {
-					// skip to eol
-					while (i < len && chr !== "\r" && chr !== "\n") {
-						chr = str[++i];
-					}
-				} else if (!insideCharacterClass && /\s/.test(chr)) {
-					// skip whitespace
-					while (i < len && /\s/.test(chr)) { 
-						chr = str[++i];
-					}
-				} else if (chr === "\\") {
-					result += chr;
-					if (!/\s/.test(str[i+1])) {
-						result += str[i+1];
-						i += 1;
-					}
-					i += 1;
-				} else if (chr === "[") {
-					insideCharacterClass = true;
-					result += chr;
-					i += 1;
-				} else if (chr === "]") {
-					insideCharacterClass = false;
-					result += chr;
-					i += 1;
-				} else {
-					result += chr;
-					i += 1;
-				}
-			}
-			return result;
-		}
-		
-		var flags = "";
-		var i;
-		
-		// Handle global "x" flag (whitespace/comments)
-		str = RegexUtil.processGlobalFlag("x", str, function(subexp) {
-				return normalize(subexp);
-			});
-		
-		// Handle global "i" flag (case-insensitive)
-		str = RegexUtil.processGlobalFlag("i", str, function(subexp) {
-				flags += "i";
-				return subexp;
-			});
-		
-		// Check for remaining unsupported syntax
-		for (i=0; i < this.unsupported.length; i++) {
-			var match;
-			if ((match = this.unsupported[i].regex.exec(str))) {
-				fail(this.unsupported[i].func(match), match);
-			}
-		}
-		
-		return new RegExp(str, flags);
-	},
-	
-	/**
-	 * Checks if flag applies to entire pattern. If so, obtains replacement string by calling processor
-	 * on the unwrapped pattern. Handles 2 possible syntaxes: (?f)pat and (?f:pat)
-	 */
-	processGlobalFlag: function(/**String*/ flag, /**String*/ str, /**Function*/ processor) {
-		function getMatchingCloseParen(/*String*/pat, /*Number*/start) {
-			var depth = 0,
-			    len = pat.length,
-			    flagStop = -1;
-			for (var i=start; i < len && flagStop === -1; i++) {
-				switch (pat[i]) {
-					case "\\":
-						i++; // escape: skip next char
-						break;
-					case "(":
-						depth++;
-						break;
-					case ")":
-						depth--;
-						if (depth === 0) {
-							flagStop = i;
-						}
-						break;
-				}
-			}
-			return flagStop;
-		}
-		var flag1 = "(?" + flag + ")",
-		    flag2 = "(?" + flag + ":";
-		if (str.substring(0, flag1.length) === flag1) {
-			return processor(str.substring(flag1.length));
-		} else if (str.substring(0, flag2.length) === flag2) {
-			var flagStop = getMatchingCloseParen(str, 0);
-			if (flagStop < str.length-1) {
-				throw new Error("Only a " + flag2 + ") group that encloses the entire regex is supported in: " + str);
-			}
-			return processor(str.substring(flag2.length, flagStop));
-		}
-		return str;
-	},
-	
-	hasBackReference: function(/**RegExp*/ regex) {
-		return (/\\\d+/).test(regex.source);
-	},
-	
-	/** @returns {RegExp} A regex made by substituting any backreferences in <code>regex</code> for the value of the property
-	 * in <code>sub</code> with the same name as the backreferenced group number. */
-	getSubstitutedRegex: function(/**RegExp*/ regex, /**Object*/ sub, /**Boolean*/ escape) {
-		escape = (typeof escape === "undefined") ? true : false;
-		var exploded = regex.source.split(/(\\\d+)/g);
-		var array = [];
-		for (var i=0; i < exploded.length; i++) {
-			var term = exploded[i];
-			var backrefMatch = /\\(\d+)/.exec(term);
-			if (backrefMatch) {
-				var text = sub[backrefMatch[1]] || "";
-				array.push(escape ? mRegex.escape(text) : text);
-			} else {
-				array.push(term);
-			}
-		}
-		return new RegExp(array.join(""));
-	},
-	
-	/**
-	 * Builds a version of <code>regex</code> with every non-capturing term converted into a capturing group. This is a workaround
-	 * for JavaScript's lack of API to get the index at which a matched group begins in the input string.<p>
-	 * Using the "groupified" regex, we can sum the lengths of matches from <i>consuming groups</i> 1..n-1 to obtain the 
-	 * starting index of group n. (A consuming group is a capturing group that is not inside a lookahead assertion).</p>
-	 * Example: groupify(/(a+)x+(b+)/) === /(a+)(x+)(b+)/<br />
-	 * Example: groupify(/(?:x+(a+))b+/) === /(?:(x+)(a+))(b+)/
-	 * @param {RegExp} regex The regex to groupify.
-	 * @param {Object} [backRefOld2NewMap] Optional. If provided, the backreference numbers in regex will be updated using the 
-	 * properties of this object rather than the new group numbers of regex itself.
-	 * <ul><li>[0] {RegExp} The groupified version of the input regex.</li>
-	 * <li>[1] {Object} A map containing old-group to new-group info. Each property is a capturing group number of <code>regex</code>
-	 * and its value is the corresponding capturing group number of [0].</li>
-	 * <li>[2] {Object} A map indicating which capturing groups of [0] are also consuming groups. If a group number is found
-	 * as a property in this object, then it's a consuming group.</li></ul>
-	 */
-	groupify: function(regex, backRefOld2NewMap) {
-		var NON_CAPTURING = 1,
-		    CAPTURING = 2,
-		    LOOKAHEAD = 3,
-		    NEW_CAPTURING = 4;
-		var src = regex.source,
-		    len = src.length;
-		var groups = [],
-		    lookaheadDepth = 0,
-		    newGroups = [],
-		    oldGroupNumber = 1,
-		    newGroupNumber = 1;
-		var result = [],
-		    old2New = {},
-		    consuming = {};
-		for (var i=0; i < len; i++) {
-			var curGroup = groups[groups.length-1];
-			var chr = src[i];
-			switch (chr) {
-				case "(":
-					// If we're in new capturing group, close it since ( signals end-of-term
-					if (curGroup === NEW_CAPTURING) {
-						groups.pop();
-						result.push(")");
-						newGroups[newGroups.length-1].end = i;
-					}
-					var peek2 = (i + 2 < len) ? (src[i+1] + "" + src[i+2]) : null;
-					if (peek2 === "?:" || peek2 === "?=" || peek2 === "?!") {
-						// Found non-capturing group or lookahead assertion. Note that we preserve non-capturing groups
-						// as such, but any term inside them will become a new capturing group (unless it happens to
-						// also be inside a lookahead).
-						var groupType;
-						if (peek2 === "?:") {
-							groupType = NON_CAPTURING;
-						} else {
-							groupType = LOOKAHEAD;
-							lookaheadDepth++;
-						}
-						groups.push(groupType);
-						newGroups.push({ start: i, end: -1, type: groupType /*non capturing*/ });
-						result.push(chr);
-						result.push(peek2);
-						i += peek2.length;
-					} else {
-						groups.push(CAPTURING);
-						newGroups.push({ start: i, end: -1, type: CAPTURING, oldNum: oldGroupNumber, num: newGroupNumber });
-						result.push(chr);
-						if (lookaheadDepth === 0) {
-							consuming[newGroupNumber] = null;
-						}
-						old2New[oldGroupNumber] = newGroupNumber;
-						oldGroupNumber++;
-						newGroupNumber++;
-					}
-					break;
-				case ")":
-					var group = groups.pop();
-					if (group === LOOKAHEAD) { lookaheadDepth--; }
-					newGroups[newGroups.length-1].end = i;
-					result.push(chr);
-					break;
-				case "*":
-				case "+":
-				case "?":
-				case "}":
-					// Unary operator. If it's being applied to a capturing group, we need to add a new capturing group
-					// enclosing the pair
-					var op = chr;
-					var prev = src[i-1],
-					    prevIndex = i-1;
-					if (chr === "}") {
-						for (var j=i-1; src[j] !== "{" && j >= 0; j--) {}
-						prev = src[j-1];
-						prevIndex = j-1;
-						op = src.substring(j, i+1);
-					}
-					var lastGroup = newGroups[newGroups.length-1];
-					if (prev === ")" && (lastGroup.type === CAPTURING || lastGroup.type === NEW_CAPTURING)) {
-						// Shove in the new group's (, increment num/start in from [lastGroup.start .. end]
-						result.splice(lastGroup.start, 0, "(");
-						result.push(op);
-						result.push(")");
-						var newGroup = { start: lastGroup.start, end: result.length-1, type: NEW_CAPTURING, num: lastGroup.num };
-						for (var k=0; k < newGroups.length; k++) {
-							group = newGroups[k];
-							if (group.type === CAPTURING || group.type === NEW_CAPTURING) {
-								if (group.start >= lastGroup.start && group.end <= prevIndex) {
-									group.start += 1;
-									group.end += 1;
-									group.num = group.num + 1;
-									if (group.type === CAPTURING) {
-										old2New[group.oldNum] = group.num;
-									}
-								}
-							}
-						}
-						newGroups.push(newGroup);
-						newGroupNumber++;
-						break;
-					} else {
-						// Fallthrough to default
-					}
-				default:
-					if (chr !== "|" && curGroup !== CAPTURING && curGroup !== NEW_CAPTURING) {
-						// Not in a capturing group, so make a new one to hold this term.
-						// Perf improvement: don't create the new group if we're inside a lookahead, since we don't 
-						// care about them (nothing inside a lookahead actually consumes input so we don't need it)
-						if (lookaheadDepth === 0) {
-							groups.push(NEW_CAPTURING);
-							newGroups.push({ start: i, end: -1, type: NEW_CAPTURING, num: newGroupNumber });
-							result.push("(");
-							consuming[newGroupNumber] = null;
-							newGroupNumber++;
-						}
-					}
-					result.push(chr);
-					if (chr === "\\") {
-						var peek = src[i+1];
-						// Eat next so following iteration doesn't think it's a real special character
-						result.push(peek);
-						i += 1;
-					}
-					break;
-			}
-		}
-		while (groups.length) {	
-			// Close any remaining new capturing groups
-			groups.pop();
-			result.push(")");
-		}
-		var newRegex = new RegExp(result.join(""));
-		
-		// Update backreferences so they refer to the new group numbers. Use backRefOld2NewMap if provided
-		var subst = {};
-		backRefOld2NewMap = backRefOld2NewMap || old2New;
-		for (var prop in backRefOld2NewMap) {
-			if (backRefOld2NewMap.hasOwnProperty(prop)) {
-				subst[prop] = "\\" + backRefOld2NewMap[prop];
-			}
-		}
-		newRegex = this.getSubstitutedRegex(newRegex, subst, false);
-		
-		return [newRegex, old2New, consuming];
-	},
-	
-	/** @returns {Boolean} True if the captures object assigns scope to a matching group other than "0". */
-	complexCaptures: function(capturesObj) {
-		if (!capturesObj) { return false; }
-		for (var prop in capturesObj) {
-			if (capturesObj.hasOwnProperty(prop)) {
-				if (prop !== "0") {
-					return true;
-				}
-			}
-		}
-		return false;
-	}
-};
-
-	/**
-	 * @name orion.editor.TextMateStyler
-	 * @class A styler that knows how to apply a subset of the TextMate grammar format to style a line.
-	 *
-	 * <h4>Styling from a grammar:</h4>
-	 * <p>Each scope name given in the grammar is converted to an array of CSS class names. For example 
-	 * a region of text with scope <code>keyword.control.php</code> will be assigned the CSS classes<br />
-	 * <code>keyword, keyword-control, keyword-control-php</code></p>
-	 *
-	 * <p>A CSS file can give rules matching any of these class names to provide generic or more specific styling.
-	 * For example,</p>
-	 * <p><code>.keyword { font-color: blue; }</code></p>
-	 * <p>colors all keywords blue, while</p>
-	 * <p><code>.keyword-control-php { font-weight: bold; }</code></p>
-	 * <p>bolds only PHP control keywords.</p>
-	 *
-	 * <p>This is useful when using grammars that adhere to TextMate's
-	 * <a href="http://manual.macromates.com/en/language_grammars.html#naming_conventions">scope name conventions</a>,
-	 * as a single CSS rule can provide consistent styling to similar constructs across different languages.</p>
-	 * 
-	 * <h4>Top-level grammar constructs:</h4>
-	 * <ul><li><code>patterns, repository</code> (with limitations, see "Other Features") are supported.</li>
-	 * <li><code>scopeName, firstLineMatch, foldingStartMarker, foldingStopMarker</code> are <b>not</b> supported.</li>
-	 * <li><code>fileTypes</code> is <b>not</b> supported. When using the Orion service registry, the "orion.edit.highlighter"
-	 * service serves a similar purpose.</li>
-	 * </ul>
-	 *
-	 * <h4>Regular expression constructs:</h4>
-	 * <ul>
-	 * <li><code>match</code> patterns are supported.</li>
-	 * <li><code>begin .. end</code> patterns are supported.</li>
-	 * <li>The "extended" regex forms <code>(?x)</code> and <code>(?x:...)</code> are supported, but <b>only</b> when they 
-	 * apply to the entire regex pattern.</li>
-	 * <li>Matching is done using native JavaScript <code>RegExp</code>s. As a result, many features of the Oniguruma regex
-	 * engine used by TextMate are <b>not</b> supported.
-	 * Unsupported features include:
-	 *   <ul><li>Named captures</li>
-	 *   <li>Setting flags inside subgroups (eg. <code>(?i:a)b</code>)</li>
-	 *   <li>Lookbehind and negative lookbehind</li>
-	 *   <li>Subexpression call</li>
-	 *   <li>etc.</li>
-	 *   </ul>
-	 * </li>
-	 * </ul>
-	 * 
-	 * <h4>Scope-assignment constructs:</h4>
-	 * <ul>
-	 * <li><code>captures, beginCaptures, endCaptures</code> are supported.</li>
-	 * <li><code>name</code> and <code>contentName</code> are supported.</li>
-	 * </ul>
-	 * 
-	 * <h4>Other features:</h4>
-	 * <ul>
-	 * <li><code>applyEndPatternLast</code> is supported.</li>
-	 * <li><code>include</code> is supported, but only when it references a rule in the current grammar's <code>repository</code>.
-	 * Including <code>$self</code>, <code>$base</code>, or <code>rule.from.another.grammar</code> is <b>not</b> supported.</li>
-	 * </ul>
-	 * 
-	 * @description Creates a new TextMateStyler.
-	 * @extends orion.editor.AbstractStyler
-	 * @param {orion.textview.TextView} textView The <code>TextView</code> to provide styling for.
-	 * @param {Object} grammar The TextMate grammar to use for styling the <code>TextView</code>, as a JavaScript object. You can
-	 * produce this object by running a PList-to-JavaScript conversion tool on a TextMate <code>.tmLanguage</code> file.
-	 * @param {Object[]} [externalGrammars] Additional grammar objects that will be used to resolve named rule references.
-	 */
-	function TextMateStyler(textView, grammar, externalGrammars) {
-		this.initialize(textView);
-		// Copy grammar object(s) since we will mutate them
-		this.grammar = this.copy(grammar);
-		this.externalGrammars = externalGrammars ? this.copy(externalGrammars) : [];
-		
-		this._styles = {}; /* key: {String} scopeName, value: {String[]} cssClassNames */
-		this._tree = null;
-		this._allGrammars = {}; /* key: {String} scopeName of grammar, value: {Object} grammar */
-		this.preprocess(this.grammar);
-	}
-	TextMateStyler.prototype = /** @lends orion.editor.TextMateStyler.prototype */ {
-		initialize: function(textView) {
-			this.textView = textView;
-			var self = this;
-			this._listener = {
-				onModelChanged: function(e) {
-					self.onModelChanged(e);
-				},
-				onDestroy: function(e) {
-					self.onDestroy(e);
-				},
-				onLineStyle: function(e) {
-					self.onLineStyle(e);
-				}
-			};
-			textView.addEventListener("ModelChanged", this._listener.onModelChanged);
-			textView.addEventListener("Destroy", this._listener.onDestroy);
-			textView.addEventListener("LineStyle", this._listener.onLineStyle);
-			textView.redrawLines();
-		},
-		onDestroy: function(/**eclipse.DestroyEvent*/ e) {
-			this.destroy();
-		},
-		destroy: function() {
-			if (this.textView) {
-				this.textView.removeEventListener("ModelChanged", this._listener.onModelChanged);
-				this.textView.removeEventListener("Destroy", this._listener.onDestroy);
-				this.textView.removeEventListener("LineStyle", this._listener.onLineStyle);
-				this.textView = null;
-			}
-			this.grammar = null;
-			this._styles = null;
-			this._tree = null;
-			this._listener = null;
-		},
-		/** @private */
-		copy: function(obj) {
-			return JSON.parse(JSON.stringify(obj));
-		},
-		/** @private */
-		preprocess: function(grammar) {
-			var stack = [grammar];
-			for (; stack.length !== 0; ) {
-				var rule = stack.pop();
-				if (rule._resolvedRule && rule._typedRule) {
-					continue;
-				}
-//					console.debug("Process " + (rule.include || rule.name));
-				
-				// Look up include'd rule, create typed *Rule instance
-				rule._resolvedRule = this._resolve(rule);
-				rule._typedRule = this._createTypedRule(rule);
-				
-				// Convert the scope names to styles and cache them for later
-				this.addStyles(rule.name);
-				this.addStyles(rule.contentName);
-				this.addStylesForCaptures(rule.captures);
-				this.addStylesForCaptures(rule.beginCaptures);
-				this.addStylesForCaptures(rule.endCaptures);
-				
-				if (rule._resolvedRule !== rule) {
-					// Add include target
-					stack.push(rule._resolvedRule);
-				}
-				if (rule.patterns) {
-					// Add subrules
-					for (var i=0; i < rule.patterns.length; i++) {
-						stack.push(rule.patterns[i]);
-					}
-				}
-			}
-		},
-		
-		/**
-		 * @private
-		 * Adds eclipse.Style objects for scope to our _styles cache.
-		 * @param {String} scope A scope name, like "constant.character.php".
-		 */
-		addStyles: function(scope) {
-			if (scope && !this._styles[scope]) {
-				this._styles[scope] = [];
-				var scopeArray = scope.split(".");
-				for (var i = 0; i < scopeArray.length; i++) {
-					this._styles[scope].push(scopeArray.slice(0, i + 1).join("-"));
-				}
-			}
-		},
-		/** @private */
-		addStylesForCaptures: function(/**Object*/ captures) {
-			for (var prop in captures) {
-				if (captures.hasOwnProperty(prop)) {
-					var scope = captures[prop].name;
-					this.addStyles(scope);
-				}
-			}
-		},
-		/**
-		 * A rule that contains subrules ("patterns" in TextMate parlance) but has no "begin" or "end".
-		 * Also handles top level of grammar.
-		 * @private
-		 */
-		ContainerRule: (function() {
-			function ContainerRule(/**Object*/ rule) {
-				this.rule = rule;
-				this.subrules = rule.patterns;
-			}
-			ContainerRule.prototype.valueOf = function() { return "aa"; };
-			return ContainerRule;
-		}()),
-		/**
-		 * A rule that is delimited by "begin" and "end" matches, which may be separated by any number of
-		 * lines. This type of rule may contain subrules, which apply only inside the begin .. end region.
-		 * @private
-		 */
-		BeginEndRule: (function() {
-			function BeginEndRule(/**Object*/ rule) {
-				this.rule = rule;
-				// TODO: the TextMate blog claims that "end" is optional.
-				this.beginRegex = RegexUtil.toRegExp(rule.begin);
-				this.endRegex = RegexUtil.toRegExp(rule.end);
-				this.subrules = rule.patterns || [];
-				
-				this.endRegexHasBackRef = RegexUtil.hasBackReference(this.endRegex);
-				
-				// Deal with non-0 captures
-				var complexCaptures = RegexUtil.complexCaptures(rule.captures);
-				var complexBeginEnd = RegexUtil.complexCaptures(rule.beginCaptures) || RegexUtil.complexCaptures(rule.endCaptures);
-				this.isComplex = complexCaptures || complexBeginEnd;
-				if (this.isComplex) {
-					var bg = RegexUtil.groupify(this.beginRegex);
-					this.beginRegex = bg[0];
-					this.beginOld2New = bg[1];
-					this.beginConsuming = bg[2];
-					
-					var eg = RegexUtil.groupify(this.endRegex, this.beginOld2New /*Update end's backrefs to begin's new group #s*/);
-					this.endRegex = eg[0];
-					this.endOld2New = eg[1];
-					this.endConsuming = eg[2];
-				}
-			}
-			BeginEndRule.prototype.valueOf = function() { return this.beginRegex; };
-			return BeginEndRule;
-		}()),
-		/**
-		 * A rule with a "match" pattern.
-		 * @private
-		 */
-		MatchRule: (function() {
-			function MatchRule(/**Object*/ rule) {
-				this.rule = rule;
-				this.matchRegex = RegexUtil.toRegExp(rule.match);
-				this.isComplex = RegexUtil.complexCaptures(rule.captures);
-				if (this.isComplex) {
-					var mg = RegexUtil.groupify(this.matchRegex);
-					this.matchRegex = mg[0];
-					this.matchOld2New = mg[1];
-					this.matchConsuming = mg[2];
-				}
-			}
-			MatchRule.prototype.valueOf = function() { return this.matchRegex; };
-			return MatchRule;
-		}()),
-		/**
-		 * @param {Object} rule A rule from the grammar.
-		 * @returns {MatchRule|BeginEndRule|ContainerRule}
-		 * @private
-		 */
-		_createTypedRule: function(rule) {
-			if (rule.match) {
-				return new this.MatchRule(rule);
-			} else if (rule.begin) {
-				return new this.BeginEndRule(rule);
-			} else {
-				return new this.ContainerRule(rule);
-			}
-		},
-		/**
-		 * Resolves a rule from the grammar (which may be an include) into the real rule that it points to.
-		 * @private
-		 */
-		_resolve: function(rule) {
-			var resolved = rule;
-			if (rule.include) {
-				if (rule.begin || rule.end || rule.match) {
-					throw new Error("Unexpected regex pattern in \"include\" rule " + rule.include);
-				}
-				var name = rule.include;
-				if (name[0] === "#") {
-					resolved = this.grammar.repository && this.grammar.repository[name.substring(1)];
-					if (!resolved) { throw new Error("Couldn't find included rule " + name + " in grammar repository"); }
-				} else if (name === "$self") {
-					resolved = this.grammar;
-				} else if (name === "$base") {
-					// $base is only relevant when including rules from foreign grammars
-					throw new Error("Include \"$base\" is not supported"); 
-				} else {
-					resolved = this._allGrammars[name];
-					if (!resolved) {
-						for (var i=0; i < this.externalGrammars.length; i++) {
-							var grammar = this.externalGrammars[i];
-							if (grammar.scopeName === name) {
-								this.preprocess(grammar);
-								this._allGrammars[name] = grammar;
-								resolved = grammar;
-								break;
-							}
-						}
-					}
-				}
-			}
-			return resolved;
-		},
-		/** @private */
-		ContainerNode: (function() {
-			function ContainerNode(parent, rule) {
-				this.parent = parent;
-				this.rule = rule;
-				this.children = [];
-				
-				this.start = null;
-				this.end = null;
-			}
-			ContainerNode.prototype.addChild = function(child) {
-				this.children.push(child);
-			};
-			ContainerNode.prototype.valueOf = function() {
-				var r = this.rule;
-				return "ContainerNode { " + (r.include || "") + " " + (r.name || "") + (r.comment || "") + "}";
-			};
-			return ContainerNode;
-		}()),
-		/** @private */
-		BeginEndNode: (function() {
-			function BeginEndNode(parent, rule, beginMatch) {
-				this.parent = parent;
-				this.rule = rule;
-				this.children = [];
-				
-				this.setStart(beginMatch);
-				this.end = null; // will be set eventually during parsing (may be EOF)
-				this.endMatch = null; // may remain null if we never match our "end" pattern
-				
-				// Build a new regex if the "end" regex has backrefs since they refer to matched groups of beginMatch
-				if (rule.endRegexHasBackRef) {
-					this.endRegexSubstituted = RegexUtil.getSubstitutedRegex(rule.endRegex, beginMatch);
-				} else {
-					this.endRegexSubstituted = null;
-				}
-			}
-			BeginEndNode.prototype.addChild = function(child) {
-				this.children.push(child);
-			};
-			/** @return {Number} This node's index in its parent's "children" list */
-			BeginEndNode.prototype.getIndexInParent = function(node) {
-				return this.parent ? this.parent.children.indexOf(this) : -1;
-			};
-			/** @param {RegExp.match} beginMatch */
-			BeginEndNode.prototype.setStart = function(beginMatch) {
-				this.start = beginMatch.index;
-				this.beginMatch = beginMatch;
-			};
-			/** @param {RegExp.match|Number} endMatchOrLastChar */
-			BeginEndNode.prototype.setEnd = function(endMatchOrLastChar) {
-				if (endMatchOrLastChar && typeof(endMatchOrLastChar) === "object") {
-					var endMatch = endMatchOrLastChar;
-					this.endMatch = endMatch;
-					this.end = endMatch.index + endMatch[0].length;
-				} else {
-					var lastChar = endMatchOrLastChar;
-					this.endMatch = null;
-					this.end = lastChar;
-				}
-			};
-			BeginEndNode.prototype.shiftStart = function(amount) {
-				this.start += amount;
-				this.beginMatch.index += amount;
-			};
-			BeginEndNode.prototype.shiftEnd = function(amount) {
-				this.end += amount;
-				if (this.endMatch) { this.endMatch.index += amount; }
-			};
-			BeginEndNode.prototype.valueOf = function() {
-				return "{" + this.rule.beginRegex + " range=" + this.start + ".." + this.end + "}";
-			};
-			return BeginEndNode;
-		}()),
-		/** Pushes rules onto stack such that rules[startFrom] is on top
-		 * @private
-		 */
-		push: function(/**Array*/ stack, /**Array*/ rules) {
-			if (!rules) { return; }
-			for (var i = rules.length; i > 0; ) {
-				stack.push(rules[--i]);
-			}
-		},
-		/** Executes <code>regex</code> on <code>text</code>, and returns the match object with its index 
-		 * offset by the given amount.
-		 * @returns {RegExp.match}
-		 * @private
-		 */
-		exec: function(/**RegExp*/ regex, /**String*/ text, /**Number*/ offset) {
-			var match = regex.exec(text);
-			if (match) { match.index += offset; }
-			regex.lastIndex = 0; // Just in case
-			return match;
-		},
-		/** @returns {Number} The position immediately following the match.
-		 * @private
-		 */
-		afterMatch: function(/**RegExp.match*/ match) {
-			return match.index + match[0].length;
-		},
-		/**
-		 * @returns {RegExp.match} If node is a BeginEndNode and its rule's "end" pattern matches the text.
-		 * @private
-		 */
-		getEndMatch: function(/**Node*/ node, /**String*/ text, /**Number*/ offset) {
-			if (node instanceof this.BeginEndNode) {
-				var rule = node.rule;
-				var endRegex = node.endRegexSubstituted || rule.endRegex;
-				if (!endRegex) { return null; }
-				return this.exec(endRegex, text, offset);
-			}
-			return null;
-		},
-		/** Called once when file is first loaded to build the parse tree. Tree is updated incrementally thereafter 
-		 * as buffer is modified.
-		 * @private
-		 */
-		initialParse: function() {
-			var last = this.textView.getModel().getCharCount();
-			// First time; make parse tree for whole buffer
-			var root = new this.ContainerNode(null, this.grammar._typedRule);
-			this._tree = root;
-			this.parse(this._tree, false, 0);
-		},
-		onModelChanged: function(/**eclipse.ModelChangedEvent*/ e) {
-			var addedCharCount = e.addedCharCount,
-			    addedLineCount = e.addedLineCount,
-			    removedCharCount = e.removedCharCount,
-			    removedLineCount = e.removedLineCount,
-			    start = e.start;
-			if (!this._tree) {
-				this.initialParse();
-			} else {
-				var model = this.textView.getModel();
-				var charCount = model.getCharCount();
-				
-				// For rs, we must rewind to the line preceding the line 'start' is on. We can't rely on start's
-				// line since it may've been changed in a way that would cause a new beginMatch at its lineStart.
-				var rs = model.getLineEnd(model.getLineAtOffset(start) - 1); // may be < 0
-				var fd = this.getFirstDamaged(rs, rs);
-				rs = rs === -1 ? 0 : rs;
-				var stoppedAt;
-				if (fd) {
-					// [rs, re] is the region we need to verify. If we find the structure of the tree
-					// has changed in that area, then we may need to reparse the rest of the file.
-					stoppedAt = this.parse(fd, true, rs, start, addedCharCount, removedCharCount);
-				} else {
-					// FIXME: fd == null ?
-					stoppedAt = charCount;
-				}
-				this.textView.redrawRange(rs, stoppedAt);
-			}
-		},
-		/** @returns {BeginEndNode|ContainerNode} The result of taking the first (smallest "start" value) 
-		 * node overlapping [start,end] and drilling down to get its deepest damaged descendant (if any).
-		 * @private
-		 */
-		getFirstDamaged: function(start, end) {
-			// If start === 0 we actually have to start from the root because there is no position
-			// we can rely on. (First index is damaged)
-			if (start < 0) {
-				return this._tree;
-			}
-			
-			var nodes = [this._tree];
-			var result = null;
-			while (nodes.length) {
-				var n = nodes.pop();
-				if (!n.parent /*n is root*/ || this.isDamaged(n, start, end)) {
-					// n is damaged by the edit, so go into its children
-					// Note: If a node is damaged, then some of its descendents MAY be damaged
-					// If a node is undamaged, then ALL of its descendents are undamaged
-					if (n instanceof this.BeginEndNode) {
-						result = n;
-					}
-					// Examine children[0] last
-					for (var i=0; i < n.children.length; i++) {
-						nodes.push(n.children[i]);
-					}
-				}
-			}
-			return result || this._tree;
-		},
-		/** @returns true If <code>n</code> overlaps the interval [start,end].
-		 * @private
-		 */
-		isDamaged: function(/**BeginEndNode*/ n, start, end) {
-			// Note strict > since [2,5] doesn't overlap [5,7]
-			return (n.start <= end && n.end > start);
-		},
-		/**
-		 * Builds tree from some of the buffer content
-		 *
-		 * TODO cleanup params
-		 * @param {BeginEndNode|ContainerNode} origNode The deepest node that overlaps [rs,rs], or the root.
-		 * @param {Boolean} repairing 
-		 * @param {Number} rs See _onModelChanged()
-		 * @param {Number} [editStart] Only used for repairing === true
-		 * @param {Number} [addedCharCount] Only used for repairing === true
-		 * @param {Number} [removedCharCount] Only used for repairing === true
-		 * @returns {Number} The end position that redrawRange should be called for.
-		 * @private
-		 */
-		parse: function(origNode, repairing, rs, editStart, addedCharCount, removedCharCount) {
-			var model = this.textView.getModel();
-			var lastLineStart = model.getLineStart(model.getLineCount() - 1);
-			var eof = model.getCharCount();
-			var initialExpected = this.getInitialExpected(origNode, rs);
-			
-			// re is best-case stopping point; if we detect change to tree, we must continue past it
-			var re = -1;
-			if (repairing) {
-				origNode.repaired = true;
-				origNode.endNeedsUpdate = true;
-				var lastChild = origNode.children[origNode.children.length-1];
-				var delta = addedCharCount - removedCharCount;
-				var lastChildLineEnd = lastChild ? model.getLineEnd(model.getLineAtOffset(lastChild.end + delta)) : -1;
-				var editLineEnd = model.getLineEnd(model.getLineAtOffset(editStart + removedCharCount));
-				re = Math.max(lastChildLineEnd, editLineEnd);
-			}
-			re = (re === -1) ? eof : re;
-			
-			var expected = initialExpected;
-			var node = origNode;
-			var matchedChildOrEnd = false;
-			var pos = rs;
-			var redrawEnd = -1;
-			while (node && (!repairing || (pos < re))) {
-				var matchInfo = this.getNextMatch(model, node, pos);
-				if (!matchInfo) {
-					// Go to next line, if any
-					pos = (pos >= lastLineStart) ? eof : model.getLineStart(model.getLineAtOffset(pos) + 1);
-				}
-				var match = matchInfo && matchInfo.match,
-				    rule = matchInfo && matchInfo.rule,
-				    isSub = matchInfo && matchInfo.isSub,
-				    isEnd = matchInfo && matchInfo.isEnd;
-				if (isSub) {
-					pos = this.afterMatch(match);
-					if (rule instanceof this.BeginEndRule) {
-						matchedChildOrEnd = true;
-						// Matched a child. Did we expect that?
-						if (repairing && rule === expected.rule && node === expected.parent) {
-							// Yes: matched expected child
-							var foundChild = expected;
-							foundChild.setStart(match);
-							// Note: the 'end' position for this node will either be matched, or fixed up by us post-loop
-							foundChild.repaired = true;
-							foundChild.endNeedsUpdate = true;
-							node = foundChild; // descend
-							expected = this.getNextExpected(expected, "begin");
-						} else {
-							if (repairing) {
-								// No: matched unexpected child.
-								this.prune(node, expected);
-								repairing = false;
-							}
-							
-							// Add the new child (will replace 'expected' in node's children list)
-							var subNode = new this.BeginEndNode(node, rule, match);
-							node.addChild(subNode);
-							node = subNode; // descend
-						}
-					} else {
-						// Matched a MatchRule; no changes to tree required
-					}
-				} else if (isEnd || pos === eof) {
-					if (node instanceof this.BeginEndNode) {
-						if (match) {
-							matchedChildOrEnd = true;
-							redrawEnd = Math.max(redrawEnd, node.end); // if end moved up, must still redraw to its old value
-							node.setEnd(match);
-							pos = this.afterMatch(match);
-							// Matched node's end. Did we expect that?
-							if (repairing && node === expected && node.parent === expected.parent) {
-								// Yes: found the expected end of node
-								node.repaired = true;
-								delete node.endNeedsUpdate;
-								expected = this.getNextExpected(expected, "end");
-							} else {
-								if (repairing) {
-									// No: found an unexpected end
-									this.prune(node, expected);
-									repairing = false;
-								}
-							}
-						} else {
-							// Force-ending a BeginEndNode that runs until eof
-							node.setEnd(eof);
-							delete node.endNeedsUpdate;
-						}
-					}
-					node = node.parent; // ascend
-				}
-				
-				if (repairing && pos >= re && !matchedChildOrEnd) {
-					// Reached re without matching any begin/end => initialExpected itself was removed => repair fail
-					this.prune(origNode, initialExpected);
-					repairing = false;
-				}
-			} // end loop
-			// TODO: do this for every node we end?
-			this.removeUnrepairedChildren(origNode, repairing, rs);
-			
-			//console.debug("parsed " + (pos - rs) + " of " + model.getCharCount + "buf");
-			this.cleanup(repairing, origNode, rs, re, eof, addedCharCount, removedCharCount);
-			if (repairing) {
-				return Math.max(redrawEnd, pos);
-			} else {
-				return pos; // where we stopped reparsing
-			}
-		},
-		/** Helper for parse() in the repair case. To be called when ending a node, as any children that
-		 * lie in [rs,node.end] and were not repaired must've been deleted.
-		 * @private
-		 */
-		removeUnrepairedChildren: function(node, repairing, start) {
-			if (repairing) {
-				var children = node.children;
-				var removeFrom = -1;
-				for (var i=0; i < children.length; i++) {
-					var child = children[i];
-					if (!child.repaired && this.isDamaged(child, start, Number.MAX_VALUE /*end doesn't matter*/)) {
-						removeFrom = i;
-						break;
-					}
-				}
-				if (removeFrom !== -1) {
-					node.children.length = removeFrom;
-				}
-			}
-		},
-		/** Helper for parse() in the repair case
-		 * @private
-		 */
-		cleanup: function(repairing, origNode, rs, re, eof, addedCharCount, removedCharCount) {
-			var i, node, maybeRepairedNodes;
-			if (repairing) {
-				// The repair succeeded, so update stale begin/end indices by simple translation.
-				var delta = addedCharCount - removedCharCount;
-				// A repaired node's end can't exceed re, but it may exceed re-delta+1.
-				// TODO: find a way to guarantee disjoint intervals for repaired vs unrepaired, then stop using flag
-				var maybeUnrepairedNodes = this.getIntersecting(re-delta+1, eof);
-				maybeRepairedNodes = this.getIntersecting(rs, re);
-				// Handle unrepaired nodes. They are those intersecting [re-delta+1, eof] that don't have the flag
-				for (i=0; i < maybeUnrepairedNodes.length; i++) {
-					node = maybeUnrepairedNodes[i];
-					if (!node.repaired && node instanceof this.BeginEndNode) {
-						node.shiftEnd(delta);
-						node.shiftStart(delta);
-					}
-				}
-				// Translate 'end' index of repaired node whose 'end' was not matched in loop (>= re)
-				for (i=0; i < maybeRepairedNodes.length; i++) {
-					node = maybeRepairedNodes[i];
-					if (node.repaired && node.endNeedsUpdate) {
-						node.shiftEnd(delta);
-					}
-					delete node.endNeedsUpdate;
-					delete node.repaired;
-				}
-			} else {
-				// Clean up after ourself
-				maybeRepairedNodes = this.getIntersecting(rs, re);
-				for (i=0; i < maybeRepairedNodes.length; i++) {
-					delete maybeRepairedNodes[i].repaired;
-				}
-			}
-		},
-		/**
-		 * @param model {orion.textview.TextModel}
-		 * @param node {Node}
-		 * @param pos {Number}
-		 * @param [matchRulesOnly] {Boolean} Optional, if true only "match" subrules will be considered.
-		 * @returns {Object} A match info object with properties:
-		 * {Boolean} isEnd
-		 * {Boolean} isSub
-		 * {RegExp.match} match
-		 * {(Match|BeginEnd)Rule} rule
-		 * @private
-		 */
-		getNextMatch: function(model, node, pos, matchRulesOnly) {
-			var lineIndex = model.getLineAtOffset(pos);
-			var lineEnd = model.getLineEnd(lineIndex);
-			var line = model.getText(pos, lineEnd);
-
-			var stack = [],
-			    expandedContainers = [],
-			    subMatches = [],
-			    subrules = [];
-			this.push(stack, node.rule.subrules);
-			while (stack.length) {
-				var next = stack.length ? stack.pop() : null;
-				var subrule = next && next._resolvedRule._typedRule;
-				if (subrule instanceof this.ContainerRule && expandedContainers.indexOf(subrule) === -1) {
-					// Expand ContainerRule by pushing its subrules on
-					expandedContainers.push(subrule);
-					this.push(stack, subrule.subrules);
-					continue;
-				}
-				if (subrule && matchRulesOnly && !(subrule.matchRegex)) {
-					continue;
-				}
-				var subMatch = subrule && this.exec(subrule.matchRegex || subrule.beginRegex, line, pos);
-				if (subMatch) {
-					subMatches.push(subMatch);
-					subrules.push(subrule);
-				}
-			}
-
-			var bestSub = Number.MAX_VALUE,
-			    bestSubIndex = -1;
-			for (var i=0; i < subMatches.length; i++) {
-				var match = subMatches[i];
-				if (match.index < bestSub) {
-					bestSub = match.index;
-					bestSubIndex = i;
-				}
-			}
-			
-			if (!matchRulesOnly) {
-				// See if the "end" pattern of the active begin/end node matches.
-				// TODO: The active begin/end node may not be the same as the node that holds the subrules
-				var activeBENode = node;
-				var endMatch = this.getEndMatch(node, line, pos);
-				if (endMatch) {
-					var doEndLast = activeBENode.rule.applyEndPatternLast;
-					var endWins = bestSubIndex === -1 || (endMatch.index < bestSub) || (!doEndLast && endMatch.index === bestSub);
-					if (endWins) {
-						return {isEnd: true, rule: activeBENode.rule, match: endMatch};
-					}
-				}
-			}
-			return bestSubIndex === -1 ? null : {isSub: true, rule: subrules[bestSubIndex], match: subMatches[bestSubIndex]};
-		},
-		/**
-		 * Gets the node corresponding to the first match we expect to see in the repair.
-		 * @param {BeginEndNode|ContainerNode} node The node returned via getFirstDamaged(rs,rs) -- may be the root.
-		 * @param {Number} rs See _onModelChanged()
-		 * Note that because rs is a line end (or 0, a line start), it will intersect a beginMatch or 
-		 * endMatch either at their 0th character, or not at all. (begin/endMatches can't cross lines).
-		 * This is the only time we rely on the start/end values from the pre-change tree. After this 
-		 * we only look at node ordering, never use the old indices.
-		 * @returns {Node}
-		 * @private
-		 */
-		getInitialExpected: function(node, rs) {
-			// TODO: Kind of weird.. maybe ContainerNodes should have start & end set, like BeginEndNodes
-			var i, child;
-			if (node === this._tree) {
-				// get whichever of our children comes after rs
-				for (i=0; i < node.children.length; i++) {
-					child = node.children[i]; // BeginEndNode
-					if (child.start >= rs) {
-						return child;
-					}
-				}
-			} else if (node instanceof this.BeginEndNode) {
-				if (node.endMatch) {
-					// Which comes next after rs: our nodeEnd or one of our children?
-					var nodeEnd = node.endMatch.index;
-					for (i=0; i < node.children.length; i++) {
-						child = node.children[i]; // BeginEndNode
-						if (child.start >= rs) {
-							break;
-						}
-					}
-					if (child && child.start < nodeEnd) {
-						return child; // Expect child as the next match
-					}
-				} else {
-					// No endMatch => node goes until eof => it end should be the next match
-				}
-			}
-			return node; // We expect node to end, so it should be the next match
-		},
-		/**
-		 * Helper for repair() to tell us what kind of event we expect next.
-		 * @param {Node} expected Last value returned by this method.
-		 * @param {String} event "begin" if the last value of expected was matched as "begin",
-		 *  or "end" if it was matched as an end.
-		 * @returns {Node} The next expected node to match, or null.
-		 * @private
-		 */
-		getNextExpected: function(/**Node*/ expected, event) {
-			var node = expected;
-			if (event === "begin") {
-				var child = node.children[0];
-				if (child) {
-					return child;
-				} else {
-					return node;
-				}
-			} else if (event === "end") {
-				var parent = node.parent;
-				if (parent) {
-					var nextSibling = parent.children[parent.children.indexOf(node) + 1];
-					if (nextSibling) {
-						return nextSibling;
-					} else {
-						return parent;
-					}
-				}
-			}
-			return null;
-		},
-		/** Helper for parse() when repairing. Prunes out the unmatched nodes from the tree so we can continue parsing.
-		 * @private
-		 */
-		prune: function(/**BeginEndNode|ContainerNode*/ node, /**Node*/ expected) {
-			var expectedAChild = expected.parent === node;
-			if (expectedAChild) {
-				// Expected child wasn't matched; prune it and all siblings after it
-				node.children.length = expected.getIndexInParent();
-			} else if (node instanceof this.BeginEndNode) {
-				// Expected node to end but it didn't; set its end unknown and we'll match it eventually
-				node.endMatch = null;
-				node.end = null;
-			}
-			// Reparsing from node, so prune the successors outside of node's subtree
-			if (node.parent) {
-				node.parent.children.length = node.getIndexInParent() + 1;
-			}
-		},
-		onLineStyle: function(/**eclipse.LineStyleEvent*/ e) {
-			function byStart(r1, r2) {
-				return r1.start - r2.start;
-			}
-			
-			if (!this._tree) {
-				// In some cases it seems onLineStyle is called before onModelChanged, so we need to parse here
-				this.initialParse();
-			}
-			var lineStart = e.lineStart,
-			    model = this.textView.getModel(),
-			    lineEnd = model.getLineEnd(e.lineIndex);
-			
-			var rs = model.getLineEnd(model.getLineAtOffset(lineStart) - 1); // may be < 0
-			var node = this.getFirstDamaged(rs, rs);
-			
-			var scopes = this.getLineScope(model, node, lineStart, lineEnd);
-			e.ranges = this.toStyleRanges(scopes);
-			// Editor requires StyleRanges must be in ascending order by 'start', or else some will be ignored
-			e.ranges.sort(byStart);
-		},
-		/** Runs parse algorithm on [start, end] in the context of node, assigning scope as we find matches.
-		 * @private
-		 */
-		getLineScope: function(model, node, start, end) {
-			var pos = start;
-			var expected = this.getInitialExpected(node, start);
-			var scopes = [],
-			    gaps = [];
-			while (node && (pos < end)) {
-				var matchInfo = this.getNextMatch(model, node, pos);
-				if (!matchInfo) { 
-					break; // line is over
-				}
-				var match = matchInfo && matchInfo.match,
-				    rule = matchInfo && matchInfo.rule,
-				    isSub = matchInfo && matchInfo.isSub,
-				    isEnd = matchInfo && matchInfo.isEnd;
-				if (match.index !== pos) {
-					// gap [pos..match.index]
-					gaps.push({ start: pos, end: match.index, node: node});
-				}
-				if (isSub) {
-					pos = this.afterMatch(match);
-					if (rule instanceof this.BeginEndRule) {
-						// Matched a "begin", assign its scope and descend into it
-						this.addBeginScope(scopes, match, rule);
-						node = expected; // descend
-						expected = this.getNextExpected(expected, "begin");
-					} else {
-						// Matched a child MatchRule;
-						this.addMatchScope(scopes, match, rule);
-					}
-				} else if (isEnd) {
-					pos = this.afterMatch(match);
-					// Matched and "end", assign its end scope and go up
-					this.addEndScope(scopes, match, rule);
-					expected = this.getNextExpected(expected, "end");
-					node = node.parent; // ascend
-				}
-			}
-			if (pos < end) {
-				gaps.push({ start: pos, end: end, node: node });
-			}
-			var inherited = this.getInheritedLineScope(gaps, start, end);
-			return scopes.concat(inherited);
-		},
-		/** @private */
-		getInheritedLineScope: function(gaps, start, end) {
-			var scopes = [];
-			for (var i=0; i < gaps.length; i++) {
-				var gap = gaps[i];
-				var node = gap.node;
-				while (node) {
-					// if node defines a contentName or name, apply it
-					var rule = node.rule.rule;
-					var name = rule.name,
-					    contentName = rule.contentName;
-					// TODO: if both are given, we don't resolve the conflict. contentName always wins
-					var scope = contentName || name;
-					if (scope) {
-						this.addScopeRange(scopes, gap.start, gap.end, scope);
-						break;
-					}
-					node = node.parent;
-				}
-			}
-			return scopes;
-		},
-		/** @private */
-		addBeginScope: function(scopes, match, typedRule) {
-			var rule = typedRule.rule;
-			this.addCapturesScope(scopes, match, (rule.beginCaptures || rule.captures), typedRule.isComplex, typedRule.beginOld2New, typedRule.beginConsuming);
-		},
-		/** @private */
-		addEndScope: function(scopes, match, typedRule) {
-			var rule = typedRule.rule;
-			this.addCapturesScope(scopes, match, (rule.endCaptures || rule.captures), typedRule.isComplex, typedRule.endOld2New, typedRule.endConsuming);
-		},
-		/** @private */
-		addMatchScope: function(scopes, match, typedRule) {
-			var rule = typedRule.rule,
-			    name = rule.name,
-			    captures = rule.captures;
-			if (captures) {	
-				// captures takes priority over name
-				this.addCapturesScope(scopes, match, captures, typedRule.isComplex, typedRule.matchOld2New, typedRule.matchConsuming);
-			} else {
-				this.addScope(scopes, match, name);
-			}
-		},
-		/** @private */
-		addScope: function(scopes, match, name) {
-			if (!name) { return; }
-			scopes.push({start: match.index, end: this.afterMatch(match), scope: name });
-		},
-		/** @private */
-		addScopeRange: function(scopes, start, end, name) {
-			if (!name) { return; }
-			scopes.push({start: start, end: end, scope: name });
-		},
-		/** @private */
-		addCapturesScope: function(/**Array*/scopes, /*RegExp.match*/ match, /**Object*/captures, /**Boolean*/isComplex, /**Object*/old2New, /**Object*/consuming) {
-			if (!captures) { return; }
-			if (!isComplex) {
-				this.addScope(scopes, match, captures[0] && captures[0].name);
-			} else {
-				// apply scopes captures[1..n] to matching groups [1]..[n] of match
-				
-				// Sum up the lengths of preceding consuming groups to get the start offset for each matched group.
-				var newGroupStarts = {1: 0};
-				var sum = 0;
-				for (var num = 1; match[num] !== undefined; num++) {
-					if (consuming[num] !== undefined) {
-						sum += match[num].length;
-					}
-					if (match[num+1] !== undefined) {
-						newGroupStarts[num + 1] = sum;
-					}
-				}
-				// Map the group numbers referred to in captures object to the new group numbers, and get the actual matched range.
-				var start = match.index;
-				for (var oldGroupNum = 1; captures[oldGroupNum]; oldGroupNum++) {
-					var scope = captures[oldGroupNum].name;
-					var newGroupNum = old2New[oldGroupNum];
-					var groupStart = start + newGroupStarts[newGroupNum];
-					// Not every capturing group defined in regex need match every time the regex is run.
-					// eg. (a)|b matches "b" but group 1 is undefined
-					if (typeof match[newGroupNum] !== "undefined") {
-						var groupEnd = groupStart + match[newGroupNum].length;
-						this.addScopeRange(scopes, groupStart, groupEnd, scope);
-					}
-				}
-			}
-		},
-		/** @returns {Node[]} In depth-first order
-		 * @private
-		 */
-		getIntersecting: function(start, end) {
-			var result = [];
-			var nodes = this._tree ? [this._tree] : [];
-			while (nodes.length) {
-				var n = nodes.pop();
-				var visitChildren = false;
-				if (n instanceof this.ContainerNode) {
-					visitChildren = true;
-				} else if (this.isDamaged(n, start, end)) {
-					visitChildren = true;
-					result.push(n);
-				}
-				if (visitChildren) {
-					var len = n.children.length;
-//					for (var i=len-1; i >= 0; i--) {
-//						nodes.push(n.children[i]);
-//					}
-					for (var i=0; i < len; i++) {
-						nodes.push(n.children[i]);
-					}
-				}
-			}
-			return result.reverse();
-		},
-		/**
-		 * Applies the grammar to obtain the {@link eclipse.StyleRange[]} for the given line.
-		 * @returns eclipse.StyleRange[]
-		 * @private
-		 */
-		toStyleRanges: function(/**ScopeRange[]*/ scopeRanges) {
-			var styleRanges = [];
-			for (var i=0; i < scopeRanges.length; i++) {
-				var scopeRange = scopeRanges[i];
-				var classNames = this._styles[scopeRange.scope];
-				if (!classNames) { throw new Error("styles not found for " + scopeRange.scope); }
-				var classNamesString = classNames.join(" ");
-				styleRanges.push({start: scopeRange.start, end: scopeRange.end, style: {styleClass: classNamesString}});
-//				console.debug("{start " + styleRanges[i].start + ", end " + styleRanges[i].end + ", style: " + styleRanges[i].style.styleClass + "}");
-			}
-			return styleRanges;
-		}
-	};
-	
-	return {
-		RegexUtil: RegexUtil,
-		TextMateStyler: TextMateStyler
-	};
-});
-/*******************************************************************************
+});/*******************************************************************************
  * @license
  * Copyright (c) 2010, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials are made 
  * available under the terms of the Eclipse Public License v1.0 
  * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
  * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
  * 
  * Contributors: IBM Corporation - initial API and implementation
- *               Alex Lakatos - fix for bug#369781
  ******************************************************************************/
 
-/*global document window navigator define */
-
-define("examples/textview/textStyler", ['orion/textview/annotations'], function(mAnnotations) {
-
-	var JS_KEYWORDS =
-		["break",
-		 "case", "class", "catch", "continue", "const", 
-		 "debugger", "default", "delete", "do",
-		 "else", "enum", "export", "extends",  
-		 "false", "finally", "for", "function",
-		 "if", "implements", "import", "in", "instanceof", "interface", 
-		 "let",
-		 "new", "null",
-		 "package", "private", "protected", "public",
-		 "return", 
-		 "static", "super", "switch",
-		 "this", "throw", "true", "try", "typeof",
-		 "undefined",
-		 "var", "void",
-		 "while", "with",
-		 "yield"];
-
-	var JAVA_KEYWORDS =
-		["abstract",
-		 "boolean", "break", "byte",
-		 "case", "catch", "char", "class", "continue",
-		 "default", "do", "double",
-		 "else", "extends",
-		 "false", "final", "finally", "float", "for",
-		 "if", "implements", "import", "instanceof", "int", "interface",
-		 "long",
-		 "native", "new", "null",
-		 "package", "private", "protected", "public",
-		 "return",
-		 "short", "static", "super", "switch", "synchronized",
-		 "this", "throw", "throws", "transient", "true", "try",
-		 "void", "volatile",
-		 "while"];
-
-	var CSS_KEYWORDS =
-		["alignment-adjust", "alignment-baseline", "animation", "animation-delay", "animation-direction", "animation-duration",
-		 "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance",
-		 "azimuth", "backface-visibility", "background", "background-attachment", "background-clip", "background-color",
-		 "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift",
-		 "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom",
-		 "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width",
-		 "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice",
-		 "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width",
-		 "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style",
-		 "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width",
-		 "border-width", "bottom", "box-align", "box-decoration-break", "box-direction", "box-flex", "box-flex-group", "box-lines",
-		 "box-ordinal-group", "box-orient", "box-pack", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
-		 "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule",
-		 "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment",
-		 "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline",
-		 "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size",
-		 "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex-align", "flex-flow", "flex-inline-pack", "flex-order",
-		 "flex-pack", "float", "float-offset", "font", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style",
-		 "font-variant", "font-weight", "grid-columns", "grid-rows", "hanging-punctuation", "height", "hyphenate-after",
-		 "hyphenate-before", "hyphenate-character", "hyphenate-lines", "hyphenate-resource", "hyphens", "icon", "image-orientation",
-		 "image-rendering", "image-resolution", "inline-box-align", "left", "letter-spacing", "line-height", "line-stacking",
-		 "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position",
-		 "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "mark", "mark-after", "mark-before",
-		 "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
-		 "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "opacity", "orphans",
-		 "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-x",
-		 "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before",
-		 "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "phonemes", "pitch",
-		 "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "rendering-intent", "resize",
-		 "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position",
-		 "ruby-span", "size", "speak", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "table-layout",
-		 "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-emphasis",
-		 "text-height", "text-indent", "text-justify", "text-outline", "text-shadow", "text-transform", "text-wrap", "top", "transform",
-		 "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property",
-		 "transition-timing-function", "unicode-bidi", "vector-effect", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family",
-		 "voice-pitch", "voice-pitch-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "white-space-collapse",
-		 "widows", "width", "word-break", "word-spacing", "word-wrap", "z-index"
-		];
-
-	// Scanner constants
-	var UNKOWN = 1;
-	var KEYWORD = 2;
-	var STRING = 3;
-	var SINGLELINE_COMMENT = 4;
-	var MULTILINE_COMMENT = 5;
-	var DOC_COMMENT = 6;
-	var WHITE = 7;
-	var WHITE_TAB = 8;
-	var WHITE_SPACE = 9;
-	var HTML_MARKUP = 10;
-	var DOC_TAG = 11;
-	var TASK_TAG = 12;
-
-	// Styles 
-	var singleCommentStyle = {styleClass: "token_singleline_comment"};
-	var multiCommentStyle = {styleClass: "token_multiline_comment"};
-	var docCommentStyle = {styleClass: "token_doc_comment"};
-	var htmlMarkupStyle = {styleClass: "token_doc_html_markup"};
-	var tasktagStyle = {styleClass: "token_task_tag"};
-	var doctagStyle = {styleClass: "token_doc_tag"};
-	var stringStyle = {styleClass: "token_string"};
-	var keywordStyle = {styleClass: "token_keyword"};
-	var spaceStyle = {styleClass: "token_space"};
-	var tabStyle = {styleClass: "token_tab"};
-	var caretLineStyle = {styleClass: "line_caret"};
-	
-	function Scanner (keywords, whitespacesVisible) {
-		this.keywords = keywords;
-		this.whitespacesVisible = whitespacesVisible;
-		this.setText("");
+/*global define */
+
+define("orion/textview/undoStack", [], function() {
+
+	/** 
+	 * Constructs a new Change object.
+	 * 
+	 * @class 
+	 * @name orion.textview.Change
+	 * @private
+	 */
+	function Change(offset, text, previousText) {
+		this.offset = offset;
+		this.text = text;
+		this.previousText = previousText;
 	}
-	
-	Scanner.prototype = {
-		getOffset: function() {
-			return this.offset;
-		},
-		getStartOffset: function() {
-			return this.startOffset;
-		},
-		getData: function() {
-			return this.text.substring(this.startOffset, this.offset);
-		},
-		getDataLength: function() {
-			return this.offset - this.startOffset;
-		},
-		_default: function(c) {
-			var keywords = this.keywords;
-			switch (c) {
-				case 32: // SPACE
-				case 9: // TAB
-					if (this.whitespacesVisible) {
-						return c === 32 ? WHITE_SPACE : WHITE_TAB;
-					}
-					do {
-						c = this._read();
-					} while(c === 32 || c === 9);
-					this._unread(c);
-					return WHITE;
-				case 123: // {
-				case 125: // }
-				case 40: // (
-				case 41: // )
-				case 91: // [
-				case 93: // ]
-				case 60: // <
-				case 62: // >
-					// BRACKETS
-					return c;
-				default:
-					var isCSS = this.isCSS;
-					if ((97 <= c && c <= 122) || (65 <= c && c <= 90) || c === 95 || (48 <= c && c <= 57) || (0x2d === c && isCSS)) { //LETTER OR UNDERSCORE OR NUMBER
-						var off = this.offset - 1;
-						do {
-							c = this._read();
-						} while((97 <= c && c <= 122) || (65 <= c && c <= 90) || c === 95 || (48 <= c && c <= 57) || (0x2d === c && isCSS));  //LETTER OR UNDERSCORE OR NUMBER
-						this._unread(c);
-						if (keywords.length > 0) {
-							var word = this.text.substring(off, this.offset);
-							//TODO slow
-							for (var i=0; i<keywords.length; i++) {
-								if (this.keywords[i] === word) { return KEYWORD; }
-							}
+	Change.prototype = {
+		/** @ignore */
+		undo: function (view, select) {
+			this._doUndoRedo(this.offset, this.previousText, this.text, view, select);
+		},
+		/** @ignore */
+		redo: function (view, select) {
+			this._doUndoRedo(this.offset, this.text, this.previousText, view, select);
+		},
+		_doUndoRedo: function(offset, text, previousText, view, select) {
+			var model = view.getModel();
+			/* 
+			* TODO UndoStack should be changing the text in the base model.
+			* This is code needs to change when modifications in the base
+			* model are supported properly by the projection model.
+			*/
+			if (model.mapOffset && view.annotationModel) {
+				var mapOffset = model.mapOffset(offset, true);
+				if (mapOffset < 0) {
+					var annotationModel = view.annotationModel;
+					var iter = annotationModel.getAnnotations(offset, offset + 1);
+					while (iter.hasNext()) {
+						var annotation = iter.next();
+						if (annotation.type === "orion.annotation.folding") {
+							annotation.expand();
+							mapOffset = model.mapOffset(offset, true);
+							break;
 						}
 					}
-					return UNKOWN;
-			}
-		},
-		_read: function() {
-			if (this.offset < this.text.length) {
-				return this.text.charCodeAt(this.offset++);
-			}
-			return -1;
-		},
-		_unread: function(c) {
-			if (c !== -1) { this.offset--; }
-		},
-		nextToken: function() {
-			this.startOffset = this.offset;
-			while (true) {
-				var c = this._read();
-				switch (c) {
-					case -1: return null;
-					case 47:	// SLASH -> comment
-						c = this._read();
-						if (!this.isCSS) {
-							if (c === 47) { // SLASH -> single line
-								while (true) {
-									c = this._read();
-									if ((c === -1) || (c === 10) || (c === 13)) {
-										this._unread(c);
-										return SINGLELINE_COMMENT;
-									}
-								}
-							}
-						}
-						if (c === 42) { // STAR -> multi line 
-							c = this._read();
-							var token = MULTILINE_COMMENT;
-							if (c === 42) {
-								token = DOC_COMMENT;
-							}
-							while (true) {
-								while (c === 42) {
-									c = this._read();
-									if (c === 47) {
-										return token;
-									}
-								}
-								if (c === -1) {
-									this._unread(c);
-									return token;
-								}
-								c = this._read();
-							}
-						}
-						this._unread(c);
-						return UNKOWN;
-					case 39:	// SINGLE QUOTE -> char const
-						while(true) {
-							c = this._read();
-							switch (c) {
-								case 39:
-									return STRING;
-								case 13:
-								case 10:
-								case -1:
-									this._unread(c);
-									return STRING;
-								case 92: // BACKSLASH
-									c = this._read();
-									break;
-							}
-						}
-						break;
-					case 34:	// DOUBLE QUOTE -> string
-						while(true) {
-							c = this._read();
-							switch (c) {
-								case 34: // DOUBLE QUOTE
-									return STRING;
-								case 13:
-								case 10:
-								case -1:
-									this._unread(c);
-									return STRING;
-								case 92: // BACKSLASH
-									c = this._read();
-									break;
-							}
-						}
-						break;
-					default:
-						return this._default(c);
-				}
-			}
-		},
-		setText: function(text) {
-			this.text = text;
-			this.offset = 0;
-			this.startOffset = 0;
+				}
+				if (mapOffset < 0) { return; }
+				offset = mapOffset;
+			}
+			view.setText(text, offset, offset + previousText.length);
+			if (select) {
+				view.setSelection(offset, offset + text.length);
+			}
+		}
+	};
+
+	/** 
+	 * Constructs a new CompoundChange object.
+	 * 
+	 * @class 
+	 * @name orion.textview.CompoundChange
+	 * @private
+	 */
+	function CompoundChange () {
+		this.changes = [];
+	}
+	CompoundChange.prototype = {
+		/** @ignore */
+		add: function (change) {
+			this.changes.push(change);
+		},
+		/** @ignore */
+		end: function (view) {
+			this.endSelection = view.getSelection();
+			this.endCaret = view.getCaretOffset();
+		},
+		/** @ignore */
+		undo: function (view, select) {
+			for (var i=this.changes.length - 1; i >= 0; i--) {
+				this.changes[i].undo(view, false);
+			}
+			if (select) {
+				var start = this.startSelection.start;
+				var end = this.startSelection.end;
+				view.setSelection(this.startCaret ? start : end, this.startCaret ? end : start);
+			}
+		},
+		/** @ignore */
+		redo: function (view, select) {
+			for (var i = 0; i < this.changes.length; i++) {
+				this.changes[i].redo(view, false);
+			}
+			if (select) {
+				var start = this.endSelection.start;
+				var end = this.endSelection.end;
+				view.setSelection(this.endCaret ? start : end, this.endCaret ? end : start);
+			}
+		},
+		/** @ignore */
+		start: function (view) {
+			this.startSelection = view.getSelection();
+			this.startCaret = view.getCaretOffset();
+		}
+	};
+
+	/**
+	 * Constructs a new UndoStack on a text view.
+	 *
+	 * @param {orion.textview.TextView} view the text view for the undo stack.
+	 * @param {Number} [size=100] the size for the undo stack.
+	 *
+	 * @name orion.textview.UndoStack
+	 * @class The UndoStack is used to record the history of a text model associated to an view. Every
+	 * change to the model is added to stack, allowing the application to undo and redo these changes.
+	 *
+	 * <p>
+	 * <b>See:</b><br/>
+	 * {@link orion.textview.TextView}<br/>
+	 * </p>
+	 */
+	function UndoStack (view, size) {
+		this.view = view;
+		this.size = size !== undefined ? size : 100;
+		this.reset();
+		var model = view.getModel();
+		if (model.getBaseModel) {
+			model = model.getBaseModel();
+		}
+		this.model = model;
+		var self = this;
+		this._listener = {
+			onChanging: function(e) {
+				self._onChanging(e);
+			},
+			onDestroy: function(e) {
+				self._onDestroy(e);
+			}
+		};
+		model.addEventListener("Changing", this._listener.onChanging);
+		view.addEventListener("Destroy", this._listener.onDestroy);
+	}
+	UndoStack.prototype = /** @lends orion.textview.UndoStack.prototype */ {
+		/**
+		 * Adds a change to the stack.
+		 * 
+		 * @param change the change to add.
+		 * @param {Number} change.offset the offset of the change
+		 * @param {String} change.text the new text of the change
+		 * @param {String} change.previousText the previous text of the change
+		 */
+		add: function (change) {
+			if (this.compoundChange) {
+				this.compoundChange.add(change);
+			} else {
+				var length = this.stack.length;
+				this.stack.splice(this.index, length-this.index, change);
+				this.index++;
+				if (this.stack.length > this.size) {
+					this.stack.shift();
+					this.index--;
+					this.cleanIndex--;
+				}
+			}
+		},
+		/** 
+		 * Marks the current state of the stack as clean.
+		 *
+		 * <p>
+		 * This function is typically called when the content of view associated with the stack is saved.
+		 * </p>
+		 *
+		 * @see #isClean
+		 */
+		markClean: function() {
+			this.endCompoundChange();
+			this._commitUndo();
+			this.cleanIndex = this.index;
+		},
+		/**
+		 * Returns true if current state of stack is the same
+		 * as the state when markClean() was called.
+		 *
+		 * <p>
+		 * For example, the application calls markClean(), then calls undo() four times and redo() four times.
+		 * At this point isClean() returns true.  
+		 * </p>
+		 * <p>
+		 * This function is typically called to determine if the content of the view associated with the stack
+		 * has changed since the last time it was saved.
+		 * </p>
+		 *
+		 * @return {Boolean} returns if the state is the same as the state when markClean() was called.
+		 *
+		 * @see #markClean
+		 */
+		isClean: function() {
+			return this.cleanIndex === this.getSize().undo;
+		},
+		/**
+		 * Returns true if there is at least one change to undo.
+		 *
+		 * @return {Boolean} returns true if there is at least one change to undo.
+		 *
+		 * @see #canRedo
+		 * @see #undo
+		 */
+		canUndo: function() {
+			return this.getSize().undo > 0;
+		},
+		/**
+		 * Returns true if there is at least one change to redo.
+		 *
+		 * @return {Boolean} returns true if there is at least one change to redo.
+		 *
+		 * @see #canUndo
+		 * @see #redo
+		 */
+		canRedo: function() {
+			return this.getSize().redo > 0;
+		},
+		/**
+		 * Finishes a compound change.
+		 *
+		 * @see #startCompoundChange
+		 */
+		endCompoundChange: function() {
+			if (this.compoundChange) {
+				this.compoundChange.end(this.view);
+			}
+			this.compoundChange = undefined;
+		},
+		/**
+		 * Returns the sizes of the stack.
+		 *
+		 * @return {object} a object where object.undo is the number of changes that can be un-done, 
+		 *  and object.redo is the number of changes that can be re-done.
+		 *
+		 * @see #canUndo
+		 * @see #canRedo
+		 */
+		getSize: function() {
+			var index = this.index;
+			var length = this.stack.length;
+			if (this._undoStart !== undefined) {
+				index++;
+			}
+			return {undo: index, redo: (length - index)};
+		},
+		/**
+		 * Undo the last change in the stack.
+		 *
+		 * @return {Boolean} returns true if a change was un-done.
+		 *
+		 * @see #redo
+		 * @see #canUndo
+		 */
+		undo: function() {
+			this._commitUndo();
+			if (this.index <= 0) {
+				return false;
+			}
+			var change = this.stack[--this.index];
+			this._ignoreUndo = true;
+			change.undo(this.view, true);
+			this._ignoreUndo = false;
+			return true;
+		},
+		/**
+		 * Redo the last change in the stack.
+		 *
+		 * @return {Boolean} returns true if a change was re-done.
+		 *
+		 * @see #undo
+		 * @see #canRedo
+		 */
+		redo: function() {
+			this._commitUndo();
+			if (this.index >= this.stack.length) {
+				return false;
+			}
+			var change = this.stack[this.index++];
+			this._ignoreUndo = true;
+			change.redo(this.view, true);
+			this._ignoreUndo = false;
+			return true;
+		},
+		/**
+		 * Reset the stack to its original state. All changes in the stack are thrown away.
+		 */
+		reset: function() {
+			this.index = this.cleanIndex = 0;
+			this.stack = [];
+			this._undoStart = undefined;
+			this._undoText = "";
+			this._undoType = 0;
+			this._ignoreUndo = false;
+			this._compoundChange = undefined;
+		},
+		/**
+		 * Starts a compound change. 
+		 * <p>
+		 * All changes added to stack from the time startCompoundChange() is called
+		 * to the time that endCompoundChange() is called are compound on one change that can be un-done or re-done
+		 * with one single call to undo() or redo().
+		 * </p>
+		 *
+		 * @see #endCompoundChange
+		 */
+		startCompoundChange: function() {
+			this._commitUndo();
+			var change = new CompoundChange();
+			this.add(change);
+			this.compoundChange = change;
+			this.compoundChange.start(this.view);
+		},
+		_commitUndo: function () {
+			if (this._undoStart !== undefined) {
+				if (this._undoType === -1) {
+					this.add(new Change(this._undoStart, "", this._undoText));
+				} else {
+					this.add(new Change(this._undoStart, this._undoText, ""));
+				}
+				this._undoStart = undefined;
+				this._undoText = "";
+				this._undoType = 0;
+			}
+		},
+		_onDestroy: function(evt) {
+			this.model.removeEventListener("Changing", this._listener.onChanging);
+			this.view.removeEventListener("Destroy", this._listener.onDestroy);
+		},
+		_onChanging: function(e) {
+			var newText = e.text;
+			var start = e.start;
+			var removedCharCount = e.removedCharCount;
+			var addedCharCount = e.addedCharCount;
+			if (this._ignoreUndo) {
+				return;
+			}
+			if (this._undoStart !== undefined && 
+				!((addedCharCount === 1 && removedCharCount === 0 && this._undoType === 1 && start === this._undoStart + this._undoText.length) ||
+					(addedCharCount === 0 && removedCharCount === 1 && this._undoType === -1 && (((start + 1) === this._undoStart) || (start === this._undoStart)))))
+			{
+				this._commitUndo();
+			}
+			if (!this.compoundChange) {
+				if (addedCharCount === 1 && removedCharCount === 0) {
+					if (this._undoStart === undefined) {
+						this._undoStart = start;
+					}
+					this._undoText = this._undoText + newText;
+					this._undoType = 1;
+					return;
+				} else if (addedCharCount === 0 && removedCharCount === 1) {
+					var deleting = this._undoText.length > 0 && this._undoStart === start;
+					this._undoStart = start;
+					this._undoType = -1;
+					if (deleting) {
+						this._undoText = this._undoText + this.model.getText(start, start + removedCharCount);
+					} else {
+						this._undoText = this.model.getText(start, start + removedCharCount) + this._undoText;
+					}
+					return;
+				}
+			}
+			this.add(new Change(start, newText, this.model.getText(start, start + removedCharCount)));
 		}
 	};
 	
-	function WhitespaceScanner () {
-		Scanner.call(this, null, true);
-	}
-	WhitespaceScanner.prototype = new Scanner(null);
-	WhitespaceScanner.prototype.nextToken = function() {
-		this.startOffset = this.offset;
-		while (true) {
-			var c = this._read();
-			switch (c) {
-				case -1: return null;
-				case 32: // SPACE
-					return WHITE_SPACE;
-				case 9: // TAB
-					return WHITE_TAB;
-				default:
-					do {
-						c = this._read();
-					} while(!(c === 32 || c === 9 || c === -1));
-					this._unread(c);
-					return UNKOWN;
-			}
-		}
+	return {
+		UndoStack: UndoStack
 	};
-	
-	function CommentScanner (whitespacesVisible) {
-		Scanner.call(this, null, whitespacesVisible);
-	}
-	CommentScanner.prototype = new Scanner(null);
-	CommentScanner.prototype.setType = function(type) {
-		this._type = type;
-	};
-	CommentScanner.prototype.nextToken = function() {
-		this.startOffset = this.offset;
-		while (true) {
-			var c = this._read();
-			switch (c) {
-				case -1: return null;
-				case 32: // SPACE
-				case 9: // TAB
-					if (this.whitespacesVisible) {
-						return c === 32 ? WHITE_SPACE : WHITE_TAB;
-					}
-					do {
-						c = this._read();
-					} while(c === 32 || c === 9);
-					this._unread(c);
-					return WHITE;
-				case 60: // <
-					if (this._type === DOC_COMMENT) {
-						do {
-							c = this._read();
-						} while(!(c === 62 || c === -1)); // >
-						if (c === 62) {
-							return HTML_MARKUP;
-						}
-					}
-					return UNKOWN;
-				case 64: // @
-					if (this._type === DOC_COMMENT) {
-						do {
-							c = this._read();
-						} while((97 <= c && c <= 122) || (65 <= c && c <= 90) || c === 95 || (48 <= c && c <= 57));  //LETTER OR UNDERSCORE OR NUMBER
-						this._unread(c);
-						return DOC_TAG;
-					}
-					return UNKOWN;
-				case 84: // T
-					if ((c = this._read()) === 79) { // O
-						if ((c = this._read()) === 68) { // D
-							if ((c = this._read()) === 79) { // O
-								c = this._read();
-								if (!((97 <= c && c <= 122) || (65 <= c && c <= 90) || c === 95 || (48 <= c && c <= 57))) {
-									this._unread(c);
-									return TASK_TAG;
-								}
-								this._unread(c);
-							} else {
-								this._unread(c);
-							}
-						} else {
-							this._unread(c);
-						}
-					} else {
-						this._unread(c);
-					}
-					//FALL THROUGH
-				default:
-					do {
-						c = this._read();
-					} while(!(c === 32 || c === 9 || c === -1 || c === 60 || c === 64 || c === 84));
-					this._unread(c);
-					return UNKOWN;
-			}
-		}
-	};
-	
-	function FirstScanner () {
-		Scanner.call(this, null, false);
-	}
-	FirstScanner.prototype = new Scanner(null);
-	FirstScanner.prototype._default = function(c) {
-		while(true) {
-			c = this._read();
-			switch (c) {
-				case 47: // SLASH
-				case 34: // DOUBLE QUOTE
-				case 39: // SINGLE QUOTE
-				case -1:
-					this._unread(c);
-					return UNKOWN;
-			}
-		}
-	};
-	
-	function TextStyler (view, lang, annotationModel) {
-		this.commentStart = "/*";
-		this.commentEnd = "*/";
-		var keywords = [];
-		switch (lang) {
-			case "java": keywords = JAVA_KEYWORDS; break;
-			case "js": keywords = JS_KEYWORDS; break;
-			case "css": keywords = CSS_KEYWORDS; break;
-		}
-		this.whitespacesVisible = false;
-		this.detectHyperlinks = true;
-		this.highlightCaretLine = false;
-		this.foldingEnabled = true;
-		this.detectTasks = true;
-		this._scanner = new Scanner(keywords, this.whitespacesVisible);
-		this._firstScanner = new FirstScanner();
-		this._commentScanner = new CommentScanner(this.whitespacesVisible);
-		this._whitespaceScanner = new WhitespaceScanner();
-		//TODO these scanners are not the best/correct way to parse CSS
-		if (lang === "css") {
-			this._scanner.isCSS = true;
-			this._firstScanner.isCSS = true;
-		}
-		this.view = view;
-		this.annotationModel = annotationModel;
-		this._bracketAnnotations = undefined; 
-		
-		var self = this;
-		this._listener = {
-			onChanged: function(e) {
-				self._onModelChanged(e);
-			},
-			onDestroy: function(e) {
-				self._onDestroy(e);
-			},
-			onLineStyle: function(e) {
-				self._onLineStyle(e);
-			},
-			onSelection: function(e) {
-				self._onSelection(e);
-			}
-		};
-		var model = view.getModel();
-		if (model.getBaseModel) {
-			model.getBaseModel().addEventListener("Changed", this._listener.onChanged);
-		} else {
-			//TODO still needed to keep the event order correct (styler before view)
-			view.addEventListener("ModelChanged", this._listener.onChanged);
-		}
-		view.addEventListener("Selection", this._listener.onSelection);
-		view.addEventListener("Destroy", this._listener.onDestroy);
-		view.addEventListener("LineStyle", this._listener.onLineStyle);
-		this._computeComments ();
-		this._computeFolding();
-		view.redrawLines();
-	}
-	
-	TextStyler.prototype = {
-		getClassNameForToken: function(token) {
-			switch (token) {
-				case "singleLineComment": return singleCommentStyle.styleClass;
-				case "multiLineComment": return multiCommentStyle.styleClass;
-				case "docComment": return docCommentStyle.styleClass;
-				case "docHtmlComment": return htmlMarkupStyle.styleClass;
-				case "tasktag": return tasktagStyle.styleClass;
-				case "doctag": return doctagStyle.styleClass;
-				case "string": return stringStyle.styleClass;
-				case "keyword": return keywordStyle.styleClass;
-				case "space": return spaceStyle.styleClass;
-				case "tab": return tabStyle.styleClass;
-				case "caretLine": return caretLineStyle.styleClass;
-			}
-			return null;
-		},
-		destroy: function() {
-			var view = this.view;
-			if (view) {
-				var model = view.getModel();
-				if (model.getBaseModel) {
-					model.getBaseModel().removeEventListener("Changed", this._listener.onChanged);
-				} else {
-					view.removeEventListener("ModelChanged", this._listener.onChanged);
-				}
-				view.removeEventListener("Selection", this._listener.onSelection);
-				view.removeEventListener("Destroy", this._listener.onDestroy);
-				view.removeEventListener("LineStyle", this._listener.onLineStyle);
-				this.view = null;
-			}
-		},
-		setHighlightCaretLine: function(highlight) {
-			this.highlightCaretLine = highlight;
-		},
-		setWhitespacesVisible: function(visible) {
-			this.whitespacesVisible = visible;
-			this._scanner.whitespacesVisible = visible;
-			this._commentScanner.whitespacesVisible = visible;
-		},
-		setDetectHyperlinks: function(enabled) {
-			this.detectHyperlinks = enabled;
-		},
-		setFoldingEnabled: function(enabled) {
-			this.foldingEnabled = enabled;
-		},
-		setDetectTasks: function(enabled) {
-			this.detectTasks = enabled;
-		},
-		_binarySearch: function (array, offset, inclusive, low, high) {
-			var index;
-			if (low === undefined) { low = -1; }
-			if (high === undefined) { high = array.length; }
-			while (high - low > 1) {
-				index = Math.floor((high + low) / 2);
-				if (offset <= array[index].start) {
-					high = index;
-				} else if (inclusive && offset < array[index].end) {
-					high = index;
-					break;
-				} else {
-					low = index;
-				}
-			}
-			return high;
-		},
-		_computeComments: function() {
-			var model = this.view.getModel();
-			if (model.getBaseModel) { model = model.getBaseModel(); }
-			this.comments = this._findComments(model.getText());
-		},
-		_computeFolding: function() {
-			if (!this.foldingEnabled) { return; }
-			var view = this.view;
-			var viewModel = view.getModel();
-			if (!viewModel.getBaseModel) { return; }
-			var annotationModel = this.annotationModel;
-			if (!annotationModel) { return; }
-			annotationModel.removeAnnotations("orion.annotation.folding");
-			var add = [];
-			var baseModel = viewModel.getBaseModel();
-			var comments = this.comments;
-			for (var i=0; i<comments.length; i++) {
-				var comment = comments[i];
-				var annotation = this._createFoldingAnnotation(viewModel, baseModel, comment.start, comment.end);
-				if (annotation) { 
-					add.push(annotation);
-				}
-			}
-			annotationModel.replaceAnnotations(null, add);
-		},
-		_createFoldingAnnotation: function(viewModel, baseModel, start, end) {
-			var startLine = baseModel.getLineAtOffset(start);
-			var endLine = baseModel.getLineAtOffset(end);
-			if (startLine === endLine) {
-				return null;
-			}
-			return new mAnnotations.FoldingAnnotation(viewModel, "orion.annotation.folding", start, end,
-				"<div class='annotationHTML expanded'></div>", {styleClass: "annotation expanded"}, 
-				"<div class='annotationHTML collapsed'></div>", {styleClass: "annotation collapsed"});
-		},
-		_computeTasks: function(type, commentStart, commentEnd) {
-			if (!this.detectTasks) { return; }
-			var annotationModel = this.annotationModel;
-			if (!annotationModel) { return; }
-			var view = this.view;
-			var viewModel = view.getModel(), baseModel = viewModel;
-			if (viewModel.getBaseModel) { baseModel = viewModel.getBaseModel(); }
-			var annotations = annotationModel.getAnnotations(commentStart, commentEnd);
-			var remove = [];
-			var annotationType = "orion.annotation.task";
-			while (annotations.hasNext()) {
-				var annotation = annotations.next();
-				if (annotation.type === annotationType) {
-					remove.push(annotation);
-				}
-			}
-			var add = [];
-			var scanner = this._commentScanner;
-			scanner.setText(baseModel.getText(commentStart, commentEnd));
-			var token;
-			while ((token = scanner.nextToken())) {
-				var tokenStart = scanner.getStartOffset() + commentStart;
-				if (token === TASK_TAG) {
-					var end = baseModel.getLineEnd(baseModel.getLineAtOffset(tokenStart));
-					if (type !== SINGLELINE_COMMENT) {
-						end = Math.min(end, commentEnd - this.commentEnd.length);
-					}
-					add.push({
-						start: tokenStart,
-						end: end,
-						type: annotationType,
-						title: baseModel.getText(tokenStart, end),
-						style: {styleClass: "annotation task"},
-						html: "<div class='annotationHTML task'></div>",
-						overviewStyle: {styleClass: "annotationOverview task"},
-						rangeStyle: {styleClass: "annotationRange task"}
-					});
-				}
-			}
-			annotationModel.replaceAnnotations(remove, add);
-		},
-		_getLineStyle: function(lineIndex) {
-			if (this.highlightCaretLine) {
-				var view = this.view;
-				var model = view.getModel();
-				var selection = view.getSelection();
-				if (selection.start === selection.end && model.getLineAtOffset(selection.start) === lineIndex) {
-					return caretLineStyle;
-				}
-			}
-			return null;
-		},
-		_getStyles: function(model, text, start) {
-			if (model.getBaseModel) {
-				start = model.mapOffset(start);
-			}
-			var end = start + text.length;
-			
-			var styles = [];
-			
-			// for any sub range that is not a comment, parse code generating tokens (keywords, numbers, brackets, line comments, etc)
-			var offset = start, comments = this.comments;
-			var startIndex = this._binarySearch(comments, start, true);
-			for (var i = startIndex; i < comments.length; i++) {
-				if (comments[i].start >= end) { break; }
-				var commentStart = comments[i].start;
-				var commentEnd = comments[i].end;
-				if (offset < commentStart) {
-					this._parse(text.substring(offset - start, commentStart - start), offset, styles);
-				}
-				var style = comments[i].type === DOC_COMMENT ? docCommentStyle : multiCommentStyle;
-				if (this.whitespacesVisible || this.detectHyperlinks) {
-					var s = Math.max(offset, commentStart);
-					var e = Math.min(end, commentEnd);
-					this._parseComment(text.substring(s - start, e - start), s, styles, style, comments[i].type);
-				} else {
-					styles.push({start: commentStart, end: commentEnd, style: style});
-				}
-				offset = commentEnd;
-			}
-			if (offset < end) {
-				this._parse(text.substring(offset - start, end - start), offset, styles);
-			}
-			if (model.getBaseModel) {
-				for (var j = 0; j < styles.length; j++) {
-					var length = styles[j].end - styles[j].start;
-					styles[j].start = model.mapOffset(styles[j].start, true);
-					styles[j].end = styles[j].start + length;
-				}
-			}
-			return styles;
-		},
-		_parse: function(text, offset, styles) {
-			var scanner = this._scanner;
-			scanner.setText(text);
-			var token;
-			while ((token = scanner.nextToken())) {
-				var tokenStart = scanner.getStartOffset() + offset;
-				var style = null;
-				switch (token) {
-					case KEYWORD: style = keywordStyle; break;
-					case STRING:
-						if (this.whitespacesVisible) {
-							this._parseString(scanner.getData(), tokenStart, styles, stringStyle);
-							continue;
-						} else {
-							style = stringStyle;
-						}
-						break;
-					case DOC_COMMENT: 
-						this._parseComment(scanner.getData(), tokenStart, styles, docCommentStyle, token);
-						continue;
-					case SINGLELINE_COMMENT:
-						this._parseComment(scanner.getData(), tokenStart, styles, singleCommentStyle, token);
-						continue;
-					case MULTILINE_COMMENT: 
-						this._parseComment(scanner.getData(), tokenStart, styles, multiCommentStyle, token);
-						continue;
-					case WHITE_TAB:
-						if (this.whitespacesVisible) {
-							style = tabStyle;
-						}
-						break;
-					case WHITE_SPACE:
-						if (this.whitespacesVisible) {
-							style = spaceStyle;
-						}
-						break;
-				}
-				styles.push({start: tokenStart, end: scanner.getOffset() + offset, style: style});
-			}
-		},
-		_parseComment: function(text, offset, styles, s, type) {
-			var scanner = this._commentScanner;
-			scanner.setText(text);
-			scanner.setType(type);
-			var token;
-			while ((token = scanner.nextToken())) {
-				var tokenStart = scanner.getStartOffset() + offset;
-				var style = s;
-				switch (token) {
-					case WHITE_TAB:
-						if (this.whitespacesVisible) {
-							style = tabStyle;
-						}
-						break;
-					case WHITE_SPACE:
-						if (this.whitespacesVisible) {
-							style = spaceStyle;
-						}
-						break;
-					case HTML_MARKUP:
-						style = htmlMarkupStyle;
-						break;
-					case DOC_TAG:
-						style = doctagStyle;
-						break;
-					case TASK_TAG:
-						style = tasktagStyle;
-						break;
-					default:
-						if (this.detectHyperlinks) {
-							style = this._detectHyperlinks(scanner.getData(), tokenStart, styles, style);
-						}
-				}
-				if (style) {
-					styles.push({start: tokenStart, end: scanner.getOffset() + offset, style: style});
-				}
-			}
-		},
-		_parseString: function(text, offset, styles, s) {
-			var scanner = this._whitespaceScanner;
-			scanner.setText(text);
-			var token;
-			while ((token = scanner.nextToken())) {
-				var tokenStart = scanner.getStartOffset() + offset;
-				var style = s;
-				switch (token) {
-					case WHITE_TAB:
-						if (this.whitespacesVisible) {
-							style = tabStyle;
-						}
-						break;
-					case WHITE_SPACE:
-						if (this.whitespacesVisible) {
-							style = spaceStyle;
-						}
-						break;
-				}
-				if (style) {
-					styles.push({start: tokenStart, end: scanner.getOffset() + offset, style: style});
-				}
-			}
-		},
-		_detectHyperlinks: function(text, offset, styles, s) {
-			var href = null, index, linkStyle;
-			if ((index = text.indexOf("://")) > 0) {
-				href = text;
-				var start = index;
-				while (start > 0) {
-					var c = href.charCodeAt(start - 1);
-					if (!((97 <= c && c <= 122) || (65 <= c && c <= 90) || 0x2d === c || (48 <= c && c <= 57))) { //LETTER OR DASH OR NUMBER
-						break;
-					}
-					start--;
-				}
-				if (start > 0) {
-					var brackets = "\"\"''(){}[]<>";
-					index = brackets.indexOf(href.substring(start - 1, start));
-					if (index !== -1 && (index & 1) === 0 && (index = href.lastIndexOf(brackets.substring(index + 1, index + 2))) !== -1) {
-						var end = index;
-						linkStyle = this._clone(s);
-						linkStyle.tagName = "A";
-						linkStyle.attributes = {href: href.substring(start, end)};
-						styles.push({start: offset, end: offset + start, style: s});
-						styles.push({start: offset + start, end: offset + end, style: linkStyle});
-						styles.push({start: offset + end, end: offset + text.length, style: s});
-						return null;
-					}
-				}
-			} else if (text.toLowerCase().indexOf("bug#") === 0) {
-				href = "https://bugs.eclipse.org/bugs/show_bug.cgi?id=" + parseInt(text.substring(4), 10);
-			}
-			if (href) {
-				linkStyle = this._clone(s);
-				linkStyle.tagName = "A";
-				linkStyle.attributes = {href: href};
-				return linkStyle;
-			}
-			return s;
-		},
-		_clone: function(obj) {
-			if (!obj) { return obj; }
-			var newObj = {};
-			for (var p in obj) {
-				if (obj.hasOwnProperty(p)) {
-					var value = obj[p];
-					newObj[p] = value;
-				}
-			}
-			return newObj;
-		},
-		_findComments: function(text, offset) {
-			offset = offset || 0;
-			var scanner = this._firstScanner, token;
-			scanner.setText(text);
-			var result = [];
-			while ((token = scanner.nextToken())) {
-				if (token === MULTILINE_COMMENT || token === DOC_COMMENT) {
-					var comment = {
-						start: scanner.getStartOffset() + offset,
-						end: scanner.getOffset() + offset,
-						type: token
-					};
-					result.push(comment);
-					//TODO can we avoid this work if edition does not overlap comment?
-					this._computeTasks(token, scanner.getStartOffset() + offset, scanner.getOffset() + offset);
-				}
-				if (token === SINGLELINE_COMMENT) {
-					//TODO can we avoid this work if edition does not overlap comment?
-					this._computeTasks(token, scanner.getStartOffset() + offset, scanner.getOffset() + offset);
-				}
-			}
-			return result;
-		}, 
-		_findMatchingBracket: function(model, offset) {
-			var brackets = "{}()[]<>";
-			var bracket = model.getText(offset, offset + 1);
-			var bracketIndex = brackets.indexOf(bracket, 0);
-			if (bracketIndex === -1) { return -1; }
-			var closingBracket;
-			if (bracketIndex & 1) {
-				closingBracket = brackets.substring(bracketIndex - 1, bracketIndex);
-			} else {
-				closingBracket = brackets.substring(bracketIndex + 1, bracketIndex + 2);
-			}
-			var lineIndex = model.getLineAtOffset(offset);
-			var lineText = model.getLine(lineIndex);
-			var lineStart = model.getLineStart(lineIndex);
-			var lineEnd = model.getLineEnd(lineIndex);
-			brackets = this._findBrackets(bracket, closingBracket, lineText, lineStart, lineStart, lineEnd);
-			for (var i=0; i<brackets.length; i++) {
-				var sign = brackets[i] >= 0 ? 1 : -1;
-				if (brackets[i] * sign === offset) {
-					var level = 1;
-					if (bracketIndex & 1) {
-						i--;
-						for (; i>=0; i--) {
-							sign = brackets[i] >= 0 ? 1 : -1;
-							level += sign;
-							if (level === 0) {
-								return brackets[i] * sign;
-							}
-						}
-						lineIndex -= 1;
-						while (lineIndex >= 0) {
-							lineText = model.getLine(lineIndex);
-							lineStart = model.getLineStart(lineIndex);
-							lineEnd = model.getLineEnd(lineIndex);
-							brackets = this._findBrackets(bracket, closingBracket, lineText, lineStart, lineStart, lineEnd);
-							for (var j=brackets.length - 1; j>=0; j--) {
-								sign = brackets[j] >= 0 ? 1 : -1;
-								level += sign;
-								if (level === 0) {
-									return brackets[j] * sign;
-								}
-							}
-							lineIndex--;
-						}
-					} else {
-						i++;
-						for (; i<brackets.length; i++) {
-							sign = brackets[i] >= 0 ? 1 : -1;
-							level += sign;
-							if (level === 0) {
-								return brackets[i] * sign;
-							}
-						}
-						lineIndex += 1;
-						var lineCount = model.getLineCount ();
-						while (lineIndex < lineCount) {
-							lineText = model.getLine(lineIndex);
-							lineStart = model.getLineStart(lineIndex);
-							lineEnd = model.getLineEnd(lineIndex);
-							brackets = this._findBrackets(bracket, closingBracket, lineText, lineStart, lineStart, lineEnd);
-							for (var k=0; k<brackets.length; k++) {
-								sign = brackets[k] >= 0 ? 1 : -1;
-								level += sign;
-								if (level === 0) {
-									return brackets[k] * sign;
-								}
-							}
-							lineIndex++;
-						}
-					}
-					break;
-				}
-			}
-			return -1;
-		},
-		_findBrackets: function(bracket, closingBracket, text, textOffset, start, end) {
-			var result = [];
-			var bracketToken = bracket.charCodeAt(0);
-			var closingBracketToken = closingBracket.charCodeAt(0);
-			// for any sub range that is not a comment, parse code generating tokens (keywords, numbers, brackets, line comments, etc)
-			var offset = start, scanner = this._scanner, token, comments = this.comments;
-			var startIndex = this._binarySearch(comments, start, true);
-			for (var i = startIndex; i < comments.length; i++) {
-				if (comments[i].start >= end) { break; }
-				var commentStart = comments[i].start;
-				var commentEnd = comments[i].end;
-				if (offset < commentStart) {
-					scanner.setText(text.substring(offset - start, commentStart - start));
-					while ((token = scanner.nextToken())) {
-						if (token === bracketToken) {
-							result.push(scanner.getStartOffset() + offset - start + textOffset);
-						} else if (token === closingBracketToken) {
-							result.push(-(scanner.getStartOffset() + offset - start + textOffset));
-						}
-					}
-				}
-				offset = commentEnd;
-			}
-			if (offset < end) {
-				scanner.setText(text.substring(offset - start, end - start));
-				while ((token = scanner.nextToken())) {
-					if (token === bracketToken) {
-						result.push(scanner.getStartOffset() + offset - start + textOffset);
-					} else if (token === closingBracketToken) {
-						result.push(-(scanner.getStartOffset() + offset - start + textOffset));
-					}
-				}
-			}
-			return result;
-		},
-		_onDestroy: function(e) {
-			this.destroy();
-		},
-		_onLineStyle: function (e) {
-			if (e.textView === this.view) {
-				e.style = this._getLineStyle(e.lineIndex);
-			}
-			e.ranges = this._getStyles(e.textView.getModel(), e.lineText, e.lineStart);
-		},
-		_onSelection: function(e) {
-			var oldSelection = e.oldValue;
-			var newSelection = e.newValue;
-			var view = this.view;
-			var model = view.getModel();
-			var lineIndex;
-			if (this.highlightCaretLine) {
-				var oldLineIndex = model.getLineAtOffset(oldSelection.start);
-				lineIndex = model.getLineAtOffset(newSelection.start);
-				var newEmpty = newSelection.start === newSelection.end;
-				var oldEmpty = oldSelection.start === oldSelection.end;
-				if (!(oldLineIndex === lineIndex && oldEmpty && newEmpty)) {
-					if (oldEmpty) {
-						view.redrawLines(oldLineIndex, oldLineIndex + 1);
-					}
-					if ((oldLineIndex !== lineIndex || !oldEmpty) && newEmpty) {
-						view.redrawLines(lineIndex, lineIndex + 1);
-					}
-				}
-			}
-			if (!this.annotationModel) { return; }
-			var remove = this._bracketAnnotations, add, caret;
-			if (newSelection.start === newSelection.end && (caret = view.getCaretOffset()) > 0) {
-				var mapCaret = caret - 1;
-				if (model.getBaseModel) {
-					mapCaret = model.mapOffset(mapCaret);
-					model = model.getBaseModel();
-				}
-				var bracket = this._findMatchingBracket(model, mapCaret);
-				if (bracket !== -1) {
-					add = [{
-						start: bracket,
-						end: bracket + 1,
-						type: "orion.annotation.matchingBracket",
-						title: "Matching Bracket",
-						html: "<div class='annotationHTML matchingBracket'></div>",
-						overviewStyle: {styleClass: "annotationOverview matchingBracket"},
-						rangeStyle: {styleClass: "annotationRange matchingBracket"}
-					},
-					{
-						start: mapCaret,
-						end: mapCaret + 1,
-						type: "orion.annotation.currentBracket",
-						title: "Current Bracket",
-						html: "<div class='annotationHTML currentBracket'></div>",
-						overviewStyle: {styleClass: "annotationOverview currentBracket"},
-						rangeStyle: {styleClass: "annotationRange currentBracket"}
-					}];
-				}
-			}
-			this._bracketAnnotations = add;
-			this.annotationModel.replaceAnnotations(remove, add);
-		},
-		_onModelChanged: function(e) {
-			var start = e.start;
-			var removedCharCount = e.removedCharCount;
-			var addedCharCount = e.addedCharCount;
-			var changeCount = addedCharCount - removedCharCount;
-			var view = this.view;
-			var viewModel = view.getModel();
-			var baseModel = viewModel.getBaseModel ? viewModel.getBaseModel() : viewModel;
-			var end = start + removedCharCount;
-			var charCount = baseModel.getCharCount();
-			var commentCount = this.comments.length;
-			var lineStart = baseModel.getLineStart(baseModel.getLineAtOffset(start));
-			var commentStart = this._binarySearch(this.comments, lineStart, true);
-			var commentEnd = this._binarySearch(this.comments, end, false, commentStart - 1, commentCount);
-			
-			var ts;
-			if (commentStart < commentCount && this.comments[commentStart].start <= lineStart && lineStart < this.comments[commentStart].end) {
-				ts = this.comments[commentStart].start;
-				if (ts > start) { ts += changeCount; }
-			} else {
-				if (commentStart === commentCount && commentCount > 0 && charCount - changeCount === this.comments[commentCount - 1].end) {
-					ts = this.comments[commentCount - 1].start;
-				} else {
-					ts = lineStart;
-				}
-			}
-			var te;
-			if (commentEnd < commentCount) {
-				te = this.comments[commentEnd].end;
-				if (te > start) { te += changeCount; }
-				commentEnd += 1;
-			} else {
-				commentEnd = commentCount;
-				te = charCount;//TODO could it be smaller?
-			}
-			var text = baseModel.getText(ts, te), comment;
-			var newComments = this._findComments(text, ts), i;
-			for (i = commentStart; i < this.comments.length; i++) {
-				comment = this.comments[i];
-				if (comment.start > start) { comment.start += changeCount; }
-				if (comment.start > start) { comment.end += changeCount; }
-			}
-			var redraw = (commentEnd - commentStart) !== newComments.length;
-			if (!redraw) {
-				for (i=0; i<newComments.length; i++) {
-					comment = this.comments[commentStart + i];
-					var newComment = newComments[i];
-					if (comment.start !== newComment.start || comment.end !== newComment.end || comment.type !== newComment.type) {
-						redraw = true;
-						break;
-					} 
-				}
-			}
-			var args = [commentStart, commentEnd - commentStart].concat(newComments);
-			Array.prototype.splice.apply(this.comments, args);
-			if (redraw) {
-				var redrawStart = ts;
-				var redrawEnd = te;
-				if (viewModel !== baseModel) {
-					redrawStart = viewModel.mapOffset(redrawStart, true);
-					redrawEnd = viewModel.mapOffset(redrawEnd, true);
-				}
-				view.redrawRange(redrawStart, redrawEnd);
-			}
-
-			if (this.foldingEnabled && baseModel !== viewModel && this.annotationModel) {
-				var annotationModel = this.annotationModel;
-				var iter = annotationModel.getAnnotations(ts, te);
-				var remove = [], all = [];
-				var annotation;
-				while (iter.hasNext()) {
-					annotation = iter.next();
-					if (annotation.type === "orion.annotation.folding") {
-						all.push(annotation);
-						for (i = 0; i < newComments.length; i++) {
-							if (annotation.start === newComments[i].start && annotation.end === newComments[i].end) {
-								break;
-							}
-						}
-						if (i === newComments.length) {
-							remove.push(annotation);
-							annotation.expand();
-						} else {
-							var annotationStart = annotation.start;
-							var annotationEnd = annotation.end;
-							if (annotationStart > start) {
-								annotationStart -= changeCount;
-							}
-							if (annotationEnd > start) {
-								annotationEnd -= changeCount;
-							}
-							if (annotationStart <= start && start < annotationEnd && annotationStart <= end && end < annotationEnd) {
-								var startLine = baseModel.getLineAtOffset(annotation.start);
-								var endLine = baseModel.getLineAtOffset(annotation.end);
-								if (startLine !== endLine) {
-									if (!annotation.expanded) {
-										annotation.expand();
-										annotationModel.modifyAnnotation(annotation);
-									}
-								} else {
-									annotationModel.removeAnnotation(annotation);
-								}
-							}
-						}
-					}
-				}
-				var add = [];
-				for (i = 0; i < newComments.length; i++) {
-					comment = newComments[i];
-					for (var j = 0; j < all.length; j++) {
-						if (all[j].start === comment.start && all[j].end === comment.end) {
-							break;
-						}
-					}
-					if (j === all.length) {
-						annotation = this._createFoldingAnnotation(viewModel, baseModel, comment.start, comment.end);
-						if (annotation) {
-							add.push(annotation);
-						}
-					}
-				}
-				annotationModel.replaceAnnotations(remove, add);
-			}
-		}
-	};
-	
-	return {TextStyler: TextStyler};
 });
+
+}
+window.knownOrionModules = ['examples/textview/textStyler', 'orion/textview/annotations', 'orion/textview/eventTarget', 'orion/editor/htmlGrammar', 'orion/editor/textMateStyler', 'orion/editor/regex', 'orion/textview/rulers', 'orion/textview/tooltip', 'orion/textview/textView', 'orion/textview/textModel', 'orion/textview/keyBinding', 'orion/textview/projectionTextModel', 'orion/textview/textDND', 'orion/textview/undoStack'];
diff --git a/browser/devtools/sourceeditor/source-editor-orion.jsm b/browser/devtools/sourceeditor/source-editor-orion.jsm
--- a/browser/devtools/sourceeditor/source-editor-orion.jsm
+++ b/browser/devtools/sourceeditor/source-editor-orion.jsm
@@ -6,26 +6,33 @@
 "use strict";
 
 const Cu = Components.utils;
 const Ci = Components.interfaces;
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource:///modules/source-editor-ui.jsm");
+Cu.import("resource:///modules/devtools/Require.jsm");
+Cu.import("resource:///modules/devtools/Console.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "clipboardHelper",
                                    "@mozilla.org/widget/clipboardhelper;1",
                                    "nsIClipboardHelper");
 
+const ORION_L10N = "chrome://browser/locale/devtools/orion.properties";
+
+XPCOMUtils.defineLazyGetter(this, "orion_strings", function() {
+  return Services.strings.createBundle(ORION_L10N);
+});
+
 const ORION_SCRIPT = "chrome://browser/content/orion.js";
 const ORION_IFRAME = "data:text/html;charset=utf8,<!DOCTYPE html>" +
   "<html style='height:100%' dir='ltr'>" +
-  "<head><link rel='stylesheet'" +
-  " href='chrome://browser/skin/devtools/orion-container.css'></head>" +
+  "<head><meta charset='utf8'></head>" +
   "<body style='height:100%;margin:0;overflow:hidden'>" +
   "<div id='editor' style='height:100%'></div>" +
   "</body></html>";
 
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 /**
  * Maximum allowed vertical offset for the line index when you call
@@ -126,16 +133,20 @@ const DEFAULT_KEYBINDINGS = [
   },
   {
     action: "Move to Bracket Closing",
     code: Ci.nsIDOMKeyEvent.DOM_VK_CLOSE_BRACKET,
     accel: true,
   },
 ];
 
+
+// Known Orion modules that we need to unregister.
+var gOrionModules = null;
+
 var EXPORTED_SYMBOLS = ["SourceEditor"];
 
 /**
  * The SourceEditor object constructor. The SourceEditor component allows you to
  * provide users with an editor tailored to the specific needs of editing source
  * code, aimed primarily at web developers.
  *
  * The editor used here is Eclipse Orion (see http://www.eclipse.org/orion).
@@ -148,16 +159,17 @@ function SourceEditor() {
   SourceEditor.DEFAULTS.tabSize =
     Services.prefs.getIntPref(SourceEditor.PREFS.TAB_SIZE);
   SourceEditor.DEFAULTS.expandTab =
     Services.prefs.getBoolPref(SourceEditor.PREFS.EXPAND_TAB);
 
   this._onOrionSelection = this._onOrionSelection.bind(this);
   this._onTextChanged = this._onTextChanged.bind(this);
   this._onOrionContextMenu = this._onOrionContextMenu.bind(this);
+  this._onIframeLoad = this._onIframeLoad.bind(this);
 
   this._eventTarget = {};
   this._eventListenersQueue = [];
   this.ui = new SourceEditorUI(this);
 }
 
 SourceEditor.prototype = {
   _view: null,
@@ -209,89 +221,113 @@ SourceEditor.prototype = {
    * @see SourceEditor.DEFAULTS
    */
   init: function SE_init(aElement, aConfig, aCallback)
   {
     if (this._iframe) {
       throw new Error("SourceEditor is already initialized!");
     }
 
-    let doc = aElement.ownerDocument;
-
-    this._iframe = doc.createElementNS(XUL_NS, "iframe");
-    this._iframe.flex = 1;
-
-    let onIframeLoad = (function() {
-      this._iframe.removeEventListener("load", onIframeLoad, true);
-      this._onIframeLoad();
-    }).bind(this);
-
-    this._iframe.addEventListener("load", onIframeLoad, true);
-
-    this._iframe.setAttribute("src", ORION_IFRAME);
-
-    aElement.appendChild(this._iframe);
-    this.parentElement = aElement;
-
     this._config = {};
     for (let key in SourceEditor.DEFAULTS) {
       this._config[key] = key in aConfig ?
                           aConfig[key] :
                           SourceEditor.DEFAULTS[key];
     }
 
-    // TODO: Bug 725677 - Remove the deprecated placeholderText option from the
-    // Source Editor initialization.
-    if (aConfig.placeholderText) {
-      this._config.initialText = aConfig.placeholderText;
-      Services.console.logStringMessage("SourceEditor.init() was called with the placeholderText option which is deprecated, please use initialText.");
+    let theme = this._config.theme;
+    let stylesheets = theme in ORION_THEMES ? ORION_THEMES[theme] : theme;
+    if (!Array.isArray(stylesheets)) {
+      stylesheets = [stylesheets];
     }
 
+    let links = [];
+    stylesheets.forEach(function(aStyle) {
+      links.push("<link rel='stylesheet' href='" + aStyle +
+                 "' type='text/css'>");
+    });
+
+    let src = ORION_IFRAME.replace("</head>", links.join("\n") + "</head>");
+
+    let doc = aElement.ownerDocument;
+    this._iframe = doc.createElementNS(XUL_NS, "iframe");
+    this._iframe.flex = 1;
+    this._iframe.addEventListener("load", this._onIframeLoad, true);
+    this._iframe.setAttribute("src", src);
+
+    aElement.appendChild(this._iframe);
+    this.parentElement = aElement;
+
     this._onReadyCallback = aCallback;
     this.ui.init();
   },
 
   /**
    * The editor iframe load event handler.
    * @private
    */
   _onIframeLoad: function SE__onIframeLoad()
   {
+    this._iframe.removeEventListener("load", this._onIframeLoad, true);
+
     this._iframeWindow = this._iframe.contentWindow.wrappedJSObject;
     let window = this._iframeWindow;
+
+    if (gOrionModules) {
+      unregisterModules(gOrionModules);
+    }
+
+    let domain = new define.Domain();
+    domain.syntax = "amd";
+
+    window.require = domain.require.bind(domain);
+    window.define = define;
+    window.console = console;
+
+    let onScriptLoad = function _onScriptLoad() {
+      script.removeEventListener("load", onScriptLoad, false);
+      this._initializeOrion();
+    }.bind(this);
+
+    let script = window.document.createElement("script");
+    script.src = ORION_SCRIPT;
+    window.document.head.appendChild(script);
+    script.addEventListener("load", onScriptLoad, false);
+  },
+
+  _initializeOrion: function SE__initializeOrion()
+  {
+    let window = this._iframeWindow;
     let config = this._config;
 
-    Services.scriptloader.loadSubScript(ORION_SCRIPT, window, "utf8");
+    if (gOrionModules) {
+      unregisterModules(gOrionModules);
+    } else {
+      gOrionModules = window.knownOrionModules;
+    }
+
+    window.initializeOrion();
 
     let TextModel = window.require("orion/textview/textModel").TextModel;
     let TextView = window.require("orion/textview/textView").TextView;
 
     this._expandTab = config.expandTab;
     this._tabSize = config.tabSize;
 
-    let theme = config.theme;
-    let stylesheet = theme in ORION_THEMES ? ORION_THEMES[theme] : theme;
-
     this._model = new TextModel(config.initialText);
     this._view = new TextView({
       model: this._model,
       parent: "editor",
-      stylesheet: stylesheet,
       tabSize: this._tabSize,
       expandTab: this._expandTab,
       readonly: config.readOnly,
+      tabMode: "tabMode" in config ? config.tabMode : !config.readOnly,
       themeClass: "mozilla" + (config.readOnly ? " readonly" : ""),
     });
 
-    let onOrionLoad = function() {
-      this._view.removeEventListener("Load", onOrionLoad);
-      this._onOrionLoad();
-    }.bind(this);
-
-    this._view.addEventListener("Load", onOrionLoad);
     if (config.highlightCurrentLine || Services.appinfo.OS == "Linux") {
       this.addEventListener(SourceEditor.EVENTS.SELECTION,
                             this._onOrionSelection);
     }
     this.addEventListener(SourceEditor.EVENTS.TEXT_CHANGED,
                            this._onTextChanged);
 
     if (typeof config.contextMenu == "string") {
@@ -393,16 +429,17 @@ SourceEditor.prototype = {
       this._view.setKeyBinding(binding, aKey.action);
 
       if (aKey.callback) {
         this._view.setAction(aKey.action, aKey.callback);
       }
     }, this);
 
     this._initEventTarget();
+    this._onOrionLoad();
   },
 
   /**
    * Initialize the private Orion EventTarget object. This is used for tracking
    * our own event listeners for events outside of Orion's scope.
    * @private
    */
   _initEventTarget: function SE__initEventTarget()
@@ -2016,8 +2053,45 @@ SourceEditor.prototype = {
     this._eventTarget = null;
     this._eventListenersQueue = null;
     this._view = null;
     this._model = null;
     this._config = null;
     this._lastFind = null;
   },
 };
+
+function unregisterModules(aModules) {
+  aModules.forEach(function(aModuleName) {
+    if (aModuleName in define.modules) {
+      delete define.modules[aModuleName];
+    }
+  });
+}
+
+function orion_strings_proxy() {
+  return Proxy.create({
+    get: function(aReceiver, aName) {
+      return orion_strings.GetStringFromName(aName);
+    }
+  });
+}
+
+function orion_i18nUtil()
+{
+  return {
+    formatMessage: function orion_formatMessage() {
+      let message = arguments[0];
+      for (let i = 1; i < arguments.length; i++) {
+        let arg = arguments[i];
+        message = message.replace(new RegExp("%" + i + "\\$S", "g"), arg);
+      }
+      if (arguments.length == 2) {
+        message = message.replace(/%S/g, arguments[1]);
+      }
+      return message.replace(/%%/g, "%");
+    }
+  };
+}
+
+define("i18n!orion/textview/nls/messages", [], orion_strings_proxy);
+define("orion/textview/i18nUtil", [], orion_i18nUtil);
+
diff --git a/browser/devtools/sourceeditor/source-editor-ui.jsm b/browser/devtools/sourceeditor/source-editor-ui.jsm
--- a/browser/devtools/sourceeditor/source-editor-ui.jsm
+++ b/browser/devtools/sourceeditor/source-editor-ui.jsm
@@ -264,17 +264,17 @@ SourceEditorController.prototype = {
         break;
       case "se-cmd-cut":
       case "se-cmd-delete": {
         let selection = this._editor.getSelection();
         result = selection.start != selection.end && !this._editor.readOnly;
         break;
       }
       case "se-cmd-paste": {
-        let window = this._editor._view._frameWindow;
+        let window = this._editor._iframeWindow;
         let controller = window.controllers.getControllerForCommand("cmd_paste");
         result = !this._editor.readOnly &&
                  controller.isCommandEnabled("cmd_paste");
         break;
       }
       default:
         result = false;
         break;
diff --git a/browser/locales/en-US/chrome/browser/devtools/orion.properties b/browser/locales/en-US/chrome/browser/devtools/orion.properties
new file mode 100644
--- /dev/null
+++ b/browser/locales/en-US/chrome/browser/devtools/orion.properties
@@ -0,0 +1,16 @@
+# LOCALIZATION NOTE: These strings are used in the Orion code editor.
+# This editor is integrated into several developer tools, like
+# Scratchpad, Style Editor and JavaScript debugger.
+
+multipleAnnotations=Multiple annotations:
+line=Line: %S
+breakpoint=Breakpoint
+bookmark=Bookmark
+task=Task
+error=Error
+warning=Warning
+matchingSearch=Matching Search
+currentSearch=Current Search
+currentLine=Current Line
+matchingBracket=Matching Bracket
+currentBracket=Current Bracket
\ No newline at end of file
diff --git a/browser/locales/jar.mn b/browser/locales/jar.mn
--- a/browser/locales/jar.mn
+++ b/browser/locales/jar.mn
@@ -30,16 +30,17 @@
     locale/browser/devtools/scratchpad.dtd            (%chrome/browser/devtools/scratchpad.dtd)
     locale/browser/devtools/styleeditor.properties    (%chrome/browser/devtools/styleeditor.properties)
     locale/browser/devtools/styleeditor.dtd           (%chrome/browser/devtools/styleeditor.dtd)
     locale/browser/devtools/styleinspector.properties (%chrome/browser/devtools/styleinspector.properties)
     locale/browser/devtools/styleinspector.dtd        (%chrome/browser/devtools/styleinspector.dtd)
     locale/browser/devtools/webConsole.dtd            (%chrome/browser/devtools/webConsole.dtd)
     locale/browser/devtools/sourceeditor.properties   (%chrome/browser/devtools/sourceeditor.properties)
     locale/browser/devtools/sourceeditor.dtd          (%chrome/browser/devtools/sourceeditor.dtd)
+    locale/browser/devtools/orion.properties          (%chrome/browser/devtools/orion.properties)
     locale/browser/devtools/layoutview.dtd            (%chrome/browser/devtools/layoutview.dtd)
     locale/browser/devtools/responsiveUI.properties   (%chrome/browser/devtools/responsiveUI.properties)
     locale/browser/newTab.dtd                      (%chrome/browser/newTab.dtd)
     locale/browser/newTab.properties               (%chrome/browser/newTab.properties)
     locale/browser/openLocation.dtd                (%chrome/browser/openLocation.dtd)
     locale/browser/openLocation.properties         (%chrome/browser/openLocation.properties)
 *   locale/browser/pageInfo.dtd                    (%chrome/browser/pageInfo.dtd)
     locale/browser/pageInfo.properties             (%chrome/browser/pageInfo.properties)
diff --git a/browser/themes/gnomestripe/devtools/orion.css b/browser/themes/gnomestripe/devtools/orion.css
--- a/browser/themes/gnomestripe/devtools/orion.css
+++ b/browser/themes/gnomestripe/devtools/orion.css
@@ -1,19 +1,24 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-.viewContainer {
+body {
+  background: #fff;
+  color: #000;
+}
+
+.textviewContainer {
   background: #cddae5; /* This will be seen as the continuation of the ruler */
   font-family: monospace;
   font-size: inherit; /* inherit browser's default monospace font size */
 }
 
-.view {
+.textviewContent {
   color: black; /* Default text color */
   background: #f0f0ff; /* Background of the editor */
   padding-left: 4px;
 }
 
 .readonly > .view {
   background: #f0f0ff;
 }
@@ -40,16 +45,35 @@
 }
 
 .ruler.overview {
   border-left: 1px solid #b4c4d3;
   width: 14px;
   text-align: start;
 }
 
+.viewTooltip {
+  font-family: monospace;
+  font-size: 13px;
+  background-color: InfoBackground;
+  color: InfoText;
+  padding: 2px;
+  border-radius: 4px;
+  border: 1px solid black;
+  z-index: 100;
+  position: fixed;
+  overflow: hidden;
+  white-space: pre;
+}
+
+.viewTooltip em {
+  font-style: normal;
+  font-weight: bold;
+}
+
 /* Styles for the annotation ruler (first line) */
 .annotationHTML {
   cursor: pointer;
   width: 16px;
   height: 16px;
   display: inline-block;
   vertical-align: middle;
   background-position: center;
@@ -130,16 +154,20 @@
   background: yellow;
 }
 
 .token_string {
   color: #1e66b1; /* blue */
   font-style: italic;
 }
 
+.token_number {
+  color: blue;
+}
+
 .token_keyword {
   color: #dd0058; /* purple */
 }
 
 .token_space {
   /* images/white_space.png */
   background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAIAAABv85FHAAAABnRSTlMA/wAAAACkwsAdAAAAIUlEQVR4nGP4z8CAC+GUIEXuABhgkTuABEiRw2cmae4EAH05X7xDolNRAAAAAElFTkSuQmCC");
   background-repeat: no-repeat;
