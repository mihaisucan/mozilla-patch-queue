# HG changeset patch
# Parent 7262fabfd83eef1f569571bb72f8943dd3870902
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1397075832 -10800

Bug 823097 - Add support for %c style formatting in console; r=past,bz

diff --git a/browser/devtools/webconsole/console-output.js b/browser/devtools/webconsole/console-output.js
--- a/browser/devtools/webconsole/console-output.js
+++ b/browser/devtools/webconsole/console-output.js
@@ -93,16 +93,17 @@ const CONSOLE_API_LEVELS_TO_SEVERITIES =
 };
 
 // Array of known message source URLs we need to hide from output.
 const IGNORED_SOURCE_URLS = ["debugger eval code", "self-hosted"];
 
 // The maximum length of strings to be displayed by the Web Console.
 const MAX_LONG_STRING_LENGTH = 200000;
 
+const RE_ALLOWED_STYLES = /^(?:-moz-)?(?:background|border|box|clear|color|cursor|float|font|line|margin|padding|text|transition|outline|white-space|word|writing|(?:min|max)width|(?:min|max)height)/;
 
 /**
  * The ConsoleOutput object is used to manage output of messages in the Web
  * Console.
  *
  * @constructor
  * @param object owner
  *        The console output owner. This usually the WebConsoleFrame instance.
@@ -1217,24 +1218,120 @@ Messages.ConsoleGeneric = function(packe
       break;
     }
     default:
       Messages.Extended.call(this, packet.arguments, options);
       break;
   }
 
   this._repeatID.consoleApiLevel = packet.level;
+  this._repeatID.styles = packet.styles;
+  this._styles = packet.styles || [];
 };
 
 Messages.ConsoleGeneric.prototype = Heritage.extend(Messages.Extended.prototype,
 {
+  _styles: null,
+
   _renderBodyPieceSeparator: function()
   {
     return this.document.createTextNode(" ");
   },
+
+  render: function()
+  {
+    let lastStyle = null;
+    let result = this.document.createDocumentFragment();
+
+    for (let i = 0; i < this._messagePieces.length; i++) {
+      let separator = i > 0 ? this._renderBodyPieceSeparator() : null;
+      if (separator) {
+        result.appendChild(separator);
+      }
+
+      let piece = this._messagePieces[i];
+      let renderedPiece = this._renderBodyPiece(piece);
+
+      let style = this._styles[i];
+      if (style && typeof style == "string" /* no long string support */) {
+        lastStyle = this.cleanupStyle(style);
+      }
+
+      if (lastStyle) {
+        if (renderedPiece.nodeType == Ci.nsIDOMNode.ELEMENT_NODE) {
+          renderedPiece.style = lastStyle;
+          result.appendChild(renderedPiece);
+        } else {
+          let span = this.document.createElementNS(XHTML_NS, "span");
+          span.style = lastStyle;
+          span.appendChild(renderedPiece);
+          result.appendChild(span);
+        }
+      } else {
+        result.appendChild(renderedPiece);
+      }
+    }
+
+    this._message = result;
+    this._messagePieces = null;
+    this._styles = null;
+    return Messages.Simple.prototype.render.call(this);
+  },
+
+  /**
+   * Given a style attribute value cleanup the string such that no external URL
+   * is allowed to load.
+   *
+   * Note: this method does not attempt to produce a correct style attribute
+   * value. URLs are not allowed and the intent here is to just break/disallow
+   * their use.
+   *
+   * @param string style
+   *        The style string to cleanup.
+   * @return string
+   *         The style value with no URLs.
+   */
+  cleanupStyle: function(style)
+  {
+    const regex = [
+      // url(), -moz-element()
+      /\b(?:url|(?:-moz-)?element)[\s('"]+/gi,
+
+      // various URL protocols
+      /['"(]*(?:chrome|resource|about|app|data|https?|ftp|file):+\/*/gi,
+    ];
+
+    for (let r of regex) {
+      style = style.replace(r, "notallowed");
+    }
+
+    let dummy = this.output._dummyElement;
+    if (!dummy) {
+      dummy = this.output._dummyElement =
+        this.document.createElementNS(XHTML_NS, "div");
+    }
+    dummy.style = style;
+
+    let toRemove = [];
+    for (let i = 0; i < dummy.style.length; i++) {
+      let prop = dummy.style[i];
+      if (!RE_ALLOWED_STYLES.test(prop)) {
+        toRemove.push(prop);
+      }
+    }
+
+    for (let prop of toRemove) {
+      dummy.style.removeProperty(prop);
+    }
+
+    style = String(dummy.style);
+    dummy.style = "";
+
+    return style;
+  },
 }); // Messages.ConsoleGeneric.prototype
 
 /**
  * The ConsoleTrace message is used for console.trace() calls.
  *
  * @constructor
  * @extends Messages.Simple
  * @param object packet
diff --git a/browser/devtools/webconsole/test/browser.ini b/browser/devtools/webconsole/test/browser.ini
--- a/browser/devtools/webconsole/test/browser.ini
+++ b/browser/devtools/webconsole/test/browser.ini
@@ -276,8 +276,9 @@ run-if = os == "mac"
 [browser_webconsole_output_dom_elements_03.js]
 [browser_webconsole_output_dom_elements_04.js]
 [browser_webconsole_output_events.js]
 [browser_console_variables_view_highlighter.js]
 [browser_webconsole_start_netmon_first.js]
 [browser_webconsole_console_trace_duplicates.js]
 [browser_webconsole_cd_iframe.js]
 [browser_webconsole_autocomplete_crossdomain_iframe.js]
+[browser_webconsole_console_custom_styles.js]
diff --git a/browser/devtools/webconsole/test/browser_webconsole_console_custom_styles.js b/browser/devtools/webconsole/test/browser_webconsole_console_custom_styles.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/test/browser_webconsole_console_custom_styles.js
@@ -0,0 +1,72 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that the '%c' modifier works with the console API. See bug 823097.
+
+function test() {
+  let hud;
+
+  const TEST_URI = "data:text/html;charset=utf8,<p>test for " +
+                   "console.log('%ccustom styles', 'color:red')";
+
+  const checks = [{
+    style: "color:red;font-size:1.3em",
+    props: { color: true, fontSize: true },
+    sameStyleExpected: true,
+  }, {
+    style: "color:blue;background-image:url('http://example.com/test')",
+    props: { color: true, fontSize: false, background: false,
+             backgroundImage: false },
+    sameStyleExpected: false,
+  }];
+
+  Task.spawn(runner).then(finishTest);
+
+  function* runner() {
+    const {tab} = yield loadTab(TEST_URI);
+    hud = yield openConsole(tab);
+
+    for (let check of checks) {
+      yield checkStyle(check);
+    }
+
+    yield closeConsole(tab);
+  }
+
+  function* checkStyle(check) {
+    hud.jsterm.clearOutput();
+
+    info("checkStyle " + check.style);
+    hud.jsterm.execute("console.log('%cfoobar', \"" + check.style + "\")");
+
+    let [result] = yield waitForMessages({
+      webconsole: hud,
+      messages: [{
+        text: "foobar",
+        category: CATEGORY_WEBDEV,
+      }],
+    });
+
+    let msg = [...result.matched][0];
+    ok(msg, "message element");
+
+    let span = msg.querySelector(".body span[style]");
+    ok(span, "span element");
+
+    info("span textContent is: " + span.textContent);
+    isnot(span.textContent.indexOf("foobar"), -1, "span textContent check");
+
+    let outputStyle = span.getAttribute("style").replace(/\s+|;+$/g, "");
+    if (check.sameStyleExpected) {
+      is(outputStyle, check.style, "span style is correct");
+    } else {
+      isnot(outputStyle, check.style, "span style is not the same");
+    }
+
+    for (let prop of Object.keys(check.props)) {
+      is(!!span.style[prop], check.props[prop], "property check for " + prop);
+    }
+  }
+}
diff --git a/dom/base/Console.cpp b/dom/base/Console.cpp
--- a/dom/base/Console.cpp
+++ b/dom/base/Console.cpp
@@ -964,17 +964,19 @@ Console::ProcessCallData(ConsoleCallData
     case MethodLog:
     case MethodInfo:
     case MethodWarn:
     case MethodError:
     case MethodException:
     case MethodDebug:
     case MethodAssert:
       event.mArguments.Construct();
-      ProcessArguments(cx, aData->mArguments, event.mArguments.Value());
+      event.mStyles.Construct();
+      ProcessArguments(cx, aData->mArguments, event.mArguments.Value(),
+                       event.mStyles.Value());
       break;
 
     default:
       event.mArguments.Construct();
       ArgumentsToValueList(aData->mArguments, event.mArguments.Value());
   }
 
   if (aData->mMethodName == MethodTrace) {
@@ -1046,29 +1048,28 @@ Console::ProcessCallData(ConsoleCallData
 
     obs->NotifyObservers(wrapper, "console-api-log-event", outerID.get());
   }
 }
 
 void
 Console::ProcessArguments(JSContext* aCx,
                           const nsTArray<JS::Heap<JS::Value>>& aData,
-                          Sequence<JS::Value>& aSequence)
+                          Sequence<JS::Value>& aSequence,
+                          Sequence<JS::Value>& aStyles)
 {
   if (aData.IsEmpty()) {
     return;
   }
 
   if (aData.Length() == 1 || !aData[0].isString()) {
     ArgumentsToValueList(aData, aSequence);
     return;
   }
 
-  SequenceRooter<JS::Value> rooter(aCx, &aSequence);
-
   JS::Rooted<JS::Value> format(aCx, aData[0]);
   JS::Rooted<JSString*> jsString(aCx, JS::ToString(aCx, format));
   if (!jsString) {
     return;
   }
 
   nsDependentJSString string;
   if (!string.init(aCx, jsString)) {
@@ -1153,16 +1154,17 @@ Console::ProcessArguments(JSContext* aCx
     }
 
     char ch = *start;
     tmp.Append(ch);
     ++start;
 
     switch (ch) {
       case 'o':
+      case 'O':
       {
         if (!output.IsEmpty()) {
           JS::Rooted<JSString*> str(aCx, JS_NewUCStringCopyN(aCx,
                                                              output.get(),
                                                              output.Length()));
           if (!str) {
             return;
           }
@@ -1175,16 +1177,48 @@ Console::ProcessArguments(JSContext* aCx
         if (index < aData.Length()) {
           v = aData[index++];
         }
 
         aSequence.AppendElement(v);
         break;
       }
 
+      case 'c':
+      {
+        if (!output.IsEmpty()) {
+          JS::Rooted<JSString*> str(aCx, JS_NewUCStringCopyN(aCx,
+                                                             output.get(),
+                                                             output.Length()));
+          if (!str) {
+            return;
+          }
+
+          aSequence.AppendElement(JS::StringValue(str));
+          output.Truncate();
+        }
+
+        if (index < aData.Length()) {
+          JS::Rooted<JS::Value> v(aCx, aData[index++]);
+          JS::Rooted<JSString*> jsString(aCx, JS::ToString(aCx, v));
+          if (!jsString) {
+            return;
+          }
+
+          int32_t diff = aSequence.Length() - aStyles.Length();
+          if (diff > 0) {
+            for (uint32_t i = 0; i < diff; i++) {
+              aStyles.AppendElement(JSVAL_NULL);
+            }
+          }
+          aStyles.AppendElement(JS::StringValue(jsString));
+        }
+        break;
+      }
+
       case 's':
         if (index < aData.Length()) {
           JS::Rooted<JS::Value> value(aCx, aData[index++]);
           JS::Rooted<JSString*> jsString(aCx, JS::ToString(aCx, value));
           if (!jsString) {
             return;
           }
 
diff --git a/dom/base/Console.h b/dom/base/Console.h
--- a/dom/base/Console.h
+++ b/dom/base/Console.h
@@ -133,26 +133,33 @@ private:
   void
   ProcessCallData(ConsoleCallData* aData);
 
   // If the first JS::Value of the array is a string, this method uses it to
   // format a string. The supported sequences are:
   //   %s    - string
   //   %d,%i - integer
   //   %f    - double
-  //   %o    - a JS object.
+  //   %o,%O - a JS object.
+  //   %c    - style string.
   // The output is an array where any object is a separated item, the rest is
   // unified in a format string.
   // Example if the input is:
   //   "string: %s, integer: %d, object: %o, double: %d", 's', 1, window, 0.9
   // The output will be:
   //   [ "string: s, integer: 1, object: ", window, ", double: 0.9" ]
+  //
+  // The aStyles array is populated with the style strings that the function
+  // finds based the format string. The index of the styles matches the indexes
+  // of elements that need the custom styling from aSequence. For elements with
+  // no custom styling the array is padded with null elements.
   void
   ProcessArguments(JSContext* aCx, const nsTArray<JS::Heap<JS::Value>>& aData,
-                   Sequence<JS::Value>& aSequence);
+                   Sequence<JS::Value>& aSequence,
+                   Sequence<JS::Value>& aStyles);
 
   void
   MakeFormatString(nsCString& aFormat, int32_t aInteger, int32_t aMantissa,
                    char aCh);
 
   // Stringify and Concat all the JS::Value in a single string using ' ' as
   // separator.
   void
diff --git a/dom/tests/browser/browser_ConsoleAPITests.js b/dom/tests/browser/browser_ConsoleAPITests.js
--- a/dom/tests/browser/browser_ConsoleAPITests.js
+++ b/dom/tests/browser/browser_ConsoleAPITests.js
@@ -1,16 +1,16 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "http://example.com/browser/dom/tests/browser/test-console-api.html";
 
-var gWindow, gLevel, gArgs, gTestDriver;
+var gWindow, gLevel, gArgs, gTestDriver, gStyle;
 
 function test() {
   waitForExplicitFinish();
 
   var tab = gBrowser.addTab(TEST_URI);
   gBrowser.selectedTab = tab;
   var browser = gBrowser.selectedBrowser;
 
@@ -59,16 +59,24 @@ function testConsoleData(aMessageObject)
         //
         // It'd be nice to just use XPCNativeWrapper.unwrap here, but there are
         // a number of dumb reasons we can't. See bug 868675.
         var arg = aMessageObject.arguments[i];
         if (Components.utils.isXrayWrapper(arg))
           arg = arg.wrappedJSObject;
         is(arg, a, "correct arg " + i);
       });
+
+      if (gStyle) {
+        is(aMessageObject.styles.length, gStyle.length, "styles.length matches");
+        is(aMessageObject.styles + "", gStyle + "", "styles match");
+      } else {
+        ok(!aMessageObject.styles || aMessageObject.styles.length === 0,
+           "styles match");
+      }
     }
   }
 
   gTestDriver.next();
 }
 
 function testLocationData(aMessageObject) {
   let messageWindow = Services.wm.getOuterWindowWithId(aMessageObject.ID);
@@ -240,22 +248,22 @@ function observeConsoleTest() {
                    "PI",
                    3.14159);
   yield undefined;
 
   expect("log", "%d, %s, %l");
   win.console.log("%d, %s, %l");
   yield undefined;
 
-  expect("log", "%a %b %c");
-  win.console.log("%a %b %c");
+  expect("log", "%a %b %g");
+  win.console.log("%a %b %g");
   yield undefined;
 
-  expect("log", "%a %b %c", "a", "b");
-  win.console.log("%a %b %c", "a", "b");
+  expect("log", "%a %b %g", "a", "b");
+  win.console.log("%a %b %g", "a", "b");
   yield undefined;
 
   expect("log", "2, a, %l", 3);
   win.console.log("%d, %s, %l", 2, "a", 3);
   yield undefined;
 
   // Bug #692550 handle null and undefined.
   expect("log", "null, undefined");
@@ -275,16 +283,28 @@ function observeConsoleTest() {
   expect("error", "arg");
   win.console.error("arg");
   yield undefined;
 
   expect("exception", "arg");
   win.console.exception("arg");
   yield undefined;
 
+  expect("log", "foobar");
+  gStyle = ["color:red;foobar;;"];
+  win.console.log("%cfoobar", gStyle[0]);
+  yield undefined;
+
+  let obj3 = { c: 3 };
+  expect("info", "foobar", "bazbaz", obj3, "omg");
+  gStyle = [null, "color:pink;", "color:red"];
+  win.console.info("foobar%cbazbaz", gStyle[1], obj3, "%comg", gStyle[2]);
+  yield undefined;
+
+  gStyle = null;
   let obj2 = { b: 2 };
   expect("log", "omg ", obj, " foo ", 4, obj2);
   win.console.log("omg %o foo %o", obj, 4, obj2);
   yield undefined;
 
   expect("assert", "message");
   win.console.assert(false, "message");
   yield undefined;
diff --git a/dom/webidl/Console.webidl b/dom/webidl/Console.webidl
--- a/dom/webidl/Console.webidl
+++ b/dom/webidl/Console.webidl
@@ -37,16 +37,17 @@ dictionary ConsoleEvent {
   (unsigned long or DOMString) ID;
   (unsigned long or DOMString) innerID;
   DOMString level = "";
   DOMString filename = "";
   unsigned long lineNumber = 0;
   DOMString functionName = "";
   double timeStamp = 0;
   sequence<any> arguments;
+  sequence<any> styles;
   boolean private = false;
   sequence<ConsoleStackEntry> stacktrace;
   DOMString groupName = "";
   any timer = null;
   any counter = null;
 };
 
 // Event for profile operations
diff --git a/toolkit/devtools/server/actors/webconsole.js b/toolkit/devtools/server/actors/webconsole.js
--- a/toolkit/devtools/server/actors/webconsole.js
+++ b/toolkit/devtools/server/actors/webconsole.js
@@ -1314,16 +1314,20 @@ WebConsoleActor.prototype =
     delete result.ID;
     delete result.innerID;
 
     result.arguments = Array.map(aMessage.arguments || [], (aObj) => {
       let dbgObj = this.makeDebuggeeValue(aObj, true);
       return this.createValueGrip(dbgObj);
     });
 
+    result.styles = Array.map(aMessage.styles || [], (aString) => {
+      return this.createValueGrip(aString);
+    });
+
     return result;
   },
 
   /**
    * Find the XUL window that owns the content window.
    *
    * @return Window
    *         The XUL window that owns the content window.
