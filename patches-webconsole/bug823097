# HG changeset patch
# Parent f4b4df9eba88f77f885467ca8dec19dec0289eba
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1396900784 -10800

Bug 823097 - Add support for %c style formatting in console; r=past,bz

diff --git a/browser/devtools/webconsole/console-output.js b/browser/devtools/webconsole/console-output.js
--- a/browser/devtools/webconsole/console-output.js
+++ b/browser/devtools/webconsole/console-output.js
@@ -1217,24 +1217,88 @@ Messages.ConsoleGeneric = function(packe
       break;
     }
     default:
       Messages.Extended.call(this, packet.arguments, options);
       break;
   }
 
   this._repeatID.consoleApiLevel = packet.level;
+  this._repeatID.styles = packet.styles;
+  this._styles = packet.styles || [];
 };
 
 Messages.ConsoleGeneric.prototype = Heritage.extend(Messages.Extended.prototype,
 {
+  _styles: null,
+
   _renderBodyPieceSeparator: function()
   {
     return this.document.createTextNode(" ");
   },
+
+  render: function()
+  {
+    let lastStyle = null;
+    let result = this.document.createDocumentFragment();
+
+    for (let i = 0; i < this._messagePieces.length; i++) {
+      let separator = i > 0 ? this._renderBodyPieceSeparator() : null;
+      if (separator) {
+        result.appendChild(separator);
+      }
+
+      let piece = this._messagePieces[i];
+      let renderedPiece = this._renderBodyPiece(piece);
+
+      let style = this._styles[i];
+      if (style && typeof style == "string" /* no long string support */) {
+        lastStyle = this.cleanupStyle(style);
+      }
+
+      if (lastStyle) {
+        if (renderedPiece.nodeType == Ci.nsIDOMNode.ELEMENT_NODE) {
+          renderedPiece.style = lastStyle;
+          result.appendChild(renderedPiece);
+        } else {
+          let span = this.document.createElementNS(XHTML_NS, "span");
+          span.style = lastStyle;
+          span.appendChild(renderedPiece);
+          result.appendChild(span);
+        }
+      } else {
+        result.appendChild(renderedPiece);
+      }
+    }
+
+    this._message = result;
+    this._messagePieces = null;
+    this._styles = null;
+    return Messages.Simple.prototype.render.call(this);
+  },
+
+  /**
+   * Given a style attribute value cleanup the string such that no external URL
+   * is allowed to load.
+   *
+   * Note: this method does not attempt to produce a correct style attribute
+   * value. URLs are not allowed and the intent here is to just break/disallow
+   * their use.
+   *
+   * @param string style
+   *        The style string to cleanup.
+   * @return string
+   *         The style value with no URLs.
+   */
+  cleanupStyle: function(style)
+  {
+    return style.replace(/\burl[\s('"]+/gi, "urlnotallowed")
+           .replace(/['"(]*(?:chrome|resource|about|app|data|https?|ftp|file):+\/*/gi,
+                    "urlnotallowed");
+  },
 }); // Messages.ConsoleGeneric.prototype
 
 /**
  * The ConsoleTrace message is used for console.trace() calls.
  *
  * @constructor
  * @extends Messages.Simple
  * @param object packet
diff --git a/browser/devtools/webconsole/test/browser.ini b/browser/devtools/webconsole/test/browser.ini
--- a/browser/devtools/webconsole/test/browser.ini
+++ b/browser/devtools/webconsole/test/browser.ini
@@ -276,8 +276,9 @@ run-if = os == "mac"
 [browser_webconsole_output_dom_elements_03.js]
 [browser_webconsole_output_dom_elements_04.js]
 [browser_webconsole_output_events.js]
 [browser_console_variables_view_highlighter.js]
 [browser_webconsole_start_netmon_first.js]
 [browser_webconsole_console_trace_duplicates.js]
 [browser_webconsole_cd_iframe.js]
 [browser_webconsole_autocomplete_crossdomain_iframe.js]
+[browser_webconsole_console_custom_styles.js]
diff --git a/browser/devtools/webconsole/test/browser_webconsole_console_custom_styles.js b/browser/devtools/webconsole/test/browser_webconsole_console_custom_styles.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/test/browser_webconsole_console_custom_styles.js
@@ -0,0 +1,72 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that the '%c' modifier works with the console API. See bug 823097.
+
+function test() {
+  let hud;
+
+  const TEST_URI = "data:text/html;charset=utf8,<p>test for " +
+                   "console.log('%ccustom styles', 'color:red')";
+
+  const checks = [{
+    style: "color:red;font-size:1.3em",
+    props: { color: true, fontSize: true },
+    sameStyleExpected: true,
+  }, {
+    style: "color:blue;background-image:url('http://example.com/test')",
+    props: { color: true, fontSize: false, background: false,
+             backgroundImage: false },
+    sameStyleExpected: false,
+  }];
+
+  Task.spawn(runner).then(finishTest);
+
+  function* runner() {
+    const {tab} = yield loadTab(TEST_URI);
+    hud = yield openConsole(tab);
+
+    for (let check of checks) {
+      yield checkStyle(check);
+    }
+
+    yield closeConsole(tab);
+  }
+
+  function* checkStyle(check) {
+    hud.jsterm.clearOutput();
+
+    info("checkStyle " + check.style);
+    hud.jsterm.execute("console.log('%cfoobar', \"" + check.style + "\")");
+
+    let [result] = yield waitForMessages({
+      webconsole: hud,
+      messages: [{
+        text: "foobar",
+        category: CATEGORY_WEBDEV,
+      }],
+    });
+
+    let msg = [...result.matched][0];
+    ok(msg, "message element");
+
+    let span = msg.querySelector(".body span[style]");
+    ok(span, "span element");
+
+    info("span textContent is: " + span.textContent);
+    isnot(span.textContent.indexOf("foobar"), -1, "span textContent check");
+
+    let outputStyle = span.getAttribute("style").replace(/\s+|;+$/g, "");
+    if (check.sameStyleExpected) {
+      is(outputStyle, check.style, "span style is correct");
+    } else {
+      isnot(outputStyle, check.style, "span style is not the same");
+    }
+
+    for (let prop of Object.keys(check.props)) {
+      is(!!span.style[prop], check.props[prop], "property check for " + prop);
+    }
+  }
+}
diff --git a/dom/base/Console.cpp b/dom/base/Console.cpp
--- a/dom/base/Console.cpp
+++ b/dom/base/Console.cpp
@@ -964,17 +964,19 @@ Console::ProcessCallData(ConsoleCallData
     case MethodLog:
     case MethodInfo:
     case MethodWarn:
     case MethodError:
     case MethodException:
     case MethodDebug:
     case MethodAssert:
       event.mArguments.Construct();
-      ProcessArguments(cx, aData->mArguments, event.mArguments.Value());
+      event.mStyles.Construct();
+      ProcessArguments(cx, aData->mArguments, event.mArguments.Value(),
+                       event.mStyles.Value());
       break;
 
     default:
       event.mArguments.Construct();
       ArgumentsToValueList(aData->mArguments, event.mArguments.Value());
   }
 
   if (aData->mMethodName == MethodTrace) {
@@ -1046,28 +1048,30 @@ Console::ProcessCallData(ConsoleCallData
 
     obs->NotifyObservers(wrapper, "console-api-log-event", outerID.get());
   }
 }
 
 void
 Console::ProcessArguments(JSContext* aCx,
                           const nsTArray<JS::Heap<JS::Value>>& aData,
-                          Sequence<JS::Value>& aSequence)
+                          Sequence<JS::Value>& aSequence,
+                          Sequence<JS::Value>& aStyles)
 {
   if (aData.IsEmpty()) {
     return;
   }
 
   if (aData.Length() == 1 || !aData[0].isString()) {
     ArgumentsToValueList(aData, aSequence);
     return;
   }
 
   SequenceRooter<JS::Value> rooter(aCx, &aSequence);
+  SequenceRooter<JS::Value> rooterStyles(aCx, &aStyles);
 
   JS::Rooted<JS::Value> format(aCx, aData[0]);
   JS::Rooted<JSString*> jsString(aCx, JS::ToString(aCx, format));
   if (!jsString) {
     return;
   }
 
   nsDependentJSString string;
@@ -1153,16 +1157,17 @@ Console::ProcessArguments(JSContext* aCx
     }
 
     char ch = *start;
     tmp.Append(ch);
     ++start;
 
     switch (ch) {
       case 'o':
+      case 'O':
       {
         if (!output.IsEmpty()) {
           JS::Rooted<JSString*> str(aCx, JS_NewUCStringCopyN(aCx,
                                                              output.get(),
                                                              output.Length()));
           if (!str) {
             return;
           }
@@ -1175,16 +1180,41 @@ Console::ProcessArguments(JSContext* aCx
         if (index < aData.Length()) {
           v = aData[index++];
         }
 
         aSequence.AppendElement(v);
         break;
       }
 
+      case 'c':
+      {
+        if (!output.IsEmpty()) {
+          JS::Rooted<JSString*> str(aCx, JS_NewUCStringCopyN(aCx,
+                                                             output.get(),
+                                                             output.Length()));
+          if (!str) {
+            return;
+          }
+
+          aSequence.AppendElement(JS::StringValue(str));
+          output.Truncate();
+        }
+
+        if (index < aData.Length()) {
+          JS::Rooted<JS::Value> v(aCx, aData[index++]);
+          JS::Rooted<JSString*> jsString(aCx, JS::ToString(aCx, v));
+          if (!jsString) {
+            return;
+          }
+          aStyles.AppendElement(JS::StringValue(jsString));
+        }
+        break;
+      }
+
       case 's':
         if (index < aData.Length()) {
           JS::Rooted<JS::Value> value(aCx, aData[index++]);
           JS::Rooted<JSString*> jsString(aCx, JS::ToString(aCx, value));
           if (!jsString) {
             return;
           }
 
diff --git a/dom/base/Console.h b/dom/base/Console.h
--- a/dom/base/Console.h
+++ b/dom/base/Console.h
@@ -142,17 +142,18 @@ private:
   // The output is an array where any object is a separated item, the rest is
   // unified in a format string.
   // Example if the input is:
   //   "string: %s, integer: %d, object: %o, double: %d", 's', 1, window, 0.9
   // The output will be:
   //   [ "string: s, integer: 1, object: ", window, ", double: 0.9" ]
   void
   ProcessArguments(JSContext* aCx, const nsTArray<JS::Heap<JS::Value>>& aData,
-                   Sequence<JS::Value>& aSequence);
+                   Sequence<JS::Value>& aSequence,
+                   Sequence<JS::Value>& aStyles);
 
   void
   MakeFormatString(nsCString& aFormat, int32_t aInteger, int32_t aMantissa,
                    char aCh);
 
   // Stringify and Concat all the JS::Value in a single string using ' ' as
   // separator.
   void
diff --git a/dom/webidl/Console.webidl b/dom/webidl/Console.webidl
--- a/dom/webidl/Console.webidl
+++ b/dom/webidl/Console.webidl
@@ -37,16 +37,17 @@ dictionary ConsoleEvent {
   (unsigned long or DOMString) ID;
   (unsigned long or DOMString) innerID;
   DOMString level = "";
   DOMString filename = "";
   unsigned long lineNumber = 0;
   DOMString functionName = "";
   double timeStamp = 0;
   sequence<any> arguments;
+  sequence<any> styles;
   boolean private = false;
   sequence<ConsoleStackEntry> stacktrace;
   DOMString groupName = "";
   any timer = null;
   any counter = null;
 };
 
 // Event for profile operations
diff --git a/toolkit/devtools/server/actors/webconsole.js b/toolkit/devtools/server/actors/webconsole.js
--- a/toolkit/devtools/server/actors/webconsole.js
+++ b/toolkit/devtools/server/actors/webconsole.js
@@ -1314,16 +1314,21 @@ WebConsoleActor.prototype =
     delete result.ID;
     delete result.innerID;
 
     result.arguments = Array.map(aMessage.arguments || [], (aObj) => {
       let dbgObj = this.makeDebuggeeValue(aObj, true);
       return this.createValueGrip(dbgObj);
     });
 
+    result.styles = Array.map(aMessage.styles || [], (aObj) => {
+      let dbgObj = this.makeDebuggeeValue(aObj, true);
+      return this.createValueGrip(dbgObj);
+    });
+
     return result;
   },
 
   /**
    * Find the XUL window that owns the content window.
    *
    * @return Window
    *         The XUL window that owns the content window.
