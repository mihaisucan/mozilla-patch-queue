# HG changeset patch
# Parent 3618915c083fc39162cfe307ab26542dcd34cf64
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1357746976 -7200

Bug 827083 - Cannot attach remote web console to Firefox Android; try: -b do -p linux,linux64,macosx64,win32,win64 -u xpcshell,mochitest-o,mochitest-bc -t none

diff --git a/browser/devtools/commandline/test/browser_cmd_calllog.js b/browser/devtools/commandline/test/browser_cmd_calllog.js
--- a/browser/devtools/commandline/test/browser_cmd_calllog.js
+++ b/browser/devtools/commandline/test/browser_cmd_calllog.js
@@ -41,17 +41,17 @@ function testCallLogStatus() {
 function testCallLogExec() {
   DeveloperToolbarTest.exec({
     typed: "calllog stop",
     args: { },
     outputMatch: /No call logging/,
   });
 
   let hud = null;
-  var onWebConsoleOpen = DeveloperToolbarTest.checkCalled(function(aSubject) {
+  function onWebConsoleOpen(aSubject) {
     Services.obs.removeObserver(onWebConsoleOpen, "web-console-created");
 
     aSubject.QueryInterface(Ci.nsISupportsString);
     hud = imported.HUDService.getHudReferenceById(aSubject.data);
     ok(hud.hudId in imported.HUDService.hudReferences, "console open");
 
     DeveloperToolbarTest.exec({
       typed: "calllog stop",
@@ -63,23 +63,25 @@ function testCallLogExec() {
       typed: "console clear",
       args: {},
       blankOutput: true,
     });
 
     let labels = hud.outputNode.querySelectorAll(".webconsole-msg-output");
     is(labels.length, 0, "no output in console");
 
-    DeveloperToolbarTest.exec({
-      typed: "console close",
-      args: {},
-      blankOutput: true,
-      completed: false,
+    executeSoon(function() {
+      DeveloperToolbarTest.exec({
+        typed: "console close",
+        args: {},
+        blankOutput: true,
+        completed: false,
+      });
     });
-  });
+  };
 
   Services.obs.addObserver(onWebConsoleOpen, "web-console-created", false);
 
   DeveloperToolbarTest.exec({
     typed: "calllog start",
     args: { },
     outputMatch: /Call logging started/,
   });
diff --git a/browser/devtools/commandline/test/browser_cmd_calllog_chrome.js b/browser/devtools/commandline/test/browser_cmd_calllog_chrome.js
--- a/browser/devtools/commandline/test/browser_cmd_calllog_chrome.js
+++ b/browser/devtools/commandline/test/browser_cmd_calllog_chrome.js
@@ -89,24 +89,26 @@ function testCallLogExec() {
       typed: "console clear",
       args: {},
       blankOutput: true,
     });
 
     let labels = hud.jsterm.outputNode.querySelectorAll(".webconsole-msg-output");
     is(labels.length, 0, "no output in console");
 
-    DeveloperToolbarTest.exec({
-      typed: "console close",
-      args: {},
-      blankOutput: true,
-      completed: false,
+    executeSoon(function() {
+      DeveloperToolbarTest.exec({
+        typed: "console close",
+        args: {},
+        blankOutput: true,
+        completed: false,
+      });
+
+      executeSoon(finish);
     });
-
-    executeSoon(finish);
   }
   Services.obs.addObserver(onWebConsoleOpen, "web-console-created", false);
 
   DeveloperToolbarTest.exec({
     typed: "calllog chromestart javascript \"({a1: function() {this.a2()},a2: function() {}});\"",
     outputMatch: /Call logging started/,
     completed: false,
   });
diff --git a/browser/devtools/framework/Toolbox.jsm b/browser/devtools/framework/Toolbox.jsm
--- a/browser/devtools/framework/Toolbox.jsm
+++ b/browser/devtools/framework/Toolbox.jsm
@@ -483,16 +483,18 @@ Toolbox.prototype = {
    *
    * @return {Host} host
    *        The created host object
    */
   _createHost: function TBOX_createHost(hostType) {
     if (!Hosts[hostType]) {
       throw new Error('Unknown hostType: '+ hostType);
     }
+    // Warning: not all Targets have a tab property - make sure you correctly
+    // mix and match hosts and targets.
     let newHost = new Hosts[hostType](this.target.tab);
 
     // clean up the toolbox if its window is closed
     newHost.on("window-closed", this.destroy);
 
     return newHost;
   },
 
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -8,252 +8,118 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 const CONSOLEAPI_CLASS_ID = "{b49c18f8-3379-4fc0-8c90-d7772c1a9ff3}";
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource:///modules/devtools/gDevTools.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "gDevTools",
+    "resource:///modules/devtools/gDevTools.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "TargetFactory",
-                                  "resource:///modules/devtools/Target.jsm");
+    "resource:///modules/devtools/Target.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Services",
-                                  "resource://gre/modules/Services.jsm");
+    "resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
-                                  "resource://gre/modules/devtools/WebConsoleUtils.jsm");
+    "resource://gre/modules/devtools/WebConsoleUtils.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "Promise",
+    "resource://gre/modules/commonjs/promise/core.js");
 
 const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
 let l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 
 this.EXPORTED_SYMBOLS = ["HUDService"];
 
-function LogFactory(aMessagePrefix)
-{
-  function log(aMessage) {
-    var _msg = aMessagePrefix + " " + aMessage + "\n";
-    dump(_msg);
-  }
-  return log;
-}
-
-let log = LogFactory("*** HUDService:");
-
-// The HTML namespace.
-const HTML_NS = "http://www.w3.org/1999/xhtml";
-
-// The XUL namespace.
-const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
 ///////////////////////////////////////////////////////////////////////////
 //// The HUD service
 
 function HUD_SERVICE()
 {
-  // These methods access the "this" object, but they're registered as
-  // event listeners. So we hammer in the "this" binding.
-  this.onWindowUnload = this.onWindowUnload.bind(this);
-
-  /**
-   * Keeps a reference for each HeadsUpDisplay that is created
-   */
   this.hudReferences = {};
-};
+}
 
 HUD_SERVICE.prototype =
 {
   /**
+   * Keeps a reference for each HeadsUpDisplay that is created
+   * @type object
+   */
+  hudReferences: null,
+
+  /**
    * getter for UI commands to be used by the frontend
    *
    * @returns object
    */
   get consoleUI() {
     return HeadsUpDisplayUICommands;
   },
 
   /**
-   * The sequencer is a generator (after initialization) that returns unique
-   * integers
-   */
-  sequencer: null,
-
-  /**
    * Firefox-specific current tab getter
    *
    * @returns nsIDOMWindow
    */
   currentContext: function HS_currentContext() {
     return Services.wm.getMostRecentWindow("navigator:browser");
   },
 
   /**
-   * Activate a HeadsUpDisplay for the given tab context.
+   * Open a Web Console for the given target.
    *
-   * @param nsIDOMElement aTab
-   *        The xul:tab element.
+   * @see devtools/framework/Target.jsm for details about targets.
+   *
+   * @param object aTarget
+   *        The target that the web console will connect to.
    * @param nsIDOMElement aIframe
    *        The iframe element into which to place the web console.
-   * @param RemoteTarget aTarget
-   *        The target that the web console will connect to.
    * @return object
-   *         The new HeadsUpDisplay instance.
+   *         A Promise object for the opening of the new WebConsole instance.
    */
-  activateHUDForContext: function HS_activateHUDForContext(aTab, aIframe,
-                                                           aTarget)
+  openWebConsole: function HS_openWebConsole(aTarget, aIframe)
   {
-    let hudId = "hud_" + aTab.linkedPanel;
-    if (hudId in this.hudReferences) {
-      return this.hudReferences[hudId];
-    }
-
-    this.wakeup();
-
-    let window = aTab.ownerDocument.defaultView;
-    let gBrowser = window.gBrowser;
-
-    window.addEventListener("unload", this.onWindowUnload, false);
-
-    let hud = new WebConsole(aTab, aIframe, aTarget);
-    this.hudReferences[hudId] = hud;
-
-    return hud;
-  },
-
-  /**
-   * Deactivate a HeadsUpDisplay for the given tab context.
-   *
-   * @param nsIDOMElement aTab
-   *        The xul:tab element you want to enable the Web Console for.
-   * @return void
-   */
-  deactivateHUDForContext: function HS_deactivateHUDForContext(aTab)
-  {
-    let hudId = "hud_" + aTab.linkedPanel;
-    if (!(hudId in this.hudReferences)) {
-      return;
-    }
-
-    let hud = this.getHudReferenceById(hudId);
-    let document = hud.chromeDocument;
-
-    hud.destroy(function() {
-      let id = WebConsoleUtils.supportsString(hudId);
-      Services.obs.notifyObservers(id, "web-console-destroyed", null);
-    });
-
-    delete this.hudReferences[hudId];
-
-    if (Object.keys(this.hudReferences).length == 0) {
-      let autocompletePopup = document.
-                              getElementById("webConsole_autocompletePopup");
-      if (autocompletePopup) {
-        autocompletePopup.parentNode.removeChild(autocompletePopup);
-      }
-
-      let window = document.defaultView;
-
-      window.removeEventListener("unload", this.onWindowUnload, false);
-
-      let gBrowser = window.gBrowser;
-      let tabContainer = gBrowser.tabContainer;
-
-      this.suspend();
-    }
-
-    let contentWindow = aTab.linkedBrowser.contentWindow;
-    contentWindow.focus();
-  },
-
-  /**
-   * get a unique ID from the sequence generator
-   *
-   * @returns integer
-   */
-  sequenceId: function HS_sequencerId()
-  {
-    if (!this.sequencer) {
-      this.sequencer = this.createSequencer(-1);
-    }
-    return this.sequencer.next();
-  },
-
-  /**
-   * "Wake up" the Web Console activity. This is called when the first Web
-   * Console is open. This method initializes the various observers we have.
-   *
-   * @returns void
-   */
-  wakeup: function HS_wakeup()
-  {
-    if (Object.keys(this.hudReferences).length > 0) {
-      return;
-    }
-
-    WebConsoleObserver.init();
-  },
-
-  /**
-   * Suspend Web Console activity. This is called when all Web Consoles are
-   * closed.
-   *
-   * @returns void
-   */
-  suspend: function HS_suspend()
-  {
-    delete this.lastFinishedRequestCallback;
-
-    WebConsoleObserver.uninit();
-  },
-
-  /**
-   * Shutdown all HeadsUpDisplays on quit-application-granted.
-   *
-   * @returns void
-   */
-  shutdown: function HS_shutdown()
-  {
-    for (let hud of this.hudReferences) {
-      this.deactivateHUDForContext(hud.tab);
-    }
+    let hud = new WebConsole(aTarget, aIframe);
+    this.hudReferences[hud.hudId] = hud;
+    return hud.init();
   },
 
   /**
    * Returns the HeadsUpDisplay object associated to a content window.
    *
    * @param nsIDOMWindow aContentWindow
    * @returns object
    */
   getHudByWindow: function HS_getHudByWindow(aContentWindow)
   {
-    let hudId = this.getHudIdByWindow(aContentWindow);
-    return hudId ? this.hudReferences[hudId] : null;
+    for each (let hud in this.hudReferences) {
+      let target = hud.target;
+      if (target && target.tab && target.window === aContentWindow) {
+        return hud;
+      }
+    }
+    return null;
   },
 
   /**
    * Returns the hudId that is corresponding to the hud activated for the
    * passed aContentWindow. If there is no matching hudId null is returned.
    *
    * @param nsIDOMWindow aContentWindow
    * @returns string or null
    */
   getHudIdByWindow: function HS_getHudIdByWindow(aContentWindow)
   {
-    let window = this.currentContext();
-    let index =
-      window.gBrowser.getBrowserIndexForDocument(aContentWindow.document);
-    if (index == -1) {
-      return null;
-    }
-
-    let tab = window.gBrowser.tabs[index];
-    let hudId = "hud_" + tab.linkedPanel;
-    return hudId in this.hudReferences ? hudId : null;
+    let hud = this.getHudByWindow(aContentWindow);
+    return hud ? hud.hudId : null;
   },
 
   /**
    * Returns the hudReference for a given id.
    *
    * @param string aId
    * @returns Object
    */
@@ -265,225 +131,157 @@ HUD_SERVICE.prototype =
   /**
    * Assign a function to this property to listen for every request that
    * completes. Used by unit tests. The callback takes one argument: the HTTP
    * activity object as received from the remote Web Console.
    *
    * @type function
    */
   lastFinishedRequestCallback: null,
-
-  /**
-   * Creates a generator that always returns a unique number for use in the
-   * indexes
-   *
-   * @returns Generator
-   */
-  createSequencer: function HS_createSequencer(aInt)
-  {
-    function sequencer(aInt)
-    {
-      while(1) {
-        aInt++;
-        yield aInt;
-      }
-    }
-    return sequencer(aInt);
-  },
-
-  /**
-   * Called whenever a browser window closes. Cleans up any consoles still
-   * around.
-   *
-   * @param nsIDOMEvent aEvent
-   *        The dispatched event.
-   * @returns void
-   */
-  onWindowUnload: function HS_onWindowUnload(aEvent)
-  {
-    let window = aEvent.target.defaultView;
-
-    window.removeEventListener("unload", this.onWindowUnload, false);
-
-    let gBrowser = window.gBrowser;
-    let tabContainer = gBrowser.tabContainer;
-
-    let tab = tabContainer.firstChild;
-    while (tab != null) {
-      this.deactivateHUDForContext(tab);
-      tab = tab.nextSibling;
-    }
-  },
 };
 
 
 /**
- * A WebConsole instance is an interactive console initialized *per tab*
+ * A WebConsole instance is an interactive console initialized *per target*
  * that displays console log data as well as provides an interactive terminal to
- * manipulate the current tab's document content.
+ * manipulate the target's document content.
  *
  * This object only wraps the iframe that holds the Web Console UI.
  *
- * @param nsIDOMElement aTab
- *        The xul:tab for which you want the WebConsole object.
+ * @constructor
+ * @param object aTarget
+ *        The target that the web console will connect to.
  * @param nsIDOMElement aIframe
  *        iframe into which we should create the WebConsole UI.
- * @param RemoteTarget aTarget
- *        The target that the web console will connect to.
  */
-function WebConsole(aTab, aIframe, aTarget)
+function WebConsole(aTarget, aIframe)
 {
-  this.tab = aTab;
-  if (this.tab == null) {
-    throw new Error('Missing tab');
-  }
-
   this.iframe = aIframe;
-  if (this.iframe == null) {
-    console.trace();
-    throw new Error('Missing iframe');
-  }
-
-  this.chromeDocument = this.tab.ownerDocument;
+  this.iframe.className = "web-console-frame";
+  this.chromeDocument = this.iframe.ownerDocument;
   this.chromeWindow = this.chromeDocument.defaultView;
-  this.hudId = "hud_" + this.tab.linkedPanel;
-
+  this.hudId = "hud_" + Date.now();
   this.target = aTarget;
-
-  this._onIframeLoad = this._onIframeLoad.bind(this);
-
-  this.iframe.className = "web-console-frame";
-  this.iframe.addEventListener("load", this._onIframeLoad, true);
-
-  this.positionConsole();
 }
 
 WebConsole.prototype = {
-  /**
-   * The xul:tab for which the current Web Console instance was created.
-   * @type nsIDOMElement
-   */
-  tab: null,
-
   chromeWindow: null,
   chromeDocument: null,
+  hudId: null,
+  target: null,
+  iframe: null,
+  _destroyer: null,
+
+  get browserWindow()
+  {
+    return this.target.isLocalTab ?
+           this.chromeWindow.top : HUDService.currentContext();
+  },
 
   /**
    * Getter for HUDService.lastFinishedRequestCallback.
    *
    * @see HUDService.lastFinishedRequestCallback
    * @type function
    */
   get lastFinishedRequestCallback() HUDService.lastFinishedRequestCallback,
 
   /**
    * Getter for the xul:popupset that holds any popups we open.
    * @type nsIDOMElement
    */
   get mainPopupSet()
   {
-    return this.chromeDocument.getElementById("mainPopupSet");
+    return this.browserWindow.document.getElementById("mainPopupSet");
   },
 
   /**
    * Getter for the output element that holds messages we display.
    * @type nsIDOMElement
    */
   get outputNode()
   {
     return this.ui ? this.ui.outputNode : null;
   },
 
-  get gViewSourceUtils() this.chromeWindow.gViewSourceUtils,
+  get gViewSourceUtils() this.browserWindow.gViewSourceUtils,
 
   /**
-   * The "load" event handler for the Web Console iframe.
-   * @private
+   * Initialize the Web Console instance.
+   *
+   * @return object
+   *         A Promise for the initialization.
    */
-  _onIframeLoad: function WC__onIframeLoad()
+  init: function WC_init()
   {
-    this.iframe.removeEventListener("load", this._onIframeLoad, true);
+    let deferred = Promise.defer();
 
-    this.iframeWindow = this.iframe.contentWindow.wrappedJSObject;
-    this.ui = new this.iframeWindow.WebConsoleFrame(this);
+    let onIframeLoad = function() {
+      this.iframe.removeEventListener("load", onIframeLoad, true);
+      initUI();
+    }.bind(this);
+
+    let initUI = function() {
+      this.iframeWindow = this.iframe.contentWindow.wrappedJSObject;
+      this.ui = new this.iframeWindow.WebConsoleFrame(this);
+      this.ui.init().then(onSuccess, onFailure);
+    }.bind(this);
+
+    let onSuccess = function() {
+      deferred.resolve(this);
+    }.bind(this);
+
+    let onFailure = function(aReason) {
+      deferred.reject(aReason);
+    };
+
+    let win, doc;
+    if ((win = this.iframe.contentWindow) &&
+        (doc = win.document) &&
+        doc.readyState == "complete") {
+      this.iframe.addEventListener("load", onIframeLoad, true);
+    }
+    else {
+      initUI();
+    }
+
+    return deferred.promise;
   },
 
   /**
    * Retrieve the Web Console panel title.
    *
    * @return string
    *         The Web Console panel title.
    */
   getPanelTitle: function WC_getPanelTitle()
   {
     let url = this.ui ? this.ui.contentLocation : "";
     return l10n.getFormatStr("webConsoleWindowTitleAndURL", [url]);
   },
 
-  consoleWindowUnregisterOnHide: true,
-
-  /**
-   * Position the Web Console UI.
-   */
-  positionConsole: function WC_positionConsole()
-  {
-    let lastIndex = -1;
-
-    if (this.outputNode && this.outputNode.getIndexOfFirstVisibleRow) {
-      lastIndex = this.outputNode.getIndexOfFirstVisibleRow() +
-                  this.outputNode.getNumberOfVisibleRows() - 1;
-    }
-
-    this._beforePositionConsole(lastIndex);
-  },
-
-  /**
-   * Common code that needs to execute before the Web Console is repositioned.
-   * @private
-   * @param number aLastIndex
-   *        The last visible message in the console output before repositioning
-   *        occurred.
-   */
-  _beforePositionConsole:
-  function WC__beforePositionConsole(aLastIndex)
-  {
-    if (!this.ui) {
-      return;
-    }
-
-    let onLoad = function() {
-      this.iframe.removeEventListener("load", onLoad, true);
-      this.iframeWindow = this.iframe.contentWindow.wrappedJSObject;
-      this.ui.positionConsole(this.iframeWindow);
-
-      if (aLastIndex > -1 && aLastIndex < this.outputNode.getRowCount()) {
-        this.outputNode.ensureIndexIsVisible(aLastIndex);
-      }
-    }.bind(this);
-
-    this.iframe.addEventListener("load", onLoad, true);
-  },
-
   /**
    * The JSTerm object that manages the console's input.
    * @see webconsole.js::JSTerm
    * @type object
    */
   get jsterm()
   {
     return this.ui ? this.ui.jsterm : null;
   },
 
   /**
    * The clear output button handler.
    * @private
    */
   _onClearButton: function WC__onClearButton()
   {
-    this.chromeWindow.DeveloperToolbar.resetErrorsCount(this.tab);
+    if (this.target.isLocalTab) {
+      this.browserWindow.DeveloperToolbar.resetErrorsCount(this.target.tab);
+    }
   },
 
   /**
    * Alias for the WebConsoleFrame.setFilterState() method.
    * @see webconsole.js::WebConsoleFrame.setFilterState()
    */
   setFilterState: function WC_setFilterState()
   {
@@ -493,17 +291,17 @@ WebConsole.prototype = {
   /**
    * Open a link in a new tab.
    *
    * @param string aLink
    *        The URL you want to open in a new tab.
    */
   openLink: function WC_openLink(aLink)
   {
-    this.chromeWindow.openUILinkIn(aLink, "tab");
+    this.browserWindow.openUILinkIn(aLink, "tab");
   },
 
   /**
    * Open a link in Firefox's view source.
    *
    * @param string aSourceURL
    *        The URL of the file.
    * @param integer aSourceLine
@@ -525,165 +323,115 @@ WebConsole.prototype = {
    * @param integer aSourceLine
    *        The line number which you want to place the caret.
    * TODO: This function breaks the client-server boundaries.
    *       To be fixed in bug 793259.
    */
   viewSourceInStyleEditor:
   function WC_viewSourceInStyleEditor(aSourceURL, aSourceLine)
   {
-    let styleSheets = this.tab.linkedBrowser.contentWindow.document.styleSheets;
+    let styleSheets = {};
+    if (this.target.isLocalTab) {
+      styleSheets = this.target.window.document.styleSheets;
+    }
     for each (let style in styleSheets) {
       if (style.href == aSourceURL) {
-        let target = TargetFactory.forTab(this.tab);
-        let gDevTools = this.chromeWindow.gDevTools;
-        gDevTools.showToolbox(target, "styleeditor").then(function(toolbox) {
+        gDevTools.showToolbox(this.target, "styleeditor").then(function(toolbox) {
           toolbox.getCurrentPanel().selectStyleSheet(style, aSourceLine);
         });
         return;
       }
     }
     // Open view source if style editor fails.
     this.viewSource(aSourceURL, aSourceLine);
   },
 
   /**
    * Destroy the object. Call this method to avoid memory leaks when the Web
    * Console is closed.
    *
-   * @param function [aOnDestroy]
-   *        Optional function to invoke when the Web Console instance is
-   *        destroyed.
+   * @return object
+   *         A Promise object that is resolved once the Web Console is closed.
    */
-  destroy: function WC_destroy(aOnDestroy)
+  destroy: function WC_destroy()
   {
-    // Make sure that the console panel does not try to call
-    // deactivateHUDForContext() again.
-    this.consoleWindowUnregisterOnHide = false;
+    if (this._destroyer) {
+      return this._destroyer.promise;
+    }
+
+    delete HUDService.hudReferences[this.hudId];
+
+    let tabWindow = this.target.isLocalTab ? this.target.window : null;
+
+    this._destroyer = Promise.defer();
 
     let popupset = this.mainPopupSet;
     let panels = popupset.querySelectorAll("panel[hudId=" + this.hudId + "]");
     for (let panel of panels) {
       panel.hidePopup();
     }
 
     let onDestroy = function WC_onDestroyUI() {
-      // Remove the iframe and the consolePanel if the Web Console is inside a
-      // floating panel.
-      if (this.consolePanel && this.consolePanel.parentNode) {
-        this.consolePanel.hidePopup();
-        this.consolePanel.parentNode.removeChild(this.consolePanel);
-        this.consolePanel = null;
+      try {
+        tabWindow && tabWindow.focus();
+      }
+      catch (ex) {
+        // Tab focus can fail if the tab is closed.
       }
 
-      if (this.iframe.parentNode) {
-        this.iframe.parentNode.removeChild(this.iframe);
-      }
+      let id = WebConsoleUtils.supportsString(this.hudId);
+      Services.obs.notifyObservers(id, "web-console-destroyed", null);
 
-      aOnDestroy && aOnDestroy();
+      this._destroyer.resolve(null);
     }.bind(this);
 
     if (this.ui) {
-      this.ui.destroy(onDestroy);
+      this.ui.destroy().then(onDestroy);
     }
     else {
       onDestroy();
     }
+
+    return this._destroyer.promise;
   },
 };
 
 //////////////////////////////////////////////////////////////////////////
 // HeadsUpDisplayUICommands
 //////////////////////////////////////////////////////////////////////////
 
 var HeadsUpDisplayUICommands = {
-  toggleHUD: function UIC_toggleHUD(aOptions)
+  /**
+   * Toggle the Web Console for the current tab.
+   *
+   * @return object
+   *         A Promise for either the opening of the toolbox that holds the Web
+   *         Console, or a Promise for the closing of the toolbox.
+   */
+  toggleHUD: function UIC_toggleHUD()
   {
-    var window = HUDService.currentContext();
+    let window = HUDService.currentContext();
     let target = TargetFactory.forTab(window.gBrowser.selectedTab);
     let toolbox = gDevTools.getToolbox(target);
 
     return toolbox && toolbox.currentToolId == "webconsole" ?
         toolbox.destroy() :
         gDevTools.showToolbox(target, "webconsole");
   },
 
-  toggleRemoteHUD: function UIC_toggleRemoteHUD()
-  {
-    if (this.getOpenHUD()) {
-      this.toggleHUD();
-      return;
-    }
-
-    let host = Services.prefs.getCharPref("devtools.debugger.remote-host");
-    let port = Services.prefs.getIntPref("devtools.debugger.remote-port");
-
-    let check = { value: false };
-    let input = { value: host + ":" + port };
-
-    let result = Services.prompt.prompt(null,
-      l10n.getStr("remoteWebConsolePromptTitle"),
-      l10n.getStr("remoteWebConsolePromptMessage"),
-      input, null, check);
-
-    if (!result) {
-      return;
-    }
-
-    let parts = input.value.split(":");
-    if (parts.length != 2) {
-      return;
-    }
-
-    [host, port] = parts;
-    if (!host.length || !port.length) {
-      return;
-    }
-
-    Services.prefs.setCharPref("devtools.debugger.remote-host", host);
-    Services.prefs.setIntPref("devtools.debugger.remote-port", port);
-
-    this.toggleHUD({
-      host: host,
-      port: port,
-    });
-  },
-
   /**
-   * Find the hudId for the active chrome window.
-   * @return string|null
-   *         The hudId or null if the active chrome window has no open Web
+   * Find if there is a Web Console open for the current tab and return the
+   * instance.
+   * @return object|null
+   *         The WebConsole object or null if the active tab has no open Web
    *         Console.
    */
-  getOpenHUD: function UIC_getOpenHUD() {
-    let chromeWindow = HUDService.currentContext();
-    let hudId = "hud_" + chromeWindow.gBrowser.selectedTab.linkedPanel;
-    return hudId in HUDService.hudReferences ? hudId : null;
-  },
-};
-
-//////////////////////////////////////////////////////////////////////////
-// WebConsoleObserver
-//////////////////////////////////////////////////////////////////////////
-
-var WebConsoleObserver = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
-
-  init: function WCO_init()
+  getOpenHUD: function UIC_getOpenHUD()
   {
-    Services.obs.addObserver(this, "quit-application-granted", false);
-  },
-
-  observe: function WCO_observe(aSubject, aTopic)
-  {
-    if (aTopic == "quit-application-granted") {
-      HUDService.shutdown();
-    }
-  },
-
-  uninit: function WCO_uninit()
-  {
-    Services.obs.removeObserver(this, "quit-application-granted");
+    let window = HUDService.currentContext();
+    let target = TargetFactory.forTab(window.gBrowser.selectedTab);
+    let toolbox = gDevTools.getToolbox(target);
+    let panel = toolbox ? toolbox.getPanel("webconsole") : null;
+    return panel ? panel.hud : null;
   },
 };
 
 const HUDService = new HUD_SERVICE();
-
diff --git a/browser/devtools/webconsole/WebConsolePanel.jsm b/browser/devtools/webconsole/WebConsolePanel.jsm
--- a/browser/devtools/webconsole/WebConsolePanel.jsm
+++ b/browser/devtools/webconsole/WebConsolePanel.jsm
@@ -4,85 +4,66 @@
 
 "use strict";
 
 this.EXPORTED_SYMBOLS = [ "WebConsolePanel" ];
 
 const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/commonjs/promise/core.js");
-Cu.import("resource:///modules/devtools/EventEmitter.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "HUDService",
-                                  "resource:///modules/HUDService.jsm");
+    "resource:///modules/HUDService.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "EventEmitter",
+    "resource:///modules/devtools/EventEmitter.jsm");
 
 /**
  * A DevToolPanel that controls the Web Console.
  */
 function WebConsolePanel(iframeWindow, toolbox) {
   this._frameWindow = iframeWindow;
   this._toolbox = toolbox;
   EventEmitter.decorate(this);
 }
 
 WebConsolePanel.prototype = {
+  hud: null,
+
   /**
-   * open is effectively an asynchronous constructor
+   * Open is effectively an asynchronous constructor.
+   *
+   * @return object
+   *         A Promise that is resolved when the Web Console completes opening.
    */
-  open: function StyleEditor_open() {
-    let parentDoc = this._frameWindow.document.defaultView.parent.document;
+  open: function WCP_open()
+  {
+    let parentDoc = this._toolbox.doc;
     let iframe = parentDoc.getElementById("toolbox-panel-iframe-webconsole");
-    this.hud = HUDService.activateHUDForContext(this.target.tab, iframe,
-                                                this._toolbox.target);
+    let promise = HUDService.openWebConsole(this.target, iframe);
 
-    let deferred = Promise.defer();
-
-    let hudId = this.hud.hudId;
-    let onOpen = function _onWebConsoleOpen(aSubject) {
-      aSubject.QueryInterface(Ci.nsISupportsString);
-      if (hudId == aSubject.data) {
-        Services.obs.removeObserver(onOpen, "web-console-created");
-
-        this._isReady = true;
-        this.emit("ready");
-        deferred.resolve(this);
-      }
-    }.bind(this);
-
-    Services.obs.addObserver(onOpen, "web-console-created", false);
-
-    return deferred.promise;
+    return promise.then(function(aWebConsole, b) {
+      this.hud = aWebConsole;
+      this._isReady = true;
+      this.emit("ready");
+      return this;
+    }.bind(this));
   },
 
   get target() this._toolbox.target,
 
   _isReady: false,
   get isReady() this._isReady,
 
   destroy: function WCP_destroy()
   {
-    if (this.destroyer) {
-      return this.destroyer.promise;
+    if (this._destroyer) {
+      return this._destroyer;
     }
 
-    this.destroyer = Promise.defer();
+    this._destroyer = this.hud.destroy();
+    this._destroyer.then(function() {
+      this.emit("destroyed");
+    }.bind(this));
 
-    let hudId = this.hud.hudId;
-
-    let onClose = function _onWebConsoleClose(aSubject)
-    {
-      aSubject.QueryInterface(Ci.nsISupportsString);
-      if (hudId == aSubject.data) {
-        Services.obs.removeObserver(onClose, "web-console-destroyed");
-
-        this.emit("destroyed");
-        this.destroyer.resolve(null);
-      }
-    }.bind(this);
-
-    Services.obs.addObserver(onClose, "web-console-destroyed", false);
-    HUDService.deactivateHUDForContext(this.hud.tab, false);
-
-    return this.destroyer.promise;
+    return this._destroyer;
   },
 };
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_580001_closing_after_completion.js b/browser/devtools/webconsole/test/browser_webconsole_bug_580001_closing_after_completion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_580001_closing_after_completion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_580001_closing_after_completion.js
@@ -23,19 +23,18 @@ function testClosingAfterCompletion(hud)
   function errorListener(evt) {
     errorWhileClosing = true;
   }
 
   browser.addEventListener("error", errorListener, false);
 
   // Focus the inputNode and perform the keycombo to close the WebConsole.
   inputNode.focus();
-  EventUtils.synthesizeKey("k", { accelKey: true, shiftKey: true });
 
-  // We can't test for errors right away, because the error occurs after a
-  // setTimeout(..., 0) in the WebConsole code.
-  executeSoon(function() {
+  gDevTools.once("toolbox-destroyed", function() {
     browser.removeEventListener("error", errorListener, false);
     is(errorWhileClosing, false, "no error while closing the WebConsole");
     finishTest();
   });
+
+  EventUtils.synthesizeKey("k", { accelKey: true, shiftKey: true });
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js b/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
@@ -52,23 +52,24 @@ function addTabs(aWindow) {
 
 function openConsoles() {
   // open the Web Console for each of the four tabs and log a message.
   let consolesOpen = 0;
   for (let i = 0; i < openTabs.length; i++) {
     let tab = openTabs[i];
     openConsole(tab, function(index, hud) {
       ok(hud, "HUD is open for tab " + index);
-      let window = hud.tab.linkedBrowser.contentWindow;
+      let window = hud.target.tab.linkedBrowser.contentWindow;
       window.console.log("message for tab " + index);
       consolesOpen++;
     }.bind(null, i));
   }
 
   waitForSuccess({
+    timeout: 10000,
     name: "4 web consoles opened",
     validatorFn: function()
     {
       return consolesOpen == 4;
     },
     successFn: closeConsoles,
     failureFn: closeConsoles,
   });
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_782653_CSS_links_in_Style_Editor.js b/browser/devtools/webconsole/test/browser_webconsole_bug_782653_CSS_links_in_Style_Editor.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_782653_CSS_links_in_Style_Editor.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_782653_CSS_links_in_Style_Editor.js
@@ -62,16 +62,17 @@ function onStyleEditorReady(aEvent, aPan
   {
     let href = aNode.getAttribute("title");
     let sheet, i = 0;
     while((sheet = content.document.styleSheets[i++])) {
       if (sheet.href == href) {
         return sheet;
       }
     }
+    return null;
   }
 
   waitForFocus(function() {
     info("style editor window focused");
 
     let sheet = sheetForNode(nodes[0]);
     ok(sheet, "sheet found");
     let line = nodes[0].sourceLine;
diff --git a/browser/devtools/webconsole/test/head.js b/browser/devtools/webconsole/test/head.js
--- a/browser/devtools/webconsole/test/head.js
+++ b/browser/devtools/webconsole/test/head.js
@@ -233,19 +233,21 @@ function finishTest()
 {
   browser = hudId = hud = filterBox = outputNode = cs = null;
 
   let hud = HUDService.getHudByWindow(content);
   if (!hud) {
     finish();
     return;
   }
-  hud.jsterm.clearOutput(true);
+  if (hud.jsterm) {
+    hud.jsterm.clearOutput(true);
+  }
 
-  closeConsole(hud.tab, finish);
+  closeConsole(hud.target.tab, finish);
 
   hud = null;
 }
 
 function tearDown()
 {
   let target = TargetFactory.forTab(gBrowser.selectedTab);
   gDevTools.closeToolbox(target);
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -38,16 +38,19 @@ XPCOMUtils.defineLazyModuleGetter(this, 
                                   "resource:///modules/NetworkPanel.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "AutocompletePopup",
                                   "resource:///modules/AutocompletePopup.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "Promise",
+                                  "resource://gre/modules/commonjs/promise/core.js");
+
 const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
 let l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 
 
 // The XUL namespace.
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 const MIXED_CONTENT_LEARN_MORE = "https://developer.mozilla.org/en/Security/MixedContent";
@@ -163,19 +166,19 @@ const THROTTLE_UPDATES = 1000; // millis
 const FILTER_PREFS_PREFIX = "devtools.webconsole.filter.";
 
 // The minimum font size.
 const MIN_FONT_SIZE = 10;
 
 const PREF_CONNECTION_TIMEOUT = "devtools.debugger.remote-timeout";
 
 /**
- * A WebConsoleFrame instance is an interactive console initialized *per tab*
+ * A WebConsoleFrame instance is an interactive console initialized *per target*
  * that displays console log data as well as provides an interactive terminal to
- * manipulate the current tab's document content.
+ * manipulate the target's document content.
  *
  * The WebConsoleFrame is responsible for the actual Web Console UI
  * implementation.
  *
  * @param object aWebConsoleOwner
  *        The WebConsole owner object.
  */
 function WebConsoleFrame(aWebConsoleOwner)
@@ -185,28 +188,19 @@ function WebConsoleFrame(aWebConsoleOwne
 
   this._cssNodes = {};
   this._outputQueue = [];
   this._pruneCategoriesQueue = {};
   this._networkRequests = {};
 
   this._toggleFilter = this._toggleFilter.bind(this);
   this._flushMessageQueue = this._flushMessageQueue.bind(this);
-  this._connectionTimeout = this._connectionTimeout.bind(this);
 
   this._outputTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
   this._outputTimerInitialized = false;
-
-  this._initDefaultFilterPrefs();
-  this._commandController = new CommandController(this);
-  this.positionConsole(window);
-
-  this.jsterm = new JSTerm(this);
-  this.jsterm.inputNode.focus();
-  this._initConnection();
 }
 
 WebConsoleFrame.prototype = {
   /**
    * The WebConsole instance that owns this frame.
    * @see HUDService.jsm::WebConsole
    * @type object
    */
@@ -218,23 +212,16 @@ WebConsoleFrame.prototype = {
    * the remote server, using the remote debugging protocol.
    *
    * @see WebConsoleConnectionProxy
    * @type object
    */
   proxy: null,
 
   /**
-   * Timer used for the connection.
-   * @private
-   * @type object
-   */
-  _connectTimer: null,
-
-  /**
    * Getter for the xul:popupset that holds any popups we open.
    * @type nsIDOMElement
    */
   get popupset() this.owner.mainPopupSet,
 
   /**
    * Holds the network requests currently displayed by the Web Console. Each key
    * represents the connection ID and the value is network request information.
@@ -301,17 +288,17 @@ WebConsoleFrame.prototype = {
   filterPrefs: null,
 
   /**
    * The nesting depth of the currently active console group.
    */
   groupDepth: 0,
 
   /**
-   * The current tab location.
+   * The current target location.
    * @type string
    */
   contentLocation: "",
 
   /**
    * The JSTerm object that manage the console's input.
    * @see JSTerm
    * @type object
@@ -331,16 +318,18 @@ WebConsoleFrame.prototype = {
   filterBox: null,
 
   /**
    * Getter for the debugger WebConsoleClient.
    * @type object
    */
   get webConsoleClient() this.proxy ? this.proxy.webConsoleClient : null,
 
+  _destroyer: null,
+
   _saveRequestAndResponseBodies: false,
 
   /**
    * Tells whether to save the bodies of network requests and responses.
    * Disabled by default to save memory.
    * @type boolean
    */
   get saveRequestAndResponseBodies() this._saveRequestAndResponseBodies,
@@ -360,77 +349,82 @@ WebConsoleFrame.prototype = {
     this.webConsoleClient.setPreferences(preferences, function(aResponse) {
       if (!aResponse.error) {
         this._saveRequestAndResponseBodies = newValue;
       }
     }.bind(this));
   },
 
   /**
+   * Initialize the WebConsoleFrame instance.
+   * @return object
+   *         A Promise object for the initialization.
+   */
+  init: function WCF_init()
+  {
+    this._initUI();
+    return this._initConnection();
+  },
+
+  /**
    * Connect to the server using the remote debugging protocol.
+   *
    * @private
+   * @return object
+   *         A Promise object that is resolved/reject based on the connection
+   *         result.
    */
   _initConnection: function WCF__initConnection()
   {
+    let deferred = Promise.defer();
+
     this.proxy = new WebConsoleConnectionProxy(this, this.owner.target);
 
-    let timeout = Services.prefs.getIntPref(PREF_CONNECTION_TIMEOUT);
-    this._connectTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
-    this._connectTimer.initWithCallback(this._connectionTimeout,
-                                        timeout, Ci.nsITimer.TYPE_ONE_SHOT);
-
-    this.proxy.connect(function() {
-      // Don't complete connection if the connection timed-out.
-      if (this._connectTimer) {
-        this._connectTimer.cancel();
-        this._connectTimer = null;
-        this.saveRequestAndResponseBodies = this._saveRequestAndResponseBodies;
-        this._onInitComplete();
-      }
-    }.bind(this));
-  },
-
-  /**
-   * Connection timeout handler. This method simply prints a message informing
-   * the user that the connection timed-out.
-   * @private
-   */
-  _connectionTimeout: function WCF__connectionTimeout()
-  {
-    this._connectTimer = null;
-
-    let node = this.createMessageNode(CATEGORY_JS, SEVERITY_ERROR,
-                                      l10n.getStr("connectionTimeout"));
-    this.outputMessage(CATEGORY_JS, node);
-
-    // Allow initialization to complete.
-    this._onInitComplete();
-  },
-
-  /**
-   * Reset the connection timeout timer.
-   * @private
-   */
-  _resetConnectionTimeout: function WCF__resetConnectionTimeout()
-  {
-    let timer = this._connectTimer;
-    if (timer) {
-      let timeout = timer.delay;
-      timer.cancel();
-      timer.initWithCallback(this._connectionTimeout, timeout,
-                             Ci.nsITimer.TYPE_ONE_SHOT);
-    }
+    let onSuccess = function() {
+      this.saveRequestAndResponseBodies = this._saveRequestAndResponseBodies;
+      sendNotification();
+      deferred.resolve(this);
+    }.bind(this);
+
+    let onFailure = function(aReason) {
+      let node = this.createMessageNode(CATEGORY_JS, SEVERITY_ERROR,
+                                        aReason.error + ": " + aReason.message);
+      this.outputMessage(CATEGORY_JS, node);
+      sendNotification();
+      deferred.reject(aReason);
+    }.bind(this);
+
+    let sendNotification = function() {
+      let id = WebConsoleUtils.supportsString(this.hudId);
+      Services.obs.notifyObservers(id, "web-console-created", null);
+    }.bind(this);
+
+    this.proxy.connect().then(onSuccess, onFailure);
+
+    return deferred.promise;
   },
 
   /**
    * Find the Web Console UI elements and setup event listeners as needed.
    * @private
    */
   _initUI: function WCF__initUI()
   {
+    // Remember that this script is loaded in the webconsole.xul context:
+    // |window| is the iframe global.
+    this.window = window;
+    this.document = this.window.document;
+    this.rootElement = this.document.documentElement;
+
+    this._initDefaultFilterPrefs();
+
+    // Register the controller to handle "select all" properly.
+    this._commandController = new CommandController(this);
+    this.window.controllers.insertControllerAt(0, this._commandController);
+
     let doc = this.document;
 
     this.filterBox = doc.querySelector(".hud-filter-box");
     this.outputNode = doc.querySelector(".hud-output-node");
     this.completeNode = doc.querySelector(".jsterm-complete-node");
     this.inputNode = doc.querySelector(".jsterm-input-node");
 
     this._setFilterTextBoxEvents();
@@ -477,16 +471,20 @@ WebConsoleFrame.prototype = {
                                        !this.getFilterState("network");
     }.bind(this));
 
     let clearButton = doc.getElementsByClassName("webconsole-clear-console-button")[0];
     clearButton.addEventListener("command", function WCF__onClearButton() {
       this.owner._onClearButton();
       this.jsterm.clearOutput(true);
     }.bind(this));
+
+    this.jsterm = new JSTerm(this);
+    this.jsterm.init();
+    this.jsterm.inputNode.focus();
   },
 
   /**
    * Initialize the default filter preferences.
    * @private
    */
   _initDefaultFilterPrefs: function WCF__initDefaultFilterPrefs()
   {
@@ -563,64 +561,16 @@ WebConsoleFrame.prototype = {
         someChecked = someChecked || checked;
       }, this);
 
       aButton.setAttribute("checked", someChecked);
     }, this);
   },
 
   /**
-   * Callback method for when the Web Console initialization is complete. For
-   * now this method sends the web-console-created notification using the
-   * nsIObserverService.
-   *
-   * @private
-   */
-  _onInitComplete: function WC__onInitComplete()
-  {
-    let id = WebConsoleUtils.supportsString(this.hudId);
-    Services.obs.notifyObservers(id, "web-console-created", null);
-  },
-
-  /**
-   * Position the console in a different location.
-   *
-   * Note: you do not usually call this method. This is called by the WebConsole
-   * instance that owns this iframe. You need to call this if you write
-   * a different owner or you manually reposition the iframe.
-   *
-   * @param object aNewWindow
-   *        Repositioning causes the iframe to reload - bug 254144. You need to
-   *        provide the new window object so we can reinitialize the UI as
-   *        needed.
-   */
-  positionConsole: function WCF_positionConsole(aNewWindow)
-  {
-    this.window = aNewWindow;
-    this.document = this.window.document;
-    this.rootElement = this.document.documentElement;
-
-    // register the controller to handle "select all" properly
-    this.window.controllers.insertControllerAt(0, this._commandController);
-
-    let oldOutputNode = this.outputNode;
-
-    this._initUI();
-    this.jsterm && this.jsterm._initUI();
-
-    if (oldOutputNode && oldOutputNode.childNodes.length) {
-      let parentNode = this.outputNode.parentNode;
-      parentNode.replaceChild(oldOutputNode, this.outputNode);
-      this.outputNode = oldOutputNode;
-    }
-
-    this.jsterm && this.jsterm.inputNode.focus();
-  },
-
-  /**
    * Increase, decrease or reset the font size.
    *
    * @param string size
    *        The size of the font change. Accepted values are "+" and "-".
    *        An unmatched size assumes a font reset.
    */
   changeFontSize: function WCF_changeFontSize(aSize)
   {
@@ -2701,52 +2651,62 @@ WebConsoleFrame.prototype = {
     if (!item || !item.url) {
       return;
     }
 
     this.owner.openLink(item.url);
   },
 
   /**
-   * Destroy the HUD object. Call this method to avoid memory leaks when the Web
-   * Console is closed.
+   * Destroy the WebConsoleFrame object. Call this method to avoid memory leaks
+   * when the Web Console is closed.
    *
-   * @param function [aOnDestroy]
-   *        Optional function to invoke when the Web Console instance is
-   *        destroyed.
+   * @return object
+   *         A Promise that is resolved when the WebConsoleFrame instance is
+   *         destroyed.
    */
-  destroy: function WCF_destroy(aOnDestroy)
+  destroy: function WCF_destroy()
   {
+    if (this._destroyer) {
+      return this._destroyer.promise;
+    }
+
+    this._destroyer = Promise.defer();
+
     this._cssNodes = {};
     this._outputQueue = [];
     this._pruneCategoriesQueue = {};
     this._networkRequests = {};
 
     if (this._outputTimerInitialized) {
       this._outputTimerInitialized = false;
       this._outputTimer.cancel();
     }
     this._outputTimer = null;
 
-    if (this._connectTimer) {
-      this._connectTimer.cancel();
-    }
-    this._connectTimer = null;
-
-    if (this.proxy) {
-      this.proxy.disconnect(aOnDestroy);
-      this.proxy = null;
-    }
-
     if (this.jsterm) {
       this.jsterm.destroy();
       this.jsterm = null;
     }
 
     this._commandController = null;
+
+    let onDestroy = function() {
+      this._destroyer.resolve(null);
+    }.bind(this);
+
+    if (this.proxy) {
+      this.proxy.disconnect().then(onDestroy);
+      this.proxy = null;
+    }
+    else {
+      onDestroy();
+    }
+
+    return this._destroyer.promise;
   },
 };
 
 /**
  * Create a JSTerminal (a JavaScript command line). This is attached to an
  * existing HeadsUpDisplay (a Web Console instance). This code is responsible
  * with handling command line input, code evaluation and result output.
  *
@@ -2758,22 +2718,18 @@ function JSTerm(aWebConsoleFrame)
 {
   this.hud = aWebConsoleFrame;
   this.hudId = this.hud.hudId;
 
   this.lastCompletion = { value: null };
   this.history = [];
   this.historyIndex = 0;
   this.historyPlaceHolder = 0;  // this.history.length;
-  this.autocompletePopup = new AutocompletePopup(this.hud.owner.chromeDocument);
-  this.autocompletePopup.onSelect = this.onAutocompleteSelect.bind(this);
-  this.autocompletePopup.onClick = this.acceptProposedCompletion.bind(this);
   this._keyPress = this.keyPress.bind(this);
   this._inputEventHandler = this.inputEventHandler.bind(this);
-  this._initUI();
 }
 
 JSTerm.prototype = {
   /**
    * Stores the data for the last completion.
    * @type object
    */
   lastCompletion: null,
@@ -2785,16 +2741,20 @@ JSTerm.prototype = {
   lastInputValue: "",
 
   /**
    * History of code that was executed.
    * @type array
    */
   history: null,
 
+  autocompletePopup: null,
+  inputNode: null,
+  completeNode: null,
+
   /**
    * Getter for the element that holds the messages we display.
    * @type nsIDOMElement
    */
   get outputNode() this.hud.outputNode,
 
   /**
    * Getter for the debugger WebConsoleClient.
@@ -2803,20 +2763,24 @@ JSTerm.prototype = {
   get webConsoleClient() this.hud.webConsoleClient,
 
   COMPLETE_FORWARD: 0,
   COMPLETE_BACKWARD: 1,
   COMPLETE_HINT_ONLY: 2,
 
   /**
    * Initialize the JSTerminal UI.
-   * @private
    */
-  _initUI: function JST__initUI()
+  init: function JST_init()
   {
+    let chromeDocument = this.hud.owner.chromeDocument;
+    this.autocompletePopup = new AutocompletePopup(chromeDocument);
+    this.autocompletePopup.onSelect = this.onAutocompleteSelect.bind(this);
+    this.autocompletePopup.onClick = this.acceptProposedCompletion.bind(this);
+
     let doc = this.hud.document;
     this.completeNode = doc.querySelector(".jsterm-complete-node");
     this.inputNode = doc.querySelector(".jsterm-input-node");
     this.inputNode.addEventListener("keypress", this._keyPress, false);
     this.inputNode.addEventListener("input", this._inputEventHandler, false);
     this.inputNode.addEventListener("keyup", this._inputEventHandler, false);
 
     this.lastInputValue && this.setInputValue(this.lastInputValue);
@@ -3814,16 +3778,22 @@ JSTerm.prototype = {
   destroy: function JST_destroy()
   {
     this.clearCompletion();
     this.clearOutput();
 
     this.autocompletePopup.destroy();
     this.autocompletePopup = null;
 
+    let popup = this.hud.owner.chromeDocument
+                .getElementById("webConsole_autocompletePopup");
+    if (popup) {
+      popup.parentNode.removeChild(popup);
+    }
+
     this.inputNode.removeEventListener("keypress", this._keyPress, false);
     this.inputNode.removeEventListener("input", this._inputEventHandler, false);
     this.inputNode.removeEventListener("keyup", this._inputEventHandler, false);
 
     this.hud = null;
   },
 };
 
@@ -4042,16 +4012,21 @@ function WebConsoleConnectionProxy(aWebC
   this.target = aTarget;
 
   this._onPageError = this._onPageError.bind(this);
   this._onConsoleAPICall = this._onConsoleAPICall.bind(this);
   this._onNetworkEvent = this._onNetworkEvent.bind(this);
   this._onNetworkEventUpdate = this._onNetworkEventUpdate.bind(this);
   this._onFileActivity = this._onFileActivity.bind(this);
   this._onTabNavigated = this._onTabNavigated.bind(this);
+  this._onListTabs = this._onListTabs.bind(this);
+  this._onAttachTab = this._onAttachTab.bind(this);
+  this._onAttachConsole = this._onAttachConsole.bind(this);
+  this._onCachedMessages = this._onCachedMessages.bind(this);
+  this._connectionTimeout = this._connectionTimeout.bind(this);
 }
 
 WebConsoleConnectionProxy.prototype = {
   /**
    * The owning Web Console instance.
    *
    * @see WebConsoleFrame
    * @type object
@@ -4088,16 +4063,26 @@ WebConsoleConnectionProxy.prototype = {
 
   /**
    * Tells if the connection is established.
    * @type boolean
    */
   connected: false,
 
   /**
+   * Timer used for the connection.
+   * @private
+   * @type object
+   */
+  _connectTimer: null,
+
+  _connectDefer: null,
+  _disconnecter: null,
+
+  /**
    * The WebConsoleActor ID.
    *
    * @private
    * @type string
    */
   _consoleActor: null,
 
   /**
@@ -4125,189 +4110,218 @@ WebConsoleConnectionProxy.prototype = {
       DebuggerServer.init();
       DebuggerServer.addBrowserActors();
     }
   },
 
   /**
    * Initialize a debugger client and connect it to the debugger server.
    *
-   * @param function [aCallback]
-   *        Optional function to invoke when connection is established.
+   * @return object
+   *         A Promise object that is resolved/rejected based on the success of
+   *         the connection initialization.
    */
-  connect: function WCCP_connect(aCallback)
+  connect: function WCCP_connect()
   {
+    if (this._connectDefer) {
+      return this._connectDefer.promise;
+    }
+
+    this._connectDefer = Promise.defer();
+
+    let timeout = Services.prefs.getIntPref(PREF_CONNECTION_TIMEOUT);
+    this._connectTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+    this._connectTimer.initWithCallback(this._connectionTimeout,
+                                        timeout, Ci.nsITimer.TYPE_ONE_SHOT);
+
+    let promise = this._connectDefer.promise;
+    promise.then(function _onSucess() {
+      this._connectTimer.cancel();
+      this._connectTimer = null;
+    }.bind(this), function _onFailure() {
+      this._connectTimer = null;
+    }.bind(this));
+
     // TODO: convert the non-remote path to use the target API as well.
     let transport, client;
     if (this.target.isRemote) {
       client = this.client = this.target.client;
     }
     else {
       this.initServer();
       transport = DebuggerServer.connectPipe();
-
       client = this.client = new DebuggerClient(transport);
     }
 
     client.addListener("pageError", this._onPageError);
     client.addListener("consoleAPICall", this._onConsoleAPICall);
     client.addListener("networkEvent", this._onNetworkEvent);
     client.addListener("networkEventUpdate", this._onNetworkEventUpdate);
     client.addListener("fileActivity", this._onFileActivity);
     client.addListener("tabNavigated", this._onTabNavigated);
 
     if (this.target.isRemote) {
       if (!this.target.chrome) {
         // target.form is a TabActor grip
-        this._attachTab(this.target.form, aCallback);
+        this._attachTab(this.target.form);
       }
       else {
         // target.form is a RootActor grip
         this._consoleActor = this.target.form.consoleActor;
-        this._attachConsole(aCallback);
+        this._attachConsole();
       }
     }
     else {
       client.connect(function(aType, aTraits) {
-        client.listTabs(this._onListTabs.bind(this, aCallback));
+        client.listTabs(this._onListTabs);
       }.bind(this));
     }
+
+    return this._connectDefer.promise;
+  },
+
+  /**
+   * Connection timeout handler.
+   * @private
+   */
+  _connectionTimeout: function WCCP__connectionTimeout()
+  {
+    let error = {
+      error: "timeout",
+      message: l10n.getStr("connectionTimeout"),
+    };
+
+    this._connectDefer.reject(error);
   },
 
   /**
    * The "listTabs" response handler.
    *
    * @private
-   * @param function [aCallback]
-   *        Optional function to invoke once the connection is established.
    * @param object aResponse
    *        The JSON response object received from the server.
    */
-  _onListTabs: function WCCP__onListTabs(aCallback, aResponse)
+  _onListTabs: function WCCP__onListTabs(aResponse)
   {
     if (aResponse.error) {
       Cu.reportError("listTabs failed: " + aResponse.error + " " +
                      aResponse.message);
+      this._connectDefer.reject(aResponse);
       return;
     }
 
-    this._attachTab(aResponse.tabs[aResponse.selected], aCallback);
+    this._attachTab(aResponse.tabs[aResponse.selected]);
   },
 
   /**
    * Attach to the tab actor.
    *
    * @private
    * @param object aTab
    *        Grip for the tab to attach to.
-   * @param function aCallback
-   *        Function to invoke when the connection is established.
    */
-  _attachTab: function WCCP__attachTab(aTab, aCallback)
+  _attachTab: function WCCP__attachTab(aTab)
   {
     this._consoleActor = aTab.consoleActor;
     this._tabActor = aTab.actor;
     this.owner.onLocationChange(aTab.url, aTab.title);
-    this.client.attachTab(this._tabActor,
-                          this._onAttachTab.bind(this, aCallback));
+    this.client.attachTab(this._tabActor, this._onAttachTab);
   },
 
   /**
    * The "attachTab" response handler.
    *
    * @private
-   * @param function [aCallback]
-   *        Optional function to invoke once the connection is established.
    * @param object aResponse
    *        The JSON response object received from the server.
    * @param object aTabClient
    *        The TabClient instance for the attached tab.
    */
-  _onAttachTab: function WCCP__onAttachTab(aCallback, aResponse, aTabClient)
+  _onAttachTab: function WCCP__onAttachTab(aResponse, aTabClient)
   {
     if (aResponse.error) {
       Cu.reportError("attachTab failed: " + aResponse.error + " " +
                      aResponse.message);
+      this._connectDefer.reject(aResponse);
       return;
     }
 
     this.tabClient = aTabClient;
-    this._attachConsole(aCallback);
+    this._attachConsole();
   },
 
   /**
    * Attach to the Web Console actor.
-   *
    * @private
-   * @param function aCallback
-   *        Function to invoke when the connection is established.
    */
-  _attachConsole: function WCCP__attachConsole(aCallback)
+  _attachConsole: function WCCP__attachConsole()
   {
     let listeners = ["PageError", "ConsoleAPI", "NetworkActivity",
                      "FileActivity"];
     this.client.attachConsole(this._consoleActor, listeners,
-                              this._onAttachConsole.bind(this, aCallback));
+                              this._onAttachConsole);
   },
 
   /**
    * The "attachConsole" response handler.
    *
    * @private
-   * @param function [aCallback]
-   *        Optional function to invoke once the connection is established.
    * @param object aResponse
    *        The JSON response object received from the server.
    * @param object aWebConsoleClient
    *        The WebConsoleClient instance for the attached console, for the
    *        specific tab we work with.
    */
-  _onAttachConsole:
-  function WCCP__onAttachConsole(aCallback, aResponse, aWebConsoleClient)
+  _onAttachConsole: function WCCP__onAttachConsole(aResponse, aWebConsoleClient)
   {
     if (aResponse.error) {
       Cu.reportError("attachConsole failed: " + aResponse.error + " " +
                      aResponse.message);
+      this._connectDefer.reject(aResponse);
       return;
     }
 
     this.webConsoleClient = aWebConsoleClient;
 
     this._hasNativeConsoleAPI = aResponse.nativeConsoleAPI;
 
     let msgs = ["PageError", "ConsoleAPI"];
-    this.webConsoleClient.getCachedMessages(msgs,
-      this._onCachedMessages.bind(this, aCallback));
+    this.webConsoleClient.getCachedMessages(msgs, this._onCachedMessages);
   },
 
   /**
    * The "cachedMessages" response handler.
    *
    * @private
-   * @param function [aCallback]
-   *        Optional function to invoke once the connection is established.
    * @param object aResponse
    *        The JSON response object received from the server.
    */
-  _onCachedMessages: function WCCP__onCachedMessages(aCallback, aResponse)
+  _onCachedMessages: function WCCP__onCachedMessages(aResponse)
   {
     if (aResponse.error) {
       Cu.reportError("Web Console getCachedMessages error: " + aResponse.error +
                      " " + aResponse.message);
+      this._connectDefer.reject(aResponse);
       return;
     }
 
+    if (!this._connectTimer) {
+      // This happens if the Promise is rejected (eg. a timeout), but the
+      // connection attempt is successful, nonetheless.
+      Cu.reportError("Web Console getCachedMessages error: invalid state.");
+    }
+
     this.owner.displayCachedMessages(aResponse.messages);
 
     if (!this._hasNativeConsoleAPI) {
       this.owner.logWarningAboutReplacedAPI();
     }
 
     this.connected = true;
-    aCallback && aCallback();
+    this._connectDefer.resolve(this);
   },
 
   /**
    * The "pageError" message type handler. We redirect any page errors to the UI
    * for displaying.
    *
    * @private
    * @param string aType
@@ -4427,40 +4441,43 @@ WebConsoleConnectionProxy.prototype = {
     if (this.client) {
       this.client.release(aActor);
     }
   },
 
   /**
    * Disconnect the Web Console from the remote server.
    *
-   * @param function [aOnDisconnect]
-   *        Optional function to invoke when the connection is dropped.
+   * @return object
+   *         A Promise object that is resolved when disconnect completes.
    */
-  disconnect: function WCCP_disconnect(aOnDisconnect)
+  disconnect: function WCCP_disconnect()
   {
+    if (this._disconnecter) {
+      return this._disconnecter.promise;
+    }
+
+    this._disconnecter = Promise.defer();
+
     if (!this.client) {
-      aOnDisconnect && aOnDisconnect();
-      return;
+      this._disconnecter.resolve(null);
+      return this._disconnecter.promise;
     }
 
     let onDisconnect = function() {
       if (timer) {
         timer.cancel();
         timer = null;
+        this._disconnecter.resolve(null);
       }
-      if (aOnDisconnect) {
-        aOnDisconnect();
-        aOnDisconnect = null;
-      }
-    };
+    }.bind(this);
 
     let timer = null;
     let remoteTarget = this.target.isRemote;
-    if (aOnDisconnect && !remoteTarget) {
+    if (!remoteTarget) {
       timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
       timer.initWithCallback(onDisconnect, 1500, Ci.nsITimer.TYPE_ONE_SHOT);
     }
 
     this.client.removeListener("pageError", this._onPageError);
     this.client.removeListener("consoleAPICall", this._onConsoleAPICall);
     this.client.removeListener("networkEvent", this._onNetworkEvent);
     this.client.removeListener("networkEventUpdate", this._onNetworkEventUpdate);
@@ -4471,30 +4488,31 @@ WebConsoleConnectionProxy.prototype = {
 
     this.client = null;
     this.webConsoleClient = null;
     this.tabClient = null;
     this.target = null;
     this.connected = false;
     this.owner = null;
 
-    try {
-      if (!remoteTarget) {
+    if (!remoteTarget) {
+      try {
         client.close(onDisconnect);
       }
+      catch (ex) {
+        Cu.reportError("Web Console disconnect exception: " + ex);
+        Cu.reportError(ex.stack);
+        onDisconnect();
+      }
     }
-    catch (ex) {
-      Cu.reportError("Web Console disconnect exception: " + ex);
-      Cu.reportError(ex.stack);
+    else {
       onDisconnect();
     }
 
-    if (remoteTarget) {
-      onDisconnect();
-    }
+    return this._disconnecter.promise;
   },
 };
 
 function gSequenceId()
 {
   return gSequenceId.n++;
 }
 gSequenceId.n = 0;
diff --git a/toolkit/devtools/webconsole/dbg-webconsole-actors.js b/toolkit/devtools/webconsole/dbg-webconsole-actors.js
--- a/toolkit/devtools/webconsole/dbg-webconsole-actors.js
+++ b/toolkit/devtools/webconsole/dbg-webconsole-actors.js
@@ -178,17 +178,17 @@ WebConsoleActor.prototype =
     if (this.networkMonitor) {
       this.networkMonitor.destroy();
       this.networkMonitor = null;
     }
     if (this.consoleProgressListener) {
       this.consoleProgressListener.destroy();
       this.consoleProgressListener = null;
     }
-    this.conn.removeActorPool(this.actorPool);
+    this.conn.removeActorPool(this._actorPool);
     this._actorPool = null;
     this.sandbox = null;
     this._sandboxWindowId = 0;
     this.conn = this._window = null;
   },
 
   /**
    * Create a grip for the given value. If the value is an object,
