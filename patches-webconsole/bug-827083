# HG changeset patch
# Parent ba8d801db3b283c47139cfaa89ca2fd2ae4b2e82
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1357595665 -7200

Bug 827083 - Cannot attach remote web console to Firefox Android

diff --git a/browser/devtools/framework/Toolbox.jsm b/browser/devtools/framework/Toolbox.jsm
--- a/browser/devtools/framework/Toolbox.jsm
+++ b/browser/devtools/framework/Toolbox.jsm
@@ -472,16 +472,18 @@ Toolbox.prototype = {
    *
    * @return {Host} host
    *        The created host object
    */
   _createHost: function TBOX_createHost(hostType) {
     if (!Hosts[hostType]) {
       throw new Error('Unknown hostType: '+ hostType);
     }
+    // Warning: not all Targets have a tab property - make sure you correctly
+    // mix and match hosts and targets.
     let newHost = new Hosts[hostType](this.target.tab);
 
     // clean up the toolbox if its window is closed
     newHost.on("window-closed", this.destroy);
 
     return newHost;
   },
 
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -8,219 +8,79 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 const CONSOLEAPI_CLASS_ID = "{b49c18f8-3379-4fc0-8c90-d7772c1a9ff3}";
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource:///modules/devtools/gDevTools.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "gDevTools",
+    "resource:///modules/devtools/gDevTools.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "TargetFactory",
-                                  "resource:///modules/devtools/Target.jsm");
+    "resource:///modules/devtools/Target.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Services",
-                                  "resource://gre/modules/Services.jsm");
+    "resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
-                                  "resource://gre/modules/devtools/WebConsoleUtils.jsm");
+    "resource://gre/modules/devtools/WebConsoleUtils.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "Promise",
+    "resource://gre/modules/commonjs/promise/core.js");
 
 const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
 let l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 
 this.EXPORTED_SYMBOLS = ["HUDService"];
 
-function LogFactory(aMessagePrefix)
-{
-  function log(aMessage) {
-    var _msg = aMessagePrefix + " " + aMessage + "\n";
-    dump(_msg);
-  }
-  return log;
-}
-
-let log = LogFactory("*** HUDService:");
-
-// The HTML namespace.
-const HTML_NS = "http://www.w3.org/1999/xhtml";
-
-// The XUL namespace.
-const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-
 ///////////////////////////////////////////////////////////////////////////
 //// The HUD service
 
-function HUD_SERVICE()
-{
-  // These methods access the "this" object, but they're registered as
-  // event listeners. So we hammer in the "this" binding.
-  this.onWindowUnload = this.onWindowUnload.bind(this);
-
-  /**
-   * Keeps a reference for each HeadsUpDisplay that is created
-   */
-  this.hudReferences = {};
-};
+function HUD_SERVICE() { }
 
 HUD_SERVICE.prototype =
 {
   /**
    * getter for UI commands to be used by the frontend
    *
    * @returns object
    */
   get consoleUI() {
     return HeadsUpDisplayUICommands;
   },
 
   /**
-   * The sequencer is a generator (after initialization) that returns unique
-   * integers
-   */
-  sequencer: null,
-
-  /**
    * Firefox-specific current tab getter
    *
    * @returns nsIDOMWindow
    */
   currentContext: function HS_currentContext() {
     return Services.wm.getMostRecentWindow("navigator:browser");
   },
 
   /**
-   * Activate a HeadsUpDisplay for the given tab context.
+   * Open a Web Console for the given target.
    *
-   * @param nsIDOMElement aTab
-   *        The xul:tab element.
+   * @see devtools/framework/Target.jsm for details about targets.
+   * @see WebConsole constructor for |aOptions|.
+   *
+   * @param object aTarget
+   *        The target that the web console will connect to.
    * @param nsIDOMElement aIframe
    *        The iframe element into which to place the web console.
-   * @param RemoteTarget aTarget
-   *        The target that the web console will connect to.
    * @return object
-   *         The new HeadsUpDisplay instance.
+   *         The new WebConsole instance.
    */
-  activateHUDForContext: function HS_activateHUDForContext(aTab, aIframe,
-                                                           aTarget)
+  openWebConsole: function HS_openWebConsole(aTarget, aIframe)
   {
-    let hudId = "hud_" + aTab.linkedPanel;
-    if (hudId in this.hudReferences) {
-      return this.hudReferences[hudId];
-    }
-
-    this.wakeup();
-
-    let window = aTab.ownerDocument.defaultView;
-    let gBrowser = window.gBrowser;
-
-    window.addEventListener("unload", this.onWindowUnload, false);
-
-    let hud = new WebConsole(aTab, aIframe, aTarget);
-    this.hudReferences[hudId] = hud;
-
-    return hud;
-  },
-
-  /**
-   * Deactivate a HeadsUpDisplay for the given tab context.
-   *
-   * @param nsIDOMElement aTab
-   *        The xul:tab element you want to enable the Web Console for.
-   * @return void
-   */
-  deactivateHUDForContext: function HS_deactivateHUDForContext(aTab)
-  {
-    let hudId = "hud_" + aTab.linkedPanel;
-    if (!(hudId in this.hudReferences)) {
-      return;
-    }
-
-    let hud = this.getHudReferenceById(hudId);
-    let document = hud.chromeDocument;
-
-    hud.destroy(function() {
-      let id = WebConsoleUtils.supportsString(hudId);
-      Services.obs.notifyObservers(id, "web-console-destroyed", null);
-    });
-
-    delete this.hudReferences[hudId];
-
-    if (Object.keys(this.hudReferences).length == 0) {
-      let autocompletePopup = document.
-                              getElementById("webConsole_autocompletePopup");
-      if (autocompletePopup) {
-        autocompletePopup.parentNode.removeChild(autocompletePopup);
-      }
-
-      let window = document.defaultView;
-
-      window.removeEventListener("unload", this.onWindowUnload, false);
-
-      let gBrowser = window.gBrowser;
-      let tabContainer = gBrowser.tabContainer;
-
-      this.suspend();
-    }
-
-    let contentWindow = aTab.linkedBrowser.contentWindow;
-    contentWindow.focus();
-  },
-
-  /**
-   * get a unique ID from the sequence generator
-   *
-   * @returns integer
-   */
-  sequenceId: function HS_sequencerId()
-  {
-    if (!this.sequencer) {
-      this.sequencer = this.createSequencer(-1);
-    }
-    return this.sequencer.next();
-  },
-
-  /**
-   * "Wake up" the Web Console activity. This is called when the first Web
-   * Console is open. This method initializes the various observers we have.
-   *
-   * @returns void
-   */
-  wakeup: function HS_wakeup()
-  {
-    if (Object.keys(this.hudReferences).length > 0) {
-      return;
-    }
-
-    WebConsoleObserver.init();
-  },
-
-  /**
-   * Suspend Web Console activity. This is called when all Web Consoles are
-   * closed.
-   *
-   * @returns void
-   */
-  suspend: function HS_suspend()
-  {
-    delete this.lastFinishedRequestCallback;
-
-    WebConsoleObserver.uninit();
-  },
-
-  /**
-   * Shutdown all HeadsUpDisplays on quit-application-granted.
-   *
-   * @returns void
-   */
-  shutdown: function HS_shutdown()
-  {
-    for (let hud of this.hudReferences) {
-      this.deactivateHUDForContext(hud.tab);
-    }
+    let hud = WebConsole(aTarget, aIframe);
+    return hud.init();
   },
 
   /**
    * Returns the HeadsUpDisplay object associated to a content window.
    *
    * @param nsIDOMWindow aContentWindow
    * @returns object
    */
@@ -265,100 +125,42 @@ HUD_SERVICE.prototype =
   /**
    * Assign a function to this property to listen for every request that
    * completes. Used by unit tests. The callback takes one argument: the HTTP
    * activity object as received from the remote Web Console.
    *
    * @type function
    */
   lastFinishedRequestCallback: null,
-
-  /**
-   * Creates a generator that always returns a unique number for use in the
-   * indexes
-   *
-   * @returns Generator
-   */
-  createSequencer: function HS_createSequencer(aInt)
-  {
-    function sequencer(aInt)
-    {
-      while(1) {
-        aInt++;
-        yield aInt;
-      }
-    }
-    return sequencer(aInt);
-  },
-
-  /**
-   * Called whenever a browser window closes. Cleans up any consoles still
-   * around.
-   *
-   * @param nsIDOMEvent aEvent
-   *        The dispatched event.
-   * @returns void
-   */
-  onWindowUnload: function HS_onWindowUnload(aEvent)
-  {
-    let window = aEvent.target.defaultView;
-
-    window.removeEventListener("unload", this.onWindowUnload, false);
-
-    let gBrowser = window.gBrowser;
-    let tabContainer = gBrowser.tabContainer;
-
-    let tab = tabContainer.firstChild;
-    while (tab != null) {
-      this.deactivateHUDForContext(tab);
-      tab = tab.nextSibling;
-    }
-  },
 };
 
 
 /**
- * A WebConsole instance is an interactive console initialized *per tab*
+ * A WebConsole instance is an interactive console initialized *per target*
  * that displays console log data as well as provides an interactive terminal to
- * manipulate the current tab's document content.
+ * manipulate the target's document content.
  *
  * This object only wraps the iframe that holds the Web Console UI.
  *
- * @param nsIDOMElement aTab
- *        The xul:tab for which you want the WebConsole object.
+ * @constructor
+ * @param object aTarget
+ *        The target that the web console will connect to.
  * @param nsIDOMElement aIframe
  *        iframe into which we should create the WebConsole UI.
- * @param RemoteTarget aTarget
- *        The target that the web console will connect to.
  */
-function WebConsole(aTab, aIframe, aTarget)
+function WebConsole(aTarget, aIframe)
 {
-  this.tab = aTab;
-  if (this.tab == null) {
-    throw new Error('Missing tab');
-  }
-
   this.iframe = aIframe;
-  if (this.iframe == null) {
-    console.trace();
-    throw new Error('Missing iframe');
-  }
-
-  this.chromeDocument = this.tab.ownerDocument;
+  this.iframe.className = "web-console-frame";
+  this.chromeDocument = this.iframe.ownerDocument;
   this.chromeWindow = this.chromeDocument.defaultView;
-  this.hudId = "hud_" + this.tab.linkedPanel;
-
+  this.hudId = "hud_" + Date.now();
   this.target = aTarget;
 
   this._onIframeLoad = this._onIframeLoad.bind(this);
-
-  this.iframe.className = "web-console-frame";
-  this.iframe.addEventListener("load", this._onIframeLoad, true);
-
-  this.positionConsole();
 }
 
 WebConsole.prototype = {
   /**
    * The xul:tab for which the current Web Console instance was created.
    * @type nsIDOMElement
    */
   tab: null,
@@ -390,83 +192,66 @@ WebConsole.prototype = {
   get outputNode()
   {
     return this.ui ? this.ui.outputNode : null;
   },
 
   get gViewSourceUtils() this.chromeWindow.gViewSourceUtils,
 
   /**
-   * The "load" event handler for the Web Console iframe.
-   * @private
+   * Initialize the Web Console instance.
+   *
+   * @return object
    */
-  _onIframeLoad: function WC__onIframeLoad()
+  init: function WC_init()
   {
-    this.iframe.removeEventListener("load", this._onIframeLoad, true);
+    let deferred = Promise.defer();
 
-    this.iframeWindow = this.iframe.contentWindow.wrappedJSObject;
-    this.ui = new this.iframeWindow.WebConsoleFrame(this);
+    let onIframeLoad = function() {
+      this.iframe.removeEventListener("load", onIframeLoad, true);
+      initUI();
+    }.bind(this);
+
+    let initUI = function() {
+      this.iframeWindow = this.iframe.contentWindow.wrappedJSObject;
+      this.ui = new this.iframeWindow.WebConsoleFrame(this);
+      this.ui.init().then(onSuccess, onFailure);
+    }.bind(this);
+
+    let onSuccess = function(aResult) {
+      deferred.resolve(aResult);
+    };
+
+    let onFailure = function(aResult) {
+      deferred.reject(aResult);
+    };
+
+    if (this.iframe.contentWindow && this.iframe.contentWindow.document &&
+        this.iframe.contentWindow.document.readyState == "complete") {
+      this.iframe.addEventListener("load", onIframeLoad, true);
+    }
+    else {
+      initUI();
+    }
+
+    return deferred.promise;
   },
 
   /**
    * Retrieve the Web Console panel title.
    *
    * @return string
    *         The Web Console panel title.
    */
   getPanelTitle: function WC_getPanelTitle()
   {
     let url = this.ui ? this.ui.contentLocation : "";
     return l10n.getFormatStr("webConsoleWindowTitleAndURL", [url]);
   },
 
-  consoleWindowUnregisterOnHide: true,
-
-  /**
-   * Position the Web Console UI.
-   */
-  positionConsole: function WC_positionConsole()
-  {
-    let lastIndex = -1;
-
-    if (this.outputNode && this.outputNode.getIndexOfFirstVisibleRow) {
-      lastIndex = this.outputNode.getIndexOfFirstVisibleRow() +
-                  this.outputNode.getNumberOfVisibleRows() - 1;
-    }
-
-    this._beforePositionConsole(lastIndex);
-  },
-
-  /**
-   * Common code that needs to execute before the Web Console is repositioned.
-   * @private
-   * @param number aLastIndex
-   *        The last visible message in the console output before repositioning
-   *        occurred.
-   */
-  _beforePositionConsole:
-  function WC__beforePositionConsole(aLastIndex)
-  {
-    if (!this.ui) {
-      return;
-    }
-
-    let onLoad = function() {
-      this.iframe.removeEventListener("load", onLoad, true);
-      this.iframeWindow = this.iframe.contentWindow.wrappedJSObject;
-      this.ui.positionConsole(this.iframeWindow);
-
-      if (aLastIndex > -1 && aLastIndex < this.outputNode.getRowCount()) {
-        this.outputNode.ensureIndexIsVisible(aLastIndex);
-      }
-    }.bind(this);
-
-    this.iframe.addEventListener("load", onLoad, true);
-  },
-
   /**
    * The JSTerm object that manages the console's input.
    * @see webconsole.js::JSTerm
    * @type object
    */
   get jsterm()
   {
     return this.ui ? this.ui.jsterm : null;
@@ -559,30 +344,34 @@ WebConsole.prototype = {
     // deactivateHUDForContext() again.
     this.consoleWindowUnregisterOnHide = false;
 
     let popupset = this.mainPopupSet;
     let panels = popupset.querySelectorAll("panel[hudId=" + this.hudId + "]");
     for (let panel of panels) {
       panel.hidePopup();
     }
+    // TODO: AutocompletePopup removal
 
     let onDestroy = function WC_onDestroyUI() {
       // Remove the iframe and the consolePanel if the Web Console is inside a
       // floating panel.
       if (this.consolePanel && this.consolePanel.parentNode) {
         this.consolePanel.hidePopup();
         this.consolePanel.parentNode.removeChild(this.consolePanel);
         this.consolePanel = null;
       }
 
       if (this.iframe.parentNode) {
         this.iframe.parentNode.removeChild(this.iframe);
       }
 
+      let id = WebConsoleUtils.supportsString(this.hudId);
+      Services.obs.notifyObservers(id, "web-console-destroyed", null);
+
       aOnDestroy && aOnDestroy();
     }.bind(this);
 
     if (this.ui) {
       this.ui.destroy(onDestroy);
     }
     else {
       onDestroy();
@@ -590,100 +379,45 @@ WebConsole.prototype = {
   },
 };
 
 //////////////////////////////////////////////////////////////////////////
 // HeadsUpDisplayUICommands
 //////////////////////////////////////////////////////////////////////////
 
 var HeadsUpDisplayUICommands = {
-  toggleHUD: function UIC_toggleHUD(aOptions)
+  /**
+   * Toggle the Web Console for the current tab.
+   *
+   * @return object
+   *         A Promise for either the opening of the toolbox that holds the Web
+   *         Console, or a Promise for the closing of the toolbox.
+   */
+  toggleHUD: function UIC_toggleHUD()
   {
-    var window = HUDService.currentContext();
+    let window = HUDService.currentContext();
     let target = TargetFactory.forTab(window.gBrowser.selectedTab);
     let toolbox = gDevTools.getToolbox(target);
 
     return toolbox && toolbox.currentToolId == "webconsole" ?
         toolbox.destroy() :
         gDevTools.showToolbox(target, "webconsole");
   },
 
-  toggleRemoteHUD: function UIC_toggleRemoteHUD()
-  {
-    if (this.getOpenHUD()) {
-      this.toggleHUD();
-      return;
-    }
-
-    let host = Services.prefs.getCharPref("devtools.debugger.remote-host");
-    let port = Services.prefs.getIntPref("devtools.debugger.remote-port");
-
-    let check = { value: false };
-    let input = { value: host + ":" + port };
-
-    let result = Services.prompt.prompt(null,
-      l10n.getStr("remoteWebConsolePromptTitle"),
-      l10n.getStr("remoteWebConsolePromptMessage"),
-      input, null, check);
-
-    if (!result) {
-      return;
-    }
-
-    let parts = input.value.split(":");
-    if (parts.length != 2) {
-      return;
-    }
-
-    [host, port] = parts;
-    if (!host.length || !port.length) {
-      return;
-    }
-
-    Services.prefs.setCharPref("devtools.debugger.remote-host", host);
-    Services.prefs.setIntPref("devtools.debugger.remote-port", port);
-
-    this.toggleHUD({
-      host: host,
-      port: port,
-    });
-  },
-
   /**
-   * Find the hudId for the active chrome window.
-   * @return string|null
-   *         The hudId or null if the active chrome window has no open Web
+   * Find if there is a Web Console open for the current tab and return the
+   * instance.
+   * @return object|null
+   *         The WebConsole object or null if the active tab has no open Web
    *         Console.
    */
-  getOpenHUD: function UIC_getOpenHUD() {
-    let chromeWindow = HUDService.currentContext();
-    let hudId = "hud_" + chromeWindow.gBrowser.selectedTab.linkedPanel;
-    return hudId in HUDService.hudReferences ? hudId : null;
-  },
-};
-
-//////////////////////////////////////////////////////////////////////////
-// WebConsoleObserver
-//////////////////////////////////////////////////////////////////////////
-
-var WebConsoleObserver = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
-
-  init: function WCO_init()
+  getOpenHUD: function UIC_getOpenHUD()
   {
-    Services.obs.addObserver(this, "quit-application-granted", false);
-  },
-
-  observe: function WCO_observe(aSubject, aTopic)
-  {
-    if (aTopic == "quit-application-granted") {
-      HUDService.shutdown();
-    }
-  },
-
-  uninit: function WCO_uninit()
-  {
-    Services.obs.removeObserver(this, "quit-application-granted");
+    // TODO: fix scratchpad and other code that uses getOpenHUD()
+    let window = HUDService.currentContext();
+    let target = TargetFactory.forTab(window.gBrowser.selectedTab);
+    let toolbox = gDevTools.getToolbox(target);
+    let panel = toolbox.getPanel("webconsole");
+    return panel ? panel.hud : null;
   },
 };
 
 const HUDService = new HUD_SERVICE();
-
diff --git a/browser/devtools/webconsole/WebConsolePanel.jsm b/browser/devtools/webconsole/WebConsolePanel.jsm
--- a/browser/devtools/webconsole/WebConsolePanel.jsm
+++ b/browser/devtools/webconsole/WebConsolePanel.jsm
@@ -4,85 +4,60 @@
 
 "use strict";
 
 this.EXPORTED_SYMBOLS = [ "WebConsolePanel" ];
 
 const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/commonjs/promise/core.js");
-Cu.import("resource:///modules/devtools/EventEmitter.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "HUDService",
-                                  "resource:///modules/HUDService.jsm");
+    "resource:///modules/HUDService.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "EventEmitter",
+    "resource:///modules/EventEmitter.jsm");
 
 /**
  * A DevToolPanel that controls the Web Console.
  */
 function WebConsolePanel(iframeWindow, toolbox) {
   this._frameWindow = iframeWindow;
   this._toolbox = toolbox;
   EventEmitter.decorate(this);
 }
 
 WebConsolePanel.prototype = {
   /**
    * open is effectively an asynchronous constructor
    */
-  open: function StyleEditor_open() {
+  open: function WCP_open() {
     let parentDoc = this._frameWindow.document.defaultView.parent.document;
     let iframe = parentDoc.getElementById("toolbox-panel-iframe-webconsole");
-    this.hud = HUDService.activateHUDForContext(this.target.tab, iframe,
-                                                this._toolbox.target);
+    let promise = HUDService.openWebConsole(this.target, iframe);
 
-    let deferred = Promise.defer();
+    promise.then(function(aResult) {
+      this._isReady = true;
+      this.emit("ready");
+    }.bind(this));
 
-    let hudId = this.hud.hudId;
-    let onOpen = function _onWebConsoleOpen(aSubject) {
-      aSubject.QueryInterface(Ci.nsISupportsString);
-      if (hudId == aSubject.data) {
-        Services.obs.removeObserver(onOpen, "web-console-created");
-
-        this._isReady = true;
-        this.emit("ready");
-        deferred.resolve(this);
-      }
-    }.bind(this);
-
-    Services.obs.addObserver(onOpen, "web-console-created", false);
-
-    return deferred.promise;
+    return promise;
   },
 
   get target() this._toolbox.target,
 
   _isReady: false,
   get isReady() this._isReady,
 
   destroy: function WCP_destroy()
   {
     if (this.destroyer) {
       return this.destroyer.promise;
     }
 
-    this.destroyer = Promise.defer();
-
-    let hudId = this.hud.hudId;
-
-    let onClose = function _onWebConsoleClose(aSubject)
-    {
-      aSubject.QueryInterface(Ci.nsISupportsString);
-      if (hudId == aSubject.data) {
-        Services.obs.removeObserver(onClose, "web-console-destroyed");
-
-        this.emit("destroyed");
-        this.destroyer.resolve(null);
-      }
-    }.bind(this);
-
-    Services.obs.addObserver(onClose, "web-console-destroyed", false);
-    HUDService.deactivateHUDForContext(this.hud.tab, false);
+    this.destroyer = this.hud.destroy();
+    this.destroyer.then(function() {
+      this.emit("destroyed");
+    }.bind(this));
 
     return this.destroyer.promise;
   },
 };
