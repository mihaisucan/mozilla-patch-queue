# HG changeset patch
# Parent 665e11e32550c9b80bbca1cb81e4b52023cb0525
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1339532207 -10800

Bug 762996 - Add errors count to the Web Console button in the developer toolbar

diff --git a/browser/devtools/shared/DeveloperToolbar.jsm b/browser/devtools/shared/DeveloperToolbar.jsm
--- a/browser/devtools/shared/DeveloperToolbar.jsm
+++ b/browser/devtools/shared/DeveloperToolbar.jsm
@@ -3,16 +3,19 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const EXPORTED_SYMBOLS = [ "DeveloperToolbar" ];
 
 const NS_XHTML = "http://www.w3.org/1999/xhtml";
 
+const WEBCONSOLE_CONTENT_SCRIPT_URL =
+  "chrome://browser/content/devtools/HUDService-content.js";
+
 Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
 Components.utils.import("resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyGetter(this, "gcli", function() {
   let obj = {};
   Components.utils.import("resource:///modules/devtools/gcli.jsm", obj);
   Components.utils.import("resource:///modules/devtools/GcliCommands.jsm", {});
   return obj.gcli;
@@ -31,16 +34,20 @@ function DeveloperToolbar(aChromeWindow,
 
   this._element = aToolbarElement;
   this._element.hidden = true;
   this._doc = this._element.ownerDocument;
 
   this._lastState = NOTIFICATIONS.HIDE;
   this._pendingShowCallback = undefined;
   this._pendingHide = false;
+  this._errorsCount = {};
+  this._webConsoleButton = this._chromeWindow.document
+                           .getElementById("developer-toolbar-webconsole");
+  this._webConsoleButtonLabel = this._webConsoleButton.label;
 }
 
 /**
  * Inspector notifications dispatched through the nsIObserverService
  */
 const NOTIFICATIONS = {
   /** DeveloperToolbar.show() has been called, and we're working on it */
   LOAD: "developer-toolbar-load",
@@ -53,26 +60,37 @@ const NOTIFICATIONS = {
 };
 
 /**
  * Attach notification constants to the object prototype so tests etc can
  * use them without needing to import anything
  */
 DeveloperToolbar.prototype.NOTIFICATIONS = NOTIFICATIONS;
 
+DeveloperToolbar.prototype._contentMessageListeners =
+  ["WebConsole:CachedMessages", "WebConsole:PageError"];
+
 /**
  * Is the toolbar open?
  */
 Object.defineProperty(DeveloperToolbar.prototype, 'visible', {
   get: function DT_visible() {
     return !this._element.hidden;
   },
   enumerable: true
 });
 
+DeveloperToolbar.prototype._sequenceId = 0;
+Object.defineProperty(DeveloperToolbar.prototype, 'sequenceId', {
+  get: function DT_visible() {
+    return this._sequenceId++;
+  },
+  enumerable: true
+});
+
 /**
  * Called from browser.xul in response to menu-click or keyboard shortcut to
  * toggle the toolbar
  */
 DeveloperToolbar.prototype.toggle = function DT_toggle()
 {
   if (this.visible) {
     this.hide();
@@ -147,19 +165,23 @@ DeveloperToolbar.prototype._onload = fun
     scratchpad: null
   });
 
   this.display.onVisibilityChange.add(this.outputPanel._visibilityChanged, this.outputPanel);
   this.display.onVisibilityChange.add(this.tooltipPanel._visibilityChanged, this.tooltipPanel);
   this.display.onOutput.add(this.outputPanel._outputChanged, this.outputPanel);
 
   this._chromeWindow.getBrowser().tabContainer.addEventListener("TabSelect", this, false);
+  this._chromeWindow.getBrowser().tabContainer.addEventListener("TabClose", this, false);
   this._chromeWindow.getBrowser().addEventListener("load", this, true);
+  this._chromeWindow.getBrowser().addEventListener("beforeunload", this, true);
   this._chromeWindow.addEventListener("resize", this, false);
 
+  this._initErrorsCount(this._chromeWindow.getBrowser().selectedTab);
+
   this._element.hidden = false;
   this._input.focus();
 
   this._notify(NOTIFICATIONS.SHOW);
   if (this._pendingShowCallback) {
     this._pendingShowCallback.call();
     this._pendingShowCallback = undefined;
   }
@@ -173,16 +195,66 @@ DeveloperToolbar.prototype._onload = fun
   }
 
   if (!DeveloperToolbar.introShownThisSession) {
     this.display.maybeShowIntro();
     DeveloperToolbar.introShownThisSession = true;
   }
 };
 
+DeveloperToolbar.prototype._initErrorsCount = function DT__initErrorsCount(aTab)
+{
+  let tabId = aTab.linkedPanel;
+  if (tabId in this._errorsCount) {
+    //dump("DT__initErrorsCount tabId already tracked! " + tabId + "\n");
+    this._updateErrorsCount();
+    return;
+  }
+  //dump("DT__initErrorsCount " + tabId + "\n");
+
+  let messageManager = aTab.linkedBrowser.messageManager;
+  messageManager.loadFrameScript(WEBCONSOLE_CONTENT_SCRIPT_URL, true);
+
+  this._errorsCount[tabId] = 0;
+
+  this._contentMessageListeners.forEach(function(aName) {
+    messageManager.addMessageListener(aName, this);
+  }, this);
+
+  let message = {
+    features: ["PageError"],
+    cachedMessages: ["PageError"],
+  };
+
+  this.sendMessageToTab(aTab, "WebConsole:Init", message);
+  this._updateErrorsCount();
+};
+
+DeveloperToolbar.prototype._stopErrorsCount = function DT__stopErrorsCount(aTab)
+{
+  let tabId = aTab.linkedPanel;
+  if (!(tabId in this._errorsCount)) {
+    //dump("DT__stopErrorsCount tabId untracked! " + tabId + "\n");
+    this._updateErrorsCount();
+    return;
+  }
+  //dump("DT__stopErrorsCount " + tabId + "\n");
+
+  let messageManager = aTab.linkedBrowser.messageManager;
+
+  this.sendMessageToTab(aTab, "WebConsole:Destroy", {});
+
+  this._contentMessageListeners.forEach(function(aName) {
+    messageManager.removeMessageListener(aName, this);
+  }, this);
+
+  delete this._errorsCount[tabId];
+  this._updateErrorsCount();
+};
+
 /**
  * Hide the developer toolbar.
  */
 DeveloperToolbar.prototype.hide = function DT_hide()
 {
   if (this._lastState == NOTIFICATIONS.HIDE) {
     return;
   }
@@ -202,16 +274,23 @@ DeveloperToolbar.prototype.hide = functi
 
 /**
  * Hide the developer toolbar
  */
 DeveloperToolbar.prototype.destroy = function DT_destroy()
 {
   this._chromeWindow.getBrowser().tabContainer.removeEventListener("TabSelect", this, false);
   this._chromeWindow.getBrowser().removeEventListener("load", this, true); 
+  this._chromeWindow.getBrowser().removeEventListener("beforeunload", this, true);
+  this._chromeWindow.removeEventListener("resize", this, false);
+
+  //dump("DT_destroy\n");
+
+  let tabs = this._chromeWindow.getBrowser().tabs;
+  Array.prototype.forEach.call(tabs, this._stopErrorsCount, this);
 
   this.display.onVisibilityChange.remove(this.outputPanel._visibilityChanged, this.outputPanel);
   this.display.onVisibilityChange.remove(this.tooltipPanel._visibilityChanged, this.tooltipPanel);
   this.display.onOutput.remove(this.outputPanel._outputChanged, this.outputPanel);
   this.display.destroy();
   this.outputPanel.destroy();
   this.tooltipPanel.destroy();
   delete this._input;
@@ -241,36 +320,153 @@ DeveloperToolbar.prototype._notify = fun
 };
 
 /**
  * Update various parts of the UI when the current tab changes
  * @param aEvent
  */
 DeveloperToolbar.prototype.handleEvent = function DT_handleEvent(aEvent)
 {
+  //dump("DT_handleEvent " + aEvent.type + "\n");
   if (aEvent.type == "TabSelect" || aEvent.type == "load") {
     this._chromeWindow.HUDConsoleUI.refreshCommand();
     this._chromeWindow.DebuggerUI.refreshCommand();
 
     if (this.visible) {
       let contentDocument = this._chromeWindow.getBrowser().contentDocument;
 
       this.display.reattach({
         contentDocument: contentDocument,
         chromeWindow: this._chromeWindow,
         environment: {
           chromeDocument: this._doc,
           contentDocument: contentDocument
         },
       });
+
+      if (aEvent.type == "TabSelect") {
+        this._initErrorsCount(aEvent.target);
+      }
     }
   }
   else if (aEvent.type == "resize") {
     this.outputPanel._resize();
   }
+  else if (aEvent.type == "TabClose") {
+    this._stopErrorsCount(aEvent.target);
+  } else if (aEvent.type == "beforeunload") {
+    this._onPageBeforeUnload(aEvent);
+  }
+};
+
+DeveloperToolbar.prototype.receiveMessage = function DT_receiveMessage(aMessage)
+{
+  if (!aMessage.json ||
+      !(aMessage.json.hudId in this._errorsCount)) {
+    //dump("received message from unknown ID " + aMessage  + "\n");
+    return;
+  }
+
+  //dump("receiveMessage " + aMessage.name + " " + aMessage.json.hudId + "\n");
+
+  let tabId = aMessage.json.hudId;
+  let errors = this._errorsCount[tabId];
+
+  switch (aMessage.name) {
+    case "WebConsole:PageError":
+      this._onPageError(tabId, aMessage.json.pageError);
+      break;
+    case "WebConsole:CachedMessages":
+      this._onCachedMessages(tabId, aMessage.json.messages);
+      break;
+  }
+
+  if (errors != this._errorsCount[tabId]) {
+    this._updateErrorsCount(tabId);
+  }
+};
+
+DeveloperToolbar.prototype.sendMessageToTab =
+function DT_sendMessageToTab(aTab, aName, aMessage)
+{
+  let tabId = aTab.linkedPanel;
+  aMessage.hudId = tabId;
+  if (!("id" in aMessage)) {
+    aMessage.id = "DevToolbar-" + this.sequenceId;
+  }
+
+  aTab.linkedBrowser.messageManager.sendAsyncMessage(aName, aMessage);
+};
+
+DeveloperToolbar.prototype._onPageError =
+function DT__onPageError(aTabId, aPageError)
+{
+  if (aPageError.category == "CSS Parser" ||
+      aPageError.category == "CSS Loader" ||
+      (aPageError.flags & aPageError.warningFlag) ||
+      (aPageError.flags & aPageError.strictFlag)) {
+    return; // just a CSS or JS warning
+  }
+
+  this._errorsCount[aTabId]++;
+};
+
+DeveloperToolbar.prototype._onCachedMessages =
+function DT__onCachedMessages(aTabId, aMessages)
+{
+  aMessages.forEach(this._onPageError.bind(this, aTabId));
+};
+
+DeveloperToolbar.prototype._onTabLocationChange =
+function DT__onTabLocationChange(aTabId)
+{
+  this._errorsCount[aTabId] = 0;
+};
+
+DeveloperToolbar.prototype._onPageBeforeUnload =
+function DT__onPageBeforeUnload(aEvent)
+{
+  //dump("DT__onPageBeforeUnload\n");
+  let window = aEvent.target.defaultView;
+  if (window.top !== window) {
+    //dump("not top window\n");
+    return;
+  }
+
+  let tabs = this._chromeWindow.getBrowser().tabs;
+  Array.prototype.some.call(tabs, function(aTab) {
+    if (aTab.linkedBrowser.contentWindow === window) {
+      let tabId = aTab.linkedPanel;
+      if (tabId in this._errorsCount) {
+        this._errorsCount[tabId] = 0;
+        this._updateErrorsCount(tabId);
+      }
+      return true;
+    }
+    return false;
+  }, this);
+}
+
+DeveloperToolbar.prototype._updateErrorsCount =
+function DT__updateErrorsCount(aChangedTabId)
+{
+  let tabId = this._chromeWindow.getBrowser().selectedTab.linkedPanel;
+  if (aChangedTabId && tabId != aChangedTabId) {
+    return;
+  }
+
+  let errors = this._errorsCount[tabId];
+
+  if (errors) {
+    this._webConsoleButton.label =
+      this._webConsoleButtonLabel + " (" + errors + ")";
+  }
+  else {
+    this._webConsoleButton.label = this._webConsoleButtonLabel;
+  }
 };
 
 /**
  * Panel to handle command line output.
  * @param aChromeDoc document from which we can pull the parts we need.
  * @param aInput the input element that should get focus.
  * @param aLoadCallback called when the panel is loaded properly.
  */
diff --git a/browser/devtools/webconsole/HUDService-content.js b/browser/devtools/webconsole/HUDService-content.js
--- a/browser/devtools/webconsole/HUDService-content.js
+++ b/browser/devtools/webconsole/HUDService-content.js
@@ -53,16 +53,17 @@ let Manager = {
    */
   get sequenceId() "HUDContent-" + (++this._sequence),
 
   /**
    * Initialize the Web Console manager.
    */
   init: function Manager_init()
   {
+    //dump("Manager_init " + this.hudId + " \n");
     this._enabledFeatures = [];
     this._messageHandlers = {};
 
     this._messageListeners.forEach(function(aName) {
       addMessageListener(aName, this);
     }, this);
 
     // Need to track the owner XUL window to listen to the unload and TabClose
@@ -83,31 +84,29 @@ let Manager = {
   },
 
   /**
    * The message handler. This method forwards all the remote messages to the
    * appropriate code.
    */
   receiveMessage: function Manager_receiveMessage(aMessage)
   {
-    if (!_alive) {
+    if (!_alive || !aMessage.json) {
       return;
     }
 
-    if (!aMessage.json || (aMessage.name != "WebConsole:Init" &&
-                           aMessage.json.hudId != this.hudId)) {
-      Cu.reportError("Web Console content script: received message " +
-                     aMessage.name + " from wrong hudId!");
+    if (aMessage.name == "WebConsole:Init" && !this.hudId) {
+      this._onInit(aMessage.json);
+      return;
+    }
+    if (aMessage.json.hudId != this.hudId) {
       return;
     }
 
     switch (aMessage.name) {
-      case "WebConsole:Init":
-        this._onInit(aMessage.json);
-        break;
       case "WebConsole:EnableFeature":
         this.enableFeature(aMessage.json.feature, aMessage.json);
         break;
       case "WebConsole:DisableFeature":
         this.disableFeature(aMessage.json.feature);
         break;
       case "WebConsole:GetPreferences":
         this.handleGetPreferences(aMessage.json);
@@ -1281,39 +1280,57 @@ let ConsoleListener = {
    */
   observe: function CL_observe(aScriptError)
   {
     if (!_alive || !(aScriptError instanceof Ci.nsIScriptError) ||
         !aScriptError.outerWindowID) {
       return;
     }
 
-    switch (aScriptError.category) {
-      // We ignore chrome-originating errors as we only care about content.
-      case "XPConnect JavaScript":
-      case "component javascript":
-      case "chrome javascript":
-      case "chrome registration":
-      case "XBL":
-      case "XBL Prototype Handler":
-      case "XBL Content Sink":
-      case "xbl javascript":
-        return;
+    if (!this.isCategoryAllowed(aScriptError.category)) {
+      return;
     }
 
     let errorWindow =
       WebConsoleUtils.getWindowByOuterId(aScriptError.outerWindowID,
                                          Manager.window);
     if (!errorWindow || errorWindow.top != Manager.window) {
       return;
     }
 
     Manager.sendMessage("WebConsole:PageError", { pageError: aScriptError });
   },
 
+
+  /**
+   * Check if the given script error category is allowed to be tracked or not.
+   * We ignore chrome-originating errors as we only care about content.
+   *
+   * @param string aCategory
+   *        The nsIScriptError category you want to check.
+   * @return boolean
+   *         True if the category is allowed to be logged, false otherwise.
+   */
+  isCategoryAllowed: function CL_isCategoryAllowed(aCategory)
+  {
+    switch (aCategory) {
+      case "XPConnect JavaScript":
+      case "component javascript":
+      case "chrome javascript":
+      case "chrome registration":
+      case "XBL":
+      case "XBL Prototype Handler":
+      case "XBL Content Sink":
+      case "xbl javascript":
+        return false;
+    }
+
+    return true;
+  },
+
   /**
    * Get the cached page errors for the current inner window.
    *
    * @return array
    *         The array of cached messages. Each element is an nsIScriptError
    *         with an added _type property so the remote Web Console instance can
    *         tell the difference between various types of cached messages.
    */
@@ -1321,24 +1338,25 @@ let ConsoleListener = {
   {
     let innerWindowId = WebConsoleUtils.getInnerWindowId(Manager.window);
     let result = [];
     let errors = {};
     Services.console.getMessageArray(errors, {});
 
     (errors.value || []).forEach(function(aError) {
       if (!(aError instanceof Ci.nsIScriptError) ||
-          aError.innerWindowID != innerWindowId) {
+          aError.innerWindowID != innerWindowId ||
+          !this.isCategoryAllowed(aError.category)) {
         return;
       }
 
       let remoteMessage = WebConsoleUtils.cloneObject(aError);
       remoteMessage._type = "PageError";
       result.push(remoteMessage);
-    });
+    }, this);
 
     return result;
   },
 
   /**
    * Remove the nsIConsoleService listener.
    */
   destroy: function CL_destroy()
@@ -2500,8 +2518,11 @@ let ConsoleProgressListener = {
     this._locationChange = false;
     let webProgress = docShell.QueryInterface(Ci.nsIWebProgress);
     webProgress.removeProgressListener(this);
   },
 };
 
 Manager.init();
 })();
+
+//dump("HUDService-content script loaded\n");
+
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -1407,20 +1407,18 @@ HeadsUpDisplay.prototype = {
     if (!aRemoteMessages.length) {
       return;
     }
 
     aRemoteMessages.forEach(function(aMessage) {
       switch (aMessage._type) {
         case "PageError": {
           let category = this.categoryForScriptError(aMessage.category);
-          if (category != -1) {
-            this.outputMessage(category, this.reportPageError,
-                               [category, aMessage]);
-          }
+          this.outputMessage(category, this.reportPageError,
+                             [category, aMessage]);
           break;
         }
         case "ConsoleAPI":
           this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
                              [aMessage]);
           break;
       }
     }, this);
@@ -2048,20 +2046,16 @@ HeadsUpDisplay.prototype = {
    *
    * @param nsIScriptError aScriptError
    *        The error message to report.
    * @return nsIDOMElement|undefined
    *         The message element to display in the Web Console output.
    */
   reportPageError: function HUD_reportPageError(aCategory, aScriptError)
   {
-    if (!aScriptError.outerWindowID) {
-      return;
-    }
-
     // Warnings and legacy strict errors become warnings; other types become
     // errors.
     let severity = SEVERITY_ERROR;
     if ((aScriptError.flags & aScriptError.warningFlag) ||
         (aScriptError.flags & aScriptError.strictFlag)) {
       severity = SEVERITY_WARNING;
     }
 
@@ -2078,34 +2072,23 @@ HeadsUpDisplay.prototype = {
     return node;
   },
 
   /**
    * Determine the category of a given nsIScriptError.
    *
    * @param nsIScriptError aScriptError
    *        The script error you want to determine the category for.
-   * @return CATEGORY_JS|CATEGORY_CSS|-1
+   * @return CATEGORY_JS|CATEGORY_CSS
    *         Depending on the script error CATEGORY_JS or CATEGORY_CSS can be
-   *         returned. If the category is unknown -1 is returned.
+   *         returned.
    */
   categoryForScriptError: function HUD_categoryForScriptError(aScriptError)
   {
     switch (aScriptError.category) {
-      // We ignore chrome-originating errors as we only care about content.
-      case "XPConnect JavaScript":
-      case "component javascript":
-      case "chrome javascript":
-      case "chrome registration":
-      case "XBL":
-      case "XBL Prototype Handler":
-      case "XBL Content Sink":
-      case "xbl javascript":
-        return -1;
-
       case "CSS Parser":
       case "CSS Loader":
         return CATEGORY_CSS;
 
       default:
         return CATEGORY_JS;
     }
   },
@@ -2301,20 +2284,18 @@ HeadsUpDisplay.prototype = {
         break;
       case "WebConsole:ConsoleAPI":
         this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
                            [aMessage.json]);
         break;
       case "WebConsole:PageError": {
         let pageError = aMessage.json.pageError;
         let category = this.categoryForScriptError(pageError);
-        if (category != -1) {
-          this.outputMessage(category, this.reportPageError,
-                             [category, pageError]);
-        }
+        this.outputMessage(category, this.reportPageError,
+                           [category, pageError]);
         break;
       }
       case "WebConsole:CachedMessages":
         this._displayCachedConsoleMessages(aMessage.json.messages);
         this._onInitComplete();
         break;
       case "WebConsole:NetworkActivity":
         this.handleNetworkActivity(aMessage.json);
