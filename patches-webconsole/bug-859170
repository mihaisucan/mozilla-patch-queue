# HG changeset patch
# Parent f4ba94a32270f692883d504ba2d93b834ce90dbf
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1365596071 -10800

Bug 859170 - Trying to select [...] for a very long message printed to the web console will hang Firefox; r=past

diff --git a/browser/devtools/webconsole/test/Makefile.in b/browser/devtools/webconsole/test/Makefile.in
--- a/browser/devtools/webconsole/test/Makefile.in
+++ b/browser/devtools/webconsole/test/Makefile.in
@@ -115,16 +115,17 @@ MOCHITEST_BROWSER_FILES = \
 	browser_output_longstring_expand.js \
 	browser_netpanel_longstring_expand.js \
 	browser_repeated_messages_accuracy.js \
 	browser_webconsole_bug_821877_csp_errors.js \
 	browser_eval_in_debugger_stackframe.js \
 	browser_console_variables_view.js \
 	browser_console_variables_view_while_debugging.js \
 	browser_console.js \
+	browser_longstring_hang.js \
 	head.js \
 	$(NULL)
 
 ifeq ($(OS_ARCH), Darwin)
 MOCHITEST_BROWSER_FILES += \
         browser_webconsole_bug_804845_ctrl_key_nav.js \
         $(NULL)
 endif
diff --git a/browser/devtools/webconsole/test/browser_longstring_hang.js b/browser/devtools/webconsole/test/browser_longstring_hang.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/test/browser_longstring_hang.js
@@ -0,0 +1,102 @@
+/* vim:set ts=2 sw=2 sts=2 et: */
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+// Test that very long strings do not hang the browser.
+
+function test()
+{
+  waitForExplicitFinish();
+
+  let DebuggerServer = Cu.import("resource://gre/modules/devtools/dbg-server.jsm",
+                                 {}).DebuggerServer;
+
+  let longString = "foobar" +
+                   (new Array(DebuggerServer.LONG_STRING_LENGTH + 4)).join("a") +
+                   "foobaz";
+
+  let veryLongString = "abbababazomglolztest";
+  for (let i = 0; i < 14; i++) {
+    veryLongString += veryLongString + veryLongString;
+  }
+
+  longString += veryLongString + "boom!";
+
+  addTab("data:text/html;charset=utf8,test for bug 859170 - check that very long strings do not hang the browser.");
+
+  let hud = null;
+
+  gBrowser.selectedBrowser.addEventListener("load", function onLoad() {
+    gBrowser.selectedBrowser.removeEventListener("load", onLoad, true);
+    openConsole(null, performTest);
+  }, true);
+
+  function performTest(aHud)
+  {
+    hud = aHud;
+
+    content.wrappedJSObject.longString = longString;
+
+    hud.jsterm.clearOutput(true);
+    hud.jsterm.execute("console.log(window.longString)");
+
+    waitForMessages({
+      webconsole: hud,
+      messages: [{
+        text: "foobar",
+        category: CATEGORY_WEBDEV,
+      }],
+    }).then(onInitialString);
+  }
+
+  function onInitialString(aResults)
+  {
+    let msg = [...aResults[0].matched][0];
+    ok(msg, "message element");
+    is(msg.textContent.indexOf("foobaz"), -1,
+       "foobaz is not shown");
+
+    let clickable = msg.querySelector(".longStringEllipsis");
+    ok(clickable, "long string ellipsis is shown");
+
+    scrollToVisible(clickable);
+
+    executeSoon(() => {
+      EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
+      waitForSuccess(waitForFullString);
+    });
+  }
+
+  let waitForFullString = {
+    name: "full string shown",
+    validatorFn: function()
+    {
+      let msg = hud.outputNode.querySelector(".webconsole-msg-log");
+      return msg.textContent.indexOf("foobaz") > -1;
+    },
+    successFn: function()
+    {
+      let msg = hud.outputNode.querySelector(".webconsole-msg-log");
+      ist(msg.textContent.indexOf("boom!"), -1,
+          "boom is not shown");
+
+      let clickable = msg.querySelector(".longStringEllipsis");
+      ok(!clickable, "long string ellipsis is not shown");
+
+      executeSoon(finishTest);
+    },
+    failureFn: finishTest,
+  };
+
+  function scrollToVisible(aNode)
+  {
+    let richListBoxNode = aNode.parentNode;
+    while (richListBoxNode.tagName != "richlistbox") {
+      richListBoxNode = richListBoxNode.parentNode;
+    }
+
+    let boxObject = richListBoxNode.scrollBoxObject;
+    let nsIScrollBoxObject = boxObject.QueryInterface(Ci.nsIScrollBoxObject);
+    nsIScrollBoxObject.ensureElementIsVisible(aNode);
+  }
+}
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -166,16 +166,19 @@ const OUTPUT_INTERVAL = 50; // milliseco
 const THROTTLE_UPDATES = 1000; // milliseconds
 
 // The preference prefix for all of the Web Console filters.
 const FILTER_PREFS_PREFIX = "devtools.webconsole.filter.";
 
 // The minimum font size.
 const MIN_FONT_SIZE = 10;
 
+// The maximum length of strings to be displayed by the Web Console.
+const MAX_LONG_STRING_LENGTH = 500000;
+
 const PREF_CONNECTION_TIMEOUT = "devtools.debugger.remote-timeout";
 
 /**
  * A WebConsoleFrame instance is an interactive console initialized *per target*
  * that displays console log data as well as provides an interactive terminal to
  * manipulate the target's document content.
  *
  * The WebConsoleFrame is responsible for the actual Web Console UI
@@ -1314,27 +1317,37 @@ WebConsoleFrame.prototype = {
    *        The file URI that was requested.
    */
   handleFileActivity: function WCF_handleFileActivity(aFileURI)
   {
     this.outputMessage(CATEGORY_NETWORK, this.logFileActivity, [aFileURI]);
   },
 
   /**
-   * Inform user that the Web Console API has been replaced by a script
+   * Inform user that the window.console API has been replaced by a script
    * in a content page.
    */
   logWarningAboutReplacedAPI: function WCF_logWarningAboutReplacedAPI()
   {
     let node = this.createMessageNode(CATEGORY_JS, SEVERITY_WARNING,
                                       l10n.getStr("ConsoleAPIDisabled"));
     this.outputMessage(CATEGORY_JS, node);
   },
 
   /**
+   * Inform user that the string he tries to view is too long.
+   */
+  logWarningAboutStringTooLong: function WCF_logWarningAboutStringTooLong()
+  {
+    let node = this.createMessageNode(CATEGORY_JS, SEVERITY_WARNING,
+                                      l10n.getStr("longStringTooLong"));
+    this.outputMessage(CATEGORY_JS, node);
+  },
+
+  /**
    * Handle the network events coming from the remote Web Console.
    *
    * @param object aActor
    *        The NetworkEventActor grip.
    */
   handleNetworkEvent: function WCF_handleNetworkEvent(aActor)
   {
     let networkInfo = {
@@ -2250,33 +2263,38 @@ WebConsoleFrame.prototype = {
   {
     aEvent.preventDefault();
 
     if (!aFormatter) {
       aFormatter = function(s) s;
     }
 
     let longString = this.webConsoleClient.longString(aActor);
-    longString.substring(longString.initial.length, longString.length,
+    let toIndex = Math.min(longString.length, MAX_LONG_STRING_LENGTH);
+    longString.substring(longString.initial.length, toIndex,
       function WCF__onSubstring(aResponse) {
         if (aResponse.error) {
           Cu.reportError("WCF__longStringClick substring failure: " +
                          aResponse.error);
           return;
         }
 
         let node = aEllipsis.previousSibling;
         node.textContent = aFormatter(longString.initial + aResponse.substring);
         aEllipsis.parentNode.removeChild(aEllipsis);
 
         if (aMessage.category == CATEGORY_WEBDEV ||
             aMessage.category == CATEGORY_OUTPUT) {
           aMessage.clipboardText = aMessage.textContent;
         }
-      });
+
+        if (toIndex != longString.length) {
+          this.logWarningAboutStringTooLong();
+        }
+      }.bind(this));
   },
 
   /**
    * Creates the XUL label that displays the textual location of an incoming
    * message.
    *
    * @param string aSourceURL
    *        The URL of the source file responsible for the error.
@@ -3472,27 +3490,32 @@ JSTerm.prototype = {
     aVar._fetched = true;
 
     let grip = aVar.value;
     if (!grip) {
       throw new Error("No long string actor grip was given for the variable.");
     }
 
     let client = this.webConsoleClient.longString(grip);
-    client.substring(grip.initial.length, grip.length, (aResponse) => {
+    let toIndex = Math.min(grip.length, MAX_LONG_STRING_LENGTH);
+    client.substring(grip.initial.length, toIndex, (aResponse) => {
       if (aResponse.error) {
         Cu.reportError("JST__fetchVarLongString substring failure: " +
                        aResponse.error + ": " + aResponse.message);
         return;
       }
 
       aVar.onexpand = null;
       aVar.setGrip(grip.initial + aResponse.substring);
       aVar.hideArrow();
       aVar._retrieved = true;
+
+      if (toIndex != grip.length) {
+        this.hud.logWarningAboutStringTooLong();
+      }
     });
   },
 
   /**
    * Writes a JS object to the JSTerm outputNode.
    *
    * @param string aOutputMessage
    *        The message to display.
diff --git a/browser/locales/en-US/chrome/browser/devtools/webconsole.properties b/browser/locales/en-US/chrome/browser/devtools/webconsole.properties
--- a/browser/locales/en-US/chrome/browser/devtools/webconsole.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/webconsole.properties
@@ -175,16 +175,20 @@ ToolboxWebconsole.label=Web Console
 # displayed inside the developer tools window.
 ToolboxWebconsole.tooltip=Web Console
 
 # LOCALIZATION NOTE (longStringEllipsis): The string displayed after a long
 # string. This string is clickable such that the rest of the string is retrieved
 # from the server.
 longStringEllipsis=[â€¦]
 
+# LOCALIZATION NOTE (longStringTooLong): The string displayed after the user
+# tries to expand a long string.
+longStringTooLong=The string you are trying to view is too long to be displayed by the Web Console.
+
 # LOCALIZATION NOTE (executeEmptyInput): This is displayed when the user tries
 # to execute code, but the input is empty.
 executeEmptyInput=No value to execute.
 
 # LOCALIZATION NOTE (NetworkPanel.fetchRemainingResponseContentLink): This is
 # displayed in the network panel when the response body is only partially
 # available.
 NetworkPanel.fetchRemainingResponseContentLink=Fetch the remaining %1$S bytes
