# HG changeset patch
# Parent 4862074511a3ac1ac436f722991ad2b284cbdd9e
# User Christos Stathis <chstath@gmail.com>
Bug 842682 - Use the debugger API for autocomplete and provide suggestions from the selected stackframe scope; r=msucan; try: -b do -p linux,linux64,macosx64,win32,win64 -u xpcshell,mochitest-bc,mochitest-o -t none

diff --git a/browser/devtools/webconsole/test/browser.ini b/browser/devtools/webconsole/test/browser.ini
--- a/browser/devtools/webconsole/test/browser.ini
+++ b/browser/devtools/webconsole/test/browser.ini
@@ -88,16 +88,17 @@ support-files =
   test-property-provider.html
   test-repeated-messages.html
   test-result-format-as-string.html
   test-webconsole-error-observer.html
   test_bug_770099_bad_policy_uri.html
   test_bug_770099_bad_policy_uri.html^headers^
   test_bug_770099_violation.html
   test_bug_770099_violation.html^headers^
+  test-autocomplete-in-stackframe.html
   testscript.js
   test-bug_923281_console_log_filter.html
   test-bug_923281_test1.js
   test-bug_923281_test2.js
 
 [browser_bug664688_sandbox_update_after_navigation.js]
 [browser_bug_638949_copy_link_location.js]
 [browser_bug_862916_console_dir_and_filter_off.js]
@@ -236,8 +237,9 @@ skip-if = os == "linux"
 [browser_webconsole_output_order.js]
 [browser_webconsole_property_provider.js]
 [browser_webconsole_scratchpad_panel_link.js]
 [browser_webconsole_split.js]
 [browser_webconsole_view_source.js]
 [browser_webconsole_reflow.js]
 [browser_webconsole_log_file_filter.js]
 [browser_webconsole_expandable_timestamps.js]
+[browser_webconsole_autocomplete_in_debugger_stackframe.js]
diff --git a/browser/devtools/webconsole/test/browser_webconsole_autocomplete_in_debugger_stackframe.js b/browser/devtools/webconsole/test/browser_webconsole_autocomplete_in_debugger_stackframe.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/test/browser_webconsole_autocomplete_in_debugger_stackframe.js
@@ -0,0 +1,212 @@
+/*
+ * Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/
+ */
+
+// Test that makes sure web console autocomplete happens in the user-selected stackframe
+// from the js debugger.
+
+const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-autocomplete-in-stackframe.html";
+
+let testDriver, gStackframes;
+
+function test()
+{
+  requestLongerTimeout(2);
+  addTab(TEST_URI);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, function(hud) {
+      testDriver = testCompletion(hud);
+      testDriver.next();
+    });
+  }, true);
+}
+
+function testNext() {
+  executeSoon(function() {
+    testDriver.next();
+  });
+}
+
+function testCompletion(hud) {
+  let jsterm = hud.jsterm;
+  let input = jsterm.inputNode;
+  let popup = jsterm.autocompletePopup;
+
+  // Test if 'f' gives 'foo1' but not 'foo2' or 'foo3'
+  input.value = "f";
+  input.setSelectionRange(1, 1);
+  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
+  yield undefined;
+
+  let newItems = popup.getItems();
+  ok(newItems.length > 0, "'f' gave a list of suggestions");
+  ok(!newItems.every(function(item) {
+       return item.label != "foo1";
+     }), "autocomplete results do contain foo1");
+  ok(!newItems.every(function(item) {
+       return item.label != "foo1Obj";
+     }), "autocomplete results do contain foo1Obj");
+  ok(newItems.every(function(item) {
+       return item.label != "foo2";
+     }), "autocomplete results do not contain foo2");
+  ok(newItems.every(function(item) {
+       return item.label != "foo2Obj";
+     }), "autocomplete results do not contain foo2Obj");
+  ok(newItems.every(function(item) {
+       return item.label != "foo3";
+     }), "autocomplete results do not contain foo3");
+  ok(newItems.every(function(item) {
+       return item.label != "foo3Obj";
+     }), "autocomplete results do not contain foo3Obj");
+
+  // Test if 'foo1Obj.' gives 'prop1' and 'prop2'
+  input.value = "foo1Obj.";
+  input.setSelectionRange(8, 8);
+  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
+  yield undefined;
+
+  newItems = popup.getItems();
+  ok(!newItems.every(function(item) {
+       return item.label != "prop1";
+     }), "autocomplete results do contain prop1");
+  ok(!newItems.every(function(item) {
+       return item.label != "prop2";
+     }), "autocomplete results do contain prop2");
+
+  // Test if 'foo1Obj.prop2.' gives 'prop21'
+  input.value = "foo1Obj.prop2.";
+  input.setSelectionRange(14, 14);
+  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
+  yield undefined;
+
+  newItems = popup.getItems();
+  ok(!newItems.every(function(item) {
+       return item.label != "prop21";
+     }), "autocomplete results do contain prop21");
+
+  info("openDebugger");
+  executeSoon(() => openDebugger().then(debuggerOpened));
+  yield undefined;
+
+  // From this point on the
+  // Test if 'f' gives 'foo3' and 'foo1' but not 'foo2'
+  input.value = "f";
+  input.setSelectionRange(1, 1);
+  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
+  yield undefined;
+
+  newItems = popup.getItems();
+  ok(newItems.length > 0, "'f' gave a list of suggestions");
+  ok(!newItems.every(function(item) {
+       return item.label != "foo3";
+     }), "autocomplete results do contain foo3");
+  ok(!newItems.every(function(item) {
+       return item.label != "foo3Obj";
+     }), "autocomplete results do contain foo3Obj");
+  ok(!newItems.every(function(item) {
+       return item.label != "foo1";
+     }), "autocomplete results do contain foo1");
+  ok(!newItems.every(function(item) {
+       return item.label != "foo1Obj";
+     }), "autocomplete results do contain foo1Obj");
+  ok(newItems.every(function(item) {
+       return item.label != "foo2";
+     }), "autocomplete results do not contain foo2");
+  ok(newItems.every(function(item) {
+       return item.label != "foo2Obj";
+     }), "autocomplete results do not contain foo2Obj");
+
+  openDebugger().then(() => {
+    gStackframes.selectFrame(1);
+
+    info("openConsole");
+    executeSoon(() => openConsole(null, () => testDriver.next()));
+  });
+  yield undefined;
+
+  // Test if 'f' gives 'foo2' and 'foo1' but not 'foo3'
+  input.value = "f";
+  input.setSelectionRange(1, 1);
+  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
+  yield undefined;
+
+  newItems = popup.getItems();
+  ok(newItems.length > 0, "'f' gave a list of suggestions");
+  ok(!newItems.every(function(item) {
+       return item.label != "foo2";
+     }), "autocomplete results do contain foo2");
+  ok(!newItems.every(function(item) {
+       return item.label != "foo2Obj";
+     }), "autocomplete results do contain foo2Obj");
+  ok(!newItems.every(function(item) {
+       return item.label != "foo1";
+     }), "autocomplete results do contain foo1");
+  ok(!newItems.every(function(item) {
+       return item.label != "foo1Obj";
+     }), "autocomplete results do contain foo1Obj");
+  ok(newItems.every(function(item) {
+       return item.label != "foo3";
+     }), "autocomplete results do not contain foo3");
+  ok(newItems.every(function(item) {
+       return item.label != "foo3Obj";
+     }), "autocomplete results do not contain foo3Obj");
+
+  // Test if 'foo2Obj.' gives 'prop1'
+  input.value = "foo2Obj.";
+  input.setSelectionRange(8, 8);
+  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
+  yield undefined;
+
+  newItems = popup.getItems();
+  ok(!newItems.every(function(item) {
+       return item.label != "prop1";
+     }), "autocomplete results do contain prop1");
+
+  // Test if 'foo1Obj.prop1.' gives 'prop11'
+  input.value = "foo2Obj.prop1.";
+  input.setSelectionRange(14, 14);
+  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
+  yield undefined;
+
+  newItems = popup.getItems();
+  ok(!newItems.every(function(item) {
+       return item.label != "prop11";
+     }), "autocomplete results do contain prop11");
+
+  // Test if 'foo1Obj.prop1.prop11.' gives suggestions for a string i.e. 'length'
+  input.value = "foo2Obj.prop1.prop11.";
+  input.setSelectionRange(21, 21);
+  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
+  yield undefined;
+
+  newItems = popup.getItems();
+  ok(!newItems.every(function(item) {
+       return item.label != "length";
+     }), "autocomplete results do contain length");
+
+  testDriver = null;
+  executeSoon(finishTest);
+  yield undefined;
+}
+
+function debuggerOpened(aResult)
+{
+  let debuggerWin = aResult.panelWin;
+  let debuggerController = debuggerWin.DebuggerController;
+  let thread = debuggerController.activeThread;
+  gStackframes = debuggerController.StackFrames;
+
+  executeSoon(() => {
+    thread.addOneTimeListener("framesadded", onFramesAdded);
+    info("firstCall()");
+    content.wrappedJSObject.firstCall();
+  });
+}
+
+function onFramesAdded()
+{
+  info("onFramesAdded, openConsole() now");
+  executeSoon(() => openConsole(null, testNext));
+}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
@@ -13,24 +13,24 @@ function test() {
     openConsole(null, consoleOpened);
   }, true);
 }
 
 function consoleOpened(aHud) {
   HUD = aHud;
   info("web console opened");
 
-  content.wrappedJSObject.foobarBug585991 = {
-    "item0": "value0",
-    "item1": "value1",
-    "item2": "value2",
-    "item3": "value3",
-  };
+  jsterm = HUD.jsterm;
 
-  jsterm = HUD.jsterm;
+  jsterm.execute("window.foobarBug585991={" +
+    "'item0': 'value0'," +
+    "'item1': 'value1'," +
+    "'item2': 'value2'," +
+    "'item3': 'value3'" +
+  "}");
   popup = jsterm.autocompletePopup;
   completeNode = jsterm.completeNode;
   inputNode = jsterm.inputNode;
 
   ok(!popup.isOpen, "popup is not open");
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js b/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
@@ -14,49 +14,55 @@ function test() {
     openConsole(null, consoleOpened);
   }, true);
 }
 
 function consoleOpened(HUD) {
   let tools = Cu.import("resource://gre/modules/devtools/Loader.jsm", {}).devtools;
   let JSPropertyProvider = tools.require("devtools/toolkit/webconsole/utils").JSPropertyProvider;
 
+  let tmp = Cu.import("resource://gre/modules/jsdebugger.jsm", {});
+  tmp.addDebuggerToGlobal(tmp);
+  let dbg = new tmp.Debugger;
+
   let jsterm = HUD.jsterm;
   let win = content.wrappedJSObject;
+  let dbgWindow = dbg.makeGlobalObjectReference(win);
 
   // Make sure autocomplete does not walk through iterators and generators.
   let result = win.gen1.next();
-  let completion = JSPropertyProvider(win, "gen1.");
-  is(completion, null, "no matches for gen1");
+  let completion = JSPropertyProvider(dbgWindow, null, "gen1.");
+  isnot(completion.matches.length, 0, "Got matches for gen1");
 
   is(result+1, win.gen1.next(), "gen1.next() did not execute");
 
   result = win.gen2.next();
 
-  completion = JSPropertyProvider(win, "gen2.");
-  is(completion, null, "no matches for gen2");
+  completion = JSPropertyProvider(dbgWindow, null, "gen2.");
+  isnot(completion.matches.length, 0, "Got matches for gen2");
 
   is((result/2+1)*2, win.gen2.next(),
      "gen2.next() did not execute");
 
   result = win.iter1.next();
   is(result[0], "foo", "iter1.next() [0] is correct");
   is(result[1], "bar", "iter1.next() [1] is correct");
 
-  completion = JSPropertyProvider(win, "iter1.");
-  is(completion, null, "no matches for iter1");
+  completion = JSPropertyProvider(dbgWindow, null, "iter1.");
+  isnot(completion.matches.length, 0, "Got matches for iter1");
 
   result = win.iter1.next();
   is(result[0], "baz", "iter1.next() [0] is correct");
   is(result[1], "baaz", "iter1.next() [1] is correct");
 
-  completion = JSPropertyProvider(content, "iter2.");
-  is(completion, null, "no matches for iter2");
+  let dbgContent = dbg.makeGlobalObjectReference(content);
+  completion = JSPropertyProvider(dbgContent, null, "iter2.");
+  isnot(completion.matches.length, 0, "Got matches for iter2");
 
-  completion = JSPropertyProvider(win, "window.");
+  completion = JSPropertyProvider(dbgWindow, null, "window.");
   ok(completion, "matches available for window");
   ok(completion.matches.length, "matches available for window (length)");
 
   jsterm.clearOutput();
 
   jsterm.execute("window", (msg) => {
     jsterm.once("variablesview-fetched", testVariablesView.bind(null, HUD));
     let anchor = msg.querySelector(".body a");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_property_provider.js b/browser/devtools/webconsole/test/browser_webconsole_property_provider.js
--- a/browser/devtools/webconsole/test/browser_webconsole_property_provider.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_property_provider.js
@@ -13,27 +13,32 @@ function test() {
   browser.addEventListener("load", testPropertyProvider, true);
 }
 
 function testPropertyProvider() {
   browser.removeEventListener("load", testPropertyProvider, true);
   let tools = Cu.import("resource://gre/modules/devtools/Loader.jsm", {}).devtools;
   let JSPropertyProvider = tools.require("devtools/toolkit/webconsole/utils").JSPropertyProvider;
 
-  let completion = JSPropertyProvider(content, "thisIsNotDefined");
+  let tmp = Cu.import("resource://gre/modules/jsdebugger.jsm", {});
+  tmp.addDebuggerToGlobal(tmp);
+  let dbg = new tmp.Debugger;
+  let dbgWindow = dbg.makeGlobalObjectReference(content);
+
+  let completion = JSPropertyProvider(dbgWindow, null, "thisIsNotDefined");
   is (completion.matches.length, 0, "no match for 'thisIsNotDefined");
 
   // This is a case the PropertyProvider can't handle. Should return null.
-  completion = JSPropertyProvider(content, "window[1].acb");
+  completion = JSPropertyProvider(dbgWindow, null, "window[1].acb");
   is (completion, null, "no match for 'window[1].acb");
 
   // A very advanced completion case.
   var strComplete =
     'function a() { }document;document.getElementById(window.locatio';
-  completion = JSPropertyProvider(content, strComplete);
+  completion = JSPropertyProvider(dbgWindow, null, strComplete);
   ok(completion.matches.length == 2, "two matches found");
   ok(completion.matchProp == "locatio", "matching part is 'test'");
   var matches = completion.matches;
   matches.sort();
   ok(matches[0] == "location", "the first match is 'location'");
   ok(matches[1] == "locationbar", "the second match is 'locationbar'");
 
   finishTest();
diff --git a/browser/devtools/webconsole/test/test-autocomplete-in-stackframe.html b/browser/devtools/webconsole/test/test-autocomplete-in-stackframe.html
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/test/test-autocomplete-in-stackframe.html
@@ -0,0 +1,50 @@
+<!DOCTYPE HTML>
+<html dir="ltr" lang="en">
+  <head>
+    <meta charset="utf8">
+    <!--
+    - Any copyright is dedicated to the Public Domain.
+    - http://creativecommons.org/publicdomain/zero/1.0/
+    -->
+    <title>Test for bug 842682 - use the debugger API for web console autocomplete</title>
+    <script>
+      var foo1 = "globalFoo";
+
+      var foo1Obj = {
+        prop1: "111",
+        prop2: {
+          prop21: "212121"
+        }
+      };
+
+      function firstCall()
+      {
+        var foo2 = "fooFirstCall";
+
+        var foo2Obj = {
+          prop1: {
+            prop11: "111111"
+          }
+        };
+
+        secondCall();
+      }
+
+      function secondCall()
+      {
+        var foo3 = "fooSecondCall";
+
+        var foo3Obj = {
+          prop1: {
+            prop11: "313131"
+          }
+        };
+
+        debugger;
+      }
+    </script>
+  </head>
+  <body>
+    <p>Hello world!</p>
+  </body>
+</html>
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -3070,16 +3070,24 @@ JSTerm.prototype = {
    * The input that caused the last request to the server, whose response is
    * cached in the _autocompleteCache array.
    * @private
    * @type string
    */
   _autocompleteQuery: null,
 
   /**
+   * The frameActorId used in the last autocomplete query. Whenever this changes
+   * the autocomplete cache must be invalidated.
+   * @private
+   * @type string
+   */
+  _lastFrameActorId: null,
+
+  /**
    * The Web Console sidebar.
    * @see this._createSidebar()
    * @see Sidebar.jsm
    */
   sidebar: null,
 
   /**
    * The Variables View instance shown in the sidebar.
@@ -4305,30 +4313,32 @@ JSTerm.prototype = {
    *        updated.
    * @returns boolean true if there existed a completion for the current input,
    *          or false otherwise.
    */
   complete: function JSTF_complete(aType, aCallback)
   {
     let inputNode = this.inputNode;
     let inputValue = inputNode.value;
+    let frameActor = this.getFrameActor(this.SELECTED_FRAME);
+
     // If the inputNode has no value, then don't try to complete on it.
     if (!inputValue) {
       this.clearCompletion();
       return false;
     }
 
     // Only complete if the selection is empty.
     if (inputNode.selectionStart != inputNode.selectionEnd) {
       this.clearCompletion();
       return false;
     }
 
     // Update the completion results.
-    if (this.lastCompletion.value != inputValue) {
+    if (this.lastCompletion.value != inputValue || frameActor != this._lastFrameActorId) {
       this._updateCompletionResult(aType, aCallback);
       return false;
     }
 
     let popup = this.autocompletePopup;
     let accepted = false;
 
     if (aType != this.COMPLETE_HINT_ONLY && popup.itemCount == 1) {
@@ -4354,32 +4364,33 @@ JSTerm.prototype = {
    * @param int aType
    *        Completion type. See this.complete() for details.
    * @param function [aCallback]
    *        Optional, function to invoke when completion results are received.
    */
   _updateCompletionResult:
   function JST__updateCompletionResult(aType, aCallback)
   {
-    if (this.lastCompletion.value == this.inputNode.value) {
+    let frameActor = this.getFrameActor(this.SELECTED_FRAME);
+    if (this.lastCompletion.value == this.inputNode.value && frameActor == this._lastFrameActorId) {
       return;
     }
 
     let requestId = gSequenceId();
     let cursor = this.inputNode.selectionStart;
     let input = this.inputNode.value.substring(0, cursor);
     let cache = this._autocompleteCache;
 
     // If the current input starts with the previous input, then we already
     // have a list of suggestions and we just need to filter the cached
     // suggestions. When the current input ends with a non-alphanumeric
     // character we ask the server again for suggestions.
 
     // Check if last character is non-alphanumeric
-    if (!/[a-zA-Z0-9]$/.test(input)) {
+    if (!/[a-zA-Z0-9]$/.test(input) || frameActor != this._lastFrameActorId) {
       this._autocompleteQuery = null;
       this._autocompleteCache = null;
     }
 
     if (this._autocompleteQuery && input.startsWith(this._autocompleteQuery)) {
       let filterBy = input;
       // Find the last non-alphanumeric if exists.
       let lastNonAlpha = input.match(/[^a-zA-Z0-9][a-zA-Z0-9]*$/);
@@ -4399,25 +4410,28 @@ JSTerm.prototype = {
         value: null,
       };
 
       let response = { matches: newList, matchProp: filterBy };
       this._receiveAutocompleteProperties(null, aCallback, response);
       return;
     }
 
+    this._lastFrameActorId = frameActor;
+
     this.lastCompletion = {
       requestId: requestId,
       completionType: aType,
       value: null,
     };
 
     let callback = this._receiveAutocompleteProperties.bind(this, requestId,
                                                             aCallback);
-    this.webConsoleClient.autocomplete(input, cursor, callback);
+
+    this.webConsoleClient.autocomplete(input, cursor, callback, frameActor);
   },
 
   /**
    * Handler for the autocompletion results. This method takes
    * the completion result received from the server and updates the UI
    * accordingly.
    *
    * @param number aRequestId
diff --git a/toolkit/devtools/server/actors/webconsole.js b/toolkit/devtools/server/actors/webconsole.js
--- a/toolkit/devtools/server/actors/webconsole.js
+++ b/toolkit/devtools/server/actors/webconsole.js
@@ -223,16 +223,23 @@ WebConsoleActor.prototype =
   consoleProgressListener: null,
 
   /**
    * The ConsoleReflowListener instance.
    */
   consoleReflowListener: null,
 
   /**
+   * The JSTerm Helpers names cache.
+   * @private
+   * @type array
+   */
+  _jstermHelpersCache: null,
+
+  /**
    * Getter for the NetworkMonitor.saveRequestAndResponseBodies preference.
    * @type boolean
    */
   get saveRequestAndResponseBodies()
     this._prefs["NetworkMonitor.saveRequestAndResponseBodies"],
 
   actorPrefix: "console",
 
@@ -687,36 +694,54 @@ WebConsoleActor.prototype =
    *
    * @param object aRequest
    *        The request message - what input to autocomplete.
    * @return object
    *         The response message - matched properties.
    */
   onAutocomplete: function WCA_onAutocomplete(aRequest)
   {
-    // TODO: Bug 842682 - use the debugger API for autocomplete in the Web
-    // Console, and provide suggestions from the selected debugger stack frame.
-    // Also, properly reuse _getJSTermHelpers instead of re-implementing it
-    // here.
-    let result = JSPropertyProvider(this.window, aRequest.text,
-                                    aRequest.cursor) || {};
+    let frameActorId = aRequest.frameActor;
+    let dbgObject = null;
+    let environment = null;
+
+    // This is the case of the paused debugger
+    if (frameActorId) {
+      let frameActor = this.conn.getActor(frameActorId);
+      if (frameActor) {
+        let frame = frameActor.frame;
+        environment = frame.environment;
+      }
+      else {
+        Cu.reportError("Web Console Actor: the frame actor was not found: " +
+                       frameActorId);
+      }
+    }
+    // This is the general case (non-paused debugger)
+    else {
+      dbgObject = this.dbg.makeGlobalObjectReference(this.window);
+    }
+
+    let result = JSPropertyProvider(dbgObject, environment, aRequest.text,
+                                    aRequest.cursor, frameActorId) || {};
     let matches = result.matches || [];
     let reqText = aRequest.text.substr(0, aRequest.cursor);
 
     // We consider '$' as alphanumerc because it is used in the names of some
     // helper functions.
     let lastNonAlphaIsDot = /[.][a-zA-Z0-9$]*$/.test(reqText);
     if (!lastNonAlphaIsDot) {
-      let helpers = {
-        sandbox: Object.create(null)
-      };
-      JSTermHelpers(helpers);
-
-      let helperNames = Object.getOwnPropertyNames(helpers.sandbox);
-      matches = matches.concat(helperNames.filter(n => n.startsWith(result.matchProp)));
+      if (!this._jstermHelpersCache) {
+        let helpers = {
+          sandbox: Object.create(null)
+        };
+        JSTermHelpers(helpers);
+        this._jstermHelpersCache = Object.getOwnPropertyNames(helpers.sandbox);
+      }
+      matches = matches.concat(this._jstermHelpersCache.filter(n => n.startsWith(result.matchProp)));
     }
 
     return {
       from: this.actorID,
       matches: matches.sort(),
       matchProp: result.matchProp,
     };
   },
diff --git a/toolkit/devtools/webconsole/client.js b/toolkit/devtools/webconsole/client.js
--- a/toolkit/devtools/webconsole/client.js
+++ b/toolkit/devtools/webconsole/client.js
@@ -116,24 +116,27 @@ WebConsoleClient.prototype = {
    * Autocomplete a JavaScript expression.
    *
    * @param string aString
    *        The code you want to autocomplete.
    * @param number aCursor
    *        Cursor location inside the string. Index starts from 0.
    * @param function aOnResponse
    *        The function invoked when the response is received.
+   * @param string aFrameActor
+   *        The id of the frame actor that made the call.
    */
-  autocomplete: function WCC_autocomplete(aString, aCursor, aOnResponse)
+  autocomplete: function WCC_autocomplete(aString, aCursor, aOnResponse, aFrameActor)
   {
     let packet = {
       to: this._actor,
       type: "autocomplete",
       text: aString,
       cursor: aCursor,
+      frameActor: aFrameActor,
     };
     this._client.request(packet, aOnResponse);
   },
 
   /**
    * Clear the cache of messages (page errors and console API calls).
    */
   clearMessagesCache: function WCC_clearMessagesCache()
diff --git a/toolkit/devtools/webconsole/utils.js b/toolkit/devtools/webconsole/utils.js
--- a/toolkit/devtools/webconsole/utils.js
+++ b/toolkit/devtools/webconsole/utils.js
@@ -736,43 +736,46 @@ function findCompletionBeginning(aStr)
   return {
     state: state,
     startPos: start
   };
 }
 
 /**
  * Provides a list of properties, that are possible matches based on the passed
- * scope and inputValue.
+ * Debugger.Environment/Debugger.Object and inputValue.
  *
- * @param object aScope
- *        Scope to use for the completion.
+ * @param object aDbgObject
+ *        When the debugger is not paused this Debugger.Object wraps the scope for autocompletion.
+ *        It is null if the debugger is paused.
+ * @param object anEnvironment
+ *        When the debugger is paused this Debugger.Environment is the scope for autocompletion.
+ *        It is null if the debugger is not paused.
  * @param string aInputValue
  *        Value that should be completed.
  * @param number [aCursor=aInputValue.length]
  *        Optional offset in the input where the cursor is located. If this is
  *        omitted then the cursor is assumed to be at the end of the input
  *        value.
  * @returns null or object
  *          If no completion valued could be computed, null is returned,
  *          otherwise a object with the following form is returned:
  *            {
  *              matches: [ string, string, string ],
  *              matchProp: Last part of the inputValue that was used to find
  *                         the matches-strings.
  *            }
  */
-function JSPropertyProvider(aScope, aInputValue, aCursor)
+function JSPropertyProvider(aDbgObject, anEnvironment, aInputValue, aCursor)
 {
   if (aCursor === undefined) {
     aCursor = aInputValue.length;
   }
 
   let inputValue = aInputValue.substring(0, aCursor);
-  let obj = WCU.unwrap(aScope);
 
   // Analyse the inputValue and find the beginning of the last part that
   // should be completed.
   let beginning = findCompletionBeginning(inputValue);
 
   // There was an error analysing the string.
   if (beginning.err) {
     return null;
@@ -794,79 +797,231 @@ function JSPropertyProvider(aScope, aInp
   let matches = null;
   let matchProp = "";
 
   let lastDot = completionPart.lastIndexOf(".");
   if (lastDot > 0 &&
       (completionPart[0] == "'" || completionPart[0] == '"') &&
       completionPart[lastDot - 1] == completionPart[0]) {
     // We are completing a string literal.
-    obj = obj.String.prototype;
+    let obj = String.prototype;
     matchProp = completionPart.slice(lastDot + 1);
+    let matches = Object.keys(getMatchedProps(obj, {matchProp:matchProp}));
 
+    return {
+      matchProp: matchProp,
+      matches: matches,
+    };
   }
   else {
     // We are completing a variable / a property lookup.
-
     let properties = completionPart.split(".");
     if (properties.length > 1) {
       matchProp = properties.pop().trimLeft();
-      for (let i = 0; i < properties.length; i++) {
+      let obj;
+
+      //The first property must be found in the environment or the Debugger.Object 
+      //depending of whether the debugger is paused or not
+      let prop = properties[0];
+      if (anEnvironment) {
+        obj = getVariableInEnvironment(anEnvironment, prop);
+      }
+      else {
+        obj = getPropertyInDebuggerObject(aDbgObject, prop);
+      }
+      if (obj == null) {
+        return null;
+      }
+
+      //We get the rest of the properties recursively starting from the Debugger.Object
+      // that wraps the first property
+      for (let i = 1; i < properties.length; i++) {
         let prop = properties[i].trim();
         if (!prop) {
           return null;
         }
 
+        obj = getPropertyInDebuggerObject(obj, prop);
+
         // If obj is undefined or null (which is what "== null" does),
         // then there is no chance to run completion on it. Exit here.
         if (obj == null) {
           return null;
         }
+      }
 
-        // Check if prop is a getter function on obj. Functions can change other
-        // stuff so we can't execute them to get the next object. Stop here.
-        if (WCU.isNonNativeGetter(obj, prop)) {
-          return null;
-        }
-        try {
-          obj = obj[prop];
-        }
-        catch (ex) {
-          return null;
-        }
+      // If the final property is a primitive
+      if (typeof obj != 'object' || obj === null) {
+        matchProp = completionPart.slice(lastDot + 1);
+        let matches = Object.keys(getMatchedProps(obj, {matchProp:matchProp}));
+
+        return {
+          matchProp: matchProp,
+          matches: matches,
+        };
       }
+      return getMatchedPropsInDbgObject(obj, matchProp);
     }
     else {
       matchProp = properties[0].trimLeft();
+      if (anEnvironment) {
+        return getMatchedPropsInEnvironment(anEnvironment, matchProp);
+      }
+      else {
+        if (typeof aDbgObject != 'object' || aDbgObject === null) {
+          matchProp = completionPart.slice(lastDot + 1);
+          let matches = Object.keys(getMatchedProps(aDbgObject, {matchProp:matchProp}));
+
+          return {
+            matchProp: matchProp,
+            matches: matches,
+          };
+        }
+        return getMatchedPropsInDbgObject(aDbgObject, matchProp);
+      }
     }
+  }
+}
 
-    // If obj is undefined or null (which is what "== null" does),
-    // then there is no chance to run completion on it. Exit here.
-    if (obj == null) {
-      return null;
-    }
-
+/**
+ * Returns the value of aProp in anEnvironment as a debuggee value, by recursively checking the environment chain
+ *
+ * @param object anEnvironment
+ *        A Debugger.Environment to look the aProp into.
+ * @param string aProp
+ *        The property that is looked up.
+ * @returns null or object
+ *        A Debugger.Object if aProp exists in the environment chain, null otherwise.
+ */
+function getVariableInEnvironment(anEnvironment, aProp)
+{
+  for (let env = anEnvironment; env; env = env.parent) {
     try {
-      // Skip Iterators and Generators.
-      if (WCU.isIteratorOrGenerator(obj)) {
-        return null;
+      let obj = env.getVariable(aProp);
+      if (obj) {
+        return obj;
       }
     }
     catch (ex) {
-      // The above can throw if |obj| is a dead object.
-      // TODO: we should use Cu.isDeadWrapper() - see bug 885800.
       return null;
     }
   }
+  return null;
+}
 
-  let matches = Object.keys(getMatchedProps(obj, {matchProp:matchProp}));
+/**
+ * Returns the value of aProp in aDbgObject as a debuggee value, by recursively checking the prototype chain
+ *
+ * @param object aDbgObject
+ *        A Debugger.Object to look the aProp into.
+ * @param string aProp
+ *        The property that is looked up.
+ * @returns null or object
+ *        A Debugger.Object if aProp exists in the prototype chain, null otherwise.
+ */
+function getPropertyInDebuggerObject(aDbgObject, aProp)
+{
+  let dbgObject = aDbgObject;
+  while (dbgObject) {
+    try {
+      let desc = dbgObject.getOwnPropertyDescriptor(aProp)
+      if (desc) {
+        let obj = desc.value;
+        if (obj)
+          return obj;
+        obj = desc.get;
+        if (obj)
+          return obj;
+      }
+      dbgObject = dbgObject.proto;
+    }
+    catch (ex) {
+      return null;
+    }
+  }
+  return null;
+}
 
+/**
+ * Get all properties on the given Debugger.Environment (and its parent chain) that match a given prefix.
+ *
+ * @param Debugger.Environment anEnvironment
+ *        Debugger.Environment whose properties we want to filter.
+ *
+ * @param string matchProp Filter for properties that match this one.
+ *
+ * @return object
+ *         Object that contains the matchProp and the list of names.
+ */
+function getMatchedPropsInEnvironment(anEnvironment, matchProp)
+{
+  let names = Object.create(null);
+  let c = MAX_COMPLETIONS;
+  for (let env = anEnvironment; env; env = env.parent) {
+    let ownNames = env.names();
+    for (let i = 0; i < ownNames.length; i++) {
+      if (ownNames[i].indexOf(matchProp) != 0 ||
+        ownNames[i] in names) {
+        continue;
+      }
+      c--;
+      if (c < 0) {
+        return {
+          matchProp: matchProp,
+          matches: Object.keys(names)
+        };
+      }
+      names[ownNames[i]] = true;
+    }
+  }
   return {
     matchProp: matchProp,
-    matches: matches,
+    matches: Object.keys(names)
+  };
+}
+
+/**
+ * Get all properties on the given Debugger.Object (and the prototype chain of the wrapped value) that match a given prefix.
+ *
+ * @param Debugger.Object aDbgObject
+ *        Debugger.Object whose properties we want to filter.
+ *
+ * @param string matchProp Filter for properties that match this one.
+ *
+ * @return object
+ *         Object that contains the matchProp and the list of names.
+ */
+function getMatchedPropsInDbgObject(aDbgObject, matchProp)
+{
+  let names = Object.create(null);
+  let c = MAX_COMPLETIONS;
+  for (let dbg = aDbgObject; dbg; dbg = dbg.proto) {
+    let raw = dbg.unsafeDereference();
+    if (Cu.isDeadWrapper(raw)) {
+      return null;
+    }
+    let ownNames = dbg.getOwnPropertyNames();
+    for (let i = 0; i < ownNames.length; i++) {
+      if (ownNames[i].indexOf(matchProp) != 0 ||
+        ownNames[i] in names) {
+        continue;
+      }
+      c--;
+      if (c < 0) {
+        return {
+          matchProp: matchProp,
+          matches: Object.keys(names)
+        };
+      }
+      names[ownNames[i]] = true;
+    }
+  }
+  return {
+    matchProp: matchProp,
+    matches: Object.keys(names)
   };
 }
 
 /**
  * Get all accessible properties on this JS value.
  * Filter those properties by name.
  * Take only a certain number of those.
  *
