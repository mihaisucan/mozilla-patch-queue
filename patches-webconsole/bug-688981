# HG changeset patch
# Parent 7489a41d60373f5f2d1044a10c018e78c8a5d02d
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1340225715 -10800

Bug 688981 - Place the web console in its own iframe

diff --git a/browser/base/content/browser.xul b/browser/base/content/browser.xul
--- a/browser/base/content/browser.xul
+++ b/browser/base/content/browser.xul
@@ -4,17 +4,16 @@
 #
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 <?xml-stylesheet href="chrome://browser/content/browser.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/content/places/places.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/devtools/common.css" type="text/css"?>
-<?xml-stylesheet href="chrome://browser/skin/devtools/webconsole.css" type="text/css"?>
 <?xml-stylesheet href="chrome://browser/skin/" type="text/css"?>
 
 <?xul-overlay href="chrome://global/content/editMenuOverlay.xul"?>
 <?xul-overlay href="chrome://browser/content/baseMenuOverlay.xul"?>
 <?xul-overlay href="chrome://browser/content/places/placesOverlay.xul"?>
 
 # All DTD information is stored in a separate file so that it can be shared by
 # hiddenWindow.xul.
diff --git a/browser/devtools/jar.mn b/browser/devtools/jar.mn
--- a/browser/devtools/jar.mn
+++ b/browser/devtools/jar.mn
@@ -1,16 +1,18 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 browser.jar:
     content/browser/inspector.html                (highlighter/inspector.html)
     content/browser/NetworkPanel.xhtml            (webconsole/NetworkPanel.xhtml)
     content/browser/devtools/HUDService-content.js (webconsole/HUDService-content.js)
+*   content/browser/devtools/webconsole.js        (webconsole/webconsole.js)
+*   content/browser/devtools/webconsole.xul       (webconsole/webconsole.xul)
 *   content/browser/scratchpad.xul                (scratchpad/scratchpad.xul)
     content/browser/scratchpad.js                 (scratchpad/scratchpad.js)
     content/browser/splitview.css                 (shared/splitview.css)
     content/browser/styleeditor.xul               (styleeditor/styleeditor.xul)
     content/browser/styleeditor.css               (styleeditor/styleeditor.css)
     content/browser/devtools/csshtmltree.xul      (styleinspector/csshtmltree.xul)
     content/browser/devtools/cssruleview.xul      (styleinspector/cssruleview.xul)
     content/browser/devtools/styleinspector.css   (styleinspector/styleinspector.css)
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -8,33 +8,17 @@ const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 const CONSOLEAPI_CLASS_ID = "{b49c18f8-3379-4fc0-8c90-d7772c1a9ff3}";
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
-var EXPORTED_SYMBOLS = ["HUDService", "ConsoleUtils"];
-
-XPCOMUtils.defineLazyServiceGetter(this, "clipboardHelper",
-                                   "@mozilla.org/widget/clipboardhelper;1",
-                                   "nsIClipboardHelper");
-
-XPCOMUtils.defineLazyModuleGetter(this, "PropertyPanel",
-                                  "resource:///modules/PropertyPanel.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "PropertyTreeView",
-                                  "resource:///modules/PropertyPanel.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "AutocompletePopup",
-                                  "resource:///modules/AutocompletePopup.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "NetworkPanel",
-                                  "resource:///modules/NetworkPanel.jsm");
+var EXPORTED_SYMBOLS = ["HUDService"];
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
                                   "resource:///modules/WebConsoleUtils.jsm");
 
 XPCOMUtils.defineLazyGetter(this, "l10n", function() {
   return WebConsoleUtils.l10n;
 });
 
@@ -44,229 +28,65 @@ function LogFactory(aMessagePrefix)
     var _msg = aMessagePrefix + " " + aMessage + "\n";
     dump(_msg);
   }
   return log;
 }
 
 let log = LogFactory("*** HUDService:");
 
-// The amount of time in milliseconds that must pass between messages to
-// trigger the display of a new group.
-const NEW_GROUP_DELAY = 5000;
-
-// The amount of time in milliseconds that we wait before performing a live
-// search.
-const SEARCH_DELAY = 200;
-
-// The number of lines that are displayed in the console output by default, for
-// each category. The user can change this number by adjusting the hidden
-// "devtools.hud.loglimit.{network,cssparser,exception,console}" preferences.
-const DEFAULT_LOG_LIMIT = 200;
-
-// The various categories of messages. We start numbering at zero so we can
-// use these as indexes into the MESSAGE_PREFERENCE_KEYS matrix below.
-const CATEGORY_NETWORK = 0;
-const CATEGORY_CSS = 1;
-const CATEGORY_JS = 2;
-const CATEGORY_WEBDEV = 3;
-const CATEGORY_INPUT = 4;   // always on
-const CATEGORY_OUTPUT = 5;  // always on
-
-// The possible message severities. As before, we start at zero so we can use
-// these as indexes into MESSAGE_PREFERENCE_KEYS.
-const SEVERITY_ERROR = 0;
-const SEVERITY_WARNING = 1;
-const SEVERITY_INFO = 2;
-const SEVERITY_LOG = 3;
-
-// A mapping from the console API log event levels to the Web Console
-// severities.
-const LEVELS = {
-  error: SEVERITY_ERROR,
-  warn: SEVERITY_WARNING,
-  info: SEVERITY_INFO,
-  log: SEVERITY_LOG,
-  trace: SEVERITY_LOG,
-  debug: SEVERITY_LOG,
-  dir: SEVERITY_LOG,
-  group: SEVERITY_LOG,
-  groupCollapsed: SEVERITY_LOG,
-  groupEnd: SEVERITY_LOG,
-  time: SEVERITY_LOG,
-  timeEnd: SEVERITY_LOG
-};
-
-// The lowest HTTP response code (inclusive) that is considered an error.
-const MIN_HTTP_ERROR_CODE = 400;
-// The highest HTTP response code (inclusive) that is considered an error.
-const MAX_HTTP_ERROR_CODE = 599;
-
 // The HTML namespace.
 const HTML_NS = "http://www.w3.org/1999/xhtml";
 
 // The XUL namespace.
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
-// The fragment of a CSS class name that identifies each category.
-const CATEGORY_CLASS_FRAGMENTS = [
-  "network",
-  "cssparser",
-  "exception",
-  "console",
-  "input",
-  "output",
-];
-
-// The fragment of a CSS class name that identifies each severity.
-const SEVERITY_CLASS_FRAGMENTS = [
-  "error",
-  "warn",
-  "info",
-  "log",
-];
-
-// The preference keys to use for each category/severity combination, indexed
-// first by category (rows) and then by severity (columns).
-//
-// Most of these rather idiosyncratic names are historical and predate the
-// division of message type into "category" and "severity".
-const MESSAGE_PREFERENCE_KEYS = [
-//  Error         Warning   Info    Log
-  [ "network",    null,         null,   "networkinfo", ],  // Network
-  [ "csserror",   "cssparser",  null,   null,          ],  // CSS
-  [ "exception",  "jswarn",     null,   null,          ],  // JS
-  [ "error",      "warn",       "info", "log",         ],  // Web Developer
-  [ null,         null,         null,   null,          ],  // Input
-  [ null,         null,         null,   null,          ],  // Output
-];
 
 // Possible directions that can be passed to HUDService.animate().
 const ANIMATE_OUT = 0;
 const ANIMATE_IN = 1;
 
-// Constants used for defining the direction of JSTerm input history navigation.
-const HISTORY_BACK = -1;
-const HISTORY_FORWARD = 1;
-
 // Minimum console height, in pixels.
 const MINIMUM_CONSOLE_HEIGHT = 150;
 
 // Minimum page height, in pixels. This prevents the Web Console from
 // remembering a height that covers the whole page.
 const MINIMUM_PAGE_HEIGHT = 50;
 
 // The default console height, as a ratio from the content window inner height.
 const DEFAULT_CONSOLE_HEIGHT = 0.33;
 
 // This script is inserted into the content process.
 const CONTENT_SCRIPT_URL = "chrome://browser/content/devtools/HUDService-content.js";
 
+// The Web Console UI is loaded in an iframe. This constant points to the file
+// to load in the iframe.
+const UI_IFRAME_URL = "chrome://browser/content/devtools/webconsole.xul";
+
 const ERRORS = { LOG_MESSAGE_MISSING_ARGS:
                  "Missing arguments: aMessage, aConsoleNode and aMessageNode are required.",
                  CANNOT_GET_HUD: "Cannot getHeads Up Display with provided ID",
                  MISSING_ARGS: "Missing arguments",
                  LOG_OUTPUT_FAILED: "Log Failure: Could not append messageNode to outputNode",
 };
 
-// The indent of a console group in pixels.
-const GROUP_INDENT = 12;
-
-// The pref prefix for webconsole filters
-const PREFS_PREFIX = "devtools.webconsole.filter.";
-
-// The number of messages to display in a single display update. If we display
-// too many messages at once we slow the Firefox UI too much.
-const MESSAGES_IN_INTERVAL = DEFAULT_LOG_LIMIT;
-
-// The delay between display updates - tells how often we should *try* to push
-// new messages to screen. This value is optimistic, updates won't always
-// happen. Keep this low so the Web Console output feels live.
-const OUTPUT_INTERVAL = 50; // milliseconds
-
-// When the output queue has more than MESSAGES_IN_INTERVAL items we throttle
-// output updates to this number of milliseconds. So during a lot of output we
-// update every N milliseconds given here.
-const THROTTLE_UPDATES = 1000; // milliseconds
-
-///////////////////////////////////////////////////////////////////////////
-//// Helper for creating the network panel.
-
-/**
- * Creates a DOMNode and sets all the attributes of aAttributes on the created
- * element.
- *
- * @param nsIDOMDocument aDocument
- *        Document to create the new DOMNode.
- * @param string aTag
- *        Name of the tag for the DOMNode.
- * @param object aAttributes
- *        Attributes set on the created DOMNode.
- *
- * @returns nsIDOMNode
- */
-function createElement(aDocument, aTag, aAttributes)
-{
-  let node = aDocument.createElement(aTag);
-  if (aAttributes) {
-    for (let attr in aAttributes) {
-      node.setAttribute(attr, aAttributes[attr]);
-    }
-  }
-  return node;
-}
-
-///////////////////////////////////////////////////////////////////////////
-//// Private utility functions for the HUD service
-
-/**
- * Ensures that the number of message nodes of type aCategory don't exceed that
- * category's line limit by removing old messages as needed.
- *
- * @param aHUDId aHUDId
- *        The HeadsUpDisplay ID.
- * @param integer aCategory
- *        The category of message nodes to limit.
- * @return number
- *         The number of removed nodes.
- */
-function pruneConsoleOutputIfNecessary(aHUDId, aCategory)
-{
-  let hudRef = HUDService.getHudReferenceById(aHUDId);
-  let outputNode = hudRef.outputNode;
-  let logLimit = hudRef.logLimitForCategory(aCategory);
-
-  let messageNodes = outputNode.getElementsByClassName("webconsole-msg-" +
-      CATEGORY_CLASS_FRAGMENTS[aCategory]);
-  let n = Math.max(0, messageNodes.length - logLimit);
-  let toRemove = Array.prototype.slice.call(messageNodes, 0, n);
-  toRemove.forEach(hudRef.removeOutputMessage, hudRef);
-
-  return n;
-}
-
 ///////////////////////////////////////////////////////////////////////////
 //// The HUD service
 
 function HUD_SERVICE()
 {
   // These methods access the "this" object, but they're registered as
   // event listeners. So we hammer in the "this" binding.
   this.onTabClose = this.onTabClose.bind(this);
   this.onWindowUnload = this.onWindowUnload.bind(this);
 
   // Remembers the last console height, in pixels.
   this.lastConsoleHeight = Services.prefs.getIntPref("devtools.hud.height");
 
   /**
-   * Each HeadsUpDisplay has a set of filter preferences
-   */
-  this.filterPrefs = {};
-
-  /**
    * Keeps a reference for each HeadsUpDisplay that is created
    */
   this.hudReferences = {};
 };
 
 HUD_SERVICE.prototype =
 {
   /**
@@ -310,28 +130,22 @@ HUD_SERVICE.prototype =
       return this.hudReferences[hudId];
     }
 
     this.wakeup();
 
     let window = aTab.ownerDocument.defaultView;
     let gBrowser = window.gBrowser;
 
-    // TODO: check that this works as intended
     gBrowser.tabContainer.addEventListener("TabClose", this.onTabClose, false);
     window.addEventListener("unload", this.onWindowUnload, false);
 
-    this.registerDisplay(hudId);
-
-    let hud = new HeadsUpDisplay(aTab);
+    let hud = new WebConsole(aTab);
     this.hudReferences[hudId] = hud;
 
-    // register the controller to handle "select all" properly
-    this.createController(window);
-
     if (!aAnimated || hud.consolePanel) {
       this.disableAnimation(hudId);
     }
 
     HeadsUpDisplayUICommands.refreshCommand();
 
     return hud;
   },
@@ -351,17 +165,40 @@ HUD_SERVICE.prototype =
     if (!(hudId in this.hudReferences)) {
       return;
     }
 
     if (!aAnimated) {
       this.storeHeight(hudId);
     }
 
-    this.unregisterDisplay(hudId);
+    let hud = this.getHudReferenceById(hudId);
+    let document = hud.chromeDocument;
+
+    hud.destroy();
+
+    delete this.hudReferences[hudId];
+
+    if (Object.keys(this.hudReferences).length == 0) {
+      let autocompletePopup = document.
+                              getElementById("webConsole_autocompletePopup");
+      if (autocompletePopup) {
+        autocompletePopup.parentNode.removeChild(autocompletePopup);
+      }
+
+      let window = document.defaultView;
+
+      window.removeEventListener("unload", this.onWindowUnload, false);
+
+      let gBrowser = window.gBrowser;
+      let tabContainer = gBrowser.tabContainer;
+      tabContainer.removeEventListener("TabClose", this.onTabClose, false);
+
+      this.suspend();
+    }
 
     let contentWindow = aTab.linkedBrowser.contentWindow;
     contentWindow.focus();
 
     HeadsUpDisplayUICommands.refreshCommand();
 
     let id = WebConsoleUtils.supportsString(hudId);
     Services.obs.notifyObservers(id, "web-console-destroyed", null);
@@ -376,257 +213,16 @@ HUD_SERVICE.prototype =
   {
     if (!this.sequencer) {
       this.sequencer = this.createSequencer(-1);
     }
     return this.sequencer.next();
   },
 
   /**
-   * get the default filter prefs
-   *
-   * @param string aHUDId
-   * @returns JS Object
-   */
-  getDefaultFilterPrefs: function HS_getDefaultFilterPrefs(aHUDId) {
-    return this.filterPrefs[aHUDId];
-  },
-
-  /**
-   * get the current filter prefs
-   *
-   * @param string aHUDId
-   * @returns JS Object
-   */
-  getFilterPrefs: function HS_getFilterPrefs(aHUDId) {
-    return this.filterPrefs[aHUDId];
-  },
-
-  /**
-   * get the filter state for a specific toggle button on a heads up display
-   *
-   * @param string aHUDId
-   * @param string aToggleType
-   * @returns boolean
-   */
-  getFilterState: function HS_getFilterState(aHUDId, aToggleType)
-  {
-    if (!aHUDId) {
-      return false;
-    }
-    try {
-      var bool = this.filterPrefs[aHUDId][aToggleType];
-      return bool;
-    }
-    catch (ex) {
-      return false;
-    }
-  },
-
-  /**
-   * set the filter state for a specific toggle button on a heads up display
-   *
-   * @param string aHUDId
-   * @param string aToggleType
-   * @param boolean aState
-   * @returns void
-   */
-  setFilterState: function HS_setFilterState(aHUDId, aToggleType, aState)
-  {
-    this.filterPrefs[aHUDId][aToggleType] = aState;
-    this.adjustVisibilityForMessageType(aHUDId, aToggleType, aState);
-    Services.prefs.setBoolPref(PREFS_PREFIX + aToggleType, aState);
-  },
-
-  /**
-   * Splits the given console messages into groups based on their timestamps.
-   *
-   * @param nsIDOMNode aOutputNode
-   *        The output node to alter.
-   * @returns void
-   */
-  regroupOutput: function HS_regroupOutput(aOutputNode)
-  {
-    // Go through the nodes and adjust the placement of "webconsole-new-group"
-    // classes.
-    let nodes = aOutputNode.querySelectorAll(".hud-msg-node" +
-      ":not(.hud-filtered-by-string):not(.hud-filtered-by-type)");
-    let lastTimestamp;
-    for (let i = 0, n = nodes.length; i < n; i++) {
-      let thisTimestamp = nodes[i].timestamp;
-      if (lastTimestamp != null &&
-          thisTimestamp >= lastTimestamp + NEW_GROUP_DELAY) {
-        nodes[i].classList.add("webconsole-new-group");
-      }
-      else {
-        nodes[i].classList.remove("webconsole-new-group");
-      }
-      lastTimestamp = thisTimestamp;
-    }
-  },
-
-  /**
-   * Turns the display of log nodes on and off appropriately to reflect the
-   * adjustment of the message type filter named by @aPrefKey.
-   *
-   * @param string aHUDId
-   *        The ID of the HUD to alter.
-   * @param string aPrefKey
-   *        The preference key for the message type being filtered: one of the
-   *        values in the MESSAGE_PREFERENCE_KEYS table.
-   * @param boolean aState
-   *        True if the filter named by @aMessageType is being turned on; false
-   *        otherwise.
-   * @returns void
-   */
-  adjustVisibilityForMessageType:
-  function HS_adjustVisibilityForMessageType(aHUDId, aPrefKey, aState)
-  {
-    let outputNode = this.getHudReferenceById(aHUDId).outputNode;
-    let doc = outputNode.ownerDocument;
-
-    // Look for message nodes ("hud-msg-node") with the given preference key
-    // ("hud-msg-error", "hud-msg-cssparser", etc.) and add or remove the
-    // "hud-filtered-by-type" class, which turns on or off the display.
-
-    let xpath = ".//*[contains(@class, 'hud-msg-node') and " +
-      "contains(concat(@class, ' '), 'hud-" + aPrefKey + " ')]";
-    let result = doc.evaluate(xpath, outputNode, null,
-      Ci.nsIDOMXPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
-    for (let i = 0; i < result.snapshotLength; i++) {
-      let node = result.snapshotItem(i);
-      if (aState) {
-        node.classList.remove("hud-filtered-by-type");
-      }
-      else {
-        node.classList.add("hud-filtered-by-type");
-      }
-    }
-
-    this.regroupOutput(outputNode);
-  },
-
-  /**
-   * Check that the passed string matches the filter arguments.
-   *
-   * @param String aString
-   *        to search for filter words in.
-   * @param String aFilter
-   *        is a string containing all of the words to filter on.
-   * @returns boolean
-   */
-  stringMatchesFilters: function stringMatchesFilters(aString, aFilter)
-  {
-    if (!aFilter || !aString) {
-      return true;
-    }
-
-    let searchStr = aString.toLowerCase();
-    let filterStrings = aFilter.toLowerCase().split(/\s+/);
-    return !filterStrings.some(function (f) {
-      return searchStr.indexOf(f) == -1;
-    });
-  },
-
-  /**
-   * Turns the display of log nodes on and off appropriately to reflect the
-   * adjustment of the search string.
-   *
-   * @param string aHUDId
-   *        The ID of the HUD to alter.
-   * @param string aSearchString
-   *        The new search string.
-   * @returns void
-   */
-  adjustVisibilityOnSearchStringChange:
-  function HS_adjustVisibilityOnSearchStringChange(aHUDId, aSearchString)
-  {
-    let outputNode = this.getHudReferenceById(aHUDId).outputNode;
-
-    let nodes = outputNode.getElementsByClassName("hud-msg-node");
-
-    for (let i = 0, n = nodes.length; i < n; ++i) {
-      let node = nodes[i];
-
-      // hide nodes that match the strings
-      let text = node.clipboardText;
-
-      // if the text matches the words in aSearchString...
-      if (this.stringMatchesFilters(text, aSearchString)) {
-        node.classList.remove("hud-filtered-by-string");
-      }
-      else {
-        node.classList.add("hud-filtered-by-string");
-      }
-    }
-
-    this.regroupOutput(outputNode);
-  },
-
-  /**
-   * Register a new Heads Up Display
-   *
-   * @returns void
-   */
-  registerDisplay: function HS_registerDisplay(aHUDId)
-  {
-    // register a display DOM node Id with the service.
-    if (!aHUDId){
-      throw new Error(ERRORS.MISSING_ARGS);
-    }
-    this.filterPrefs[aHUDId] = {
-      network: Services.prefs.getBoolPref(PREFS_PREFIX + "network"),
-      networkinfo: Services.prefs.getBoolPref(PREFS_PREFIX + "networkinfo"),
-      csserror: Services.prefs.getBoolPref(PREFS_PREFIX + "csserror"),
-      cssparser: Services.prefs.getBoolPref(PREFS_PREFIX + "cssparser"),
-      exception: Services.prefs.getBoolPref(PREFS_PREFIX + "exception"),
-      jswarn: Services.prefs.getBoolPref(PREFS_PREFIX + "jswarn"),
-      error: Services.prefs.getBoolPref(PREFS_PREFIX + "error"),
-      info: Services.prefs.getBoolPref(PREFS_PREFIX + "info"),
-      warn: Services.prefs.getBoolPref(PREFS_PREFIX + "warn"),
-      log: Services.prefs.getBoolPref(PREFS_PREFIX + "log"),
-    };
-  },
-
-  /**
-   * When a display is being destroyed, unregister it first
-   *
-   * @param string aHUDId
-   *        The ID of a HUD.
-   * @returns void
-   */
-  unregisterDisplay: function HS_unregisterDisplay(aHUDId)
-  {
-    let hud = this.getHudReferenceById(aHUDId);
-    let document = hud.chromeDocument;
-
-    hud.destroy();
-
-    delete this.hudReferences[aHUDId];
-
-    if (Object.keys(this.hudReferences).length == 0) {
-      let autocompletePopup = document.
-                              getElementById("webConsole_autocompletePopup");
-      if (autocompletePopup) {
-        autocompletePopup.parentNode.removeChild(autocompletePopup);
-      }
-
-      let window = document.defaultView;
-
-      window.removeEventListener("unload", this.onWindowUnload, false);
-
-      let gBrowser = window.gBrowser;
-      let tabContainer = gBrowser.tabContainer;
-      tabContainer.removeEventListener("TabClose", this.onTabClose, false);
-
-      this.suspend();
-    }
-  },
-
-  /**
    * "Wake up" the Web Console activity. This is called when the first Web
    * Console is open. This method initializes the various observers we have.
    *
    * @returns void
    */
   wakeup: function HS_wakeup()
   {
     if (Object.keys(this.hudReferences).length > 0) {
@@ -639,17 +235,16 @@ HUD_SERVICE.prototype =
   /**
    * Suspend Web Console activity. This is called when all Web Consoles are
    * closed.
    *
    * @returns void
    */
   suspend: function HS_suspend()
   {
-    delete this.defaultFilterPrefs;
     delete this.lastFinishedRequestCallback;
 
     WebConsoleObserver.uninit();
   },
 
   /**
    * Shutdown all HeadsUpDisplays on quit-application-granted.
    *
@@ -702,84 +297,25 @@ HUD_SERVICE.prototype =
    * @returns Object
    */
   getHudReferenceById: function HS_getHudReferenceById(aId)
   {
     return aId in this.hudReferences ? this.hudReferences[aId] : null;
   },
 
   /**
-   * Get the current filter string for the HeadsUpDisplay
-   *
-   * @param string aHUDId
-   * @returns string
-   */
-  getFilterStringByHUDId: function HS_getFilterStringbyHUDId(aHUDId) {
-    return this.getHudReferenceById(aHUDId).filterBox.value;
-  },
-
-  /**
-   * Update the filter text in the internal tracking object for all
-   * filter strings
-   *
-   * @param nsIDOMNode aTextBoxNode
-   * @returns void
-   */
-  updateFilterText: function HS_updateFiltertext(aTextBoxNode)
-  {
-    var hudId = aTextBoxNode.getAttribute("hudId");
-    this.adjustVisibilityOnSearchStringChange(hudId, aTextBoxNode.value);
-  },
-
-  /**
    * Assign a function to this property to listen for every request that
    * completes. Used by unit tests. The callback takes one argument: the HTTP
    * activity object as received from the remote Web Console.
    *
    * @type function
    */
   lastFinishedRequestCallback: null,
 
   /**
-   * Opens a NetworkPanel.
-   *
-   * @param nsIDOMNode aNode
-   *        The message node you want the panel to be anchored to.
-   * @param object aHttpActivity
-   *        The HTTP activity object that holds network request and response
-   *        information. This object is given to the NetworkPanel constructor.
-   * @return object
-   *         The new NetworkPanel instance.
-   */
-  openNetworkPanel: function HS_openNetworkPanel(aNode, aHttpActivity)
-  {
-    let doc = aNode.ownerDocument;
-    let parent = doc.getElementById("mainPopupSet");
-    let netPanel = new NetworkPanel(parent, aHttpActivity);
-    netPanel.linkNode = aNode;
-    aNode._netPanel = netPanel;
-
-    let panel = netPanel.panel;
-    panel.openPopup(aNode, "after_pointer", 0, 0, false, false);
-    panel.sizeTo(450, 500);
-    panel.setAttribute("hudId", aHttpActivity.hudId);
-
-    panel.addEventListener("popuphiding", function HS_netPanel_onHide() {
-      panel.removeEventListener("popuphiding", HS_netPanel_onHide);
-
-      aNode._panelOpen = false;
-      aNode._netPanel = null;
-    });
-
-    aNode._panelOpen = true;
-
-    return netPanel;
-  },
-
-  /**
    * Creates a generator that always returns a unique number for use in the
    * indexes
    *
    * @returns Generator
    */
   createSequencer: function HS_createSequencer(aInt)
   {
     function sequencer(aInt)
@@ -822,52 +358,31 @@ HUD_SERVICE.prototype =
 
     tabContainer.removeEventListener("TabClose", this.onTabClose, false);
 
     let tab = tabContainer.firstChild;
     while (tab != null) {
       this.deactivateHUDForContext(tab, false);
       tab = tab.nextSibling;
     }
-
-    if (window.webConsoleCommandController) {
-      window.controllers.removeController(window.webConsoleCommandController);
-      window.webConsoleCommandController = null;
-    }
-  },
-
-  /**
-   * Adds the command controller to the XUL window if it's not already present.
-   *
-   * @param nsIDOMWindow aWindow
-   *        The browser XUL window.
-   * @returns void
-   */
-  createController: function HS_createController(aWindow)
-  {
-    if (!aWindow.webConsoleCommandController) {
-      aWindow.webConsoleCommandController = new CommandController(aWindow);
-      aWindow.controllers.insertControllerAt(0,
-        aWindow.webConsoleCommandController);
-    }
   },
 
   /**
    * Animates the Console appropriately.
    *
    * @param string aHUDId The ID of the console.
    * @param string aDirection Whether to animate the console appearing
    *        (ANIMATE_IN) or disappearing (ANIMATE_OUT).
    * @param function aCallback An optional callback, which will be called with
    *        the "transitionend" event passed as a parameter once the animation
    *        finishes.
    */
   animate: function HS_animate(aHUDId, aDirection, aCallback)
   {
-    let hudBox = this.getHudReferenceById(aHUDId).HUDBox;
+    let hudBox = this.getHudReferenceById(aHUDId).iframe;
     if (!hudBox.classList.contains("animated")) {
       if (aCallback) {
         aCallback();
       }
       return;
     }
 
     switch (aDirection) {
@@ -888,279 +403,318 @@ HUD_SERVICE.prototype =
    * Disables all animation for a console, for unit testing. After this call,
    * the console will instantly take on a reasonable height, and the close
    * animation will not occur.
    *
    * @param string aHUDId The ID of the console.
    */
   disableAnimation: function HS_disableAnimation(aHUDId)
   {
-    let hudBox = HUDService.hudReferences[aHUDId].HUDBox;
+    let hudBox = HUDService.hudReferences[aHUDId].iframe;
     if (hudBox.classList.contains("animated")) {
       hudBox.classList.remove("animated");
       this.resetHeight(aHUDId);
     }
   },
 
   /**
    * Reset the height of the Web Console.
    *
    * @param string aHUDId The ID of the Web Console.
    */
   resetHeight: function HS_resetHeight(aHUDId)
   {
     let HUD = this.hudReferences[aHUDId];
-    let innerHeight = HUD.browser.clientHeight;
+    let innerHeight = HUD.tab.linkedBrowser.clientHeight;
     let chromeWindow = HUD.chromeWindow;
     if (!HUD.consolePanel) {
       let splitterStyle = chromeWindow.getComputedStyle(HUD.splitter, null);
       innerHeight += parseInt(splitterStyle.height) +
                      parseInt(splitterStyle.borderTopWidth) +
                      parseInt(splitterStyle.borderBottomWidth);
     }
 
-    let boxStyle = chromeWindow.getComputedStyle(HUD.HUDBox, null);
+    let boxStyle = chromeWindow.getComputedStyle(HUD.iframe, null);
     innerHeight += parseInt(boxStyle.height) +
                    parseInt(boxStyle.borderTopWidth) +
                    parseInt(boxStyle.borderBottomWidth);
 
     let height = this.lastConsoleHeight > 0 ? this.lastConsoleHeight :
       Math.ceil(innerHeight * DEFAULT_CONSOLE_HEIGHT);
 
     if ((innerHeight - height) < MINIMUM_PAGE_HEIGHT) {
       height = innerHeight - MINIMUM_PAGE_HEIGHT;
     }
 
     if (isNaN(height) || height < MINIMUM_CONSOLE_HEIGHT) {
       height = MINIMUM_CONSOLE_HEIGHT;
     }
 
-    HUD.HUDBox.style.height = height + "px";
+    HUD.iframe.style.height = height + "px";
   },
 
   /**
    * Remember the height of the given Web Console, such that it can later be
    * reused when other Web Consoles are open.
    *
    * @param string aHUDId The ID of the Web Console.
    */
   storeHeight: function HS_storeHeight(aHUDId)
   {
-    let hudBox = this.hudReferences[aHUDId].HUDBox;
+    let hudBox = this.hudReferences[aHUDId].iframe;
     let window = hudBox.ownerDocument.defaultView;
     let style = window.getComputedStyle(hudBox, null);
     let height = parseInt(style.height);
     height += parseInt(style.borderTopWidth);
     height += parseInt(style.borderBottomWidth);
     this.lastConsoleHeight = height;
 
     let pref = Services.prefs.getIntPref("devtools.hud.height");
     if (pref > -1) {
       Services.prefs.setIntPref("devtools.hud.height", height);
     }
   },
+};
+
+
+/**
+ * A WebConsole instance is an interactive console initialized *per tab*
+ * that displays console log data as well as provides an interactive terminal to
+ * manipulate the current tab's document content.
+ *
+ * This object only wraps the iframe that holds the Web Console UI.
+ *
+ * @param nsIDOMElement aTab
+ *        The xul:tab for which you want the WebConsole object.
+ */
+// TODO: update comment
+function WebConsole(aTab)
+{
+  this.tab = aTab;
+  this._onIframeLoad = this._onIframeLoad.bind(this);
+  this._asyncRequests = {};
+  this._init();
+}
+
+WebConsole.prototype = {
+  get lastFinishedRequestCallback() HUDService.lastFinishedRequestCallback,
 
   /**
-   * Copies the selected items to the system clipboard.
+   * Track callback functions registered for specific async requests sent to
+   * the content process.
    *
-   * @param nsIDOMNode aOutputNode
-   *        The output node.
-   * @returns void
-   */
-  copySelectedItems: function HS_copySelectedItems(aOutputNode)
-  {
-    // Gather up the selected items and concatenate their clipboard text.
-
-    let strings = [];
-    let newGroup = false;
-
-    let children = aOutputNode.children;
-
-    for (let i = 0; i < children.length; i++) {
-      let item = children[i];
-      if (!item.selected) {
-        continue;
-      }
-
-      // Add dashes between groups so that group boundaries show up in the
-      // copied output.
-      if (i > 0 && item.classList.contains("webconsole-new-group")) {
-        newGroup = true;
-      }
-
-      // Ensure the selected item hasn't been filtered by type or string.
-      if (!item.classList.contains("hud-filtered-by-type") &&
-          !item.classList.contains("hud-filtered-by-string")) {
-        let timestampString = l10n.timestampString(item.timestamp);
-        if (newGroup) {
-          strings.push("--");
-          newGroup = false;
-        }
-        strings.push("[" + timestampString + "] " + item.clipboardText);
-      }
-    }
-    clipboardHelper.copyString(strings.join("\n"));
-  }
-};
-
-//////////////////////////////////////////////////////////////////////////
-// HeadsUpDisplay
-//////////////////////////////////////////////////////////////////////////
-
-/**
- * HeadsUpDisplay is an interactive console initialized *per tab*  that
- * displays console log data as well as provides an interactive terminal to
- * manipulate the current tab's document content.
- *
- * @param nsIDOMElement aTab
- *        The xul:tab for which you want the HeadsUpDisplay object.
- */
-function HeadsUpDisplay(aTab)
-{
-  this.tab = aTab;
-  this.hudId = "hud_" + this.tab.linkedPanel;
-  this.chromeDocument = this.tab.ownerDocument;
-  this.chromeWindow = this.chromeDocument.defaultView;
-  this.notificationBox = this.chromeDocument.getElementById(this.tab.linkedPanel);
-  this.browser = this.tab.linkedBrowser;
-  this.messageManager = this.browser.messageManager;
-
-  // Track callback functions registered for specific async requests sent to the
-  // content process.
-  this.asyncRequests = {};
-
-  // create a panel dynamically and attach to the parentNode
-  this.createHUD();
-
-  this._outputQueue = [];
-  this._pruneCategoriesQueue = {};
-
-  // create the JSTerm input element
-  this.jsterm = new JSTerm(this);
-  this.jsterm.inputNode.focus();
-
-  // A cache for tracking repeated CSS Nodes.
-  this.cssNodes = {};
-
-  this._networkRequests = {};
-
-  this._setupMessageManager();
-}
-
-HeadsUpDisplay.prototype = {
-  /**
-   * Holds the network requests currently displayed by the Web Console. Each key
-   * represents the connection ID and the value is network request information.
    * @private
    * @type object
    */
-  _networkRequests: null,
-
-  /**
-   * Last time when we displayed any message in the output.
-   *
-   * @private
-   * @type number
-   *       Timestamp in milliseconds since the Unix epoch.
-   */
-  _lastOutputFlush: 0,
-
-  /**
-   * Message nodes are stored here in a queue for later display.
-   *
-   * @private
-   * @type array
-   */
-  _outputQueue: null,
-
-  /**
-   * Keep track of the categories we need to prune from time to time.
-   *
-   * @private
-   * @type array
-   */
-  _pruneCategoriesQueue: null,
+  _asyncRequests: null,
 
   /**
    * Message names that the HUD listens for. These messages come from the remote
    * Web Console content script.
    *
    * @private
    * @type array
    */
   _messageListeners: ["JSTerm:EvalObject", "WebConsole:ConsoleAPI",
     "WebConsole:CachedMessages", "WebConsole:PageError", "JSTerm:EvalResult",
     "JSTerm:AutocompleteProperties", "JSTerm:ClearOutput",
     "JSTerm:InspectObject", "WebConsole:NetworkActivity",
     "WebConsole:FileActivity", "WebConsole:LocationChange",
     "JSTerm:NonNativeConsoleAPI"],
 
-  consolePanel: null,
+  _init: function WC__init()
+  {
+    this.chromeDocument = this.tab.ownerDocument;
+    this.chromeWindow = this.chromeDocument.defaultView;
+    this.messageManager = this.tab.linkedBrowser.messageManager;
+    this.hudId = "hud_" + this.tab.linkedPanel;
+    this.notificationBox = this.chromeDocument.getElementById(this.tab.linkedPanel);
 
-  contentLocation: "",
+    this._initUI();
+  },
+
+  _initUI: function WC__initUI()
+  {
+    this.splitter = this.chromeDocument.createElement("splitter");
+    this.splitter.setAttribute("class", "hud-splitter");
+
+    this.iframe = this.chromeDocument.createElement("iframe");
+    this.iframe.setAttribute("id", this.hudId);
+    this.iframe.setAttribute("class", "hud-box animated");
+    this.iframe.style.height = 0;
+    this.iframe.addEventListener("load", this._onIframeLoad, true);
+    this.iframe.setAttribute("src", UI_IFRAME_URL);
+
+    let position = Services.prefs.getCharPref("devtools.webconsole.position");
+    this.positionConsole(position);
+  },
+
+  _onIframeLoad: function WC__onIframeLoad()
+  {
+    this.iframe.removeEventListener("load", this._onIframeLoad, true);
+
+    this.iframeWindow = this.iframe.contentWindow.wrappedJSObject;
+    this.ui = new this.iframeWindow.WebConsoleFrame(this);
+    this.ui.positionConsole(this._currentUIPosition, this.iframeWindow);
+    this._setupMessageManager();
+  },
 
   /**
-   * The nesting depth of the currently active console group.
+   * Setup the message manager used to communicate with the Web Console content
+   * script. This method loads the content script, adds the message listeners
+   * and initializes the connection to the content script.
+   *
+   * @private
    */
-  groupDepth: 0,
+  _setupMessageManager: function HUD__setupMessageManager()
+  {
+    this.messageManager.loadFrameScript(CONTENT_SCRIPT_URL, true);
 
-  _saveRequestAndResponseBodies: false,
-
-  /**
-   * Tells whether to save the bodies of network requests and responses.
-   * Disabled by default to save memory.
-   * @type boolean
-   */
-  get saveRequestAndResponseBodies() this._saveRequestAndResponseBodies,
-
-  /**
-   * Setter for saving of network request and response bodies.
-   *
-   * @param boolean aValue
-   *        The new value you want to set.
-   */
-  set saveRequestAndResponseBodies(aValue) {
-    this._saveRequestAndResponseBodies = aValue;
+    this._messageListeners.forEach(function(aName) {
+      this.messageManager.addMessageListener(aName, this.ui);
+    }, this);
 
     let message = {
+      features: ["ConsoleAPI", "JSTerm", "PageError", "NetworkMonitor",
+                 "LocationChange"],
+      cachedMessages: ["ConsoleAPI", "PageError"],
+      NetworkMonitor: { monitorFileActivity: true },
+      JSTerm: { notifyNonNativeConsoleAPI: true },
       preferences: {
         "NetworkMonitor.saveRequestAndResponseBodies":
-          this._saveRequestAndResponseBodies,
+          this.ui.saveRequestAndResponseBodies,
       },
     };
 
-    this.sendMessageToContent("WebConsole:SetPreferences", message);
+    this.sendMessageToContent("WebConsole:Init", message);
   },
 
-  get mainPopupSet()
+  /**
+   * Callback method for when the Web Console initialization is complete. For
+   * now this method sends the web-console-created notification using the
+   * nsIObserverService.
+   *
+   * @private
+   */
+  _onInitComplete: function HUD__onInitComplete()
   {
-    return this.chromeDocument.getElementById("mainPopupSet");
+    let id = WebConsoleUtils.supportsString(this.hudId);
+    Services.obs.notifyObservers(id, "web-console-created", null);
   },
 
   /**
+   * Handler for messages that have an associated callback function. The
+   * this.sendMessageToContent() allows one to provide a function to be invoked
+   * when the content script replies to the message previously sent. This is the
+   * method that invokes the callback.
+   *
+   * @see this.sendMessageToContent
+   * @private
+   * @param object aResponse
+   *        Message object received from the content script.
+   */
+  _receiveMessageWithCallback:
+  function HUD__receiveMessageWithCallback(aResponse)
+  {
+    if (aResponse.id in this._asyncRequests) {
+      let request = this._asyncRequests[aResponse.id];
+      request.callback(aResponse, request.message);
+      delete this._asyncRequests[aResponse.id];
+    }
+    else {
+      Cu.reportError("receiveMessageWithCallback response for stale request " +
+                     "ID " + aResponse.id);
+    }
+  },
+
+  /**
+   * Send a message to the content script.
+   *
+   * @param string aName
+   *        The name of the message you want to send.
+   *
+   * @param object aMessage
+   *        The message object you want to send. This object needs to have no
+   *        cyclic references and it needs to be JSON-stringifiable.
+   *
+   * @param function [aCallback]
+   *        Optional function you want to have called when the content script
+   *        replies to your message. Your callback receives two arguments:
+   *        (1) the response object from the content script and (2) the message
+   *        you sent to the content script (which is aMessage here).
+   */
+  sendMessageToContent:
+  function HUD_sendMessageToContent(aName, aMessage, aCallback)
+  {
+    aMessage.hudId = this.hudId;
+    if (!("id" in aMessage)) {
+      aMessage.id = "HUDChrome-" + HUDService.sequenceId();
+    }
+
+    if (aCallback) {
+      this._asyncRequests[aMessage.id] = {
+        name: aName,
+        message: aMessage,
+        callback: aCallback,
+      };
+    }
+    this.messageManager.sendAsyncMessage(aName, aMessage);
+  },
+
+  consolePanel: null,
+
+  positions: {
+    above: 0, // the childNode index
+    below: 2,
+    window: null
+  },
+
+  consoleWindowUnregisterOnHide: true,
+
+  get mainPopupSet() this.chromeDocument.getElementById("mainPopupSet"),
+
+  get outputNode()
+  {
+    return this.ui ? this.ui.outputNode : null;
+  },
+
+  get jsterm()
+  {
+    return this.ui ? this.ui.jsterm : null;
+  },
+
+  setFilterState: function WC_setFilterState()
+  {
+    this.ui && this.ui.setFilterState.apply(this.ui, arguments);
+  },
+
+  get gViewSourceUtils() this.chromeWindow.gViewSourceUtils,
+
+  /**
    * Create a panel to open the web console if it should float above
    * the content in its own window.
+   * @private
    */
-  createOwnWindowPanel: function HUD_createOwnWindowPanel()
+  _createOwnWindowPanel: function WC__createOwnWindowPanel()
   {
-    if (this.uiInOwnWindow) {
-      return this.consolePanel;
+    if (this.consolePanel) {
+      return;
     }
 
     let width = 0;
     try {
       width = Services.prefs.getIntPref("devtools.webconsole.width");
     }
     catch (ex) {}
 
     if (width < 1) {
-      width = this.HUDBox.clientWidth || this.chromeWindow.innerWidth;
+      width = this.iframe.clientWidth || this.chromeWindow.innerWidth;
     }
 
-    let height = this.HUDBox.clientHeight;
+    let height = this.iframe.clientHeight;
 
     let top = 0;
     try {
       top = Services.prefs.getIntPref("devtools.webconsole.top");
     }
     catch (ex) {}
 
     let left = 0;
@@ -1193,27 +747,22 @@ HeadsUpDisplay.prototype = {
 
     let onPopupShown = (function HUD_onPopupShown() {
       panel.removeEventListener("popupshown", onPopupShown, false);
 
       // Make sure that the HUDBox size updates when the panel is resized.
 
       let height = panel.clientHeight;
 
-      this.HUDBox.style.height = "auto";
-      this.HUDBox.setAttribute("flex", "1");
+      this.iframe.style.height = "auto";
+      this.iframe.setAttribute("flex", "1");
 
       panel.setAttribute("height", height);
 
-      // Scroll the outputNode back to the last location.
-      if (lastIndex > -1 && lastIndex < this.outputNode.getRowCount()) {
-        this.outputNode.ensureIndexIsVisible(lastIndex);
-      }
-
-      this.jsterm.inputNode.focus();
+      this._afterPositionConsole("window", lastIndex);
     }).bind(this);
 
     panel.addEventListener("popupshown", onPopupShown,false);
 
     let onPopupHidden = (function HUD_onPopupHidden(aEvent) {
       if (aEvent.target != panel) {
         return;
       }
@@ -1235,25 +784,25 @@ HeadsUpDisplay.prototype = {
         HUDService.deactivateHUDForContext(this.tab, false);
       }
     }).bind(this);
 
     panel.addEventListener("popuphidden", onPopupHidden, false);
 
     let lastIndex = -1;
 
-    if (this.outputNode.getIndexOfFirstVisibleRow) {
+    if (this.outputNode && this.outputNode.getIndexOfFirstVisibleRow) {
       lastIndex = this.outputNode.getIndexOfFirstVisibleRow() +
                   this.outputNode.getNumberOfVisibleRows() - 1;
     }
 
     if (this.splitter.parentNode) {
       this.splitter.parentNode.removeChild(this.splitter);
     }
-    panel.appendChild(this.HUDBox);
+    panel.appendChild(this.iframe);
 
     let space = this.chromeDocument.createElement("spacer");
     space.setAttribute("flex", "1");
 
     let bottomBox = this.chromeDocument.createElement("hbox");
     space.setAttribute("flex", "1");
 
     let resizer = this.chromeDocument.createElement("resizer");
@@ -1262,1232 +811,108 @@ HeadsUpDisplay.prototype = {
 
     bottomBox.appendChild(space);
     bottomBox.appendChild(resizer);
 
     panel.appendChild(bottomBox);
 
     this.mainPopupSet.appendChild(panel);
 
-    Services.prefs.setCharPref("devtools.webconsole.position", "window");
-
     panel.openPopup(null, "overlay", left, top, false, false);
 
     this.consolePanel = panel;
     this.consoleWindowUnregisterOnHide = true;
-
-    return panel;
   },
 
   /**
-   * Retrieve the Web Console panel title.
+   * Position the Web Console UI.
    *
-   * @return string
-   *         The Web Console panel title.
+   * @param string aPosition
+   *        The desired Web Console UI location: above, below or window.
    */
-  getPanelTitle: function HUD_getPanelTitle()
-  {
-    return l10n.getFormatStr("webConsoleWindowTitleAndURL", [this.contentLocation]);
-  },
-
-  positions: {
-    above: 0, // the childNode index
-    below: 2,
-    window: null
-  },
-
-  consoleWindowUnregisterOnHide: true,
-
-  /**
-   * Re-position the console
-   */
-  positionConsole: function HUD_positionConsole(aPosition)
+  positionConsole: function WC_positionConsole(aPosition)
   {
     if (!(aPosition in this.positions)) {
       throw new Error("Incorrect argument: " + aPosition +
         ". Cannot position Web Console");
     }
 
     if (aPosition == "window") {
-      let closeButton = this.consoleFilterToolbar.
-        querySelector(".webconsole-close-button");
-      closeButton.setAttribute("hidden", "true");
-      this.createOwnWindowPanel();
-      this.positionMenuitems.window.setAttribute("checked", true);
-      if (this.positionMenuitems.last) {
-        this.positionMenuitems.last.setAttribute("checked", false);
-      }
-      this.positionMenuitems.last = this.positionMenuitems[aPosition];
-      this.uiInOwnWindow = true;
+      this._createOwnWindowPanel();
       return;
     }
 
-    let height = this.HUDBox.clientHeight;
+    let height = this.iframe.clientHeight;
 
     // get the node position index
     let nodeIdx = this.positions[aPosition];
     let nBox = this.notificationBox;
     let node = nBox.childNodes[nodeIdx];
 
     // check to see if console is already positioned in aPosition
-    if (node == this.HUDBox) {
+    if (node == this.iframe) {
       return;
     }
 
     let lastIndex = -1;
 
-    if (this.outputNode.getIndexOfFirstVisibleRow) {
+    if (this.outputNode && this.outputNode.getIndexOfFirstVisibleRow) {
       lastIndex = this.outputNode.getIndexOfFirstVisibleRow() +
                   this.outputNode.getNumberOfVisibleRows() - 1;
     }
 
     // remove the console and splitter and reposition
     if (this.splitter.parentNode) {
       this.splitter.parentNode.removeChild(this.splitter);
     }
 
     if (aPosition == "below") {
       nBox.appendChild(this.splitter);
-      nBox.appendChild(this.HUDBox);
+      nBox.appendChild(this.iframe);
     }
     else {
       nBox.insertBefore(this.splitter, node);
-      nBox.insertBefore(this.HUDBox, this.splitter);
+      nBox.insertBefore(this.iframe, this.splitter);
     }
 
-    this.positionMenuitems[aPosition].setAttribute("checked", true);
-    if (this.positionMenuitems.last) {
-      this.positionMenuitems.last.setAttribute("checked", false);
-    }
-    this.positionMenuitems.last = this.positionMenuitems[aPosition];
-
-    Services.prefs.setCharPref("devtools.webconsole.position", aPosition);
-
-    if (lastIndex > -1 && lastIndex < this.outputNode.getRowCount()) {
-      this.outputNode.ensureIndexIsVisible(lastIndex);
-    }
-
-    let closeButton = this.consoleFilterToolbar.
-      getElementsByClassName("webconsole-close-button")[0];
-    closeButton.removeAttribute("hidden");
-
-    this.uiInOwnWindow = false;
     if (this.consolePanel) {
       // must destroy the consolePanel
       this.consoleWindowUnregisterOnHide = false;
       this.consolePanel.hidePopup();
       this.consolePanel.parentNode.removeChild(this.consolePanel);
       this.consolePanel = null;   // remove this as we're not in panel anymore
-      this.HUDBox.removeAttribute("flex");
-      this.HUDBox.removeAttribute("height");
-      this.HUDBox.style.height = height + "px";
+      this.iframe.removeAttribute("flex");
+      this.iframe.removeAttribute("height");
+      this.iframe.style.height = height + "px";
     }
 
-    if (this.jsterm) {
-      this.jsterm.inputNode.focus();
-    }
+    this._afterPositionConsole(aPosition, lastIndex);
   },
 
-  /**
-   * The JSTerm object that contains the console's inputNode
-   *
-   */
-  jsterm: null,
+  _afterPositionConsole:
+  function WCF__afterPositionConsole(aPosition, aLastIndex)
+  {
+    let onLoad = function _onLoad() {
+      this.iframe.removeEventListener("load", onLoad, true);
+      this.iframeWindow = this.iframe.contentWindow.wrappedJSObject;
+      this.ui && this.ui.positionConsole(aPosition, this.iframeWindow);
 
-  /**
-   * Display cached messages that may have been collected before the UI is
-   * displayed.
-   *
-   * @private
-   * @param array aRemoteMessages
-   *        Array of cached messages coming from the remote Web Console
-   *        content instance.
-   */
-  _displayCachedConsoleMessages:
-  function HUD__displayCachedConsoleMessages(aRemoteMessages)
-  {
-    if (!aRemoteMessages.length) {
-      return;
-    }
-
-    aRemoteMessages.forEach(function(aMessage) {
-      switch (aMessage._type) {
-        case "PageError": {
-          let category = this.categoryForScriptError(aMessage.category);
-          this.outputMessage(category, this.reportPageError,
-                             [category, aMessage]);
-          break;
-        }
-        case "ConsoleAPI":
-          this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
-                             [aMessage]);
-          break;
-      }
-    }, this);
-  },
-
-  /**
-   * Shortcut to make XUL nodes
-   *
-   * @param string aTag
-   * @returns nsIDOMNode
-   */
-  makeXULNode:
-  function HUD_makeXULNode(aTag)
-  {
-    return this.chromeDocument.createElement(aTag);
-  },
-
-  /**
-   * Build the UI of each HeadsUpDisplay
-   *
-   * @returns nsIDOMNode
-   */
-  makeHUDNodes: function HUD_makeHUDNodes()
-  {
-    this.splitter = this.makeXULNode("splitter");
-    this.splitter.setAttribute("class", "hud-splitter");
-
-    this.HUDBox = this.makeXULNode("vbox");
-    this.HUDBox.setAttribute("id", this.hudId);
-    this.HUDBox.setAttribute("class", "hud-box animated");
-    this.HUDBox.style.height = 0;
-    this.HUDBox.lastTimestamp = 0;
-
-    let outerWrap = this.makeXULNode("vbox");
-    outerWrap.setAttribute("class", "hud-outer-wrapper");
-    outerWrap.setAttribute("flex", "1");
-
-    let consoleCommandSet = this.makeXULNode("commandset");
-    outerWrap.appendChild(consoleCommandSet);
-
-    let consoleWrap = this.makeXULNode("vbox");
-    this.consoleWrap = consoleWrap;
-    consoleWrap.setAttribute("class", "hud-console-wrapper");
-    consoleWrap.setAttribute("flex", "1");
-
-    this.filterSpacer = this.makeXULNode("spacer");
-    this.filterSpacer.setAttribute("flex", "1");
-
-    this.filterBox = this.makeXULNode("textbox");
-    this.filterBox.setAttribute("class", "compact hud-filter-box");
-    this.filterBox.setAttribute("hudId", this.hudId);
-    this.filterBox.setAttribute("placeholder", l10n.getStr("stringFilter"));
-    this.filterBox.setAttribute("type", "search");
-
-    this.setFilterTextBoxEvents();
-
-    this.createConsoleMenu(this.consoleWrap);
-
-    this.filterPrefs = HUDService.getDefaultFilterPrefs(this.hudId);
-
-    let consoleFilterToolbar = this.makeFilterToolbar();
-    consoleFilterToolbar.setAttribute("id", "viewGroup");
-    this.consoleFilterToolbar = consoleFilterToolbar;
-
-    this.hintNode = this.makeXULNode("vbox");
-    this.hintNode.setAttribute("class", "gcliterm-hint-node");
-
-    let hintParentNode = this.makeXULNode("vbox");
-    hintParentNode.setAttribute("flex", "0");
-    hintParentNode.setAttribute("class", "gcliterm-hint-parent");
-    hintParentNode.setAttribute("pack", "end");
-    hintParentNode.appendChild(this.hintNode);
-    hintParentNode.hidden = true;
-
-    let hbox = this.makeXULNode("hbox");
-    hbox.setAttribute("flex", "1");
-    hbox.setAttribute("class", "gcliterm-display");
-
-    this.outputNode = this.makeXULNode("richlistbox");
-    this.outputNode.setAttribute("class", "hud-output-node");
-    this.outputNode.setAttribute("flex", "1");
-    this.outputNode.setAttribute("orient", "vertical");
-    this.outputNode.setAttribute("context", this.hudId + "-output-contextmenu");
-    this.outputNode.setAttribute("style", "direction: ltr;");
-    this.outputNode.setAttribute("seltype", "multiple");
-
-    hbox.appendChild(hintParentNode);
-    hbox.appendChild(this.outputNode);
-
-    consoleWrap.appendChild(consoleFilterToolbar);
-    consoleWrap.appendChild(hbox);
-
-    outerWrap.appendChild(consoleWrap);
-
-    this.HUDBox.lastTimestamp = 0;
-
-    this.jsTermParentNode = this.consoleWrap;
-    this.HUDBox.appendChild(outerWrap);
-
-    return this.HUDBox;
-  },
-
-  /**
-   * sets the click events for all binary toggle filter buttons
-   *
-   * @returns void
-   */
-  setFilterTextBoxEvents: function HUD_setFilterTextBoxEvents()
-  {
-    var filterBox = this.filterBox;
-    function onChange()
-    {
-      // To improve responsiveness, we let the user finish typing before we
-      // perform the search.
-
-      if (this.timer == null) {
-        let timerClass = Cc["@mozilla.org/timer;1"];
-        this.timer = timerClass.createInstance(Ci.nsITimer);
-      } else {
-        this.timer.cancel();
+      if (aLastIndex > -1 && aLastIndex < this.outputNode.getRowCount()) {
+        this.outputNode.ensureIndexIsVisible(aLastIndex);
       }
 
-      let timerEvent = {
-        notify: function setFilterTextBoxEvents_timerEvent_notify() {
-          HUDService.updateFilterText(filterBox);
-        }
-      };
+      this._currentUIPosition = aPosition;
+      Services.prefs.setCharPref("devtools.webconsole.position", aPosition);
+    }.bind(this);
 
-      this.timer.initWithCallback(timerEvent, SEARCH_DELAY,
-        Ci.nsITimer.TYPE_ONE_SHOT);
-    }
-
-    filterBox.addEventListener("command", onChange, false);
-    filterBox.addEventListener("input", onChange, false);
-  },
-
-  /**
-   * Make the filter toolbar where we can toggle logging filters
-   *
-   * @returns nsIDOMNode
-   */
-  makeFilterToolbar: function HUD_makeFilterToolbar()
-  {
-    const BUTTONS = [
-      {
-        name: "PageNet",
-        category: "net",
-        severities: [
-          { name: "ConsoleErrors", prefKey: "network" },
-          { name: "ConsoleLog", prefKey: "networkinfo" }
-        ]
-      },
-      {
-        name: "PageCSS",
-        category: "css",
-        severities: [
-          { name: "ConsoleErrors", prefKey: "csserror" },
-          { name: "ConsoleWarnings", prefKey: "cssparser" }
-        ]
-      },
-      {
-        name: "PageJS",
-        category: "js",
-        severities: [
-          { name: "ConsoleErrors", prefKey: "exception" },
-          { name: "ConsoleWarnings", prefKey: "jswarn" }
-        ]
-      },
-      {
-        name: "PageLogging",
-        category: "logging",
-        severities: [
-          { name: "ConsoleErrors", prefKey: "error" },
-          { name: "ConsoleWarnings", prefKey: "warn" },
-          { name: "ConsoleInfo", prefKey: "info" },
-          { name: "ConsoleLog", prefKey: "log" }
-        ]
-      }
-    ];
-
-    let toolbar = this.makeXULNode("toolbar");
-    toolbar.setAttribute("class", "hud-console-filter-toolbar");
-    toolbar.setAttribute("mode", "full");
-
-#ifdef XP_MACOSX
-    this.makeCloseButton(toolbar);
-#endif
-
-    for (let i = 0; i < BUTTONS.length; i++) {
-      this.makeFilterButton(toolbar, BUTTONS[i]);
-    }
-
-    toolbar.appendChild(this.filterSpacer);
-
-    let positionUI = this.createPositionUI();
-    toolbar.appendChild(positionUI);
-
-    toolbar.appendChild(this.filterBox);
-    this.makeClearConsoleButton(toolbar);
-
-#ifndef XP_MACOSX
-    this.makeCloseButton(toolbar);
-#endif
-
-    return toolbar;
-  },
-
-  /**
-   * Creates the UI for re-positioning the console
-   *
-   * @return nsIDOMNode
-   *         The toolbarbutton which holds the menu that allows the user to
-   *         change the console position.
-   */
-  createPositionUI: function HUD_createPositionUI()
-  {
-    this._positionConsoleAbove = (function HUD_positionAbove() {
-      this.positionConsole("above");
-    }).bind(this);
-
-    this._positionConsoleBelow = (function HUD_positionBelow() {
-      this.positionConsole("below");
-    }).bind(this);
-    this._positionConsoleWindow = (function HUD_positionWindow() {
-      this.positionConsole("window");
-    }).bind(this);
-
-    let button = this.makeXULNode("toolbarbutton");
-    button.setAttribute("type", "menu");
-    button.setAttribute("label", l10n.getStr("webConsolePosition"));
-    button.setAttribute("tooltip", l10n.getStr("webConsolePositionTooltip"));
-
-    let menuPopup = this.makeXULNode("menupopup");
-    button.appendChild(menuPopup);
-
-    let itemAbove = this.makeXULNode("menuitem");
-    itemAbove.setAttribute("label", l10n.getStr("webConsolePositionAbove"));
-    itemAbove.setAttribute("type", "checkbox");
-    itemAbove.setAttribute("autocheck", "false");
-    itemAbove.addEventListener("command", this._positionConsoleAbove, false);
-    menuPopup.appendChild(itemAbove);
-
-    let itemBelow = this.makeXULNode("menuitem");
-    itemBelow.setAttribute("label", l10n.getStr("webConsolePositionBelow"));
-    itemBelow.setAttribute("type", "checkbox");
-    itemBelow.setAttribute("autocheck", "false");
-    itemBelow.addEventListener("command", this._positionConsoleBelow, false);
-    menuPopup.appendChild(itemBelow);
-
-    let itemWindow = this.makeXULNode("menuitem");
-    itemWindow.setAttribute("label", l10n.getStr("webConsolePositionWindow"));
-    itemWindow.setAttribute("type", "checkbox");
-    itemWindow.setAttribute("autocheck", "false");
-    itemWindow.addEventListener("command", this._positionConsoleWindow, false);
-    menuPopup.appendChild(itemWindow);
-
-    this.positionMenuitems = {
-      last: null,
-      above: itemAbove,
-      below: itemBelow,
-      window: itemWindow,
-    };
-
-    return button;
-  },
-
-  /**
-   * Creates the context menu on the console.
-   *
-   * @param nsIDOMNode aOutputNode
-   *        The console output DOM node.
-   * @returns void
-   */
-  createConsoleMenu: function HUD_createConsoleMenu(aConsoleWrapper) {
-    let menuPopup = this.makeXULNode("menupopup");
-    let id = this.hudId + "-output-contextmenu";
-    menuPopup.setAttribute("id", id);
-    menuPopup.addEventListener("popupshowing", function() {
-      saveBodiesItem.setAttribute("checked", this.saveRequestAndResponseBodies);
-    }.bind(this), true);
-
-    let saveBodiesItem = this.makeXULNode("menuitem");
-    saveBodiesItem.setAttribute("label", l10n.getStr("saveBodies.label"));
-    saveBodiesItem.setAttribute("accesskey",
-                                 l10n.getStr("saveBodies.accesskey"));
-    saveBodiesItem.setAttribute("type", "checkbox");
-    saveBodiesItem.setAttribute("buttonType", "saveBodies");
-    saveBodiesItem.setAttribute("oncommand", "HUDConsoleUI.command(this);");
-    saveBodiesItem.setAttribute("hudId", this.hudId);
-    menuPopup.appendChild(saveBodiesItem);
-
-    menuPopup.appendChild(this.makeXULNode("menuseparator"));
-
-    let copyItem = this.makeXULNode("menuitem");
-    copyItem.setAttribute("label", l10n.getStr("copyCmd.label"));
-    copyItem.setAttribute("accesskey", l10n.getStr("copyCmd.accesskey"));
-    copyItem.setAttribute("key", "key_copy");
-    copyItem.setAttribute("command", "cmd_copy");
-    copyItem.setAttribute("buttonType", "copy");
-    menuPopup.appendChild(copyItem);
-
-    let selectAllItem = this.makeXULNode("menuitem");
-    selectAllItem.setAttribute("label", l10n.getStr("selectAllCmd.label"));
-    selectAllItem.setAttribute("accesskey",
-                               l10n.getStr("selectAllCmd.accesskey"));
-    selectAllItem.setAttribute("hudId", this.hudId);
-    selectAllItem.setAttribute("buttonType", "selectAll");
-    selectAllItem.setAttribute("oncommand", "HUDConsoleUI.command(this);");
-    menuPopup.appendChild(selectAllItem);
-
-    aConsoleWrapper.appendChild(menuPopup);
-    aConsoleWrapper.setAttribute("context", id);
-  },
-
-  /**
-   * Creates one of the filter buttons on the toolbar.
-   *
-   * @param nsIDOMNode aParent
-   *        The node to which the filter button should be appended.
-   * @param object aDescriptor
-   *        A descriptor that contains info about the button. Contains "name",
-   *        "category", and "prefKey" properties, and optionally a "severities"
-   *        property.
-   * @return void
-   */
-  makeFilterButton: function HUD_makeFilterButton(aParent, aDescriptor)
-  {
-    let toolbarButton = this.makeXULNode("toolbarbutton");
-    aParent.appendChild(toolbarButton);
-
-    let toggleFilter = HeadsUpDisplayUICommands.toggleFilter;
-    toolbarButton.addEventListener("click", toggleFilter, false);
-
-    let name = aDescriptor.name;
-    toolbarButton.setAttribute("type", "menu-button");
-    toolbarButton.setAttribute("label", l10n.getStr("btn" + name));
-    toolbarButton.setAttribute("tooltip", l10n.getStr("tip" + name));
-    toolbarButton.setAttribute("category", aDescriptor.category);
-    toolbarButton.setAttribute("hudId", this.hudId);
-    toolbarButton.classList.add("webconsole-filter-button");
-
-    let menuPopup = this.makeXULNode("menupopup");
-    toolbarButton.appendChild(menuPopup);
-
-    let someChecked = false;
-    for (let i = 0; i < aDescriptor.severities.length; i++) {
-      let severity = aDescriptor.severities[i];
-      let menuItem = this.makeXULNode("menuitem");
-      menuItem.setAttribute("label", l10n.getStr("btn" + severity.name));
-      menuItem.setAttribute("type", "checkbox");
-      menuItem.setAttribute("autocheck", "false");
-      menuItem.setAttribute("hudId", this.hudId);
-
-      let prefKey = severity.prefKey;
-      menuItem.setAttribute("prefKey", prefKey);
-
-      let checked = this.filterPrefs[prefKey];
-      menuItem.setAttribute("checked", checked);
-      if (checked) {
-        someChecked = true;
-      }
-
-      menuItem.addEventListener("command", toggleFilter, false);
-
-      menuPopup.appendChild(menuItem);
-    }
-
-    toolbarButton.setAttribute("checked", someChecked);
-  },
-
-  /**
-   * Creates the close button on the toolbar.
-   *
-   * @param nsIDOMNode aParent
-   *        The toolbar to attach the close button to.
-   * @return void
-   */
-  makeCloseButton: function HUD_makeCloseButton(aToolbar)
-  {
-    this.closeButtonOnCommand = (function HUD_closeButton_onCommand() {
-      HUDService.animate(this.hudId, ANIMATE_OUT, (function() {
-        HUDService.deactivateHUDForContext(this.tab, true);
-      }).bind(this));
-    }).bind(this);
-
-    this.closeButton = this.makeXULNode("toolbarbutton");
-    this.closeButton.classList.add("webconsole-close-button");
-    this.closeButton.addEventListener("command",
-      this.closeButtonOnCommand, false);
-    aToolbar.appendChild(this.closeButton);
-  },
-
-  /**
-   * Creates the "Clear Console" button.
-   *
-   * @param nsIDOMNode aParent
-   *        The toolbar to attach the "Clear Console" button to.
-   * @param string aHUDId
-   *        The ID of the console.
-   * @return void
-   */
-  makeClearConsoleButton: function HUD_makeClearConsoleButton(aToolbar)
-  {
-    let hudId = this.hudId;
-    function HUD_clearButton_onCommand() {
-      let hud = HUDService.getHudReferenceById(hudId);
-      hud.jsterm.clearOutput(true);
-    }
-
-    let clearButton = this.makeXULNode("toolbarbutton");
-    clearButton.setAttribute("label", l10n.getStr("btnClear"));
-    clearButton.classList.add("webconsole-clear-console-button");
-    clearButton.addEventListener("command", HUD_clearButton_onCommand, false);
-
-    aToolbar.appendChild(clearButton);
-  },
-
-  /**
-   * Destroy the property inspector message node. This performs the necessary
-   * cleanup for the tree widget and removes it from the DOM.
-   *
-   * @param nsIDOMNode aMessageNode
-   *        The message node that contains the property inspector from a
-   *        console.dir call.
-   */
-  pruneConsoleDirNode: function HUD_pruneConsoleDirNode(aMessageNode)
-  {
-    if (aMessageNode.parentNode) {
-      aMessageNode.parentNode.removeChild(aMessageNode);
-    }
-
-    let tree = aMessageNode.querySelector("tree");
-    tree.parentNode.removeChild(tree);
-    aMessageNode.propertyTreeView = null;
-    if (tree.view) {
-      tree.view.data = null;
-    }
-    tree.view = null;
-  },
-
-  /**
-   * Create the Web Console UI.
-   *
-   * @return nsIDOMNode
-   *         The Web Console container element (HUDBox).
-   */
-  createHUD: function HUD_createHUD()
-  {
-    if (!this.HUDBox) {
-      this.makeHUDNodes();
-      let positionPref = Services.prefs.getCharPref("devtools.webconsole.position");
-      this.positionConsole(positionPref);
-    }
-    return this.HUDBox;
-  },
-
-  uiInOwnWindow: false,
-
-  /**
-   * Logs a message to the Web Console that originates from the remote Web
-   * Console instance.
-   *
-   * @param object aMessage
-   *        The message received from the remote Web Console instance.
-   *        console service. This object needs to hold:
-   *          - hudId - the Web Console ID.
-   *          - apiMessage - a representation of the object sent by the console
-   *          storage service. This object holds the console message level, the
-   *          arguments that were passed to the console method and other
-   *          information.
-   *          - argumentsToString - the array of arguments passed to the console
-   *          method, each converted to a string.
-   * @return nsIDOMElement|undefined
-   *         The message element to display in the Web Console output.
-   */
-  logConsoleAPIMessage: function HUD_logConsoleAPIMessage(aMessage)
-  {
-    let body = null;
-    let clipboardText = null;
-    let sourceURL = null;
-    let sourceLine = 0;
-    let level = aMessage.apiMessage.level;
-    let args = aMessage.apiMessage.arguments;
-    let argsToString = aMessage.argumentsToString;
-
-    switch (level) {
-      case "log":
-      case "info":
-      case "warn":
-      case "error":
-      case "debug":
-        body = argsToString.join(" ");
-        sourceURL = aMessage.apiMessage.filename;
-        sourceLine = aMessage.apiMessage.lineNumber;
-        break;
-
-      case "trace":
-        let filename = WebConsoleUtils.abbreviateSourceURL(args[0].filename);
-        let functionName = args[0].functionName ||
-                           l10n.getStr("stacktrace.anonymousFunction");
-        let lineNumber = args[0].lineNumber;
-
-        body = l10n.getFormatStr("stacktrace.outputMessage",
-                                 [filename, functionName, lineNumber]);
-
-        sourceURL = args[0].filename;
-        sourceLine = args[0].lineNumber;
-
-        clipboardText = "";
-
-        args.forEach(function(aFrame) {
-          clipboardText += aFrame.filename + " :: " +
-                           aFrame.functionName + " :: " +
-                           aFrame.lineNumber + "\n";
-        });
-
-        clipboardText = clipboardText.trimRight();
-        break;
-
-      case "dir":
-        body = {
-          cacheId: aMessage.objectsCacheId,
-          resultString: argsToString[0],
-          remoteObject: args[0],
-          remoteObjectProvider:
-            this.jsterm.remoteObjectProvider.bind(this.jsterm),
-        };
-        clipboardText = body.resultString;
-        sourceURL = aMessage.apiMessage.filename;
-        sourceLine = aMessage.apiMessage.lineNumber;
-        break;
-
-      case "group":
-      case "groupCollapsed":
-        clipboardText = body = args;
-        sourceURL = aMessage.apiMessage.filename;
-        sourceLine = aMessage.apiMessage.lineNumber;
-        this.groupDepth++;
-        break;
-
-      case "groupEnd":
-        if (this.groupDepth > 0) {
-          this.groupDepth--;
-        }
-        return;
-
-      case "time":
-        if (!args) {
-          return;
-        }
-        if (args.error) {
-          Cu.reportError(l10n.getStr(args.error));
-          return;
-        }
-        body = l10n.getFormatStr("timerStarted", [args.name]);
-        clipboardText = body;
-        sourceURL = aMessage.apiMessage.filename;
-        sourceLine = aMessage.apiMessage.lineNumber;
-        break;
-
-      case "timeEnd":
-        if (!args) {
-          return;
-        }
-        body = l10n.getFormatStr("timeEnd", [args.name, args.duration]);
-        clipboardText = body;
-        sourceURL = aMessage.apiMessage.filename;
-        sourceLine = aMessage.apiMessage.lineNumber;
-        break;
-
-      default:
-        Cu.reportError("Unknown Console API log level: " + level);
-        return;
-    }
-
-    let node = ConsoleUtils.createMessageNode(this.chromeDocument,
-                                              CATEGORY_WEBDEV,
-                                              LEVELS[level],
-                                              body,
-                                              this.hudId,
-                                              sourceURL,
-                                              sourceLine,
-                                              clipboardText,
-                                              level,
-                                              aMessage.timeStamp);
-
-    // Make the node bring up the property panel, to allow the user to inspect
-    // the stack trace.
-    if (level == "trace") {
-      node._stacktrace = args;
-
-      this.makeOutputMessageLink(node, function _traceNodeClickCallback() {
-        if (node._panelOpen) {
-          return;
-        }
-
-        let options = {
-          anchor: node,
-          data: { object: node._stacktrace },
-        };
-
-        let propPanel = this.jsterm.openPropertyPanel(options);
-        propPanel.panel.setAttribute("hudId", this.hudId);
-      }.bind(this));
-    }
-
-    if (level == "dir") {
-      // Make sure the cached evaluated object will be purged when the node is
-      // removed.
-      node._evalCacheId = aMessage.objectsCacheId;
-
-      // Initialize the inspector message node, by setting the PropertyTreeView
-      // object on the tree view. This has to be done *after* the node is
-      // shown, because the tree binding must be attached first.
-      node._onOutput = function _onMessageOutput() {
-        node.querySelector("tree").view = node.propertyTreeView;
-      };
-    }
-
-    return node;
-  },
-
-  /**
-   * Reports an error in the page source, either JavaScript or CSS.
-   *
-   * @param nsIScriptError aScriptError
-   *        The error message to report.
-   * @return nsIDOMElement|undefined
-   *         The message element to display in the Web Console output.
-   */
-  reportPageError: function HUD_reportPageError(aCategory, aScriptError)
-  {
-    // Warnings and legacy strict errors become warnings; other types become
-    // errors.
-    let severity = SEVERITY_ERROR;
-    if ((aScriptError.flags & aScriptError.warningFlag) ||
-        (aScriptError.flags & aScriptError.strictFlag)) {
-      severity = SEVERITY_WARNING;
-    }
-
-    let node = ConsoleUtils.createMessageNode(this.chromeDocument,
-                                              aCategory,
-                                              severity,
-                                              aScriptError.errorMessage,
-                                              this.hudId,
-                                              aScriptError.sourceName,
-                                              aScriptError.lineNumber,
-                                              null,
-                                              null,
-                                              aScriptError.timeStamp);
-    return node;
-  },
-
-  /**
-   * Determine the category of a given nsIScriptError.
-   *
-   * @param nsIScriptError aScriptError
-   *        The script error you want to determine the category for.
-   * @return CATEGORY_JS|CATEGORY_CSS
-   *         Depending on the script error CATEGORY_JS or CATEGORY_CSS can be
-   *         returned.
-   */
-  categoryForScriptError: function HUD_categoryForScriptError(aScriptError)
-  {
-    switch (aScriptError.category) {
-      case "CSS Parser":
-      case "CSS Loader":
-        return CATEGORY_CSS;
-
-      default:
-        return CATEGORY_JS;
-    }
-  },
-
-  /**
-   * Log network activity.
-   *
-   * @param object aHttpActivity
-   *        The HTTP activity to log.
-   * @return nsIDOMElement|undefined
-   *         The message element to display in the Web Console output.
-   */
-  logNetActivity: function HUD_logNetActivity(aConnectionId)
-  {
-    let networkInfo = this._networkRequests[aConnectionId];
-    if (!networkInfo) {
-      return;
-    }
-
-    let entry = networkInfo.httpActivity.log.entries[0];
-    let request = entry.request;
-
-    let msgNode = this.chromeDocument.createElementNS(XUL_NS, "hbox");
-
-    let methodNode = this.chromeDocument.createElementNS(XUL_NS, "label");
-    methodNode.setAttribute("value", request.method);
-    methodNode.classList.add("webconsole-msg-body-piece");
-    msgNode.appendChild(methodNode);
-
-    let linkNode = this.chromeDocument.createElementNS(XUL_NS, "hbox");
-    linkNode.setAttribute("flex", "1");
-    linkNode.classList.add("webconsole-msg-body-piece");
-    linkNode.classList.add("webconsole-msg-link");
-    msgNode.appendChild(linkNode);
-
-    let urlNode = this.chromeDocument.createElementNS(XUL_NS, "label");
-    urlNode.setAttribute("crop", "center");
-    urlNode.setAttribute("flex", "1");
-    urlNode.setAttribute("title", request.url);
-    urlNode.setAttribute("value", request.url);
-    urlNode.classList.add("hud-clickable");
-    urlNode.classList.add("webconsole-msg-body-piece");
-    urlNode.classList.add("webconsole-msg-url");
-    linkNode.appendChild(urlNode);
-
-    let statusNode = this.chromeDocument.createElementNS(XUL_NS, "label");
-    statusNode.setAttribute("value", "");
-    statusNode.classList.add("hud-clickable");
-    statusNode.classList.add("webconsole-msg-body-piece");
-    statusNode.classList.add("webconsole-msg-status");
-    linkNode.appendChild(statusNode);
-
-    let clipboardText = request.method + " " + request.url;
-
-    let messageNode = ConsoleUtils.createMessageNode(this.chromeDocument,
-                                                     CATEGORY_NETWORK,
-                                                     SEVERITY_LOG,
-                                                     msgNode,
-                                                     this.hudId,
-                                                     null,
-                                                     null,
-                                                     clipboardText);
-
-    messageNode._connectionId = entry.connection;
-
-    this.makeOutputMessageLink(messageNode, function HUD_net_message_link() {
-      if (!messageNode._panelOpen) {
-        HUDService.openNetworkPanel(messageNode, networkInfo.httpActivity);
-      }
-    }.bind(this));
-
-    networkInfo.node = messageNode;
-
-    this._updateNetMessage(entry.connection);
-
-    return messageNode;
-  },
-
-  /**
-   * Log file activity.
-   *
-   * @param string aFileURI
-   *        The file URI that was loaded.
-   * @return nsIDOMElement|undefined
-   *         The message element to display in the Web Console output.
-   */
-  logFileActivity: function HUD_logFileActivity(aFileURI)
-  {
-    let chromeDocument = this.chromeDocument;
-
-    let urlNode = chromeDocument.createElementNS(XUL_NS, "label");
-    urlNode.setAttribute("crop", "center");
-    urlNode.setAttribute("flex", "1");
-    urlNode.setAttribute("title", aFileURI);
-    urlNode.setAttribute("value", aFileURI);
-    urlNode.classList.add("hud-clickable");
-    urlNode.classList.add("webconsole-msg-url");
-
-    let outputNode = ConsoleUtils.createMessageNode(chromeDocument,
-                                                    CATEGORY_NETWORK,
-                                                    SEVERITY_LOG,
-                                                    urlNode,
-                                                    this.hudId,
-                                                    null,
-                                                    null,
-                                                    aFileURI);
-
-    this.makeOutputMessageLink(outputNode, function HUD__onFileClick() {
-      let viewSourceUtils = chromeDocument.defaultView.gViewSourceUtils;
-      viewSourceUtils.viewSource(aFileURI, null, chromeDocument);
-    });
-
-    return outputNode;
-  },
-
-  /**
-   * Inform user that the Web Console API has been replaced by a script
-   * in a content page.
-   *
-   * @return nsIDOMElement|undefined
-   *         The message element to display in the Web Console output.
-   */
-  logWarningAboutReplacedAPI: function HUD_logWarningAboutReplacedAPI()
-  {
-    let message = l10n.getStr("ConsoleAPIDisabled");
-    let node = ConsoleUtils.createMessageNode(this.chromeDocument, CATEGORY_JS,
-                                              SEVERITY_WARNING, message,
-                                              this.hudId);
-    return node;
-  },
-
-  ERRORS: {
-    HUD_BOX_DOES_NOT_EXIST: "Heads Up Display does not exist",
-    TAB_ID_REQUIRED: "Tab DOM ID is required",
-    PARENTNODE_NOT_FOUND: "parentNode element not found"
-  },
-
-  /**
-   * Setup the message manager used to communicate with the Web Console content
-   * script. This method loads the content script, adds the message listeners
-   * and initializes the connection to the content script.
-   *
-   * @private
-   */
-  _setupMessageManager: function HUD__setupMessageManager()
-  {
-    this.messageManager.loadFrameScript(CONTENT_SCRIPT_URL, true);
-
-    this._messageListeners.forEach(function(aName) {
-      this.messageManager.addMessageListener(aName, this);
-    }, this);
-
-    let message = {
-      features: ["ConsoleAPI", "JSTerm", "PageError", "NetworkMonitor",
-                 "LocationChange"],
-      cachedMessages: ["ConsoleAPI", "PageError"],
-      NetworkMonitor: { monitorFileActivity: true },
-      JSTerm: { notifyNonNativeConsoleAPI: true },
-      preferences: {
-        "NetworkMonitor.saveRequestAndResponseBodies":
-          this.saveRequestAndResponseBodies,
-      },
-    };
-    this.sendMessageToContent("WebConsole:Init", message);
-  },
-
-  /**
-   * Handler for all of the messages coming from the Web Console content script.
-   *
-   * @private
-   * @param object aMessage
-   *        A MessageManager object that holds the remote message.
-   */
-  receiveMessage: function HUD_receiveMessage(aMessage)
-  {
-    if (!aMessage.json || aMessage.json.hudId != this.hudId) {
-      return;
-    }
-
-    switch (aMessage.name) {
-      case "JSTerm:EvalResult":
-      case "JSTerm:EvalObject":
-      case "JSTerm:AutocompleteProperties":
-        this._receiveMessageWithCallback(aMessage.json);
-        break;
-      case "JSTerm:ClearOutput":
-        this.jsterm.clearOutput();
-        break;
-      case "JSTerm:InspectObject":
-        this.jsterm.handleInspectObject(aMessage.json);
-        break;
-      case "WebConsole:ConsoleAPI":
-        this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
-                           [aMessage.json]);
-        break;
-      case "WebConsole:PageError": {
-        let pageError = aMessage.json.pageError;
-        let category = this.categoryForScriptError(pageError);
-        this.outputMessage(category, this.reportPageError,
-                           [category, pageError]);
-        break;
-      }
-      case "WebConsole:CachedMessages":
-        this._displayCachedConsoleMessages(aMessage.json.messages);
-        this._onInitComplete();
-        break;
-      case "WebConsole:NetworkActivity":
-        this.handleNetworkActivity(aMessage.json);
-        break;
-      case "WebConsole:FileActivity":
-        this.outputMessage(CATEGORY_NETWORK, this.logFileActivity,
-                           [aMessage.json.uri]);
-        break;
-      case "WebConsole:LocationChange":
-        this.onLocationChange(aMessage.json);
-        break;
-      case "JSTerm:NonNativeConsoleAPI":
-        this.outputMessage(CATEGORY_JS, this.logWarningAboutReplacedAPI);
-        break;
-    }
-  },
-
-  /**
-   * Callback method for when the Web Console initialization is complete. For
-   * now this method sends the web-console-created notification using the
-   * nsIObserverService.
-   *
-   * @private
-   */
-  _onInitComplete: function HUD__onInitComplete()
-  {
-    let id = WebConsoleUtils.supportsString(this.hudId);
-    Services.obs.notifyObservers(id, "web-console-created", null);
-  },
-
-  /**
-   * Handler for messages that have an associated callback function. The
-   * this.sendMessageToContent() allows one to provide a function to be invoked
-   * when the content script replies to the message previously sent. This is the
-   * method that invokes the callback.
-   *
-   * @see this.sendMessageToContent
-   * @private
-   * @param object aResponse
-   *        Message object received from the content script.
-   */
-  _receiveMessageWithCallback:
-  function HUD__receiveMessageWithCallback(aResponse)
-  {
-    if (aResponse.id in this.asyncRequests) {
-      let request = this.asyncRequests[aResponse.id];
-      request.callback(aResponse, request.message);
-      delete this.asyncRequests[aResponse.id];
+    if (this._currentUIPosition) {
+      this.iframe.addEventListener("load", onLoad, true);
     }
     else {
-      Cu.reportError("receiveMessageWithCallback response for stale request " +
-                     "ID " + aResponse.id);
-    }
-  },
-
-  /**
-   * Send a message to the content script.
-   *
-   * @param string aName
-   *        The name of the message you want to send.
-   *
-   * @param object aMessage
-   *        The message object you want to send. This object needs to have no
-   *        cyclic references and it needs to be JSON-stringifiable.
-   *
-   * @param function [aCallback]
-   *        Optional function you want to have called when the content script
-   *        replies to your message. Your callback receives two arguments:
-   *        (1) the response object from the content script and (2) the message
-   *        you sent to the content script (which is aMessage here).
-   */
-  sendMessageToContent:
-  function HUD_sendMessageToContent(aName, aMessage, aCallback)
-  {
-    aMessage.hudId = this.hudId;
-    if (!("id" in aMessage)) {
-      aMessage.id = "HUDChrome-" + HUDService.sequenceId();
-    }
-
-    if (aCallback) {
-      this.asyncRequests[aMessage.id] = {
-        name: aName,
-        message: aMessage,
-        callback: aCallback,
-      };
-    }
-    this.messageManager.sendAsyncMessage(aName, aMessage);
-  },
-
-  /**
-   * Handle the "WebConsole:NetworkActivity" message coming from the remote Web
-   * Console.
-   *
-   * @param object aMessage
-   *        The HTTP activity object. This object needs to hold two properties:
-   *        - meta - some metadata about the request log:
-   *          - stages - the stages the network request went through.
-   *          - discardRequestBody and discardResponseBody - booleans that tell
-   *          if the network request/response body was discarded or not.
-   *        - log - the request and response information. This is a HAR-like
-   *        object. See HUDService-content.js
-   *        NetworkMonitor.createActivityObject().
-   */
-  handleNetworkActivity: function HUD_handleNetworkActivity(aMessage)
-  {
-    let stage = aMessage.meta.stages[aMessage.meta.stages.length - 1];
-    let entry = aMessage.log.entries[0];
-
-    if (stage == "REQUEST_HEADER") {
-      let networkInfo = {
-        node: null,
-        httpActivity: aMessage,
-      };
-
-      this._networkRequests[entry.connection] = networkInfo;
-      this.outputMessage(CATEGORY_NETWORK, this.logNetActivity,
-                         [entry.connection]);
-      return;
-    }
-    else if (!(entry.connection in this._networkRequests)) {
-      return;
-    }
-
-    let networkInfo = this._networkRequests[entry.connection];
-    networkInfo.httpActivity = aMessage;
-
-    if (networkInfo.node) {
-      this._updateNetMessage(entry.connection);
-    }
-
-    // For unit tests we pass the HTTP activity object to the test callback,
-    // once requests complete.
-    if (HUDService.lastFinishedRequestCallback &&
-        aMessage.meta.stages.indexOf("REQUEST_STOP") > -1 &&
-        aMessage.meta.stages.indexOf("TRANSACTION_CLOSE") > -1) {
-      HUDService.lastFinishedRequestCallback(aMessage);
-    }
-  },
-
-  /**
-   * Update an output message to reflect the latest state of a network request,
-   * given a network connection ID.
-   *
-   * @private
-   * @param string aConnectionId
-   *        The connection ID to update.
-   */
-  _updateNetMessage: function HUD__updateNetMessage(aConnectionId)
-  {
-    let networkInfo = this._networkRequests[aConnectionId];
-    if (!networkInfo || !networkInfo.node) {
-      return;
-    }
-
-    let messageNode = networkInfo.node;
-    let httpActivity = networkInfo.httpActivity;
-    let stages = httpActivity.meta.stages;
-    let hasTransactionClose = stages.indexOf("TRANSACTION_CLOSE") > -1;
-    let hasResponseHeader = stages.indexOf("RESPONSE_HEADER") > -1;
-    let entry = httpActivity.log.entries[0];
-    let request = entry.request;
-    let response = entry.response;
-
-    if (hasTransactionClose || hasResponseHeader) {
-      let status = [];
-      if (response.httpVersion && response.status) {
-        status = [response.httpVersion, response.status, response.statusText];
-      }
-      if (hasTransactionClose) {
-        status.push(l10n.getFormatStr("NetworkPanel.durationMS", [entry.time]));
-      }
-      let statusText = "[" + status.join(" ") + "]";
-
-      let linkNode = messageNode.querySelector(".webconsole-msg-link");
-      let statusNode = linkNode.querySelector(".webconsole-msg-status");
-      statusNode.setAttribute("value", statusText);
-
-      messageNode.clipboardText = [request.method, request.url, statusText]
-                                  .join(" ");
-
-      if (hasResponseHeader && response.status >= MIN_HTTP_ERROR_CODE &&
-          response.status <= MAX_HTTP_ERROR_CODE) {
-        ConsoleUtils.setMessageType(messageNode, CATEGORY_NETWORK,
-                                    SEVERITY_ERROR);
-      }
-    }
-
-    if (messageNode._netPanel) {
-      messageNode._netPanel.update();
+      onLoad();
     }
   },
 
   /**
    * Handler for the "WebConsole:LocationChange" message. If the Web Console is
    * opened in a panel the panel title is updated.
    *
    * @param object aMessage
@@ -2498,1926 +923,73 @@ HeadsUpDisplay.prototype = {
   {
     this.contentLocation = aMessage.location;
     if (this.consolePanel) {
       this.consolePanel.label = this.getPanelTitle();
     }
   },
 
   /**
-   * Make a link given an output element.
+   * Retrieve the Web Console panel title.
    *
-   * @param nsIDOMNode aNode
-   *        The message element you want to make a link for.
-   * @param function aCallback
-   *        The function you want invoked when the user clicks on the message
-   *        element.
+   * @return string
+   *         The Web Console panel title.
    */
-  makeOutputMessageLink: function HUD_makeOutputMessageLink(aNode, aCallback)
+  getPanelTitle: function HUD_getPanelTitle()
   {
-    let linkNode;
-    if (aNode.category === CATEGORY_NETWORK) {
-      linkNode = aNode.querySelector(".webconsole-msg-link, .webconsole-msg-url");
-    }
-    else {
-      linkNode = aNode.querySelector(".webconsole-msg-body");
-      linkNode.classList.add("hud-clickable");
-    }
-
-    linkNode.setAttribute("aria-haspopup", "true");
-
-    aNode.addEventListener("mousedown", function(aEvent) {
-      this._startX = aEvent.clientX;
-      this._startY = aEvent.clientY;
-    }, false);
-
-    aNode.addEventListener("click", function(aEvent) {
-      if (aEvent.detail != 1 || aEvent.button != 0 ||
-          (this._startX != aEvent.clientX &&
-           this._startY != aEvent.clientY)) {
-        return;
-      }
-
-      aCallback(this, aEvent);
-    }, false);
+    return l10n.getFormatStr("webConsoleWindowTitleAndURL",
+                             [this.contentLocation]);
   },
 
-  /**
-   * Output a message node. This filters a node appropriately, then sends it to
-   * the output, regrouping and pruning output as necessary.
-   *
-   * Note: this call is async - the given message node may not be displayed when
-   * you call this method.
-   *
-   * @param integer aCategory
-   *        The category of the message you want to output. See the CATEGORY_*
-   *        constants.
-   * @param function|nsIDOMElement aMethodOrNode
-   *        The method that creates the message element to send to the output or
-   *        the actual element. If a method is given it will be bound to the HUD
-   *        object and the arguments will be |aArguments|.
-   * @param array [aArguments]
-   *        If a method is given to output the message element then the method
-   *        will be invoked with the list of arguments given here.
-   */
-  outputMessage: function HUD_outputMessage(aCategory, aMethodOrNode, aArguments)
+  onCloseButton: function WC_onCloseButton()
   {
-    if (!this._outputQueue.length) {
-      // If the queue is empty we consider that now was the last output flush.
-      // This avoid an immediate output flush when the timer executes.
-      this._lastOutputFlush = Date.now();
-    }
-
-    this._outputQueue.push([aCategory, aMethodOrNode, aArguments]);
-
-    if (!this._outputTimeout) {
-      this._outputTimeout =
-        this.chromeWindow.setTimeout(this._flushMessageQueue.bind(this),
-                                     OUTPUT_INTERVAL);
-    }
+    HUDService.animate(this.hudId, ANIMATE_OUT, function() {
+      HUDService.deactivateHUDForContext(this.tab, true);
+    }.bind(this));
   },
 
-  /**
-   * Try to flush the output message queue. This takes the messages in the
-   * output queue and displays them. Outputting stops at MESSAGES_IN_INTERVAL.
-   * Further output is queued to happen later - see OUTPUT_INTERVAL.
-   *
-   * @private
-   */
-  _flushMessageQueue: function HUD__flushMessageQueue()
-  {
-    let timeSinceFlush = Date.now() - this._lastOutputFlush;
-    if (this._outputQueue.length > MESSAGES_IN_INTERVAL &&
-        timeSinceFlush < THROTTLE_UPDATES) {
-      this._outputTimeout =
-        this.chromeWindow.setTimeout(this._flushMessageQueue.bind(this),
-                                     OUTPUT_INTERVAL);
-      return;
-    }
-
-    // Determine how many messages we can display now.
-    let toDisplay = Math.min(this._outputQueue.length, MESSAGES_IN_INTERVAL);
-    if (toDisplay < 1) {
-      this._outputTimeout = null;
-      return;
-    }
-
-    // Try to prune the message queue.
-    let shouldPrune = false;
-    if (this._outputQueue.length > toDisplay && this._pruneOutputQueue()) {
-      toDisplay = Math.min(this._outputQueue.length, toDisplay);
-      shouldPrune = true;
-    }
-
-    let batch = this._outputQueue.splice(0, toDisplay);
-    if (!batch.length) {
-      this._outputTimeout = null;
-      return;
-    }
-
-    let outputNode = this.outputNode;
-    let lastVisibleNode = null;
-    let scrolledToBottom = ConsoleUtils.isOutputScrolledToBottom(outputNode);
-    let scrollBox = outputNode.scrollBoxObject.element;
-
-    let hudIdSupportsString = WebConsoleUtils.supportsString(this.hudId);
-
-    // Output the current batch of messages.
-    for (let item of batch) {
-      let node = this._outputMessageFromQueue(hudIdSupportsString, item);
-      if (node) {
-        lastVisibleNode = node;
-      }
-    }
-
-    let oldScrollHeight = 0;
-
-    // Prune messages if needed. We do not do this for every flush call to
-    // improve performance.
-    let removedNodes = 0;
-    if (shouldPrune || !this._outputQueue.length) {
-      oldScrollHeight = scrollBox.scrollHeight;
-
-      let categories = Object.keys(this._pruneCategoriesQueue);
-      categories.forEach(function _pruneOutput(aCategory) {
-        removedNodes += pruneConsoleOutputIfNecessary(this.hudId, aCategory);
-      }, this);
-      this._pruneCategoriesQueue = {};
-    }
-
-    // Regroup messages at the end of the queue.
-    if (!this._outputQueue.length) {
-      HUDService.regroupOutput(outputNode);
-    }
-
-    let isInputOutput = lastVisibleNode &&
-      (lastVisibleNode.classList.contains("webconsole-msg-input") ||
-       lastVisibleNode.classList.contains("webconsole-msg-output"));
-
-    // Scroll to the new node if it is not filtered, and if the output node is
-    // scrolled at the bottom or if the new node is a jsterm input/output
-    // message.
-    if (lastVisibleNode && (scrolledToBottom || isInputOutput)) {
-      ConsoleUtils.scrollToVisible(lastVisibleNode);
-    }
-    else if (!scrolledToBottom && removedNodes > 0 &&
-             oldScrollHeight != scrollBox.scrollHeight) {
-      // If there were pruned messages and if scroll is not at the bottom, then
-      // we need to adjust the scroll location.
-      scrollBox.scrollTop -= oldScrollHeight - scrollBox.scrollHeight;
-    }
-
-    // If the queue is not empty, schedule another flush.
-    if (this._outputQueue.length > 0) {
-      this._outputTimeout =
-        this.chromeWindow.setTimeout(this._flushMessageQueue.bind(this),
-                                     OUTPUT_INTERVAL);
-    }
-    else {
-      this._outputTimeout = null;
-    }
-
-    this._lastOutputFlush = Date.now();
-  },
-
-  /**
-   * Output a message from the queue.
-   *
-   * @private
-   * @param nsISupportsString aHudIdSupportsString
-   *        The HUD ID as an nsISupportsString.
-   * @param array aItem
-   *        An item from the output queue - this item represents a message.
-   * @return nsIDOMElement|undefined
-   *         The DOM element of the message if the message is visible, undefined
-   *         otherwise.
-   */
-  _outputMessageFromQueue:
-  function HUD__outputMessageFromQueue(aHudIdSupportsString, aItem)
-  {
-    let [category, methodOrNode, args] = aItem;
-
-    let node = typeof methodOrNode == "function" ?
-               methodOrNode.apply(this, args || []) :
-               methodOrNode;
-    if (!node) {
-      return;
-    }
-
-    let afterNode = node._outputAfterNode;
-    if (afterNode) {
-      delete node._outputAfterNode;
-    }
-
-    let isFiltered = ConsoleUtils.filterMessageNode(node, this.hudId);
-
-    let isRepeated = false;
-    if (node.classList.contains("webconsole-msg-cssparser")) {
-      isRepeated = ConsoleUtils.filterRepeatedCSS(node, this.outputNode,
-                                                  this.hudId);
-    }
-
-    if (!isRepeated &&
-        !node.classList.contains("webconsole-msg-network") &&
-        (node.classList.contains("webconsole-msg-console") ||
-         node.classList.contains("webconsole-msg-exception") ||
-         node.classList.contains("webconsole-msg-error"))) {
-      isRepeated = ConsoleUtils.filterRepeatedConsole(node, this.outputNode);
-    }
-
-    let lastVisible = !isRepeated && !isFiltered;
-    if (!isRepeated) {
-      this.outputNode.insertBefore(node,
-                                   afterNode ? afterNode.nextSibling : null);
-      this._pruneCategoriesQueue[node.category] = true;
-      if (afterNode) {
-        lastVisible = this.outputNode.lastChild == node;
-      }
-    }
-
-    if (node._onOutput) {
-      node._onOutput();
-      delete node._onOutput;
-    }
-
-    let nodeID = node.getAttribute("id");
-    Services.obs.notifyObservers(aHudIdSupportsString,
-                                 "web-console-message-created", nodeID);
-
-    return lastVisible ? node : null;
-  },
-
-  /**
-   * Prune the queue of messages to display. This avoids displaying messages
-   * that will be removed at the end of the queue anyway.
-   * @private
-   */
-  _pruneOutputQueue: function HUD__pruneOutputQueue()
-  {
-    let nodes = {};
-
-    // Group the messages per category.
-    this._outputQueue.forEach(function(aItem, aIndex) {
-      let [category] = aItem;
-      if (!(category in nodes)) {
-        nodes[category] = [];
-      }
-      nodes[category].push(aIndex);
-    }, this);
-
-    let pruned = 0;
-
-    // Loop through the categories we found and prune if needed.
-    for (let category in nodes) {
-      let limit = this.logLimitForCategory(category);
-      let indexes = nodes[category];
-      if (indexes.length > limit) {
-        let n = Math.max(0, indexes.length - limit);
-        pruned += n;
-        for (let i = n - 1; i >= 0; i--) {
-          this._pruneItemFromQueue(this._outputQueue[indexes[i]]);
-          this._outputQueue.splice(indexes[i], 1);
-        }
-      }
-    }
-
-    return pruned;
-  },
-
-  /**
-   * Prune an item from the output queue.
-   *
-   * @private
-   * @param array aItem
-   *        The item you want to remove from the output queue.
-   */
-  _pruneItemFromQueue: function HUD__pruneItemFromQueue(aItem)
-  {
-    let [category, methodOrNode, args] = aItem;
-    if (typeof methodOrNode != "function" &&
-        methodOrNode._evalCacheId && !methodOrNode._panelOpen) {
-      this.jsterm.clearObjectCache(methodOrNode._evalCacheId);
-    }
-
-    if (category == CATEGORY_NETWORK) {
-      let connectionId = null;
-      if (methodOrNode == this.logNetActivity) {
-        connectionId = args[0];
-      }
-      else if (typeof methodOrNode != "function") {
-        connectionId = methodOrNode._connectionId;
-      }
-      if (connectionId && connectionId in this._networkRequests) {
-        delete this._networkRequests[connectionId];
-      }
-    }
-    else if (category == CATEGORY_WEBDEV &&
-             methodOrNode == this.logConsoleAPIMessage) {
-      let level = args[0].apiMessage.level;
-      if (level == "dir") {
-        this.jsterm.clearObjectCache(args[0].objectsCacheId);
-      }
-    }
-  },
-
-  /**
-   * Retrieve the limit of messages for a specific category.
-   *
-   * @param number aCategory
-   *        The category of messages you want to retrieve the limit for. See the
-   *        CATEGORY_* constants.
-   * @return number
-   *         The number of messages allowed for the specific category.
-   */
-  logLimitForCategory: function HUD_logLimitForCategory(aCategory)
-  {
-    let logLimit = DEFAULT_LOG_LIMIT;
-
-    try {
-      let prefName = CATEGORY_CLASS_FRAGMENTS[aCategory];
-      logLimit = Services.prefs.getIntPref("devtools.hud.loglimit." + prefName);
-      logLimit = Math.max(logLimit, 1);
-    }
-    catch (e) { }
-
-    return logLimit;
-  },
-
-  /**
-   * Remove a given message from the output.
-   *
-   * @param nsIDOMNode aNode
-   *        The message node you want to remove.
-   */
-  removeOutputMessage: function HUD_removeOutputMessage(aNode)
-  {
-    if (aNode._evalCacheId && !aNode._panelOpen) {
-      this.jsterm.clearObjectCache(aNode._evalCacheId);
-    }
-
-    if (aNode.classList.contains("webconsole-msg-cssparser")) {
-      let desc = aNode.childNodes[2].textContent;
-      let location = "";
-      if (aNode.childNodes[4]) {
-        location = aNode.childNodes[4].getAttribute("title");
-      }
-      delete this.cssNodes[desc + location];
-    }
-    else if (aNode.classList.contains("webconsole-msg-network")) {
-      delete this._networkRequests[aNode._connectionId];
-    }
-    else if (aNode.classList.contains("webconsole-msg-inspector")) {
-      this.pruneConsoleDirNode(aNode);
-      return;
-    }
-
-    if (aNode.parentNode) {
-      aNode.parentNode.removeChild(aNode);
-    }
-  },
-
-  /**
-   * Destroy the HUD object. Call this method to avoid memory leaks when the Web
-   * Console is closed.
-   */
-  destroy: function HUD_destroy()
+  destroy: function WC_destroy()
   {
     this.sendMessageToContent("WebConsole:Destroy", {});
 
     this._messageListeners.forEach(function(aName) {
-      this.messageManager.removeMessageListener(aName, this);
+      this.messageManager.removeMessageListener(aName, this.ui);
     }, this);
 
-    if (this.jsterm) {
-      this.jsterm.destroy();
-    }
-
     // Make sure that the console panel does not try to call
     // deactivateHUDForContext() again.
     this.consoleWindowUnregisterOnHide = false;
 
-    let popupset = this.chromeDocument.getElementById("mainPopupSet");
+    let popupset = this.mainPopupSet;
     let panels = popupset.querySelectorAll("panel[hudId=" + this.hudId + "]");
     for (let panel of panels) {
       if (panel != this.consolePanel) {
         panel.hidePopup();
       }
     }
 
-    // Remove the HUDBox and the consolePanel if the Web Console is inside a
+    if (this.ui) {
+      this.ui.destroy();
+    }
+
+    // Remove the iframe and the consolePanel if the Web Console is inside a
     // floating panel.
     if (this.consolePanel && this.consolePanel.parentNode) {
       this.consolePanel.hidePopup();
       this.consolePanel.parentNode.removeChild(this.consolePanel);
       this.consolePanel = null;
     }
 
-    if (this.HUDBox.parentNode) {
-      this.HUDBox.parentNode.removeChild(this.HUDBox);
+    if (this.iframe.parentNode) {
+      this.iframe.parentNode.removeChild(this.iframe);
     }
 
     if (this.splitter.parentNode) {
       this.splitter.parentNode.removeChild(this.splitter);
     }
-
-    delete this.asyncRequests;
-    delete this.messageManager;
-    delete this.browser;
-    delete this.chromeDocument;
-    delete this.chromeWindow;
-    delete this.outputNode;
-
-    this.positionMenuitems.above.removeEventListener("command",
-      this._positionConsoleAbove, false);
-    this.positionMenuitems.below.removeEventListener("command",
-      this._positionConsoleBelow, false);
-    this.positionMenuitems.window.removeEventListener("command",
-      this._positionConsoleWindow, false);
-
-    this.closeButton.removeEventListener("command",
-      this.closeButtonOnCommand, false);
-  },
-};
-
-/**
- * Creates a DOM Node factory for XUL nodes - as well as textNodes
- * @param aFactoryType "xul" or "text"
- * @param ignored This parameter is currently ignored, and will be removed
- * See bug 594304
- * @param aDocument The document, the factory is to generate nodes from
- * @return DOM Node Factory function
- */
-function NodeFactory(aFactoryType, ignored, aDocument)
-{
-  // aDocument is presumed to be a XULDocument
-  if (aFactoryType == "text") {
-    return function factory(aText)
-    {
-      return aDocument.createTextNode(aText);
-    }
-  }
-  else if (aFactoryType == "xul") {
-    return function factory(aTag)
-    {
-      return aDocument.createElement(aTag);
-    }
-  }
-  else {
-    throw new Error('NodeFactory: Unknown factory type: ' + aFactoryType);
-  }
-}
-
-
-/**
- * Create a JSTerminal (a JavaScript command line). This is attached to an
- * existing HeadsUpDisplay (a Web Console instance). This code is responsible
- * with handling command line input, code evaluation and result output.
- *
- * @constructor
- * @param object aHud
- *        The HeadsUpDisplay object that owns this JSTerm instance.
- */
-function JSTerm(aHud)
-{
-  this.hud = aHud;
-  this.document = this.hud.chromeDocument;
-  this.parentNode = this.hud.jsTermParentNode;
-
-  this.hudId = this.hud.hudId;
-
-  this.lastCompletion = { value: null };
-  this.history = [];
-  this.historyIndex = 0;
-  this.historyPlaceHolder = 0;  // this.history.length;
-  this.autocompletePopup = new AutocompletePopup(this.document);
-  this.autocompletePopup.onSelect = this.onAutocompleteSelect.bind(this);
-  this.autocompletePopup.onClick = this.acceptProposedCompletion.bind(this);
-  this.init();
-}
-
-JSTerm.prototype = {
-  lastInputValue: "",
-  COMPLETE_FORWARD: 0,
-  COMPLETE_BACKWARD: 1,
-  COMPLETE_HINT_ONLY: 2,
-
-  /**
-   * Initialize the JSTerminal instance.
-   */
-  init: function JST_init()
-  {
-    this._generateUI();
-
-    this._keyPress = this.keyPress.bind(this);
-    this._inputEventHandler = this.inputEventHandler.bind(this);
-
-    this.inputNode.addEventListener("keypress", this._keyPress, false);
-    this.inputNode.addEventListener("input", this._inputEventHandler, false);
-    this.inputNode.addEventListener("keyup", this._inputEventHandler, false);
-  },
-
-  /**
-   * Generate the JSTerminal UI.
-   * @private
-   */
-  _generateUI: function JST__generateUI()
-  {
-    this.completeNode = this.hud.makeXULNode("textbox");
-    this.completeNode.setAttribute("class", "jsterm-complete-node");
-    this.completeNode.setAttribute("multiline", "true");
-    this.completeNode.setAttribute("rows", "1");
-    this.completeNode.setAttribute("tabindex", "-1");
-
-    this.inputNode = this.hud.makeXULNode("textbox");
-    this.inputNode.setAttribute("class", "jsterm-input-node");
-    this.inputNode.setAttribute("multiline", "true");
-    this.inputNode.setAttribute("rows", "1");
-
-    let inputStack = this.hud.makeXULNode("stack");
-    inputStack.setAttribute("class", "jsterm-stack-node");
-    inputStack.setAttribute("flex", "1");
-    inputStack.appendChild(this.completeNode);
-    inputStack.appendChild(this.inputNode);
-
-    let term = this.hud.makeXULNode("hbox");
-    term.setAttribute("class", "jsterm-input-container");
-    term.setAttribute("style", "direction: ltr;");
-    term.appendChild(inputStack);
-
-    this.parentNode.appendChild(term);
-  },
-
-  get outputNode() this.hud.outputNode,
-
-  /**
-   * Asynchronously evaluate a string in the content process sandbox.
-   *
-   * @param string aString
-   *        String to evaluate in the content process JavaScript sandbox.
-   * @param function [aCallback]
-   *        Optional function to be invoked when the evaluation result is
-   *        received.
-   */
-  evalInContentSandbox: function JST_evalInContentSandbox(aString, aCallback)
-  {
-    let message = {
-      str: aString,
-      resultCacheId: "HUDEval-" + HUDService.sequenceId(),
-    };
-
-    this.hud.sendMessageToContent("JSTerm:EvalRequest", message, aCallback);
-
-    return message;
-  },
-
-  /**
-   * The "JSTerm:EvalResult" message handler. This is the JSTerm execution
-   * result callback which is invoked whenever JavaScript code evaluation
-   * results come from the content process.
-   *
-   * @private
-   * @param object aResponse
-   *        The JSTerm:EvalResult message received from the content process. See
-   *        JSTerm.handleEvalRequest() in HUDService-content.js for further
-   *        details.
-   * @param object aRequest
-   *        The JSTerm:EvalRequest message we sent to the content process.
-   * @see JSTerm.handleEvalRequest() in HUDService-content.js
-   */
-  _executeResultCallback:
-  function JST__executeResultCallback(aResponse, aRequest)
-  {
-    let errorMessage = aResponse.errorMessage;
-    let resultString = aResponse.resultString;
-
-    // Hide undefined results coming from JSTerm helper functions.
-    if (!errorMessage &&
-        resultString == "undefined" &&
-        aResponse.helperResult &&
-        !aResponse.inspectable &&
-        !aResponse.helperRawOutput) {
-      return;
-    }
-
-    let afterNode = aRequest.outputNode;
-
-    if (aResponse.errorMessage) {
-      this.writeOutput(aResponse.errorMessage, CATEGORY_OUTPUT, SEVERITY_ERROR,
-                       afterNode, aResponse.timestamp);
-    }
-    else if (aResponse.inspectable) {
-      let node = this.writeOutputJS(aResponse.resultString,
-                                    this._evalOutputClick.bind(this, aResponse),
-                                    afterNode, aResponse.timestamp);
-      node._evalCacheId = aResponse.childrenCacheId;
-    }
-    else {
-      this.writeOutput(aResponse.resultString, CATEGORY_OUTPUT, SEVERITY_LOG,
-                       afterNode, aResponse.timestamp);
-    }
-  },
-
-  /**
-   * Execute a string. Execution happens asynchronously in the content process.
-   *
-   * @param string [aExecuteString]
-   *        The string you want to execute. If this is not provided, the current
-   *        user input is used - taken from |this.inputNode.value|.
-   */
-  execute: function JST_execute(aExecuteString)
-  {
-    // attempt to execute the content of the inputNode
-    aExecuteString = aExecuteString || this.inputNode.value;
-    if (!aExecuteString) {
-      this.writeOutput("no value to execute", CATEGORY_OUTPUT, SEVERITY_LOG);
-      return;
-    }
-
-    let node = this.writeOutput(aExecuteString, CATEGORY_INPUT, SEVERITY_LOG);
-
-    let messageToContent =
-      this.evalInContentSandbox(aExecuteString,
-                                this._executeResultCallback.bind(this));
-    messageToContent.outputNode = node;
-
-    this.history.push(aExecuteString);
-    this.historyIndex++;
-    this.historyPlaceHolder = this.history.length;
-    this.setInputValue("");
-    this.clearCompletion();
-  },
-
-  /**
-   * Opens a new property panel that allows the inspection of the given object.
-   * The object information can be retrieved both async and sync, depending on
-   * the given options.
-   *
-   * @param object aOptions
-   *        Property panel options:
-   *        - title:
-   *        Panel title.
-   *        - anchor:
-   *        The DOM element you want the panel to be anchored to.
-   *        - updateButtonCallback:
-   *        An optional function you want invoked when the user clicks the
-   *        Update button. If this function is not provided the Update button is
-   *        not shown.
-   *        - data:
-   *        An object that represents the object you want to inspect. Please see
-   *        the PropertyPanel documentation - this object is passed to the
-   *        PropertyPanel constructor
-   * @return object
-   *         The new instance of PropertyPanel.
-   */
-  openPropertyPanel: function JST_openPropertyPanel(aOptions)
-  {
-    // The property panel has one button:
-    //    `Update`: reexecutes the string executed on the command line. The
-    //    result will be inspected by this panel.
-    let buttons = [];
-
-    if (aOptions.updateButtonCallback) {
-      buttons.push({
-        label: l10n.getStr("update.button"),
-        accesskey: l10n.getStr("update.accesskey"),
-        oncommand: aOptions.updateButtonCallback,
-      });
-    }
-
-    let parent = this.document.getElementById("mainPopupSet");
-    let title = aOptions.title ?
-                l10n.getFormatStr("jsPropertyInspectTitle", [aOptions.title]) :
-                l10n.getStr("jsPropertyTitle");
-
-    let propPanel = new PropertyPanel(parent, title, aOptions.data, buttons);
-
-    propPanel.panel.openPopup(aOptions.anchor, "after_pointer", 0, 0, false, false);
-    propPanel.panel.sizeTo(350, 450);
-
-    if (aOptions.anchor) {
-      propPanel.panel.addEventListener("popuphiding", function onPopupHide() {
-        propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
-        aOptions.anchor._panelOpen = false;
-      }, false);
-      aOptions.anchor._panelOpen = true;
-    }
-
-    return propPanel;
-  },
-
-  /**
-   * Writes a JS object to the JSTerm outputNode.
-   *
-   * @param string aOutputMessage
-   *        The message to display.
-   * @param function [aCallback]
-   *        Optional function to invoke when users click the message.
-   * @param nsIDOMNode [aNodeAfter]
-   *        Optional DOM node after which you want to insert the new message.
-   *        This is used when execution results need to be inserted immediately
-   *        after the user input.
-   * @param number [aTimestamp]
-   *        Optional timestamp to show for the output message (millisconds since
-   *        the UNIX epoch). If no timestamp is provided then Date.now() is
-   *        used.
-   * @return nsIDOMNode
-   *         The new message node.
-   */
-  writeOutputJS:
-  function JST_writeOutputJS(aOutputMessage, aCallback, aNodeAfter, aTimestamp)
-  {
-    let node = this.writeOutput(aOutputMessage, CATEGORY_OUTPUT, SEVERITY_LOG,
-                                aNodeAfter, aTimestamp);
-    if (aCallback) {
-      this.hud.makeOutputMessageLink(node, aCallback);
-    }
-    return node;
-  },
-
-  /**
-   * Writes a message to the HUD that originates from the interactive
-   * JavaScript console.
-   *
-   * @param string aOutputMessage
-   *        The message to display.
-   * @param number aCategory
-   *        The category of message: one of the CATEGORY_ constants.
-   * @param number aSeverity
-   *        The severity of message: one of the SEVERITY_ constants.
-   * @param nsIDOMNode [aNodeAfter]
-   *        Optional DOM node after which you want to insert the new message.
-   *        This is used when execution results need to be inserted immediately
-   *        after the user input.
-   * @param number [aTimestamp]
-   *        Optional timestamp to show for the output message (millisconds since
-   *        the UNIX epoch). If no timestamp is provided then Date.now() is
-   *        used.
-   * @return nsIDOMNode
-   *         The new message node.
-   */
-  writeOutput:
-  function JST_writeOutput(aOutputMessage, aCategory, aSeverity, aNodeAfter,
-                           aTimestamp)
-  {
-    let node = ConsoleUtils.createMessageNode(this.document, aCategory,
-                                              aSeverity, aOutputMessage,
-                                              this.hudId, null, null, null,
-                                              null, aTimestamp);
-    node._outputAfterNode = aNodeAfter;
-    this.hud.outputMessage(aCategory, node);
-    return node;
-  },
-
-  /**
-   * Clear the Web Console output.
-   *
-   * @param boolean aClearStorage
-   *        True if you want to clear the console messages storage associated to
-   *        this Web Console.
-   */
-  clearOutput: function JST_clearOutput(aClearStorage)
-  {
-    let hud = this.hud;
-    let outputNode = hud.outputNode;
-    let node;
-    while ((node = outputNode.firstChild)) {
-      hud.removeOutputMessage(node);
-    }
-
-    hud.HUDBox.lastTimestamp = 0;
-    hud.groupDepth = 0;
-    hud._outputQueue.forEach(hud._pruneItemFromQueue, hud);
-    hud._outputQueue = [];
-    hud._networkRequests = {};
-    hud.cssNodes = {};
-
-    if (aClearStorage) {
-      hud.sendMessageToContent("ConsoleAPI:ClearCache", {});
-    }
-  },
-
-  /**
-   * Updates the size of the input field (command line) to fit its contents.
-   *
-   * @returns void
-   */
-  resizeInput: function JST_resizeInput()
-  {
-    let inputNode = this.inputNode;
-
-    // Reset the height so that scrollHeight will reflect the natural height of
-    // the contents of the input field.
-    inputNode.style.height = "auto";
-
-    // Now resize the input field to fit its contents.
-    let scrollHeight = inputNode.inputField.scrollHeight;
-    if (scrollHeight > 0) {
-      inputNode.style.height = scrollHeight + "px";
-    }
-  },
-
-  /**
-   * Sets the value of the input field (command line), and resizes the field to
-   * fit its contents. This method is preferred over setting "inputNode.value"
-   * directly, because it correctly resizes the field.
-   *
-   * @param string aNewValue
-   *        The new value to set.
-   * @returns void
-   */
-  setInputValue: function JST_setInputValue(aNewValue)
-  {
-    this.inputNode.value = aNewValue;
-    this.lastInputValue = aNewValue;
-    this.completeNode.value = "";
-    this.resizeInput();
-  },
-
-  /**
-   * The inputNode "input" and "keyup" event handler.
-   *
-   * @param nsIDOMEvent aEvent
-   */
-  inputEventHandler: function JSTF_inputEventHandler(aEvent)
-  {
-    if (this.lastInputValue != this.inputNode.value) {
-      this.resizeInput();
-      this.complete(this.COMPLETE_HINT_ONLY);
-      this.lastInputValue = this.inputNode.value;
-    }
-  },
-
-  /**
-   * The inputNode "keypress" event handler.
-   *
-   * @param nsIDOMEvent aEvent
-   */
-  keyPress: function JSTF_keyPress(aEvent)
-  {
-    if (aEvent.ctrlKey) {
-      switch (aEvent.charCode) {
-        case 97:
-          // control-a
-          this.inputNode.setSelectionRange(0, 0);
-          aEvent.preventDefault();
-          break;
-        case 101:
-          // control-e
-          this.inputNode.setSelectionRange(this.inputNode.value.length,
-                                           this.inputNode.value.length);
-          aEvent.preventDefault();
-          break;
-        default:
-          break;
-      }
-      return;
-    }
-    else if (aEvent.shiftKey &&
-        aEvent.keyCode == Ci.nsIDOMKeyEvent.DOM_VK_RETURN) {
-      // shift return
-      // TODO: expand the inputNode height by one line
-      return;
-    }
-
-    let inputUpdated = false;
-
-    switch(aEvent.keyCode) {
-      case Ci.nsIDOMKeyEvent.DOM_VK_ESCAPE:
-        if (this.autocompletePopup.isOpen) {
-          this.clearCompletion();
-          aEvent.preventDefault();
-        }
-        break;
-
-      case Ci.nsIDOMKeyEvent.DOM_VK_RETURN:
-        if (this.autocompletePopup.isOpen && this.autocompletePopup.selectedIndex > -1) {
-          this.acceptProposedCompletion();
-        }
-        else {
-          this.execute();
-        }
-        aEvent.preventDefault();
-        break;
-
-      case Ci.nsIDOMKeyEvent.DOM_VK_UP:
-        if (this.autocompletePopup.isOpen) {
-          inputUpdated = this.complete(this.COMPLETE_BACKWARD);
-        }
-        else if (this.canCaretGoPrevious()) {
-          inputUpdated = this.historyPeruse(HISTORY_BACK);
-        }
-        if (inputUpdated) {
-          aEvent.preventDefault();
-        }
-        break;
-
-      case Ci.nsIDOMKeyEvent.DOM_VK_DOWN:
-        if (this.autocompletePopup.isOpen) {
-          inputUpdated = this.complete(this.COMPLETE_FORWARD);
-        }
-        else if (this.canCaretGoNext()) {
-          inputUpdated = this.historyPeruse(HISTORY_FORWARD);
-        }
-        if (inputUpdated) {
-          aEvent.preventDefault();
-        }
-        break;
-
-      case Ci.nsIDOMKeyEvent.DOM_VK_TAB:
-        // Generate a completion and accept the first proposed value.
-        if (this.complete(this.COMPLETE_HINT_ONLY) &&
-            this.lastCompletion &&
-            this.acceptProposedCompletion()) {
-          aEvent.preventDefault();
-        }
-        else {
-          this.updateCompleteNode(l10n.getStr("Autocomplete.blank"));
-          aEvent.preventDefault();
-        }
-        break;
-
-      default:
-        break;
-    }
-  },
-
-  /**
-   * Go up/down the history stack of input values.
-   *
-   * @param number aDirection
-   *        History navigation direction: HISTORY_BACK or HISTORY_FORWARD.
-   *
-   * @returns boolean
-   *          True if the input value changed, false otherwise.
-   */
-  historyPeruse: function JST_historyPeruse(aDirection)
-  {
-    if (!this.history.length) {
-      return false;
-    }
-
-    // Up Arrow key
-    if (aDirection == HISTORY_BACK) {
-      if (this.historyPlaceHolder <= 0) {
-        return false;
-      }
-
-      let inputVal = this.history[--this.historyPlaceHolder];
-      if (inputVal){
-        this.setInputValue(inputVal);
-      }
-    }
-    // Down Arrow key
-    else if (aDirection == HISTORY_FORWARD) {
-      if (this.historyPlaceHolder == this.history.length - 1) {
-        this.historyPlaceHolder ++;
-        this.setInputValue("");
-      }
-      else if (this.historyPlaceHolder >= (this.history.length)) {
-        return false;
-      }
-      else {
-        let inputVal = this.history[++this.historyPlaceHolder];
-        if (inputVal){
-          this.setInputValue(inputVal);
-        }
-      }
-    }
-    else {
-      throw new Error("Invalid argument 0");
-    }
-
-    return true;
-  },
-
-  /**
-   * Check if the caret is at a location that allows selecting the previous item
-   * in history when the user presses the Up arrow key.
-   *
-   * @return boolean
-   *         True if the caret is at a location that allows selecting the
-   *         previous item in history when the user presses the Up arrow key,
-   *         otherwise false.
-   */
-  canCaretGoPrevious: function JST_canCaretGoPrevious()
-  {
-    let node = this.inputNode;
-    if (node.selectionStart != node.selectionEnd) {
-      return false;
-    }
-
-    let multiline = /[\r\n]/.test(node.value);
-    return node.selectionStart == 0 ? true :
-           node.selectionStart == node.value.length && !multiline;
-  },
-
-  /**
-   * Check if the caret is at a location that allows selecting the next item in
-   * history when the user presses the Down arrow key.
-   *
-   * @return boolean
-   *         True if the caret is at a location that allows selecting the next
-   *         item in history when the user presses the Down arrow key, otherwise
-   *         false.
-   */
-  canCaretGoNext: function JST_canCaretGoNext()
-  {
-    let node = this.inputNode;
-    if (node.selectionStart != node.selectionEnd) {
-      return false;
-    }
-
-    let multiline = /[\r\n]/.test(node.value);
-    return node.selectionStart == node.value.length ? true :
-           node.selectionStart == 0 && !multiline;
-  },
-
-  history: null,
-
-  // Stores the data for the last completion.
-  lastCompletion: null,
-
-  /**
-   * Completes the current typed text in the inputNode. Completion is performed
-   * only if the selection/cursor is at the end of the string. If no completion
-   * is found, the current inputNode value and cursor/selection stay.
-   *
-   * @param int aType possible values are
-   *    - this.COMPLETE_FORWARD: If there is more than one possible completion
-   *          and the input value stayed the same compared to the last time this
-   *          function was called, then the next completion of all possible
-   *          completions is used. If the value changed, then the first possible
-   *          completion is used and the selection is set from the current
-   *          cursor position to the end of the completed text.
-   *          If there is only one possible completion, then this completion
-   *          value is used and the cursor is put at the end of the completion.
-   *    - this.COMPLETE_BACKWARD: Same as this.COMPLETE_FORWARD but if the
-   *          value stayed the same as the last time the function was called,
-   *          then the previous completion of all possible completions is used.
-   *    - this.COMPLETE_HINT_ONLY: If there is more than one possible
-   *          completion and the input value stayed the same compared to the
-   *          last time this function was called, then the same completion is
-   *          used again. If there is only one possible completion, then
-   *          the inputNode.value is set to this value and the selection is set
-   *          from the current cursor position to the end of the completed text.
-   * @param function aCallback
-   *        Optional function invoked when the autocomplete properties are
-   *        updated.
-   * @returns boolean true if there existed a completion for the current input,
-   *          or false otherwise.
-   */
-  complete: function JSTF_complete(aType, aCallback)
-  {
-    let inputNode = this.inputNode;
-    let inputValue = inputNode.value;
-    // If the inputNode has no value, then don't try to complete on it.
-    if (!inputValue) {
-      this.clearCompletion();
-      return false;
-    }
-
-    // Only complete if the selection is empty and at the end of the input.
-    if (inputNode.selectionStart == inputNode.selectionEnd &&
-        inputNode.selectionEnd != inputValue.length) {
-      this.clearCompletion();
-      return false;
-    }
-
-    // Update the completion results.
-    if (this.lastCompletion.value != inputValue) {
-      this._updateCompletionResult(aType, aCallback);
-      return false;
-    }
-
-    let popup = this.autocompletePopup;
-    let accepted = false;
-
-    if (aType != this.COMPLETE_HINT_ONLY && popup.itemCount == 1) {
-      this.acceptProposedCompletion();
-      accepted = true;
-    }
-    else if (aType == this.COMPLETE_BACKWARD) {
-      popup.selectPreviousItem();
-    }
-    else if (aType == this.COMPLETE_FORWARD) {
-      popup.selectNextItem();
-    }
-
-    aCallback && aCallback(this);
-    return accepted || popup.itemCount > 0;
-  },
-
-  /**
-   * Update the completion result. This operation is performed asynchronously by
-   * fetching updated results from the content process.
-   *
-   * @private
-   * @param int aType
-   *        Completion type. See this.complete() for details.
-   * @param function [aCallback]
-   *        Optional, function to invoke when completion results are received.
-   */
-  _updateCompletionResult:
-  function JST__updateCompletionResult(aType, aCallback)
-  {
-    if (this.lastCompletion.value == this.inputNode.value) {
-      return;
-    }
-
-    let message = {
-      id: "HUDComplete-" + HUDService.sequenceId(),
-      input: this.inputNode.value,
-    };
-
-    this.lastCompletion = {
-      requestId: message.id,
-      completionType: aType,
-      value: null,
-    };
-    let callback = this._receiveAutocompleteProperties.bind(this, aCallback);
-    this.hud.sendMessageToContent("JSTerm:Autocomplete", message, callback);
-  },
-
-  /**
-   * Handler for the "JSTerm:AutocompleteProperties" message. This method takes
-   * the completion result received from the content process and updates the UI
-   * accordingly.
-   *
-   * @param function [aCallback=null]
-   *        Optional, function to invoke when the completion result is received.
-   * @param object aMessage
-   *        The JSON message which holds the completion results received from
-   *        the content process.
-   */
-  _receiveAutocompleteProperties:
-  function JST__receiveAutocompleteProperties(aCallback, aMessage)
-  {
-    let inputNode = this.inputNode;
-    let inputValue = inputNode.value;
-    if (aMessage.input != inputValue ||
-        this.lastCompletion.value == inputValue ||
-        aMessage.id != this.lastCompletion.requestId) {
-      return;
-    }
-
-    let matches = aMessage.matches;
-    if (!matches.length) {
-      this.clearCompletion();
-      return;
-    }
-
-    let items = matches.map(function(aMatch) {
-      return { label: aMatch };
-    });
-
-    let popup = this.autocompletePopup;
-    popup.setItems(items);
-
-    let completionType = this.lastCompletion.completionType;
-    this.lastCompletion = {
-      value: inputValue,
-      matchProp: aMessage.matchProp,
-    };
-
-    if (items.length > 1 && !popup.isOpen) {
-      popup.openPopup(inputNode);
-    }
-    else if (items.length < 2 && popup.isOpen) {
-      popup.hidePopup();
-    }
-
-    if (items.length == 1) {
-      popup.selectedIndex = 0;
-    }
-
-    this.onAutocompleteSelect();
-
-    if (completionType != this.COMPLETE_HINT_ONLY && popup.itemCount == 1) {
-      this.acceptProposedCompletion();
-    }
-    else if (completionType == this.COMPLETE_BACKWARD) {
-      popup.selectPreviousItem();
-    }
-    else if (completionType == this.COMPLETE_FORWARD) {
-      popup.selectNextItem();
-    }
-
-    aCallback && aCallback(this);
-  },
-
-  onAutocompleteSelect: function JSTF_onAutocompleteSelect()
-  {
-    let currentItem = this.autocompletePopup.selectedItem;
-    if (currentItem && this.lastCompletion.value) {
-      let suffix = currentItem.label.substring(this.lastCompletion.
-                                               matchProp.length);
-      this.updateCompleteNode(suffix);
-    }
-    else {
-      this.updateCompleteNode("");
-    }
-  },
-
-  /**
-   * Clear the current completion information and close the autocomplete popup,
-   * if needed.
-   */
-  clearCompletion: function JSTF_clearCompletion()
-  {
-    this.autocompletePopup.clearItems();
-    this.lastCompletion = { value: null };
-    this.updateCompleteNode("");
-    if (this.autocompletePopup.isOpen) {
-      this.autocompletePopup.hidePopup();
-    }
-  },
-
-  /**
-   * Accept the proposed input completion.
-   *
-   * @return boolean
-   *         True if there was a selected completion item and the input value
-   *         was updated, false otherwise.
-   */
-  acceptProposedCompletion: function JSTF_acceptProposedCompletion()
-  {
-    let updated = false;
-
-    let currentItem = this.autocompletePopup.selectedItem;
-    if (currentItem && this.lastCompletion.value) {
-      let suffix = currentItem.label.substring(this.lastCompletion.
-                                               matchProp.length);
-      this.setInputValue(this.inputNode.value + suffix);
-      updated = true;
-    }
-
-    this.clearCompletion();
-
-    return updated;
-  },
-
-  /**
-   * Update the node that displays the currently selected autocomplete proposal.
-   *
-   * @param string aSuffix
-   *        The proposed suffix for the inputNode value.
-   */
-  updateCompleteNode: function JSTF_updateCompleteNode(aSuffix)
-  {
-    // completion prefix = input, with non-control chars replaced by spaces
-    let prefix = aSuffix ? this.inputNode.value.replace(/[\S]/g, " ") : "";
-    this.completeNode.value = prefix + aSuffix;
-  },
-
-  /**
-   * Clear the object cache from the Web Console content instance.
-   *
-   * @param string aCacheId
-   *        The cache ID you want to clear. Multiple objects are cached into one
-   *        group which is given an ID.
-   */
-  clearObjectCache: function JST_clearObjectCache(aCacheId)
-  {
-    if (this.hud) {
-      this.hud.sendMessageToContent("JSTerm:ClearObjectCache",
-                                    { cacheId: aCacheId });
-    }
-  },
-
-  /**
-   * The remote object provider allows you to retrieve a given object from
-   * a specific cache and have your callback invoked when the desired object is
-   * received from the Web Console content instance.
-   *
-   * @param string aCacheId
-   *        Retrieve the desired object from this cache ID.
-   * @param string aObjectId
-   *        The ID of the object you want.
-   * @param string aResultCacheId
-   *        The ID of the cache where you want any object references to be
-   *        stored into.
-   * @param function aCallback
-   *        The function you want invoked when the desired object is retrieved.
-   */
-  remoteObjectProvider:
-  function JST_remoteObjectProvider(aCacheId, aObjectId, aResultCacheId,
-                                    aCallback) {
-    let message = {
-      cacheId: aCacheId,
-      objectId: aObjectId,
-      resultCacheId: aResultCacheId,
-    };
-
-    this.hud.sendMessageToContent("JSTerm:GetEvalObject", message, aCallback);
-  },
-
-  /**
-   * The "JSTerm:InspectObject" remote message handler. This allows the content
-   * process to open the Property Panel for a given object.
-   *
-   * @param object aRequest
-   *        The request message from the content process. This message includes
-   *        the user input string that was evaluated to inspect an object and
-   *        the result object which is to be inspected.
-   */
-  handleInspectObject: function JST_handleInspectObject(aRequest)
-  {
-    let options = {
-      title: aRequest.input,
-
-      data: {
-        rootCacheId: aRequest.objectCacheId,
-        panelCacheId: aRequest.objectCacheId,
-        remoteObject: aRequest.resultObject,
-        remoteObjectProvider: this.remoteObjectProvider.bind(this),
-      },
-    };
-
-    let propPanel = this.openPropertyPanel(options);
-    propPanel.panel.setAttribute("hudId", this.hudId);
-
-    let onPopupHide = function JST__onPopupHide() {
-      propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
-
-      this.clearObjectCache(options.data.panelCacheId);
-    }.bind(this);
-
-    propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
-  },
-
-  /**
-   * The click event handler for evaluation results in the output.
-   *
-   * @private
-   * @param object aResponse
-   *        The JSTerm:EvalResult message received from the content process.
-   * @param nsIDOMNode aLink
-   *        The message node for which we are handling events.
-   */
-  _evalOutputClick: function JST__evalOutputClick(aResponse, aLinkNode)
-  {
-    if (aLinkNode._panelOpen) {
-      return;
-    }
-
-    let options = {
-      title: aResponse.input,
-      anchor: aLinkNode,
-
-      // Data to inspect.
-      data: {
-        // This is where the resultObject children are cached.
-        rootCacheId: aResponse.childrenCacheId,
-        remoteObject: aResponse.resultObject,
-        // This is where all objects retrieved by the panel will be cached.
-        panelCacheId: "HUDPanel-" + HUDService.sequenceId(),
-        remoteObjectProvider: this.remoteObjectProvider.bind(this),
-      },
-    };
-
-    options.updateButtonCallback = function JST__evalUpdateButton() {
-      this.evalInContentSandbox(aResponse.input,
-        this._evalOutputUpdatePanelCallback.bind(this, options, propPanel,
-                                                 aResponse));
-    }.bind(this);
-
-    let propPanel = this.openPropertyPanel(options);
-    propPanel.panel.setAttribute("hudId", this.hudId);
-
-    let onPopupHide = function JST__evalInspectPopupHide() {
-      propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
-
-      this.clearObjectCache(options.data.panelCacheId);
-
-      if (!aLinkNode.parentNode && aLinkNode._evalCacheId) {
-        this.clearObjectCache(aLinkNode._evalCacheId);
-      }
-    }.bind(this);
-
-    propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
-  },
-
-  /**
-   * The callback used for updating the Property Panel when the user clicks the
-   * Update button.
-   *
-   * @private
-   * @param object aOptions
-   *        The options object used for opening the initial Property Panel.
-   * @param object aPropPanel
-   *        The Property Panel instance.
-   * @param object aOldResponse
-   *        The previous JSTerm:EvalResult message received from the content
-   *        process.
-   * @param object aNewResponse
-   *        The new JSTerm:EvalResult message received after the user clicked
-   *        the Update button.
-   */
-  _evalOutputUpdatePanelCallback:
-  function JST__updatePanelCallback(aOptions, aPropPanel, aOldResponse,
-                                    aNewResponse)
-  {
-    if (aNewResponse.errorMessage) {
-      this.writeOutput(aNewResponse.errorMessage, CATEGORY_OUTPUT,
-                       SEVERITY_ERROR);
-      return;
-    }
-
-    if (!aNewResponse.inspectable) {
-      this.writeOutput(l10n.getStr("JSTerm.updateNotInspectable"), CATEGORY_OUTPUT, SEVERITY_ERROR);
-      return;
-    }
-
-    this.clearObjectCache(aOptions.data.panelCacheId);
-    this.clearObjectCache(aOptions.data.rootCacheId);
-
-    if (aOptions.anchor && aOptions.anchor._evalCacheId) {
-      aOptions.anchor._evalCacheId = aNewResponse.childrenCacheId;
-    }
-
-    // Update the old response object such that when the panel is reopen, the
-    // user sees the new response.
-    aOldResponse.id = aNewResponse.id;
-    aOldResponse.childrenCacheId = aNewResponse.childrenCacheId;
-    aOldResponse.resultObject = aNewResponse.resultObject;
-    aOldResponse.resultString = aNewResponse.resultString;
-
-    aOptions.data.rootCacheId = aNewResponse.childrenCacheId;
-    aOptions.data.remoteObject = aNewResponse.resultObject;
-
-    // TODO: This updates the value of the tree.
-    // However, the states of open nodes is not saved.
-    // See bug 586246.
-    aPropPanel.treeView.data = aOptions.data;
-  },
-
-  /**
-   * Destroy the JSTerm object. Call this method to avoid memory leaks.
-   */
-  destroy: function JST_destroy()
-  {
-    this.clearCompletion();
-    this.clearOutput();
-
-    this.autocompletePopup.destroy();
-
-    this.inputNode.removeEventListener("keypress", this._keyPress, false);
-    this.inputNode.removeEventListener("input", this._inputEventHandler, false);
-    this.inputNode.removeEventListener("keyup", this._inputEventHandler, false);
-
-    delete this.history;
-    delete this.hud;
-    delete this.autocompletePopup;
-    delete this.document;
-  },
-};
-
-//////////////////////////////////////////////////////////////////////////////
-// Utility functions used by multiple callers
-//////////////////////////////////////////////////////////////////////////////
-
-/**
- * ConsoleUtils: a collection of globally used functions
- *
- */
-ConsoleUtils = {
-  /**
-   * Flag to turn on and off scrolling.
-   */
-  scroll: true,
-
-  /**
-   * Scrolls a node so that it's visible in its containing XUL "scrollbox"
-   * element.
-   *
-   * @param nsIDOMNode aNode
-   *        The node to make visible.
-   * @returns void
-   */
-  scrollToVisible: function ConsoleUtils_scrollToVisible(aNode) {
-    if (!this.scroll) {
-      return;
-    }
-
-    // Find the enclosing richlistbox node.
-    let richListBoxNode = aNode.parentNode;
-    while (richListBoxNode.tagName != "richlistbox") {
-      richListBoxNode = richListBoxNode.parentNode;
-    }
-
-    // Use the scroll box object interface to ensure the element is visible.
-    let boxObject = richListBoxNode.scrollBoxObject;
-    let nsIScrollBoxObject = boxObject.QueryInterface(Ci.nsIScrollBoxObject);
-    nsIScrollBoxObject.ensureElementIsVisible(aNode);
-  },
-
-  /**
-   * Given a category and message body, creates a DOM node to represent an
-   * incoming message. The timestamp is automatically added.
-   *
-   * @param nsIDOMDocument aDocument
-   *        The document in which to create the node.
-   * @param number aCategory
-   *        The category of the message: one of the CATEGORY_* constants.
-   * @param number aSeverity
-   *        The severity of the message: one of the SEVERITY_* constants;
-   * @param string|nsIDOMNode aBody
-   *        The body of the message, either a simple string or a DOM node.
-   * @param number aHUDId
-   *        The HeadsUpDisplay ID.
-   * @param string aSourceURL [optional]
-   *        The URL of the source file that emitted the error.
-   * @param number aSourceLine [optional]
-   *        The line number on which the error occurred. If zero or omitted,
-   *        there is no line number associated with this message.
-   * @param string aClipboardText [optional]
-   *        The text that should be copied to the clipboard when this node is
-   *        copied. If omitted, defaults to the body text. If `aBody` is not
-   *        a string, then the clipboard text must be supplied.
-   * @param number aLevel [optional]
-   *        The level of the console API message.
-   * @param number aTimeStamp [optional]
-   *        The timestamp to use for this message node. If omitted, the current
-   *        date and time is used.
-   * @return nsIDOMNode
-   *         The message node: a XUL richlistitem ready to be inserted into
-   *         the Web Console output node.
-   */
-  createMessageNode:
-  function ConsoleUtils_createMessageNode(aDocument, aCategory, aSeverity,
-                                          aBody, aHUDId, aSourceURL,
-                                          aSourceLine, aClipboardText, aLevel,
-                                          aTimeStamp) {
-    if (typeof aBody != "string" && aClipboardText == null && aBody.innerText) {
-      aClipboardText = aBody.innerText;
-    }
-
-    // Make the icon container, which is a vertical box. Its purpose is to
-    // ensure that the icon stays anchored at the top of the message even for
-    // long multi-line messages.
-    let iconContainer = aDocument.createElementNS(XUL_NS, "vbox");
-    iconContainer.classList.add("webconsole-msg-icon-container");
-    // Apply the curent group by indenting appropriately.
-    let hud = HUDService.getHudReferenceById(aHUDId);
-    iconContainer.style.marginLeft = hud.groupDepth * GROUP_INDENT + "px";
-
-    // Make the icon node. It's sprited and the actual region of the image is
-    // determined by CSS rules.
-    let iconNode = aDocument.createElementNS(XUL_NS, "image");
-    iconNode.classList.add("webconsole-msg-icon");
-    iconContainer.appendChild(iconNode);
-
-    // Make the spacer that positions the icon.
-    let spacer = aDocument.createElementNS(XUL_NS, "spacer");
-    spacer.setAttribute("flex", "1");
-    iconContainer.appendChild(spacer);
-
-    // Create the message body, which contains the actual text of the message.
-    let bodyNode = aDocument.createElementNS(XUL_NS, "description");
-    bodyNode.setAttribute("flex", "1");
-    bodyNode.classList.add("webconsole-msg-body");
-
-    // Store the body text, since it is needed later for the property tree
-    // case.
-    let body = aBody;
-    // If a string was supplied for the body, turn it into a DOM node and an
-    // associated clipboard string now.
-    aClipboardText = aClipboardText ||
-                     (aBody + (aSourceURL ? " @ " + aSourceURL : "") +
-                              (aSourceLine ? ":" + aSourceLine : ""));
-    if (!(aBody instanceof Ci.nsIDOMNode)) {
-      aBody = aDocument.createTextNode(aLevel == "dir" ?
-                                       aBody.resultString : aBody);
-    }
-
-    if (!aBody.nodeType) {
-      aBody = aDocument.createTextNode(aBody.toString());
-    }
-    if (typeof aBody == "string") {
-      aBody = aDocument.createTextNode(aBody);
-    }
-
-    bodyNode.appendChild(aBody);
-
-    let repeatContainer = aDocument.createElementNS(XUL_NS, "hbox");
-    repeatContainer.setAttribute("align", "start");
-    let repeatNode = aDocument.createElementNS(XUL_NS, "label");
-    repeatNode.setAttribute("value", "1");
-    repeatNode.classList.add("webconsole-msg-repeat");
-    repeatContainer.appendChild(repeatNode);
-
-    // Create the timestamp.
-    let timestampNode = aDocument.createElementNS(XUL_NS, "label");
-    timestampNode.classList.add("webconsole-timestamp");
-    let timestamp = aTimeStamp || Date.now();
-    let timestampString = l10n.timestampString(timestamp);
-    timestampNode.setAttribute("value", timestampString);
-
-    // Create the source location (e.g. www.example.com:6) that sits on the
-    // right side of the message, if applicable.
-    let locationNode;
-    if (aSourceURL) {
-      locationNode = this.createLocationNode(aDocument, aSourceURL,
-                                             aSourceLine);
-    }
-
-    // Create the containing node and append all its elements to it.
-    let node = aDocument.createElementNS(XUL_NS, "richlistitem");
-    node.clipboardText = aClipboardText;
-    node.classList.add("hud-msg-node");
-
-    node.timestamp = timestamp;
-    ConsoleUtils.setMessageType(node, aCategory, aSeverity);
-
-    node.appendChild(timestampNode);
-    node.appendChild(iconContainer);
-    // Display the object tree after the message node.
-    if (aLevel == "dir") {
-      // Make the body container, which is a vertical box, for grouping the text
-      // and tree widgets.
-      let bodyContainer = aDocument.createElement("vbox");
-      bodyContainer.setAttribute("flex", "1");
-      bodyContainer.appendChild(bodyNode);
-      // Create the tree.
-      let tree = createElement(aDocument, "tree", {
-        flex: 1,
-        hidecolumnpicker: "true"
-      });
-
-      let treecols = aDocument.createElement("treecols");
-      let treecol = createElement(aDocument, "treecol", {
-        primary: "true",
-        flex: 1,
-        hideheader: "true",
-        ignoreincolumnpicker: "true"
-      });
-      treecols.appendChild(treecol);
-      tree.appendChild(treecols);
-
-      tree.appendChild(aDocument.createElement("treechildren"));
-
-      bodyContainer.appendChild(tree);
-      node.appendChild(bodyContainer);
-      node.classList.add("webconsole-msg-inspector");
-      // Create the treeView object.
-      let treeView = node.propertyTreeView = new PropertyTreeView();
-
-      treeView.data = {
-        rootCacheId: body.cacheId,
-        panelCacheId: body.cacheId,
-        remoteObject: body.remoteObject,
-        remoteObjectProvider: body.remoteObjectProvider,
-      };
-
-      tree.setAttribute("rows", treeView.rowCount);
-    }
-    else {
-      node.appendChild(bodyNode);
-    }
-    node.appendChild(repeatContainer);
-    if (locationNode) {
-      node.appendChild(locationNode);
-    }
-
-    node.setAttribute("id", "console-msg-" + HUDService.sequenceId());
-
-    return node;
-  },
-
-  /**
-   * Adjusts the category and severity of the given message, clearing the old
-   * category and severity if present.
-   *
-   * @param nsIDOMNode aMessageNode
-   *        The message node to alter.
-   * @param number aNewCategory
-   *        The new category for the message; one of the CATEGORY_ constants.
-   * @param number aNewSeverity
-   *        The new severity for the message; one of the SEVERITY_ constants.
-   * @return void
-   */
-  setMessageType:
-  function ConsoleUtils_setMessageType(aMessageNode, aNewCategory,
-                                       aNewSeverity) {
-    // Remove the old CSS classes, if applicable.
-    if ("category" in aMessageNode) {
-      let oldCategory = aMessageNode.category;
-      let oldSeverity = aMessageNode.severity;
-      aMessageNode.classList.remove("webconsole-msg-" +
-                                    CATEGORY_CLASS_FRAGMENTS[oldCategory]);
-      aMessageNode.classList.remove("webconsole-msg-" +
-                                    SEVERITY_CLASS_FRAGMENTS[oldSeverity]);
-      let key = "hud-" + MESSAGE_PREFERENCE_KEYS[oldCategory][oldSeverity];
-      aMessageNode.classList.remove(key);
-    }
-
-    // Add in the new CSS classes.
-    aMessageNode.category = aNewCategory;
-    aMessageNode.severity = aNewSeverity;
-    aMessageNode.classList.add("webconsole-msg-" +
-                               CATEGORY_CLASS_FRAGMENTS[aNewCategory]);
-    aMessageNode.classList.add("webconsole-msg-" +
-                               SEVERITY_CLASS_FRAGMENTS[aNewSeverity]);
-    let key = "hud-" + MESSAGE_PREFERENCE_KEYS[aNewCategory][aNewSeverity];
-    aMessageNode.classList.add(key);
-  },
-
-  /**
-   * Creates the XUL label that displays the textual location of an incoming
-   * message.
-   *
-   * @param nsIDOMDocument aDocument
-   *        The document in which to create the node.
-   * @param string aSourceURL
-   *        The URL of the source file responsible for the error.
-   * @param number aSourceLine [optional]
-   *        The line number on which the error occurred. If zero or omitted,
-   *        there is no line number associated with this message.
-   * @return nsIDOMNode
-   *         The new XUL label node, ready to be added to the message node.
-   */
-  createLocationNode:
-  function ConsoleUtils_createLocationNode(aDocument, aSourceURL,
-                                           aSourceLine) {
-    let locationNode = aDocument.createElementNS(XUL_NS, "label");
-
-    // Create the text, which consists of an abbreviated version of the URL
-    // plus an optional line number.
-    let text = WebConsoleUtils.abbreviateSourceURL(aSourceURL);
-    if (aSourceLine) {
-      text += ":" + aSourceLine;
-    }
-    locationNode.setAttribute("value", text);
-
-    // Style appropriately.
-    locationNode.setAttribute("crop", "center");
-    locationNode.setAttribute("title", aSourceURL);
-    locationNode.classList.add("webconsole-location");
-    locationNode.classList.add("text-link");
-
-    // Make the location clickable.
-    locationNode.addEventListener("click", function() {
-      if (aSourceURL == "Scratchpad") {
-        let win = Services.wm.getMostRecentWindow("devtools:scratchpad");
-        if (win) {
-          win.focus();
-        }
-        return;
-      }
-      let viewSourceUtils = aDocument.defaultView.gViewSourceUtils;
-      viewSourceUtils.viewSource(aSourceURL, null, aDocument, aSourceLine);
-    }, true);
-
-    return locationNode;
-  },
-
-  /**
-   * Applies the user's filters to a newly-created message node via CSS
-   * classes.
-   *
-   * @param nsIDOMNode aNode
-   *        The newly-created message node.
-   * @param string aHUDId
-   *        The ID of the HUD which this node is to be inserted into.
-   * @return boolean
-   *         True if the message was filtered or false otherwise.
-   */
-  filterMessageNode: function ConsoleUtils_filterMessageNode(aNode, aHUDId) {
-    let isFiltered = false;
-
-    // Filter by the message type.
-    let prefKey = MESSAGE_PREFERENCE_KEYS[aNode.category][aNode.severity];
-    if (prefKey && !HUDService.getFilterState(aHUDId, prefKey)) {
-      // The node is filtered by type.
-      aNode.classList.add("hud-filtered-by-type");
-      isFiltered = true;
-    }
-
-    // Filter on the search string.
-    let search = HUDService.getFilterStringByHUDId(aHUDId);
-    let text = aNode.clipboardText;
-
-    // if string matches the filter text
-    if (!HUDService.stringMatchesFilters(text, search)) {
-      aNode.classList.add("hud-filtered-by-string");
-      isFiltered = true;
-    }
-
-    return isFiltered;
-  },
-
-  /**
-   * Merge the attributes of the two nodes that are about to be filtered.
-   * Increment the number of repeats of aOriginal.
-   *
-   * @param nsIDOMNode aOriginal
-   *        The Original Node. The one being merged into.
-   * @param nsIDOMNode aFiltered
-   *        The node being filtered out because it is repeated.
-   */
-  mergeFilteredMessageNode:
-  function ConsoleUtils_mergeFilteredMessageNode(aOriginal, aFiltered) {
-    // childNodes[3].firstChild is the node containing the number of repetitions
-    // of a node.
-    let repeatNode = aOriginal.childNodes[3].firstChild;
-    if (!repeatNode) {
-      return aOriginal; // no repeat node, return early.
-    }
-
-    let occurrences = parseInt(repeatNode.getAttribute("value")) + 1;
-    repeatNode.setAttribute("value", occurrences);
-  },
-
-  /**
-   * Filter the css node from the output node if it is a repeat. CSS messages
-   * are merged with previous messages if they occurred in the past.
-   *
-   * @param nsIDOMNode aNode
-   *        The message node to be filtered or not.
-   * @param nsIDOMNode aOutput
-   *        The outputNode of the HUD.
-   * @returns boolean
-   *         true if the message is filtered, false otherwise.
-   */
-  filterRepeatedCSS:
-  function ConsoleUtils_filterRepeatedCSS(aNode, aOutput, aHUDId) {
-    let hud = HUDService.getHudReferenceById(aHUDId);
-
-    // childNodes[2] is the description node containing the text of the message.
-    let description = aNode.childNodes[2].textContent;
-    let location;
-
-    // childNodes[4] represents the location (source URL) of the error message.
-    // The full source URL is stored in the title attribute.
-    if (aNode.childNodes[4]) {
-      // browser_webconsole_bug_595934_message_categories.js
-      location = aNode.childNodes[4].getAttribute("title");
-    }
-    else {
-      location = "";
-    }
-
-    let dupe = hud.cssNodes[description + location];
-    if (!dupe) {
-      // no matching nodes
-      hud.cssNodes[description + location] = aNode;
-      return false;
-    }
-
-    this.mergeFilteredMessageNode(dupe, aNode);
-
-    return true;
-  },
-
-  /**
-   * Filter the console node from the output node if it is a repeat. Console
-   * messages are filtered from the output if and only if they match the
-   * immediately preceding message. The output node's last occurrence should
-   * have its timestamp updated.
-   *
-   * @param nsIDOMNode aNode
-   *        The message node to be filtered or not.
-   * @param nsIDOMNode aOutput
-   *        The outputNode of the HUD.
-   * @return boolean
-   *         true if the message is filtered, false otherwise.
-   */
-  filterRepeatedConsole:
-  function ConsoleUtils_filterRepeatedConsole(aNode, aOutput) {
-    let lastMessage = aOutput.lastChild;
-
-    // childNodes[2] is the description element
-    if (lastMessage && lastMessage.childNodes[2] &&
-        !aNode.classList.contains("webconsole-msg-inspector") &&
-        aNode.childNodes[2].textContent ==
-        lastMessage.childNodes[2].textContent) {
-      this.mergeFilteredMessageNode(lastMessage, aNode);
-      return true;
-    }
-
-    return false;
-  },
-
-  /**
-   * Check if the given output node is scrolled to the bottom.
-   *
-   * @param nsIDOMNode aOutputNode
-   * @return boolean
-   *         True if the output node is scrolled to the bottom, or false
-   *         otherwise.
-   */
-  isOutputScrolledToBottom:
-  function ConsoleUtils_isOutputScrolledToBottom(aOutputNode)
-  {
-    let lastNodeHeight = aOutputNode.lastChild ?
-                         aOutputNode.lastChild.clientHeight : 0;
-    let scrollBox = aOutputNode.scrollBoxObject.element;
-
-    return scrollBox.scrollTop + scrollBox.clientHeight >=
-           scrollBox.scrollHeight - lastNodeHeight / 2;
   },
 };
 
 //////////////////////////////////////////////////////////////////////////
 // HeadsUpDisplayUICommands
 //////////////////////////////////////////////////////////////////////////
 
 HeadsUpDisplayUICommands = {
@@ -4475,110 +1047,16 @@ HeadsUpDisplayUICommands = {
    *         The hudId or null if the active chrome window has no open Web
    *         Console.
    */
   getOpenHUD: function UIC_getOpenHUD() {
     let chromeWindow = HUDService.currentContext();
     let hudId = "hud_" + chromeWindow.gBrowser.selectedTab.linkedPanel;
     return hudId in HUDService.hudReferences ? hudId : null;
   },
-
-  /**
-   * The event handler that is called whenever a user switches a filter on or
-   * off.
-   *
-   * @param nsIDOMEvent aEvent
-   *        The event that triggered the filter change.
-   * @return boolean
-   */
-  toggleFilter: function UIC_toggleFilter(aEvent) {
-    let hudId = this.getAttribute("hudId");
-    switch (this.tagName) {
-      case "toolbarbutton": {
-        let originalTarget = aEvent.originalTarget;
-        let classes = originalTarget.classList;
-
-        if (originalTarget.localName !== "toolbarbutton") {
-          // Oddly enough, the click event is sent to the menu button when
-          // selecting a menu item with the mouse. Detect this case and bail
-          // out.
-          break;
-        }
-
-        if (!classes.contains("toolbarbutton-menubutton-button") &&
-            originalTarget.getAttribute("type") === "menu-button") {
-          // This is a filter button with a drop-down. The user clicked the
-          // drop-down, so do nothing. (The menu will automatically appear
-          // without our intervention.)
-          break;
-        }
-
-        let state = this.getAttribute("checked") !== "true";
-        this.setAttribute("checked", state);
-
-        // This is a filter button with a drop-down, and the user clicked the
-        // main part of the button. Go through all the severities and toggle
-        // their associated filters.
-        let menuItems = this.querySelectorAll("menuitem");
-        for (let i = 0; i < menuItems.length; i++) {
-          menuItems[i].setAttribute("checked", state);
-          let prefKey = menuItems[i].getAttribute("prefKey");
-          HUDService.setFilterState(hudId, prefKey, state);
-        }
-        break;
-      }
-
-      case "menuitem": {
-        let state = this.getAttribute("checked") !== "true";
-        this.setAttribute("checked", state);
-
-        let prefKey = this.getAttribute("prefKey");
-        HUDService.setFilterState(hudId, prefKey, state);
-
-        // Adjust the state of the button appropriately.
-        let menuPopup = this.parentNode;
-
-        let someChecked = false;
-        let menuItem = menuPopup.firstChild;
-        while (menuItem) {
-          if (menuItem.getAttribute("checked") === "true") {
-            someChecked = true;
-            break;
-          }
-          menuItem = menuItem.nextSibling;
-        }
-        let toolbarButton = menuPopup.parentNode;
-        toolbarButton.setAttribute("checked", someChecked);
-        break;
-      }
-    }
-
-    return true;
-  },
-
-  command: function UIC_command(aButton) {
-    var filter = aButton.getAttribute("buttonType");
-    var hudId = aButton.getAttribute("hudId");
-    switch (filter) {
-      case "copy": {
-        let outputNode = HUDService.hudReferences[hudId].outputNode;
-        HUDService.copySelectedItems(outputNode);
-        break;
-      }
-      case "selectAll": {
-        HUDService.hudReferences[hudId].outputNode.selectAll();
-        break;
-      }
-      case "saveBodies": {
-        let checked = aButton.getAttribute("checked") === "true";
-        HUDService.hudReferences[hudId].saveRequestAndResponseBodies = checked;
-        break;
-      }
-    }
-  },
 };
 
 //////////////////////////////////////////////////////////////////////////
 // WebConsoleObserver
 //////////////////////////////////////////////////////////////////////////
 
 let WebConsoleObserver = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
@@ -4596,102 +1074,13 @@ let WebConsoleObserver = {
   },
 
   uninit: function WCO_uninit()
   {
     Services.obs.removeObserver(this, "quit-application-granted");
   },
 };
 
-///////////////////////////////////////////////////////////////////////////////
-// CommandController
-///////////////////////////////////////////////////////////////////////////////
-
-/**
- * A controller (an instance of nsIController) that makes editing actions
- * behave appropriately in the context of the Web Console.
- */
-function CommandController(aWindow) {
-  this.window = aWindow;
-}
-
-CommandController.prototype = {
-  /**
-   * Returns the HUD output node that currently has the focus, or null if the
-   * currently-focused element isn't inside the output node.
-   *
-   * @returns nsIDOMNode
-   *          The currently-focused output node.
-   */
-  _getFocusedOutputNode: function CommandController_getFocusedOutputNode()
-  {
-    let element = this.window.document.commandDispatcher.focusedElement;
-    if (element && element.classList.contains("hud-output-node")) {
-      return element;
-    }
-    return null;
-  },
-
-  /**
-   * Copies the currently-selected entries in the Web Console output to the
-   * clipboard.
-   *
-   * @param nsIDOMNode aOutputNode
-   *        The Web Console output node.
-   * @returns void
-   */
-  copy: function CommandController_copy(aOutputNode)
-  {
-    HUDService.copySelectedItems(aOutputNode);
-  },
-
-  /**
-   * Selects all the text in the HUD output.
-   *
-   * @param nsIDOMNode aOutputNode
-   *        The HUD output node.
-   * @returns void
-   */
-  selectAll: function CommandController_selectAll(aOutputNode)
-  {
-    aOutputNode.selectAll();
-  },
-
-  supportsCommand: function CommandController_supportsCommand(aCommand)
-  {
-    return this.isCommandEnabled(aCommand);
-  },
-
-  isCommandEnabled: function CommandController_isCommandEnabled(aCommand)
-  {
-    let outputNode = this._getFocusedOutputNode();
-    if (!outputNode) {
-      return false;
-    }
-
-    switch (aCommand) {
-      case "cmd_copy":
-        // Only enable "copy" if nodes are selected.
-        return outputNode.selectedCount > 0;
-      case "cmd_selectAll":
-        // "Select All" is always enabled.
-        return true;
-    }
-  },
-
-  doCommand: function CommandController_doCommand(aCommand)
-  {
-    let outputNode = this._getFocusedOutputNode();
-    switch (aCommand) {
-      case "cmd_copy":
-        this.copy(outputNode);
-        break;
-      case "cmd_selectAll":
-        this.selectAll(outputNode);
-        break;
-    }
-  }
-};
 
 XPCOMUtils.defineLazyGetter(this, "HUDService", function () {
   return new HUD_SERVICE();
 });
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_579412_input_focus.js b/browser/devtools/webconsole/test/browser_webconsole_bug_579412_input_focus.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_579412_input_focus.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_579412_input_focus.js
@@ -10,16 +10,16 @@ const TEST_URI = "http://example.com/bro
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("DOMContentLoaded", testInputFocus, false);
 }
 
 function testInputFocus() {
   browser.removeEventListener("DOMContentLoaded", testInputFocus, false);
 
-  openConsole();
+  openConsole(null, function(hud) {
+    let inputNode = hud.jsterm.inputNode;
+    ok(inputNode.getAttribute("focused"), "input node is focused");
 
-  let inputNode = HUDService.getHudByWindow(content).jsterm.inputNode;
-  ok(inputNode.getAttribute("focused"), "input node is focused");
-
-  finishTest();
+    finishTest();
+  });
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_580001_closing_after_completion.js b/browser/devtools/webconsole/test/browser_webconsole_bug_580001_closing_after_completion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_580001_closing_after_completion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_580001_closing_after_completion.js
@@ -5,40 +5,37 @@
 
 // Tests to ensure that errors don't appear when the console is closed while a
 // completion is being performed.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testClosingAfterCompletion,
-                           false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testClosingAfterCompletion);
+  }, true);
 }
 
-function testClosingAfterCompletion() {
-  browser.removeEventListener("DOMContentLoaded",
-                              testClosingAfterCompletion, false);
-
-  openConsole();
-
-  let inputNode = HUDService.getHudByWindow(content).jsterm.inputNode;
+function testClosingAfterCompletion(hud) {
+  let inputNode = hud.jsterm.inputNode;
 
   let errorWhileClosing = false;
   function errorListener(evt) {
     errorWhileClosing = true;
   }
 
   browser.addEventListener("error", errorListener, false);
 
   // Focus the inputNode and perform the keycombo to close the WebConsole.
   inputNode.focus();
   EventUtils.synthesizeKey("k", { accelKey: true, shiftKey: true });
 
-  // We can't test for errors right away, because the error occures after a
+  // We can't test for errors right away, because the error occurs after a
   // setTimeout(..., 0) in the WebConsole code.
   executeSoon(function() {
     browser.removeEventListener("error", errorListener, false);
     is(errorWhileClosing, false, "no error while closing the WebConsole");
     finishTest();
   });
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_581231_close_button.js b/browser/devtools/webconsole/test/browser_webconsole_bug_581231_close_button.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_581231_close_button.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_581231_close_button.js
@@ -9,38 +9,29 @@
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that the Web Console close button functions.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testCloseButton, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testCloseButton);
+  }, true);
 }
 
-function testCloseButton() {
-  browser.removeEventListener("DOMContentLoaded", testCloseButton, false);
-
-  openConsole();
-
-  let hud = HUDService.getHudByWindow(content);
+function testCloseButton(hud) {
   let hudId = hud.hudId;
-
   HUDService.disableAnimation(hudId);
-  executeSoon(function() {
-    let closeButton = hud.HUDBox.querySelector(".webconsole-close-button");
+  waitForFocus(function() {
+    let closeButton = hud.ui.closeButton;
     ok(closeButton != null, "we have the close button");
 
-    // XXX: ASSERTION: ###!!! ASSERTION: XPConnect is being called on a scope without a 'Components' property!: 'Error', file /home/ddahl/code/moz/mozilla-central/mozilla-central/js/src/xpconnect/src/xpcwrappednativescope.cpp, line 795
+    EventUtils.synthesizeMouse(closeButton, 2, 2, {}, hud.iframeWindow);
 
-    closeButton.addEventListener("command", function() {
-      closeButton.removeEventListener("command", arguments.callee, false);
+    ok(!(hudId in HUDService.hudReferences), "the console is closed when " +
+       "the close button is pressed");
 
-      ok(!(hudId in HUDService.hudReferences), "the console is closed when " +
-         "the close button is pressed");
-      closeButton = null;
-      finishTest();
-    }, false);
-
-    EventUtils.synthesizeMouse(closeButton, 2, 2, {});
-  });
+    finishTest();
+  }, hud.iframeWindow);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js b/browser/devtools/webconsole/test/browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js
@@ -2,25 +2,24 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/browser/test-console.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testCompletion, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testCompletion);
+  }, true);
 }
 
-function testCompletion() {
-  browser.removeEventListener("DOMContentLoaded", testCompletion, false);
-
-  openConsole();
-
-  var jsterm = HUDService.getHudByWindow(content).jsterm;
+function testCompletion(hud) {
+  var jsterm = hud.jsterm;
   var input = jsterm.inputNode;
 
   jsterm.setInputValue("");
   EventUtils.synthesizeKey("VK_TAB", {});
   is(jsterm.completeNode.value, "<- no result", "<- no result - matched");
   is(input.value, "", "inputnode is empty - matched")
   is(input.getAttribute("focused"), "true", "input is still focused");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_popup.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_popup.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_popup.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_popup.js
@@ -2,31 +2,29 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>bug 585991 - autocomplete popup test";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", tabLoaded, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
 
-function tabLoaded() {
-  browser.removeEventListener("load", tabLoaded, true);
-  openConsole();
-
+function consoleOpened(HUD) {
   let items = [
     {label: "item0", value: "value0"},
     {label: "item1", value: "value1"},
     {label: "item2", value: "value2"},
   ];
 
-  let hudId = HUDService.getHudIdByWindow(content);
-  let HUD = HUDService.hudReferences[hudId];
   let popup = HUD.jsterm.autocompletePopup;
 
   ok(!popup.isOpen, "popup is not open");
 
   popup._panel.addEventListener("popupshown", function() {
     popup._panel.removeEventListener("popupshown", arguments.callee, false);
 
     ok(popup.isOpen, "popup is open");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
@@ -42,40 +42,39 @@ function testSelectionWhenMovingBetweenB
 function performTestsAfterOutput(hud) {
   let outputNode = hud.outputNode;
 
   ok(outputNode.childNodes.length >= 3, "the output node has children after " +
      "executing some JavaScript");
 
   // Test that the global Firefox "Select All" functionality (e.g. Edit >
   // Select All) works properly in the Web Console.
-  let commandController = window.webConsoleCommandController;
+  let commandController = hud.ui._commandController;
   ok(commandController != null, "the window has a command controller object");
 
   commandController.selectAll(outputNode);
   is(outputNode.selectedCount, outputNode.childNodes.length, "all console " +
      "messages are selected after performing a regular browser select-all " +
      "operation");
 
   outputNode.selectedIndex = -1;
 
   // Test the context menu "Select All" (which has a different code path) works
   // properly as well.
   let contextMenuId = outputNode.getAttribute("context");
-  let contextMenu = document.getElementById(contextMenuId);
+  let contextMenu = hud.ui.document.getElementById(contextMenuId);
   ok(contextMenu != null, "the output node has a context menu");
 
   let selectAllItem = contextMenu.querySelector("*[buttonType=\"selectAll\"]");
   ok(selectAllItem != null,
      "the context menu on the output node has a \"Select All\" item");
 
-  let commandEvent = document.createEvent("XULCommandEvent");
-  commandEvent.initCommandEvent("command", true, true, window, 0, false, false,
-                                false, false, null);
-  selectAllItem.dispatchEvent(commandEvent);
+  outputNode.focus();
+
+  selectAllItem.doCommand();
 
   is(outputNode.selectedCount, outputNode.childNodes.length, "all console " +
      "messages are selected after performing a select-all operation from " +
      "the context menu");
 
   outputNode.selectedIndex = -1;
 
   finishTest();
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js b/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
@@ -5,25 +5,29 @@
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *  Patrick Walton <pcwalton@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
+let HUD, outputNode;
+
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
     openConsole(null, consoleOpened);
   }, true);
 }
 
-function consoleOpened(HUD) {
+function consoleOpened(aHud) {
+  HUD = aHud;
+
   // See bugs 574036, 586386 and 587617.
   outputNode = HUD.outputNode;
   let selection = getSelection();
   let jstermInput = HUD.jsterm.inputNode;
   let console = content.wrappedJSObject.console;
   let contentSelection = content.wrappedJSObject.getSelection();
 
   HUD.jsterm.clearOutput();
@@ -56,28 +60,27 @@ function consoleOpened(HUD) {
     failureFn: finishTest,
   });
 }
 
 // Test that the context menu "Copy" (which has a different code path) works
 // properly as well.
 function testContextMenuCopy() {
   let contextMenuId = outputNode.getAttribute("context");
-  let contextMenu = document.getElementById(contextMenuId);
+  let contextMenu = HUD.ui.document.getElementById(contextMenuId);
   ok(contextMenu, "the output node has a context menu");
 
   let copyItem = contextMenu.querySelector("*[buttonType=\"copy\"]");
   ok(copyItem, "the context menu on the output node has a \"Copy\" item");
 
-  let commandEvent = document.createEvent("XULCommandEvent");
-  commandEvent.initCommandEvent("command", true, true, window, 0, false, false,
-                                false, false, null);
-  copyItem.dispatchEvent(commandEvent);
+  copyItem.doCommand();
 
   let selectedNode = outputNode.getItemAtIndex(0);
+
+  HUD = outputNode = null;
   waitForClipboard(getExpectedClipboardText(selectedNode), clipboardSetup,
     finishTest, finishTest);
 }
 
 function getExpectedClipboardText(aItem) {
   return "[" + WebConsoleUtils.l10n.timestampString(aItem.timestamp) + "] " +
          aItem.clipboardText;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_588342_document_focus.js b/browser/devtools/webconsole/test/browser_webconsole_bug_588342_document_focus.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_588342_document_focus.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_588342_document_focus.js
@@ -4,65 +4,36 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 588342";
-let fm, notificationBox, input;
+let fm;
 
 function test() {
   fm = Cc["@mozilla.org/focus-manager;1"].getService(Ci.nsIFocusManager);
   addTab(TEST_URI);
-  browser.addEventListener("load", tabLoad, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
 
-function tabLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
-
-  notificationBox = gBrowser.getNotificationBox(browser);
-  let DOMNodeInserted = false;
-
-  document.addEventListener("DOMNodeInserted", function(aEvent) {
-    input = notificationBox.querySelector(".jsterm-input-node");
-    if (input && !DOMNodeInserted) {
-      DOMNodeInserted = true;
-      document.removeEventListener(aEvent.type, arguments.callee, false);
-      if (!input.getAttribute("focused")) {
-        input.addEventListener("focus", function(aEvent) {
-          input.removeEventListener(aEvent.type, arguments.callee, false);
-          executeSoon(runTest);
-        }, false);
-      }
-      else {
-        executeSoon(runTest);
-      }
-    }
-  }, false);
-
+function consoleOpened(hud) {
   waitForFocus(function() {
-    openConsole();
-  }, content);
+    is(hud.jsterm.inputNode.getAttribute("focused"), "true",
+       "jsterm input is focused on web console open");
+    isnot(fm.focusedWindow, content, "content document has no focus");
+    closeConsole(null, consoleClosed);
+  }, hud.iframeWindow);
 }
 
-function runTest() {
-  is(input.getAttribute("focused"), "true", "input node is focused");
-  isnot(fm.focusedWindow, content, "content document has no focus");
+function consoleClosed() {
+  is(fm.focusedWindow, browser.contentWindow,
+     "content document has focus");
 
-  let DOMNodeRemoved = false;
-  function domNodeRemoved(aEvent) {
-    executeSoon(function() {
-      if (!DOMNodeRemoved && !notificationBox.querySelector(".hud-box")) {
-        DOMNodeRemoved = true;
-        document.removeEventListener(aEvent.type, domNodeRemoved, false);
-        is(fm.focusedWindow, browser.contentWindow,
-           "content document has focus");
-        input = notificationBox = fm = null;
-        finishTest();
-      }
-    });
-  }
-  document.addEventListener("DOMNodeRemoved", domNodeRemoved, false);
-  HUDService.deactivateHUDForContext(tab);
+  fm = null;
+  finishTest();
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_588967_input_expansion.js b/browser/devtools/webconsole/test/browser_webconsole_bug_588967_input_expansion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_588967_input_expansion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_588967_input_expansion.js
@@ -2,25 +2,24 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testInputExpansion, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testInputExpansion);
+  }, true);
 }
 
-function testInputExpansion() {
-  browser.removeEventListener("DOMContentLoaded", testInputExpansion, false);
-
-  openConsole();
-
-  let input = HUDService.getHudByWindow(content).jsterm.inputNode;
+function testInputExpansion(hud) {
+  let input = hud.jsterm.inputNode;
 
   input.focus();
 
   is(input.getAttribute("multiline"), "true", "multiline is enabled");
 
   let ordinaryHeight = input.clientHeight;
 
   // Tests if the inputNode expands.
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js b/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js
@@ -25,37 +25,38 @@ function onContentLoaded()
   waitForSuccess({
     name: "css error displayed",
     validatorFn: function()
     {
       return outputNode.textContent.indexOf("foobarCssParser") > -1;
     },
     successFn: function()
     {
-      HUDService.setFilterState(hudId, "cssparser", false);
+      HUD.setFilterState("cssparser", false);
 
       let msg = "the unknown CSS property warning is not displayed, " +
                 "after filtering";
       testLogEntry(outputNode, "foobarCssParser", msg, true, true);
 
-      HUDService.setFilterState(hudId, "cssparser", true);
+      HUD.setFilterState("cssparser", true);
       finishTest();
     },
     failureFn: finishTest,
   });
 }
 
 /**
  * Unit test for bug 589162:
  * CSS filtering on the console does not work
  */
 function test()
 {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
 
-    openConsole();
-    browser.addEventListener("load", onContentLoaded, true);
-    content.location.reload();
+    openConsole(null, function() {
+      browser.addEventListener("load", onContentLoaded, true);
+      content.location.reload();
+    });
   }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_592442_closing_brackets.js b/browser/devtools/webconsole/test/browser_webconsole_bug_592442_closing_brackets.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_592442_closing_brackets.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_592442_closing_brackets.js
@@ -10,34 +10,32 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that, when the user types an extraneous closing bracket, no error
 // appears.
 
 function test() {
   addTab("data:text/html;charset=utf-8,test for bug 592442");
-  browser.addEventListener("load", testExtraneousClosingBrackets, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testExtraneousClosingBrackets);
+  }, true);
 }
 
-function testExtraneousClosingBrackets(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
-
-  openConsole();
-
-  let jsterm = HUDService.getHudByWindow(content).jsterm;
+function testExtraneousClosingBrackets(hud) {
+  let jsterm = hud.jsterm;
 
   jsterm.setInputValue("document.getElementById)");
 
   let error = false;
   try {
     jsterm.complete(jsterm.COMPLETE_HINT_ONLY);
   }
   catch (ex) {
     error = true;
   }
 
   ok(!error, "no error was thrown when an extraneous bracket was inserted");
 
-  HUDService.deactivateHUDForContext(tab);
   finishTest();
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js b/browser/devtools/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
@@ -6,41 +6,36 @@
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 let inputNode, values;
 
 function tabLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
+  browser.removeEventListener(aEvent.type, tabLoad, true);
 
-  waitForFocus(function() {
-    openConsole();
-
-    let hudId = HUDService.getHudIdByWindow(content);
-    let HUD = HUDService.hudReferences[hudId];
-
+  openConsole(null, function(HUD) {
     inputNode = HUD.jsterm.inputNode;
 
     inputNode.focus();
 
     ok(!inputNode.value, "inputNode.value is empty");
 
     values = ["document", "window", "document.body"];
     values.push(values.join(";\n"), "document.location");
 
     // Execute each of the values;
     for (let i = 0; i < values.length; i++) {
       HUD.jsterm.setInputValue(values[i]);
       HUD.jsterm.execute();
     }
 
     performTests();
-  }, content);
+  });
 }
 
 function performTests() {
   EventUtils.synthesizeKey("VK_UP", {});
 
   is(inputNode.value, values[4],
      "VK_UP: inputNode.value #4 is correct");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js b/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
@@ -52,17 +52,18 @@ function addTabs(aWindow) {
 
 function openConsoles() {
   // open the Web Console for each of the four tabs and log a message.
   let consolesOpen = 0;
   for (let i = 0; i < openTabs.length; i++) {
     let tab = openTabs[i];
     openConsole(tab, function(index, hud) {
       ok(hud, "HUD is open for tab " + index);
-      hud.browser.contentWindow.console.log("message for tab " + index);
+      let window = hud.tab.linkedBrowser.contentWindow;
+      window.console.log("message for tab " + index);
       consolesOpen++;
     }.bind(null, i));
   }
 
   waitForSuccess({
     name: "4 web consoles opened",
     validatorFn: function()
     {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_597136_external_script_errors.js b/browser/devtools/webconsole/test/browser_webconsole_bug_597136_external_script_errors.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_597136_external_script_errors.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_597136_external_script_errors.js
@@ -9,25 +9,25 @@
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/" +
                  "webconsole/test/test-bug-597136-external-script-" +
                  "errors.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", tabLoaded, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
 
-function tabLoaded(aEvent) {
-  browser.removeEventListener("load", tabLoaded, true);
-  openConsole();
-
+function consoleOpened(hud) {
   let button = content.document.querySelector("button");
-  let outputNode = HUDService.getHudByWindow(content).outputNode;
+  let outputNode = hud.outputNode;
 
   expectUncaughtException();
   EventUtils.sendMouseEvent({ type: "click" }, button, content);
 
   waitForSuccess({
     name: "external script error message",
     validatorFn: function()
     {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_597460_filter_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_597460_filter_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_597460_filter_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_597460_filter_scroll.js
@@ -12,21 +12,21 @@ const TEST_URI = "http://example.com/bro
 
 function consoleOpened(aHud) {
   hud = aHud;
 
   for (let i = 0; i < 200; i++) {
     content.console.log("test message " + i);
   }
 
-  HUDService.setFilterState(hud.hudId, "network", false);
-  HUDService.setFilterState(hud.hudId, "networkinfo", false);
+  hud.setFilterState("network", false);
+  hud.setFilterState("networkinfo", false);
 
-  hud.filterBox.value = "test message";
-  HUDService.updateFilterText(hud.filterBox);
+  hud.ui.filterBox.value = "test message";
+  hud.ui.adjustVisibilityOnSearchStringChange();
 
   let waitForNetwork = {
     name: "network message",
     validatorFn: function()
     {
       return hud.outputNode.querySelector(".webconsole-msg-network");
     },
     successFn: testScroll,
@@ -62,18 +62,18 @@ function testScroll() {
   ok(scrollBox.scrollTop > 0, "scroll location is not at the top");
 
   // Make sure the Web Console output is scrolled as near as possible to the
   // bottom.
   let nodeHeight = hud.outputNode.querySelector(".hud-log").clientHeight;
   ok(scrollBox.scrollTop >= scrollBox.scrollHeight - scrollBox.clientHeight -
      nodeHeight * 2, "scroll location is correct");
 
-  HUDService.setFilterState(hud.hudId, "network", true);
-  HUDService.setFilterState(hud.hudId, "networkinfo", true);
+  hud.setFilterState("network", true);
+  hud.setFilterState("networkinfo", true);
 
   executeSoon(finishTest);
 }
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js b/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
@@ -30,17 +30,17 @@ function test()
   addTab("data:text/html;charset=utf-8,Web Console - bug 600183 test");
 
   let initialLoad = true;
 
   browser.addEventListener("load", function onLoad() {
     if (initialLoad) {
       openConsole(null, function(hud) {
 
-        hud.saveRequestAndResponseBodies = true;
+        hud.ui.saveRequestAndResponseBodies = true;
         HUDService.lastFinishedRequestCallback = performTest;
 
         content.location = TEST_URI;
       });
       initialLoad = false;
     } else {
       browser.removeEventListener("load", onLoad, true);
     }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_601667_filter_buttons.js b/browser/devtools/webconsole/test/browser_webconsole_bug_601667_filter_buttons.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_601667_filter_buttons.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_601667_filter_buttons.js
@@ -2,26 +2,26 @@
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests that the filter button UI logic works correctly.
 
 const TEST_URI = "http://example.com/";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", testFilterButtons, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testFilterButtons);
+  }, true);
 }
 
-function testFilterButtons() {
-  browser.removeEventListener("load", testFilterButtons, true);
-  openConsole();
-
-  let hud = HUDService.getHudByWindow(content);
+function testFilterButtons(aHud) {
+  hud = aHud;
   hudId = hud.hudId;
-  hudBox = hud.HUDBox;
+  hudBox = hud.ui.rootElement;
 
   testMenuFilterButton("net");
   testMenuFilterButton("css");
   testMenuFilterButton("js");
   testMenuFilterButton("logging");
 
   finishTest();
 }
@@ -47,35 +47,35 @@ function testMenuFilterButton(aCategory)
   // Turn all the filters on; make sure the button gets checked.
   menuItem = firstMenuItem;
   let prefKey;
   while (menuItem) {
     prefKey = menuItem.getAttribute("prefKey");
     chooseMenuItem(menuItem);
     ok(isChecked(menuItem), "menu item " + prefKey + " for category " +
        aCategory + " is checked after clicking it");
-    ok(HUDService.filterPrefs[hudId][prefKey], prefKey + " messages are " +
+    ok(hud.ui.filterPrefs[prefKey], prefKey + " messages are " +
        "on after clicking the appropriate menu item");
     menuItem = menuItem.nextSibling;
   }
   ok(isChecked(button), "the button for category " + aCategory + " is " +
      "checked after turning on all its menu items");
 
   // Turn one filter off; make sure the button is still checked.
   prefKey = firstMenuItem.getAttribute("prefKey");
   chooseMenuItem(firstMenuItem);
   ok(!isChecked(firstMenuItem), "the first menu item for category " +
      aCategory + " is no longer checked after clicking it");
-  ok(!HUDService.filterPrefs[hudId][prefKey], prefKey + " messages are " +
+  ok(!hud.ui.filterPrefs[prefKey], prefKey + " messages are " +
      "turned off after clicking the appropriate menu item");
   ok(isChecked(button), "the button for category " + aCategory + " is still " +
      "checked after turning off its first menu item");
 
   // Turn all the filters off by clicking the main part of the button.
-  let anonymousNodes = document.getAnonymousNodes(button);
+  let anonymousNodes = hud.ui.document.getAnonymousNodes(button);
   let subbutton;
   for (let i = 0; i < anonymousNodes.length; i++) {
     let node = anonymousNodes[i];
     if (node.classList.contains("toolbarbutton-menubutton-button")) {
       subbutton = node;
       break;
     }
   }
@@ -85,33 +85,33 @@ function testMenuFilterButton(aCategory)
   ok(!isChecked(button), "the button for category " + aCategory + " is " +
      "no longer checked after clicking its main part");
 
   menuItem = firstMenuItem;
   while (menuItem) {
     let prefKey = menuItem.getAttribute("prefKey");
     ok(!isChecked(menuItem), "menu item " + prefKey + " for category " +
        aCategory + " is no longer checked after clicking the button");
-    ok(!HUDService.filterPrefs[hudId][prefKey], prefKey + " messages are " +
+    ok(!hud.ui.filterPrefs[prefKey], prefKey + " messages are " +
        "off after clicking the button");
     menuItem = menuItem.nextSibling;
   }
 
   // Turn all the filters on by clicking the main part of the button.
   clickButton(subbutton);
 
   ok(isChecked(button), "the button for category " + aCategory + " is " +
      "checked after clicking its main part");
 
   menuItem = firstMenuItem;
   while (menuItem) {
     let prefKey = menuItem.getAttribute("prefKey");
     ok(isChecked(menuItem), "menu item " + prefKey + " for category " +
        aCategory + " is checked after clicking the button");
-    ok(HUDService.filterPrefs[hudId][prefKey], prefKey + " messages are " +
+    ok(hud.ui.filterPrefs[prefKey], prefKey + " messages are " +
        "on after clicking the button");
     menuItem = menuItem.nextSibling;
   }
 
   // Uncheck the main button by unchecking all the filters
   menuItem = firstMenuItem;
   while (menuItem) {
     chooseMenuItem(menuItem);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_601909_remember_height.js b/browser/devtools/webconsole/test/browser_webconsole_bug_601909_remember_height.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_601909_remember_height.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_601909_remember_height.js
@@ -11,28 +11,21 @@
 // Minimum console height, in pixels.
 const MINIMUM_CONSOLE_HEIGHT = 150;
 
 // Minimum page height, in pixels. This prevents the Web Console from
 // remembering a height that covers the whole page.
 const MINIMUM_PAGE_HEIGHT = 50;
 const HEIGHT_PREF = "devtools.hud.height";
 
-let hud, newHeight, height;
+let hud, newHeight, height, innerHeight;
 
-function performTests(aEvent)
+function performTests(aWebConsole)
 {
-  browser.removeEventListener(aEvent, arguments.callee, true);
-
-  let innerHeight = content.innerHeight;
-
-  openConsole();
-
-  let hudId = HUDService.getHudIdByWindow(content);
-  hud = HUDService.hudReferences[hudId].HUDBox;
+  hud = aWebConsole.iframe;
   height = parseInt(hud.style.height);
 
   toggleConsole();
 
   is(newHeight, height, "same height after reopening the console");
   is(Services.prefs.getIntPref(HEIGHT_PREF), HUDService.lastConsoleHeight,
     "pref is correct");
 
@@ -73,24 +66,28 @@ function performTests(aEvent)
 }
 
 function toggleConsole()
 {
   closeConsole();
   openConsole();
 
   let hudId = HUDService.getHudIdByWindow(content);
-  hud = HUDService.hudReferences[hudId].HUDBox;
+  hud = HUDService.hudReferences[hudId].iframe;
   newHeight = parseInt(hud.style.height);
 }
 
 function setHeight(aHeight)
 {
   height = aHeight;
   hud.style.height = height + "px";
 }
 
 function test()
 {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 601909");
-  browser.addEventListener("load", performTests, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    innerHeight = content.innerHeight;
+    openConsole(null, performTests);
+  }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js b/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
@@ -14,67 +14,82 @@ function test()
 {
   // open tab 1
   addTab("data:text/html;charset=utf-8,Web Console test for bug 602572: log bodies checkbox. tab 1");
   tabs.push(tab);
 
   browser.addEventListener("load", function onLoad1(aEvent) {
     browser.removeEventListener(aEvent.type, onLoad1, true);
 
-    openConsole(null, function() {
+    openConsole(null, function(aHud) {
+      info("iframe1 height " + aHud.iframe.clientHeight);
+      info("iframe1 root height " + aHud.ui.rootElement.clientHeight);
+
       // open tab 2
       addTab("data:text/html;charset=utf-8,Web Console test for bug 602572: log bodies checkbox. tab 2");
       tabs.push(tab);
 
       browser.addEventListener("load", function onLoad2(aEvent) {
         browser.removeEventListener(aEvent.type, onLoad2, true);
 
-        openConsole(null, startTest);
+        openConsole(null, function(aHud) {
+          info("iframe2 height " + aHud.iframe.clientHeight);
+          info("iframe2 root height " + aHud.ui.rootElement.clientHeight);
+          waitForFocus(startTest, aHud.iframeWindow);
+        });
       }, true);
     });
   }, true);
 }
 
 function startTest()
 {
   // Find the relevant elements in the Web Console of tab 2.
   let win2 = tabs[1].linkedBrowser.contentWindow;
   let hudId2 = HUDService.getHudIdByWindow(win2);
   huds[1] = HUDService.hudReferences[hudId2];
   HUDService.disableAnimation(hudId2);
 
-  menuitems[1] = huds[1].HUDBox.querySelector("menuitem[buttonType=saveBodies]");
-  menupopups[1] = huds[1].HUDBox.querySelector("menupopup");
+  menuitems[1] = huds[1].ui.rootElement
+                 .querySelector("menuitem[buttonType=saveBodies]");
+  menupopups[1] = huds[1].ui.rootElement.querySelector("menupopup");
 
   // Open the context menu from tab 2.
   menupopups[1].addEventListener("popupshown", onpopupshown2, false);
-  menupopups[1].openPopup(huds[1].outputNode, "overlap", 10, 10, true, false);
+  executeSoon(function() {
+    menupopups[1].openPopup();
+  });
 }
 
 function onpopupshown2(aEvent)
 {
   menupopups[1].removeEventListener(aEvent.type, onpopupshown2, false);
 
   // By default bodies are not logged.
   isnot(menuitems[1].getAttribute("checked"), "true",
         "menuitems[1] is not checked");
 
-  ok(!huds[1].saveRequestAndResponseBodies, "bodies are not logged");
+  ok(!huds[1].ui.saveRequestAndResponseBodies, "bodies are not logged");
 
   // Enable body logging.
-  huds[1].saveRequestAndResponseBodies = true;
+  huds[1].ui.saveRequestAndResponseBodies = true;
 
   menupopups[1].addEventListener("popuphidden", function _onhidden(aEvent) {
     menupopups[1].removeEventListener(aEvent.type, _onhidden, false);
 
     // Reopen the context menu.
     menupopups[1].addEventListener("popupshown", onpopupshown2b, false);
-    menupopups[1].openPopup(huds[1].outputNode, "overlap", 11, 11, true, false);
+    executeSoon(function() {
+      menupopups[1].openPopup();
+    });
   }, false);
-  menupopups[1].hidePopup();
+
+  executeSoon(function() {
+    menupopups[1].hidePopup();
+  });
 }
 
 function onpopupshown2b(aEvent)
 {
   menupopups[1].removeEventListener(aEvent.type, onpopupshown2b, false);
   is(menuitems[1].getAttribute("checked"), "true", "menuitems[1] is checked");
 
   menupopups[1].addEventListener("popuphidden", function _onhidden(aEvent) {
@@ -84,49 +99,59 @@ function onpopupshown2b(aEvent)
     gBrowser.selectedTab = tabs[0];
     waitForFocus(function() {
       // Find the relevant elements in the Web Console of tab 1.
       let win1 = tabs[0].linkedBrowser.contentWindow;
       let hudId1 = HUDService.getHudIdByWindow(win1);
       huds[0] = HUDService.hudReferences[hudId1];
       HUDService.disableAnimation(hudId1);
 
-      menuitems[0] = huds[0].HUDBox.querySelector("menuitem[buttonType=saveBodies]");
-      menupopups[0] = huds[0].HUDBox.querySelector("menupopup");
+      info("iframe1 height " + huds[0].iframe.clientHeight);
+      info("iframe1 root height " + huds[0].ui.rootElement.clientHeight);
+
+      menuitems[0] = huds[0].ui.rootElement
+                     .querySelector("menuitem[buttonType=saveBodies]");
+      menupopups[0] = huds[0].ui.rootElement.querySelector("menupopup");
 
       menupopups[0].addEventListener("popupshown", onpopupshown1, false);
-      menupopups[0].openPopup(huds[0].outputNode, "overlap", 12, 12, true, false);
+      menupopups[0].openPopup();
     }, tabs[0].linkedBrowser.contentWindow);
   }, false);
-  menupopups[1].hidePopup();
+
+  executeSoon(function() {
+    menupopups[1].hidePopup();
+  });
 }
 
 function onpopupshown1(aEvent)
 {
   menupopups[0].removeEventListener(aEvent.type, onpopupshown1, false);
 
   // The menuitem checkbox must not be in sync with the other tabs.
   isnot(menuitems[0].getAttribute("checked"), "true",
         "menuitems[0] is not checked");
 
   // Enable body logging for tab 1 as well.
-  huds[0].saveRequestAndResponseBodies = true;
+  huds[0].ui.saveRequestAndResponseBodies = true;
 
   // Close the menu, and switch back to tab 2.
   menupopups[0].addEventListener("popuphidden", function _onhidden(aEvent) {
     menupopups[0].removeEventListener(aEvent.type, _onhidden, false);
 
     gBrowser.selectedTab = tabs[1];
     waitForFocus(function() {
       // Reopen the context menu from tab 2.
       menupopups[1].addEventListener("popupshown", onpopupshown2c, false);
-      menupopups[1].openPopup(huds[1].outputNode, "overlap", 13, 13, true, false);
+      menupopups[1].openPopup();
     }, tabs[1].linkedBrowser.contentWindow);
   }, false);
-  menupopups[0].hidePopup();
+
+  executeSoon(function() {
+    menupopups[0].hidePopup();
+  });
 }
 
 function onpopupshown2c(aEvent)
 {
   menupopups[1].removeEventListener(aEvent.type, onpopupshown2c, false);
 
   is(menuitems[1].getAttribute("checked"), "true", "menuitems[1] is checked");
 
@@ -135,10 +160,13 @@ function onpopupshown2c(aEvent)
 
     // Done!
     huds = menuitems = menupopups = tabs = null;
     closeConsole(gBrowser.selectedTab, function() {
       gBrowser.removeCurrentTab();
       executeSoon(finishTest);
     });
   }, false);
-  menupopups[1].hidePopup();
+
+  executeSoon(function() {
+    menupopups[1].hidePopup();
+  });
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
@@ -94,14 +94,14 @@ function performTest() {
     name: "jsterm output message",
     validatorFn: function()
     {
       return HUD.outputNode.querySelector(".webconsole-msg-output");
     },
     successFn: function()
     {
       let jstermMessage = HUD.outputNode.querySelector(".webconsole-msg-output");
-      EventUtils.synthesizeMouse(jstermMessage, 2, 2, {});
-      EventUtils.synthesizeMouse(networkLink, 2, 2, {});
+      EventUtils.synthesizeMouse(jstermMessage, 2, 2, {}, HUD.iframeWindow);
+      EventUtils.synthesizeMouse(networkLink, 2, 2, {}, HUD.iframeWindow);
     },
     failureFn: finishTest,
   });
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js
@@ -119,18 +119,18 @@ function performTest() {
     name: "jsterm output message",
     validatorFn: function()
     {
       return HUD.outputNode.querySelector(".webconsole-msg-output");
     },
     successFn: function()
     {
       let jstermMessage = HUD.outputNode.querySelector(".webconsole-msg-output");
-      EventUtils.synthesizeMouse(jstermMessage, 2, 2, {});
-      EventUtils.synthesizeMouse(networkLink, 2, 2, {});
+      EventUtils.synthesizeMouse(jstermMessage, 2, 2, {}, HUD.iframeWindow);
+      EventUtils.synthesizeMouse(networkLink, 2, 2, {}, HUD.iframeWindow);
     },
     failureFn: finishTest,
   });
 }
 
 function togglePBAndThen(callback) {
   function pbObserver(aSubject, aTopic, aData) {
     if (aTopic != "private-browsing-transition-complete") {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_622303_persistent_filters.js b/browser/devtools/webconsole/test/browser_webconsole_bug_622303_persistent_filters.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_622303_persistent_filters.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_622303_persistent_filters.js
@@ -1,115 +1,124 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
+let prefService = Services.prefs;
+
+let prefs = {
+  "net": [
+    "network",
+    "networkinfo"
+  ],
+  "css": [
+    "csserror",
+    "cssparser"
+  ],
+  "js": [
+    "exception",
+    "jswarn"
+  ],
+  "logging": [
+     "error",
+     "warn",
+     "info",
+     "log"
+  ]
+};
+
 function test() {
-  let prefService = Services.prefs;
-
-  let prefs = {
-    "net": [
-      "network",
-      "networkinfo"
-    ],
-    "css": [
-      "csserror",
-      "cssparser"
-    ],
-    "js": [
-      "exception",
-      "jswarn"
-    ],
-    "logging": [
-       "error",
-       "warn",
-       "info",
-       "log"
-    ]
-  };
-
   // Set all prefs to true
   for (let category in prefs) {
     prefs[category].forEach(function(pref) {
       prefService.setBoolPref("devtools.webconsole.filter." + pref, true);
     });
   }
 
   addTab("about:blank");
-  openConsole();
+  openConsole(null, onConsoleOpen);
+}
 
-  let hud = HUDService.getHudByWindow(content);
+function onConsoleOpen(hud) {
+  let hudBox = hud.ui.rootElement;
 
   // Check if the filters menuitems exists and are checked
   for (let category in prefs) {
-    let button = hud.HUDBox.querySelector(".webconsole-filter-button[category=\""
-                                           + category + "\"]");
+    let button = hudBox.querySelector(".webconsole-filter-button[category=\""
+                                      + category + "\"]");
     ok(isChecked(button), "main button for " + category + " category is checked");
 
     prefs[category].forEach(function(pref) {
-      let menuitem = hud.HUDBox.querySelector("menuitem[prefKey=" + pref + "]");
+      let menuitem = hudBox.querySelector("menuitem[prefKey=" + pref + "]");
       ok(isChecked(menuitem), "menuitem for " + pref + " is checked");
     });
   }
 
   // Set all prefs to false
   for (let category in prefs) {
     prefs[category].forEach(function(pref) {
-      HUDService.setFilterState(hud.hudId, pref, false);
+      hud.setFilterState(pref, false);
     });
   }
 
   //Re-init the console
-  closeConsole();
-  openConsole();
+  closeConsole(null, function() {
+    openConsole(null, onConsoleReopen1);
+  });
+}
 
-  hud = HUDService.getHudByWindow(content);
+function onConsoleReopen1(hud) {
+  let hudBox = hud.ui.rootElement;
 
   // Check if the filter button and menuitems are unchecked
   for (let category in prefs) {
-    let button = hud.HUDBox.querySelector(".webconsole-filter-button[category=\""
+    let button = hudBox.querySelector(".webconsole-filter-button[category=\""
                                            + category + "\"]");
     ok(isUnchecked(button), "main button for " + category + " category is not checked");
 
     prefs[category].forEach(function(pref) {
-      let menuitem = hud.HUDBox.querySelector("menuitem[prefKey=" + pref + "]");
+      let menuitem = hudBox.querySelector("menuitem[prefKey=" + pref + "]");
       ok(isUnchecked(menuitem), "menuitem for " + pref + " is not checked");
     });
   }
 
   // Set first pref in each category to true
   for (let category in prefs) {
-    HUDService.setFilterState(hud.hudId, prefs[category][0], true);
+    hud.setFilterState(prefs[category][0], true);
   }
 
   // Re-init the console
-  closeConsole();
-  openConsole();
+  closeConsole(null, function() {
+    openConsole(null, onConsoleReopen2);
+  });
+}
 
-  hud = HUDService.getHudByWindow(content);
+function onConsoleReopen2(hud) {
+  let hudBox = hud.ui.rootElement;
 
   // Check the main category button is checked and first menuitem is checked
   for (let category in prefs) {
-    let button = hud.HUDBox.querySelector(".webconsole-filter-button[category=\""
+    let button = hudBox.querySelector(".webconsole-filter-button[category=\""
                                            + category + "\"]");
     ok(isChecked(button), category  + " button is checked when first pref is true");
 
     let pref = prefs[category][0];
-    let menuitem = hud.HUDBox.querySelector("menuitem[prefKey=" + pref + "]");
+    let menuitem = hudBox.querySelector("menuitem[prefKey=" + pref + "]");
     ok(isChecked(menuitem), "first " + category + " menuitem is checked");
   }
 
   // Clear prefs
   for (let category in prefs) {
     prefs[category].forEach(function(pref) {
       prefService.clearUserPref("devtools.webconsole.filter." + pref);
     });
   }
 
+  prefs = prefService = null;
   gBrowser.removeCurrentTab();
-  finish();
+  finishTest();
 }
 
 function isChecked(aNode) {
   return aNode.getAttribute("checked") === "true";
 }
 
 function isUnchecked(aNode) {
   return aNode.getAttribute("checked") === "false";
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js b/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
@@ -60,17 +60,17 @@ function performTest(aEvent)
 function test()
 {
   addTab("data:text/html;charset=utf-8,<p>Web Console test for bug 630733");
 
   browser.addEventListener("load", function onLoad1(aEvent) {
     browser.removeEventListener(aEvent.type, onLoad1, true);
 
     openConsole(null, function(hud) {
-      hud.saveRequestAndResponseBodies = true;
+      hud.ui.saveRequestAndResponseBodies = true;
       HUDService.lastFinishedRequestCallback = requestDoneCallback;
 
       browser.addEventListener("load", function onLoad2(aEvent) {
         browser.removeEventListener(aEvent.type, onLoad2, true);
         executeSoon(performTest);
       }, true);
 
       content.location = TEST_URI;
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js b/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
@@ -80,17 +80,17 @@ function consoleOpened(HUD) {
     successFn: function()
     {
       document.addEventListener("popupshown", function onShown(aEvent) {
         document.removeEventListener("popupshown", onShown, false);
         executeSoon(testPropertyPanel.bind(null, aEvent.target));
       }, false);
 
       let node = HUD.outputNode.querySelector(".webconsole-msg-output");
-      EventUtils.synthesizeMouse(node, 2, 2, {});
+      EventUtils.synthesizeMouse(node, 2, 2, {}, HUD.iframeWindow);
     },
     failureFn: finishTest,
   });
 }
 
 function testPropertyPanel(aPanel) {
   let tree = aPanel.querySelector("tree");
   let view = tree.view;
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js b/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js
@@ -172,23 +172,23 @@ function testLiveFilteringOnSearchString
   lastRequest = null;
   requestCallback = null;
   finishTest();
 }
 
 function countMessageNodes() {
   let messageNodes = hud.outputNode.querySelectorAll(".hud-msg-node");
   let displayedMessageNodes = 0;
-  let view = hud.chromeWindow;
+  let view = hud.iframeWindow;
   for (let i = 0; i < messageNodes.length; i++) {
     let computedStyle = view.getComputedStyle(messageNodes[i], null);
     if (computedStyle.display !== "none")
       displayedMessageNodes++;
   }
 
   return displayedMessageNodes;
 }
 
 function setStringFilter(aValue)
 {
-  hud.filterBox.value = aValue;
-  HUDService.adjustVisibilityOnSearchStringChange(hud.hudId, aValue);
+  hud.ui.filterBox.value = aValue;
+  hud.ui.adjustVisibilityOnSearchStringChange();
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_642108_pruneTest.js b/browser/devtools/webconsole/test/browser_webconsole_bug_642108_pruneTest.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_642108_pruneTest.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_642108_pruneTest.js
@@ -24,64 +24,54 @@ function test() {
       Services.prefs.clearUserPref("devtools.hud.loglimit.cssparser");
     });
 
     openConsole(null, testCSSPruning);
   }, true);
 }
 
 function populateConsoleRepeats(aHudRef) {
-  let hud = aHudRef.HUDBox;
-
   for (let i = 0; i < 5; i++) {
-    let node = ConsoleUtils.createMessageNode(hud.ownerDocument,
-                                              CATEGORY_CSS,
-                                              SEVERITY_WARNING,
-                                              "css log x",
-                                              aHudRef.hudId);
-   aHudRef.outputMessage(CATEGORY_CSS, node);
+    let node = aHudRef.ui.createMessageNode(CATEGORY_CSS, SEVERITY_WARNING,
+                                            "css log x");
+    aHudRef.ui.outputMessage(CATEGORY_CSS, node);
   }
 }
 
-
 function populateConsole(aHudRef) {
-  let hud = aHudRef.HUDBox;
-
   for (let i = 0; i < LOG_LIMIT + 5; i++) {
-    let node = ConsoleUtils.createMessageNode(hud.ownerDocument,
-                                              CATEGORY_CSS,
-                                              SEVERITY_WARNING,
-                                              "css log " + i,
-                                              aHudRef.hudId);
-    aHudRef.outputMessage(CATEGORY_CSS, node);
+    let node = aHudRef.ui.createMessageNode(CATEGORY_CSS, SEVERITY_WARNING,
+                                            "css log " + i);
+    aHudRef.ui.outputMessage(CATEGORY_CSS, node);
   }
 }
 
 function testCSSPruning(hudRef) {
   populateConsoleRepeats(hudRef);
 
   let waitForNoRepeatedNodes = {
     name:  "number of nodes is LOG_LIMIT",
     validatorFn: function()
     {
       return countMessageNodes() == LOG_LIMIT;
     },
     successFn: function()
     {
-      ok(!hudRef.cssNodes["css log x"], "repeated nodes pruned from cssNodes");
+      ok(!hudRef.ui._cssNodes["css log x"],
+         "repeated nodes pruned from cssNodes");
       finishTest();
     },
     failureFn: finishTest,
   };
 
   waitForSuccess({
     name: "repeated nodes in cssNodes",
     validatorFn: function()
     {
-      return hudRef.cssNodes["css log x"];
+      return hudRef.ui._cssNodes["css log x"];
     },
     successFn: function()
     {
       populateConsole(hudRef);
       waitForSuccess(waitForNoRepeatedNodes);
     },
     failureFn: finishTest,
   });
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js b/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
@@ -88,17 +88,17 @@ function testPropertyPanel()
     successFn: function()
     {
       document.addEventListener("popupshown", function onShown(aEvent) {
         document.removeEventListener("popupshown", onShown, false);
         executeSoon(propertyPanelShown.bind(null, aEvent.target));
       }, false);
 
       let node = gHUD.outputNode.querySelector(".webconsole-msg-output");
-      EventUtils.synthesizeMouse(node, 2, 2, {});
+      EventUtils.synthesizeMouse(node, 2, 2, {}, gHUD.iframeWindow);
     },
     failureFn: finishTest,
   });
 }
 
 function propertyPanelShown(aPanel)
 {
   let tree = aPanel.querySelector("tree");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_660806_history_nav.js b/browser/devtools/webconsole/test/browser_webconsole_bug_660806_history_nav.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_660806_history_nav.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_660806_history_nav.js
@@ -1,31 +1,29 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>bug 660806 - history navigation must not show the autocomplete popup";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", tabLoaded, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
 
-function tabLoaded()
+function consoleOpened(HUD)
 {
-  browser.removeEventListener("load", tabLoaded, true);
-  openConsole();
-
   content.wrappedJSObject.foobarBug660806 = {
     "location": "value0",
     "locationbar": "value1",
   };
 
-  let hudId = HUDService.getHudIdByWindow(content);
-  let HUD = HUDService.hudReferences[hudId];
   let jsterm = HUD.jsterm;
   let popup = jsterm.autocompletePopup;
   popup._panel.addEventListener("popupshown", function() {
     popup._panel.removeEventListener("popupshown", arguments.callee, false);
     ok(false, "popup shown");
   }, false);
 
   ok(!popup.isOpen, "popup is not open");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_704295.js b/browser/devtools/webconsole/test/browser_webconsole_bug_704295.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_704295.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_704295.js
@@ -4,25 +4,24 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests for bug 704295
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testCompletion, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testCompletion);
+  }, true);
 }
 
-function testCompletion() {
-  browser.removeEventListener("DOMContentLoaded", testCompletion, false);
-
-  openConsole();
-
-  var jsterm = HUDService.getHudByWindow(content).jsterm;
+function testCompletion(hud) {
+  var jsterm = hud.jsterm;
   var input = jsterm.inputNode;
 
   // Test typing 'var d = 5;' and press RETURN
   jsterm.setInputValue("var d = ");
   EventUtils.synthesizeKey("5", {});
   EventUtils.synthesizeKey(";", {});
   is(input.value, "var d = 5;", "var d = 5;");
   is(jsterm.completeNode.value, "", "no completion");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_chrome.js b/browser/devtools/webconsole/test/browser_webconsole_chrome.js
--- a/browser/devtools/webconsole/test/browser_webconsole_chrome.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_chrome.js
@@ -11,17 +11,17 @@ function test() {
     browser.removeEventListener("load", onLoad, true);
     openConsole(null, testChrome);
   }, true);
 }
 
 function testChrome(hud) {
   ok(hud, "we have a console");
   
-  ok(hud.HUDBox, "we have the console display");
+  ok(hud.iframe, "we have the console iframe");
 
   let jsterm = hud.jsterm;
   ok(jsterm, "we have a jsterm");
 
   let input = jsterm.inputNode;
   ok(hud.outputNode, "we have an output node");
 
   // Test typing 'docu'.
diff --git a/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js b/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js
--- a/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js
@@ -55,17 +55,17 @@ function subtestGen(aMethod) {
   subtestDriver.next();
 }
 
 function testConsoleLoggingAPI(aMethod) {
   let console = content.wrappedJSObject.console;
 
   hud.jsterm.clearOutput();
 
-  setStringFilter(hudId, "foo");
+  setStringFilter("foo");
   console[aMethod]("foo-bar-baz");
   console[aMethod]("bar-baz");
 
   function nextTest() {
     subtestDriver.next();
   }
 
   waitForSuccess({
@@ -80,50 +80,50 @@ function testConsoleLoggingAPI(aMethod) 
 
   yield;
 
   hud.jsterm.clearOutput();
 
   // now toggle the current method off - make sure no visible message
 
   // TODO: move all filtering tests into a separate test file: see bug 608135
-  setStringFilter(hudId, "");
-  HUDService.setFilterState(hudId, aMethod, false);
+  setStringFilter("");
+  hud.setFilterState(aMethod, false);
   console[aMethod]("foo-bar-baz");
 
   waitForSuccess({
     name: "1 message hidden for " + aMethod + " (logging turned off)",
     validatorFn: function()
     {
       return outputNode.querySelectorAll("description").length == 1;
     },
     successFn: nextTest,
     failureFn: nextTest,
   });
 
   yield;
 
   hud.jsterm.clearOutput();
-  HUDService.setFilterState(hudId, aMethod, true);
+  hud.setFilterState(aMethod, true);
   console[aMethod]("foo-bar-baz");
 
   waitForSuccess({
     name: "1 message shown for " + aMethod + " (logging turned on)",
     validatorFn: function()
     {
       return outputNode.querySelectorAll("description").length == 1;
     },
     successFn: nextTest,
     failureFn: nextTest,
   });
 
   yield;
 
   hud.jsterm.clearOutput();
-  setStringFilter(hudId, "");
+  setStringFilter("");
 
   // test for multiple arguments.
   console[aMethod]("foo", "bar");
 
   waitForSuccess({
     name: "show both console arguments for " + aMethod,
     validatorFn: function()
     {
@@ -134,13 +134,13 @@ function testConsoleLoggingAPI(aMethod) 
     failureFn: nextTest,
   });
 
   yield;
   testDriver.next();
   yield;
 }
 
-function setStringFilter(aId, aValue) {
-  hud.filterBox.value = aValue;
-  HUDService.adjustVisibilityOnSearchStringChange(aId, aValue);
+function setStringFilter(aValue) {
+  hud.ui.filterBox.value = aValue;
+  hud.ui.adjustVisibilityOnSearchStringChange();
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_js_input_expansion.js b/browser/devtools/webconsole/test/browser_webconsole_js_input_expansion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_js_input_expansion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_js_input_expansion.js
@@ -4,40 +4,36 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the input box expands as the user types long lines.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testJSInputExpansion, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testJSInputExpansion);
+  }, true);
 }
 
-function testJSInputExpansion() {
-  browser.removeEventListener("DOMContentLoaded", testJSInputExpansion,
-                              false);
-
-  openConsole();
-
-  let jsterm = HUDService.getHudByWindow(content).jsterm;
+function testJSInputExpansion(hud) {
+  let jsterm = hud.jsterm;
   let input = jsterm.inputNode;
   input.focus();
 
   is(input.getAttribute("multiline"), "true", "multiline is enabled");
   // Tests if the inputNode expands.
   input.value = "hello\nworld\n";
   let length = input.value.length;
   input.selectionEnd = length;
   input.selectionStart = length;
   function getHeight()
   {
-    let h = browser.contentDocument.defaultView.getComputedStyle(input, null)
-      .getPropertyValue("height");
-    return parseInt(h);
+    return input.clientHeight;
   }
   let initialHeight = getHeight();
   // Performs an "d". This will trigger/test for the input event that should
   // change the "row" attribute of the inputNode.
   EventUtils.synthesizeKey("d", {});
   let newHeight = getHeight();
   ok(initialHeight < newHeight, "Height changed: " + newHeight);
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js
--- a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js
@@ -32,33 +32,31 @@ function consoleOpened(aHud) {
       return hud.outputNode.itemCount == 50;
     },
     successFn: testLiveFilteringOfMessageTypes,
     failureFn: finishTest,
   });
 }
 
 function testLiveFilteringOfMessageTypes() {
-  // TODO: bug 744732 - broken live filtering tests.
-
-  HUDService.setFilterState(hud.hudId, "log", false);
+  hud.setFilterState("log", false);
   is(countMessageNodes(), 0, "the log nodes are hidden when the " +
     "corresponding filter is switched off");
 
-  HUDService.setFilterState(hud.hudId, "log", true);
-  isnot(countMessageNodes(), 0, "the log nodes reappear when the " +
+  hud.setFilterState("log", true);
+  is(countMessageNodes(), 50, "the log nodes reappear when the " +
     "corresponding filter is switched on");
 
   finishTest();
 }
 
 function countMessageNodes() {
   let messageNodes = hud.outputNode.querySelectorAll(".hud-log");
   let displayedMessageNodes = 0;
-  let view = hud.chromeWindow;
+  let view = hud.iframeWindow;
   for (let i = 0; i < messageNodes.length; i++) {
     let computedStyle = view.getComputedStyle(messageNodes[i], null);
     if (computedStyle.display !== "none") {
       displayedMessageNodes++;
     }
   }
 
   return displayedMessageNodes;
diff --git a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js
--- a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js
@@ -33,18 +33,16 @@ function consoleOpened(aHud) {
       return hud.outputNode.itemCount == 50;
     },
     successFn: testLiveFilteringOnSearchStrings,
     failureFn: finishTest,
   });
 }
 
 function testLiveFilteringOnSearchStrings() {
-  // TODO: bug 744732 - broken live filtering tests.
-
   setStringFilter("http");
   isnot(countMessageNodes(), 0, "the log nodes are not hidden when the " +
     "search string is set to \"http\"");
 
   setStringFilter("hxxp");
   is(countMessageNodes(), 0, "the log nodes are hidden when the search " +
     "string is set to \"hxxp\"");
 
@@ -83,25 +81,25 @@ function testLiveFilteringOnSearchString
   finishTest();
 }
 
 function countMessageNodes() {
   let outputNode = hud.outputNode;
 
   let messageNodes = outputNode.querySelectorAll(".hud-log");
   let displayedMessageNodes = 0;
-  let view = hud.chromeWindow;
+  let view = hud.iframeWindow;
   for (let i = 0; i < messageNodes.length; i++) {
     let computedStyle = view.getComputedStyle(messageNodes[i], null);
     if (computedStyle.display !== "none") {
       displayedMessageNodes++;
     }
   }
 
   return displayedMessageNodes;
 }
 
 function setStringFilter(aValue)
 {
-  hud.filterBox.value = aValue;
-  HUDService.adjustVisibilityOnSearchStringChange(hud.hudId, aValue);
+  hud.ui.filterBox.value = aValue;
+  hud.ui.adjustVisibilityOnSearchStringChange();
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_netlogging.js b/browser/devtools/webconsole/test/browser_webconsole_netlogging.js
--- a/browser/devtools/webconsole/test/browser_webconsole_netlogging.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_netlogging.js
@@ -67,17 +67,17 @@ function testPageLoad()
 }
 
 function testPageLoadBody()
 {
   let loaded = false;
   let requestCallbackInvoked = false;
 
   // Turn on logging of request bodies and check again.
-  hud.saveRequestAndResponseBodies = true;
+  hud.ui.saveRequestAndResponseBodies = true;
   requestCallback = function() {
     ok(lastRequest, "Page load was logged again");
     is(lastRequest.response.content.text.indexOf("<!DOCTYPE HTML>"), 0,
       "Response body's beginning is okay");
 
     lastRequest = null;
     requestCallback = null;
     requestCallbackInvoked = true;
@@ -160,18 +160,18 @@ function testFormSubmission()
   ok(form, "we have the HTML form");
   form.submit();
 }
 
 function testNetworkPanel()
 {
   // Open the NetworkPanel. The functionality of the NetworkPanel is tested
   // within separate test files.
-  let networkPanel = HUDService.openNetworkPanel(hud.filterBox, lastActivity);
-  is(networkPanel, hud.filterBox._netPanel,
+  let networkPanel = hud.ui.openNetworkPanel(hud.ui.filterBox, lastActivity);
+  is(networkPanel, hud.ui.filterBox._netPanel,
      "Network panel stored on anchor node");
 
   networkPanel.panel.addEventListener("load", function onLoad(aEvent) {
     networkPanel.panel.removeEventListener(aEvent.type, onLoad, true);
 
     ok(true, "NetworkPanel was opened");
 
     // All tests are done. Shutdown.
diff --git a/browser/devtools/webconsole/test/browser_webconsole_network_panel.js b/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
--- a/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
@@ -56,17 +56,18 @@ function checkNodeKeyValue(aPanel, aId, 
       return;
     }
   }
 
   ok(false, "content check failed for " + aId + ", key " + aKey);
 }
 
 function testGen() {
-  let filterBox = HUDService.getHudByWindow(content).filterBox;
+  let hud = HUDService.getHudByWindow(content);
+  let filterBox = hud.ui.filterBox;
 
   let tempScope  = {};
   Cu.import("resource:///modules/WebConsoleUtils.jsm", tempScope);
   let l10n = tempScope.WebConsoleUtils.l10n;
   tempScope = null;
 
   let httpActivity = {
     meta: {
@@ -91,17 +92,17 @@ function testGen() {
         },
         timings: {},
       }],
     },
   };
 
   let entry = httpActivity.log.entries[0];
 
-  let networkPanel = HUDService.openNetworkPanel(filterBox, httpActivity);
+  let networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
 
   is(filterBox._netPanel, networkPanel,
      "Network panel stored on the anchor object");
 
   networkPanel.panel.addEventListener("load", function onLoad() {
     networkPanel.panel.removeEventListener("load", onLoad, true);
     testDriver.next();
   }, true);
@@ -210,17 +211,17 @@ function testGen() {
   // Second run: Test for cookies and response body.
   info("test 6: cookies and response body");
   entry.request.cookies.push(
     { name: "foo", value: "bar" },
     { name: "hello", value: "world" }
   );
   entry.response.content.text = "get out here";
 
-  networkPanel = HUDService.openNetworkPanel(filterBox, httpActivity);
+  networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
   is(filterBox._netPanel, networkPanel,
      "Network panel stored on httpActivity object");
 
   networkPanel.panel.addEventListener("load", function onLoad() {
     networkPanel.panel.removeEventListener("load", onLoad, true);
     testDriver.next();
   }, true);
 
@@ -245,17 +246,17 @@ function testGen() {
   networkPanel.panel.hidePopup();
 
   // Check image request.
   info("test 7: image request");
   entry.response.headers[1].value = "image/png";
   entry.response.content.mimeType = "image/png";
   entry.request.url = TEST_IMG;
 
-  networkPanel = HUDService.openNetworkPanel(filterBox, httpActivity);
+  networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
   networkPanel.panel.addEventListener("load", function onLoad() {
     networkPanel.panel.removeEventListener("load", onLoad, true);
     testDriver.next();
   }, true);
 
   yield;
 
   checkIsVisible(networkPanel, {
@@ -294,17 +295,17 @@ function testGen() {
   }
 
   // Check cached image request.
   info("test 8: cached image request");
   entry.response.httpVersion = "HTTP/1.1";
   entry.response.status = 304;
   entry.response.statusText = "Not Modified";
 
-  networkPanel = HUDService.openNetworkPanel(filterBox, httpActivity);
+  networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
   networkPanel.panel.addEventListener("load", function onLoad() {
     networkPanel.panel.removeEventListener("load", onLoad, true);
     testDriver.next();
   }, true);
 
   yield;
 
   checkIsVisible(networkPanel, {
@@ -326,17 +327,17 @@ function testGen() {
   // Test sent form data.
   info("test 9: sent form data");
   entry.request.postData.text = [
     "Content-Type:      application/x-www-form-urlencoded",
     "Content-Length: 59",
     "name=rob&age=20"
   ].join("\n");
 
-  networkPanel = HUDService.openNetworkPanel(filterBox, httpActivity);
+  networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
   networkPanel.panel.addEventListener("load", function onLoad() {
     networkPanel.panel.removeEventListener("load", onLoad, true);
     testDriver.next();
   }, true);
 
   yield;
 
   checkIsVisible(networkPanel, {
@@ -353,17 +354,17 @@ function testGen() {
   checkNodeKeyValue(networkPanel, "requestFormDataContent", "name", "rob");
   checkNodeKeyValue(networkPanel, "requestFormDataContent", "age", "20");
   networkPanel.panel.hidePopup();
 
   // Test no space after Content-Type:
   info("test 10: no space after Content-Type header in post data");
   entry.request.postData.text = "Content-Type:application/x-www-form-urlencoded\n";
 
-  networkPanel = HUDService.openNetworkPanel(filterBox, httpActivity);
+  networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
   networkPanel.panel.addEventListener("load", function onLoad() {
     networkPanel.panel.removeEventListener("load", onLoad, true);
     testDriver.next();
   }, true);
 
   yield;
 
   checkIsVisible(networkPanel, {
@@ -383,17 +384,17 @@ function testGen() {
 
   info("test 11: cached data");
 
   entry.request.url = TEST_ENCODING_ISO_8859_1;
   entry.response.headers[1].value = "application/json";
   entry.response.content.mimeType = "application/json";
   entry.response.content.text = "my cached data is here!";
 
-  networkPanel = HUDService.openNetworkPanel(filterBox, httpActivity);
+  networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
   networkPanel.panel.addEventListener("load", function onLoad() {
     networkPanel.panel.removeEventListener("load", onLoad, true);
     testDriver.next();
   }, true);
 
   yield;
 
   checkIsVisible(networkPanel, {
@@ -414,17 +415,17 @@ function testGen() {
   networkPanel.panel.hidePopup();
 
   // Test a response with a content type that can't be displayed in the
   // NetworkPanel.
   info("test 12: unknown content type");
   entry.response.headers[1].value = "application/x-shockwave-flash";
   entry.response.content.mimeType = "application/x-shockwave-flash";
 
-  networkPanel = HUDService.openNetworkPanel(filterBox, httpActivity);
+  networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
   networkPanel.panel.addEventListener("load", function onLoad() {
     networkPanel.panel.removeEventListener("load", onLoad, true);
     testDriver.next();
   }, true);
 
   yield;
 
   checkIsVisible(networkPanel, {
@@ -450,17 +451,17 @@ function testGen() {
 
   // This test disabled. See bug 603620.
 
   // Test if the NetworkPanel figures out the content type based on an URL as
   // well.
   delete httpActivity.response.header["Content-Type"];
   httpActivity.url = "http://www.test.com/someCrazyFile.swf?done=right&ending=txt";
 
-  networkPanel = HUDService.openNetworkPanel(filterBox, httpActivity);
+  networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
   networkPanel.isDoneCallback = function NP_doneCallback() {
     networkPanel.isDoneCallback = null;
     testDriver.next();
   }
 
   yield;
 
   checkIsVisible(networkPanel, {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_position_ui.js b/browser/devtools/webconsole/test/browser_webconsole_position_ui.js
--- a/browser/devtools/webconsole/test/browser_webconsole_position_ui.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_position_ui.js
@@ -5,170 +5,200 @@
 const TEST_URI = "data:text/html;charset=utf-8,<p>test for bug 577721";
 
 const POSITION_PREF = "devtools.webconsole.position";
 const TOP_PREF = "devtools.webconsole.top";
 const LEFT_PREF = "devtools.webconsole.left";
 const WIDTH_PREF = "devtools.webconsole.width";
 const HEIGHT_PREF = "devtools.hud.height";
 
+let hudRef, boxHeight, panelWidth;
+
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", onLoad, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
   registerCleanupFunction(testEnd);
 }
 
 function testEnd() {
+  hudRef = null;
   Services.prefs.clearUserPref(POSITION_PREF);
   Services.prefs.clearUserPref(WIDTH_PREF);
   Services.prefs.clearUserPref(HEIGHT_PREF);
   Services.prefs.clearUserPref(TOP_PREF);
   Services.prefs.clearUserPref(LEFT_PREF);
 }
 
-function onLoad() {
-  browser.removeEventListener("DOMContentLoaded", onLoad, false);
+function waitForPosition(aPosition, aCallback) {
+  waitForSuccess({
+    name: "web console position changed to '" + aPosition + "'",
+    validatorFn: function()
+    {
+      return hudRef._currentUIPosition == aPosition;
+    },
+    successFn: aCallback,
+    failureFn: finishTest,
+  });
+}
 
-  openConsole();
-
+function consoleOpened(aHudRef) {
+  hudRef = aHudRef;
   testMenuitems();
 
-  let hudId = HUDService.getHudIdByWindow(content);
-  let hudRef = HUDService.hudReferences[hudId];
-  let hudBox = hudRef.HUDBox;
+  let hudBox = hudRef.iframe;
 
-  is(hudBox.parentNode.childNodes[0].getAttribute("id"), hudId,
+  is(hudBox.parentNode.childNodes[0].getAttribute("id"), hudRef.hudId,
      "initial console position is correct");
 
-  is(hudRef.positionMenuitems.above.getAttribute("checked"), "true",
+  is(hudRef.ui.positionMenuitems.above.getAttribute("checked"), "true",
      "position menu checkbox is above");
   is(Services.prefs.getCharPref(POSITION_PREF), "above", "pref is above");
 
   hudRef.positionConsole("below");
+
+  waitForPosition("below", onPositionBelow1);
+}
+
+function onPositionBelow1() {
+  let hudBox = hudRef.iframe;
+
   let id = hudBox.parentNode.childNodes[2].getAttribute("id");
-  is(id, hudId, "below position is correct");
+  is(id, hudRef.hudId, "below position is correct");
 
-  is(hudRef.positionMenuitems.below.getAttribute("checked"), "true",
+  is(hudRef.ui.positionMenuitems.below.getAttribute("checked"), "true",
      "position menu checkbox is below");
   is(Services.prefs.getCharPref(POSITION_PREF), "below", "pref is below");
 
-  // listen for the panel popupshown event.
-  document.addEventListener("popupshown", function popupShown() {
-    document.removeEventListener("popupshown", popupShown, false);
-
-    document.addEventListener("popuphidden", function popupHidden() {
-      document.removeEventListener("popuphidden", popupHidden, false);
-
-      id = hudBox.parentNode.childNodes[2].getAttribute("id");
-      is(id, hudId, "below position is correct after reopen");
-
-      diffHeight = Math.abs(hudBox.clientHeight - boxHeight);
-      // dump("Diffheight: " + diffHeight + " clientHeight: " + hudBox.clientHeight + " boxHeight: " + boxHeight + "\n");
-      // XXX TODO bug 702707
-      todo(diffHeight < 3, "hudBox height is still correct");
-
-      is(Services.prefs.getCharPref(POSITION_PREF), "below", "pref is below");
-
-      // following three disabled due to bug 674562
-      // is(Services.prefs.getIntPref(WIDTH_PREF), panelWidth, "width pref updated - bug 674562");
-      // isnot(Services.prefs.getIntPref(TOP_PREF), 50, "top location pref updated - bug 674562");
-      // isnot(Services.prefs.getIntPref(LEFT_PREF), 51, "left location pref updated - bug 674562");
-
-      // Close the window console via the toolbar button
-      let btn = hudBox.querySelector(".webconsole-close-button");
-      EventUtils.sendMouseEvent({ type: "click" }, btn);
-
-      openConsole();
-
-      hudId = HUDService.getHudIdByWindow(content);
-      hudRef = HUDService.hudReferences[hudId];
-      hudBox = hudRef.HUDBox;
-
-      id = hudBox.parentNode.childNodes[2].getAttribute("id");
-      is(id, hudId, "below position is correct after another reopen");
-
-      is(hudRef.positionMenuitems.below.getAttribute("checked"), "true",
-         "position menu checkbox is below");
-
-      executeSoon(finishTest);
-    }, false);
-
-    let diffHeight = Math.abs(hudBox.clientHeight - boxHeight);
-    ok(diffHeight < 8, "hudBox height is correct");
-
-    let consolePanel = hudRef.consolePanel;
-
-    is(consolePanel.getAttribute("width"), panelWidth, "panel width is correct");
-    is(consolePanel.getAttribute("top"), 50, "panel top position is correct");
-    is(consolePanel.getAttribute("left"), 51, "panel left position is correct");
-
-    let panelHeight = parseInt(consolePanel.getAttribute("height"));
-    let boxWidth = hudBox.clientWidth;
-    boxHeight = hudBox.clientHeight;
-
-    hudRef.consolePanel.sizeTo(panelWidth - 15, panelHeight - 13);
-
-    let popupBoxObject = consolePanel.popupBoxObject;
-    let screenX = popupBoxObject.screenX;
-    let screenY = popupBoxObject.screenY;
-    consolePanel.moveTo(screenX - 11, screenY - 13);
-
-    isnot(hudBox.clientWidth, boxWidth, "hudBox width was updated");
-    isnot(hudBox.clientHeight, boxHeight, "hudBox height was updated");
-
-    isnot(popupBoxObject.screenX, screenX, "panel screenX was updated");
-    isnot(popupBoxObject.screenY, screenY, "panel screenY was updated");
-
-    panelWidth = consolePanel.clientWidth;
-    boxHeight = hudBox.clientHeight;
-
-    executeSoon(function() {
-      hudRef.positionConsole("below");
-    });
-  }, false);
-
-  let boxHeight = content.innerHeight * 0.5;
-  let panelWidth = content.innerWidth * 0.5;
+  boxHeight = content.innerHeight * 0.5;
+  panelWidth = content.innerWidth * 0.5;
 
   hudBox.style.height = boxHeight + "px";
 
   boxHeight = hudBox.clientHeight;
 
   Services.prefs.setIntPref(WIDTH_PREF, panelWidth);
   Services.prefs.setIntPref(TOP_PREF, 50);
   Services.prefs.setIntPref(LEFT_PREF, 51);
 
   hudRef.positionConsole("window");
-  id = hudBox.parentNode.getAttribute("id");
-  is(id, "console_window_" + hudId, "window position is correct");
+  waitForPosition("window", onPositionWindow);
+}
+
+function onPositionWindow() {
+  let hudBox = hudRef.iframe;
+
+  let id = hudBox.parentNode.getAttribute("id");
+  is(id, "console_window_" + hudRef.hudId, "window position is correct");
   is(Services.prefs.getCharPref(POSITION_PREF), "window", "pref is window");
+
+  let diffHeight = Math.abs(hudBox.clientHeight - boxHeight);
+  ok(diffHeight < 8, "hudBox height is correct");
+
+  let consolePanel = hudRef.consolePanel;
+
+  is(consolePanel.getAttribute("width"), panelWidth, "panel width is correct");
+  is(consolePanel.getAttribute("top"), 50, "panel top position is correct");
+  is(consolePanel.getAttribute("left"), 51, "panel left position is correct");
+
+  let panelHeight = parseInt(consolePanel.getAttribute("height"));
+  let boxWidth = hudBox.clientWidth;
+  boxHeight = hudBox.clientHeight;
+
+  hudRef.consolePanel.sizeTo(panelWidth - 15, panelHeight - 13);
+
+  let popupBoxObject = consolePanel.popupBoxObject;
+  let screenX = popupBoxObject.screenX;
+  let screenY = popupBoxObject.screenY;
+  consolePanel.moveTo(screenX - 11, screenY - 13);
+
+  isnot(hudBox.clientWidth, boxWidth, "hudBox width was updated");
+  isnot(hudBox.clientHeight, boxHeight, "hudBox height was updated");
+
+  isnot(popupBoxObject.screenX, screenX, "panel screenX was updated");
+  isnot(popupBoxObject.screenY, screenY, "panel screenY was updated");
+
+  panelWidth = consolePanel.clientWidth;
+  boxHeight = hudBox.clientHeight;
+
+  executeSoon(function() {
+    hudRef.positionConsole("below");
+    waitForPosition("below", onPositionBelow2);
+  });
+}
+
+function onPositionBelow2() {
+  let hudBox = hudRef.iframe;
+
+  let id = hudBox.parentNode.childNodes[2].getAttribute("id");
+  is(id, hudRef.hudId, "below position is correct after reopen");
+
+  let diffHeight = Math.abs(hudBox.clientHeight - boxHeight);
+  // dump("Diffheight: " + diffHeight + " clientHeight: " + hudBox.clientHeight + " boxHeight: " + boxHeight + "\n");
+  // XXX TODO bug 702707
+  ok(diffHeight < 8, "hudBox height is still correct");
+
+  is(Services.prefs.getCharPref(POSITION_PREF), "below", "pref is below");
+
+  // following three disabled due to bug 674562
+  // is(Services.prefs.getIntPref(WIDTH_PREF), panelWidth, "width pref updated - bug 674562");
+  // isnot(Services.prefs.getIntPref(TOP_PREF), 50, "top location pref updated - bug 674562");
+  // isnot(Services.prefs.getIntPref(LEFT_PREF), 51, "left location pref updated - bug 674562");
+
+  Services.obs.addObserver(onConsoleClose, "web-console-destroyed", false);
+
+  // Close the window console via the toolbar button
+  let btn = hudRef.ui.closeButton;
+  executeSoon(function() {
+    EventUtils.synthesizeMouse(btn, 2, 2, {}, hudRef.iframeWindow);
+  });
+}
+
+function onConsoleClose()
+{
+  Services.obs.removeObserver(onConsoleClose, "web-console-destroyed");
+
+  executeSoon(function() {
+    hudRef = null;
+    openConsole(null, onConsoleReopen);
+  });
+}
+
+function onConsoleReopen(aHudRef) {
+  let hudBox = aHudRef.iframe;
+
+  let id = hudBox.parentNode.childNodes[2].getAttribute("id");
+  is(id, aHudRef.hudId, "below position is correct after another reopen");
+
+  is(aHudRef.ui.positionMenuitems.below.getAttribute("checked"), "true",
+     "position menu checkbox is below");
+
+  executeSoon(finishTest);
 }
 
 function testMenuitems() {
-  let hudId = HUDService.getHudIdByWindow(content);
-  let hudRef = HUDService.hudReferences[hudId];
-  let hudBox = hudRef.HUDBox;
-
   let positionConsole = hudRef.positionConsole;
   is(typeof positionConsole, "function", "positionConsole() is available");
 
   let param = null;
   hudRef.positionConsole = function(aPosition) {
     param = aPosition;
   };
 
   // Make sure the menuitems call the correct method.
 
-  hudRef.positionMenuitems.above.doCommand();
+  hudRef.ui.positionMenuitems.above.doCommand();
 
   is(param, "above", "menuitem for above positioning calls positionConsole() correctly");
 
-  hudRef.positionMenuitems.below.doCommand();
+  hudRef.ui.positionMenuitems.below.doCommand();
 
   is(param, "below", "menuitem for below positioning calls positionConsole() correctly");
 
-  hudRef.positionMenuitems.window.doCommand();
+  hudRef.ui.positionMenuitems.window.doCommand();
 
   is(param, "window", "menuitem for window positioning calls positionConsole() correctly");
 
   hudRef.positionConsole = positionConsole;
 }
 
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/webconsole.js
@@ -0,0 +1,3139 @@
+/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cu = Components.utils;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+
+XPCOMUtils.defineLazyServiceGetter(this, "clipboardHelper",
+                                   "@mozilla.org/widget/clipboardhelper;1",
+                                   "nsIClipboardHelper");
+
+XPCOMUtils.defineLazyModuleGetter(this, "PropertyPanel",
+                                  "resource:///modules/PropertyPanel.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "PropertyTreeView",
+                                  "resource:///modules/PropertyPanel.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "NetworkPanel",
+                                  "resource:///modules/NetworkPanel.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "AutocompletePopup",
+                                  "resource:///modules/AutocompletePopup.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
+                                  "resource:///modules/WebConsoleUtils.jsm");
+
+XPCOMUtils.defineLazyGetter(this, "l10n", function() {
+  return WebConsoleUtils.l10n;
+});
+
+
+// The XUL namespace.
+const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+// The amount of time in milliseconds that must pass between messages to
+// trigger the display of a new group.
+const NEW_GROUP_DELAY = 5000;
+
+// The amount of time in milliseconds that we wait before performing a live
+// search.
+const SEARCH_DELAY = 200;
+
+// The number of lines that are displayed in the console output by default, for
+// each category. The user can change this number by adjusting the hidden
+// "devtools.hud.loglimit.{network,cssparser,exception,console}" preferences.
+const DEFAULT_LOG_LIMIT = 200;
+
+// The various categories of messages. We start numbering at zero so we can
+// use these as indexes into the MESSAGE_PREFERENCE_KEYS matrix below.
+const CATEGORY_NETWORK = 0;
+const CATEGORY_CSS = 1;
+const CATEGORY_JS = 2;
+const CATEGORY_WEBDEV = 3;
+const CATEGORY_INPUT = 4;   // always on
+const CATEGORY_OUTPUT = 5;  // always on
+
+// The possible message severities. As before, we start at zero so we can use
+// these as indexes into MESSAGE_PREFERENCE_KEYS.
+const SEVERITY_ERROR = 0;
+const SEVERITY_WARNING = 1;
+const SEVERITY_INFO = 2;
+const SEVERITY_LOG = 3;
+
+// The fragment of a CSS class name that identifies each category.
+const CATEGORY_CLASS_FRAGMENTS = [
+  "network",
+  "cssparser",
+  "exception",
+  "console",
+  "input",
+  "output",
+];
+
+// The fragment of a CSS class name that identifies each severity.
+const SEVERITY_CLASS_FRAGMENTS = [
+  "error",
+  "warn",
+  "info",
+  "log",
+];
+
+// The preference keys to use for each category/severity combination, indexed
+// first by category (rows) and then by severity (columns).
+//
+// Most of these rather idiosyncratic names are historical and predate the
+// division of message type into "category" and "severity".
+const MESSAGE_PREFERENCE_KEYS = [
+//  Error         Warning   Info    Log
+  [ "network",    null,         null,   "networkinfo", ],  // Network
+  [ "csserror",   "cssparser",  null,   null,          ],  // CSS
+  [ "exception",  "jswarn",     null,   null,          ],  // JS
+  [ "error",      "warn",       "info", "log",         ],  // Web Developer
+  [ null,         null,         null,   null,          ],  // Input
+  [ null,         null,         null,   null,          ],  // Output
+];
+
+// A mapping from the console API log event levels to the Web Console
+// severities.
+const LEVELS = {
+  error: SEVERITY_ERROR,
+  warn: SEVERITY_WARNING,
+  info: SEVERITY_INFO,
+  log: SEVERITY_LOG,
+  trace: SEVERITY_LOG,
+  debug: SEVERITY_LOG,
+  dir: SEVERITY_LOG,
+  group: SEVERITY_LOG,
+  groupCollapsed: SEVERITY_LOG,
+  groupEnd: SEVERITY_LOG,
+  time: SEVERITY_LOG,
+  timeEnd: SEVERITY_LOG
+};
+
+// The lowest HTTP response code (inclusive) that is considered an error.
+const MIN_HTTP_ERROR_CODE = 400;
+// The highest HTTP response code (inclusive) that is considered an error.
+const MAX_HTTP_ERROR_CODE = 599;
+
+// Constants used for defining the direction of JSTerm input history navigation.
+const HISTORY_BACK = -1;
+const HISTORY_FORWARD = 1;
+
+// The indent of a console group in pixels.
+const GROUP_INDENT = 12;
+
+// The number of messages to display in a single display update. If we display
+// too many messages at once we slow the Firefox UI too much.
+const MESSAGES_IN_INTERVAL = DEFAULT_LOG_LIMIT;
+
+// The delay between display updates - tells how often we should *try* to push
+// new messages to screen. This value is optimistic, updates won't always
+// happen. Keep this low so the Web Console output feels live.
+const OUTPUT_INTERVAL = 50; // milliseconds
+
+// When the output queue has more than MESSAGES_IN_INTERVAL items we throttle
+// output updates to this number of milliseconds. So during a lot of output we
+// update every N milliseconds given here.
+const THROTTLE_UPDATES = 1000; // milliseconds
+
+// The preference prefix for all of the Web Console filters.
+const FILTER_PREFS_PREFIX = "devtools.webconsole.filter.";
+
+/**
+ * A WebConsoleFrame instance is an interactive console initialized *per tab*
+ * that displays console log data as well as provides an interactive terminal to
+ * manipulate the current tab's document content.
+ *
+ * The WebConsoleFrame is responsible for the actual Web Console UI
+ * implementation.
+ *
+ * @param object aWebConsoleOwner
+ *        The WebConsole owner object.
+ */
+// TODO: update comments
+function WebConsoleFrame(aWebConsoleOwner)
+{
+  this.owner = aWebConsoleOwner;
+  this.hudId = this.owner.hudId;
+  this.window = window;
+  this.document = document;
+
+  this._cssNodes = {};
+  this._outputQueue = [];
+  this._pruneCategoriesQueue = {};
+  this._networkRequests = {};
+
+  this._toggleFilter = this._toggleFilter.bind(this);
+  this._onPositionConsoleCommand = this._onPositionConsoleCommand.bind(this);
+
+  this._initDefaultFilterPrefs();
+  this._initUI();
+  this._commandController = new CommandController(this);
+
+  // create the JSTerm input element
+  this.jsterm = new JSTerm(this);
+  this.jsterm.inputNode.focus();
+}
+
+WebConsoleFrame.prototype = {
+  get popupset() this.owner.mainPopupSet,
+
+  /**
+   * Holds the network requests currently displayed by the Web Console. Each key
+   * represents the connection ID and the value is network request information.
+   * @private
+   * @type object
+   */
+  _networkRequests: null,
+
+  /**
+   * Last time when we displayed any message in the output.
+   *
+   * @private
+   * @type number
+   *       Timestamp in milliseconds since the Unix epoch.
+   */
+  _lastOutputFlush: 0,
+
+  /**
+   * Message nodes are stored here in a queue for later display.
+   *
+   * @private
+   * @type array
+   */
+  _outputQueue: null,
+
+  /**
+   * Keep track of the categories we need to prune from time to time.
+   *
+   * @private
+   * @type array
+   */
+  _pruneCategoriesQueue: null,
+
+  contentLocation: "",
+
+  /**
+   * The nesting depth of the currently active console group.
+   */
+  groupDepth: 0,
+
+  _saveRequestAndResponseBodies: false,
+
+  /**
+   * Tells whether to save the bodies of network requests and responses.
+   * Disabled by default to save memory.
+   * @type boolean
+   */
+  get saveRequestAndResponseBodies() this._saveRequestAndResponseBodies,
+
+  /**
+   * Setter for saving of network request and response bodies.
+   *
+   * @param boolean aValue
+   *        The new value you want to set.
+   */
+  set saveRequestAndResponseBodies(aValue) {
+    this._saveRequestAndResponseBodies = aValue;
+
+    let message = {
+      preferences: {
+        "NetworkMonitor.saveRequestAndResponseBodies":
+          this._saveRequestAndResponseBodies,
+      },
+    };
+
+    this.owner.sendMessageToContent("WebConsole:SetPreferences", message);
+  },
+
+  /**
+   * The JSTerm object that contains the console's inputNode
+   *
+   */
+  jsterm: null,
+
+  /**
+   * Handler for all of the messages coming from the Web Console content script.
+   *
+   * @private
+   * @param object aMessage
+   *        A MessageManager object that holds the remote message.
+   */
+  receiveMessage: function WCF_receiveMessage(aMessage)
+  {
+    if (!aMessage.json || aMessage.json.hudId != this.hudId) {
+      return;
+    }
+
+    switch (aMessage.name) {
+      case "JSTerm:EvalResult":
+      case "JSTerm:EvalObject":
+      case "JSTerm:AutocompleteProperties":
+        this.owner._receiveMessageWithCallback(aMessage.json);
+        break;
+      case "JSTerm:ClearOutput":
+        this.jsterm.clearOutput();
+        break;
+      case "JSTerm:InspectObject":
+        this.jsterm.handleInspectObject(aMessage.json);
+        break;
+      case "WebConsole:ConsoleAPI":
+        this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
+                           [aMessage.json]);
+        break;
+      case "WebConsole:PageError": {
+        let pageError = aMessage.json.pageError;
+        let category = this.categoryForScriptError(pageError);
+        this.outputMessage(category, this.reportPageError,
+                           [category, pageError]);
+        break;
+      }
+      case "WebConsole:CachedMessages":
+        this._displayCachedConsoleMessages(aMessage.json.messages);
+        this.owner._onInitComplete();
+        break;
+      case "WebConsole:NetworkActivity":
+        this.handleNetworkActivity(aMessage.json);
+        break;
+      case "WebConsole:FileActivity":
+        this.outputMessage(CATEGORY_NETWORK, this.logFileActivity,
+                           [aMessage.json.uri]);
+        break;
+      case "WebConsole:LocationChange":
+        this.owner.onLocationChange(aMessage.json);
+        break;
+      case "JSTerm:NonNativeConsoleAPI":
+        this.outputMessage(CATEGORY_JS, this.logWarningAboutReplacedAPI);
+        break;
+    }
+  },
+
+  /**
+   * Display cached messages that may have been collected before the UI is
+   * displayed.
+   *
+   * @private
+   * @param array aRemoteMessages
+   *        Array of cached messages coming from the remote Web Console
+   *        content instance.
+   */
+  _displayCachedConsoleMessages:
+  function WCF__displayCachedConsoleMessages(aRemoteMessages)
+  {
+    if (!aRemoteMessages.length) {
+      return;
+    }
+
+    aRemoteMessages.forEach(function(aMessage) {
+      switch (aMessage._type) {
+        case "PageError": {
+          let category = this.categoryForScriptError(aMessage.category);
+          this.outputMessage(category, this.reportPageError,
+                             [category, aMessage]);
+          break;
+        }
+        case "ConsoleAPI":
+          this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
+                             [aMessage]);
+          break;
+      }
+    }, this);
+  },
+
+  /**
+   * Build the Web Console UI elements.
+   * @private
+   */
+  _initUI: function WCF__initUI()
+  {
+    let doc = this.document;
+
+    this.filterBox = doc.getElementsByClassName("hud-filter-box")[0];
+    this.outputNode = doc.getElementsByClassName("hud-output-node")[0];
+
+    this._setFilterTextBoxEvents();
+    this._initPositionUI();
+    this._initFilterButtons();
+
+    let saveBodies = doc.getElementById("saveBodies");
+    saveBodies.addEventListener("command", function() {
+      this.saveRequestAndResponseBodies = !this.saveRequestAndResponseBodies;
+    }.bind(this));
+
+    this.closeButton = doc.getElementsByClassName("webconsole-close-button")[0];
+    this.closeButton.addEventListener("command",
+                                      this.owner.onCloseButton.bind(this.owner));
+
+    let clearButton = doc.getElementsByClassName("webconsole-clear-console-button")[0];
+    clearButton.addEventListener("command", function() {
+      this.jsterm.clearOutput(true);
+    }.bind(this));
+  },
+
+  /**
+   * Initialize the default filter preferences.
+   * @private
+   */
+  _initDefaultFilterPrefs: function WCF__initDefaultFilterPrefs()
+  {
+    this.filterPrefs = {
+      network: Services.prefs.getBoolPref(FILTER_PREFS_PREFIX + "network"),
+      networkinfo: Services.prefs.getBoolPref(FILTER_PREFS_PREFIX + "networkinfo"),
+      csserror: Services.prefs.getBoolPref(FILTER_PREFS_PREFIX + "csserror"),
+      cssparser: Services.prefs.getBoolPref(FILTER_PREFS_PREFIX + "cssparser"),
+      exception: Services.prefs.getBoolPref(FILTER_PREFS_PREFIX + "exception"),
+      jswarn: Services.prefs.getBoolPref(FILTER_PREFS_PREFIX + "jswarn"),
+      error: Services.prefs.getBoolPref(FILTER_PREFS_PREFIX + "error"),
+      info: Services.prefs.getBoolPref(FILTER_PREFS_PREFIX + "info"),
+      warn: Services.prefs.getBoolPref(FILTER_PREFS_PREFIX + "warn"),
+      log: Services.prefs.getBoolPref(FILTER_PREFS_PREFIX + "log"),
+    };
+  },
+
+  /**
+   * The event handler that is called whenever a user switches a filter on or
+   * off.
+   *
+   * @private
+   * @param nsIDOMEvent aEvent
+   *        The event that triggered the filter change.
+   * @return boolean
+   */
+  _toggleFilter: function WCF__toggleFilter(aEvent)
+  {
+    let target = aEvent.target;
+    let tagName = target.tagName;
+    if (tagName != aEvent.currentTarget.tagName) {
+      return;
+    }
+
+    switch (tagName) {
+      case "toolbarbutton": {
+        let originalTarget = aEvent.originalTarget;
+        let classes = originalTarget.classList;
+
+        if (originalTarget.localName !== "toolbarbutton") {
+          // Oddly enough, the click event is sent to the menu button when
+          // selecting a menu item with the mouse. Detect this case and bail
+          // out.
+          break;
+        }
+
+        if (!classes.contains("toolbarbutton-menubutton-button") &&
+            originalTarget.getAttribute("type") === "menu-button") {
+          // This is a filter button with a drop-down. The user clicked the
+          // drop-down, so do nothing. (The menu will automatically appear
+          // without our intervention.)
+          break;
+        }
+
+        let state = target.getAttribute("checked") !== "true";
+        target.setAttribute("checked", state);
+
+        // This is a filter button with a drop-down, and the user clicked the
+        // main part of the button. Go through all the severities and toggle
+        // their associated filters.
+        let menuItems = target.querySelectorAll("menuitem");
+        for (let i = 0; i < menuItems.length; i++) {
+          menuItems[i].setAttribute("checked", state);
+          let prefKey = menuItems[i].getAttribute("prefKey");
+          this.setFilterState(prefKey, state);
+        }
+        break;
+      }
+
+      case "menuitem": {
+        let state = target.getAttribute("checked") !== "true";
+        target.setAttribute("checked", state);
+
+        let prefKey = target.getAttribute("prefKey");
+        this.setFilterState(prefKey, state);
+
+        // Adjust the state of the button appropriately.
+        let menuPopup = target.parentNode;
+
+        let someChecked = false;
+        let menuItem = menuPopup.firstChild;
+        while (menuItem) {
+          if (menuItem.getAttribute("checked") === "true") {
+            someChecked = true;
+            break;
+          }
+          menuItem = menuItem.nextSibling;
+        }
+        let toolbarButton = menuPopup.parentNode;
+        toolbarButton.setAttribute("checked", someChecked);
+        break;
+      }
+    }
+  },
+
+  /**
+   * set the filter state for a specific toggle button on a heads up display
+   *
+   * @param string aToggleType
+   * @param boolean aState
+   * @returns void
+   */
+  setFilterState: function WCF_setFilterState(aToggleType, aState)
+  {
+    this.filterPrefs[aToggleType] = aState;
+    this.adjustVisibilityForMessageType(aToggleType, aState);
+    Services.prefs.setBoolPref(FILTER_PREFS_PREFIX + aToggleType, aState);
+  },
+
+  /**
+   * get the filter state for a specific toggle button on a heads up display
+   *
+   * @param string aToggleType
+   * @returns boolean
+   */
+  getFilterState: function WCF_getFilterState(aToggleType)
+  {
+    return this.filterPrefs[aToggleType];
+  },
+
+  /**
+   * Get the current filter string.
+   *
+   * @returns string
+   */
+  getFilterString: function WCF_getFilterString()
+  {
+    return this.filterBox.value;
+  },
+
+  /**
+   * Check that the passed string matches the filter arguments.
+   *
+   * @param String aString
+   *        to search for filter words in.
+   * @param String aFilter
+   *        is a string containing all of the words to filter on.
+   * @returns boolean
+   */
+  stringMatchesFilters: function WCF_stringMatchesFilters(aString, aFilter)
+  {
+    if (!aFilter || !aString) {
+      return true;
+    }
+
+    let searchStr = aString.toLowerCase();
+    let filterStrings = aFilter.toLowerCase().split(/\s+/);
+    return !filterStrings.some(function (f) {
+      return searchStr.indexOf(f) == -1;
+    });
+  },
+
+  /**
+   * Sets the click events for all binary toggle filter buttons.
+   * @private
+   */
+  _setFilterTextBoxEvents: function WCF__setFilterTextBoxEvents()
+  {
+    let timer = null;
+    let timerEvent = this.adjustVisibilityOnSearchStringChange.bind(this);
+
+    let onChange = function _onChange() {
+      let timer;
+
+      // To improve responsiveness, we let the user finish typing before we
+      // perform the search.
+      if (timer == null) {
+        let timerClass = Cc["@mozilla.org/timer;1"];
+        timer = timerClass.createInstance(Ci.nsITimer);
+      }
+      else {
+        timer.cancel();
+      }
+
+      timer.initWithCallback(timerEvent, SEARCH_DELAY,
+                             Ci.nsITimer.TYPE_ONE_SHOT);
+    }.bind(this);
+
+    this.filterBox.addEventListener("command", onChange, false);
+    this.filterBox.addEventListener("input", onChange, false);
+  },
+
+  /**
+   * Initialize the UI for re-positioning the console
+   * @private
+   */
+  _initPositionUI: function WCF__initPositionUI()
+  {
+    let doc = this.document;
+
+    let itemAbove = doc.querySelector("*[consolePosition='above']");
+    itemAbove.addEventListener("command", this._onPositionConsoleCommand, false);
+
+    let itemBelow = doc.querySelector("*[consolePosition='below']");
+    itemBelow.addEventListener("command", this._onPositionConsoleCommand, false);
+
+    let itemWindow = doc.querySelector("*[consolePosition='window']");
+    itemWindow.addEventListener("command", this._onPositionConsoleCommand, false);
+
+    this.positionMenuitems = {
+      last: null,
+      above: itemAbove,
+      below: itemBelow,
+      window: itemWindow,
+    };
+  },
+
+  /**
+   * Handle the "command" event for the buttons that allow the user to
+   * reposition the Web Console UI.
+   *
+   * @private
+   * @param nsIDOMEvent aEvent
+   */
+  _onPositionConsoleCommand: function WCF__onPositionConsoleCommand(aEvent)
+  {
+    let position = aEvent.target.getAttribute("consolePosition");
+    this.owner.positionConsole(position);
+  },
+
+  /**
+   * Creates one of the filter buttons on the toolbar.
+   *
+   * @private
+   * @param nsIDOMNode aParent
+   *        The node to which the filter button should be appended.
+   * @param object aDescriptor
+   *        A descriptor that contains info about the button. Contains "name",
+   *        "category", and "prefKey" properties, and optionally a "severities"
+   *        property.
+   */
+  _initFilterButtons: function WCF__initFilterButtons()
+  {
+    let categories = this.document
+                     .querySelectorAll(".webconsole-filter-button[category]");
+    Array.prototype.forEach.call(categories, function(aButton) {
+      aButton.addEventListener("click", this._toggleFilter, false);
+
+      let someChecked = false;
+      let severities = aButton.querySelectorAll("menuitem[prefKey]");
+      Array.prototype.forEach.call(severities, function(aMenuItem) {
+        aMenuItem.addEventListener("command", this._toggleFilter, false);
+
+        let prefKey = aMenuItem.getAttribute("prefKey");
+        let checked = this.filterPrefs[prefKey];
+        aMenuItem.setAttribute("checked", checked);
+        someChecked = someChecked || checked;
+      }, this);
+
+      aButton.setAttribute("checked", someChecked);
+    }, this);
+  },
+
+  /**
+   * Destroy the property inspector message node. This performs the necessary
+   * cleanup for the tree widget and removes it from the DOM.
+   *
+   * @param nsIDOMNode aMessageNode
+   *        The message node that contains the property inspector from a
+   *        console.dir call.
+   */
+  pruneConsoleDirNode: function HUD_pruneConsoleDirNode(aMessageNode)
+  {
+    if (aMessageNode.parentNode) {
+      aMessageNode.parentNode.removeChild(aMessageNode);
+    }
+
+    let tree = aMessageNode.querySelector("tree");
+    tree.parentNode.removeChild(tree);
+    aMessageNode.propertyTreeView = null;
+    if (tree.view) {
+      tree.view.data = null;
+    }
+    tree.view = null;
+  },
+
+  positionConsole: function WCF_positionConsole(aPosition, aNewWindow)
+  {
+    this.window = aNewWindow;
+    this.document = this.window.document;
+    this.rootElement = this.document.documentElement;
+
+    // register the controller to handle "select all" properly
+    this.window.controllers.insertControllerAt(0, this._commandController);
+
+    //let outerWrap = this.jsTermParentNode.parentNode;
+
+    this.closeButton.hidden = aPosition == "window";
+
+    this.positionMenuitems[aPosition].setAttribute("checked", true);
+    if (this.positionMenuitems.last) {
+      this.positionMenuitems.last.setAttribute("checked", false);
+    }
+    this.positionMenuitems.last = this.positionMenuitems[aPosition];
+
+    //this.rootElement.appendChild(outerWrap);
+
+    if (this.jsterm) {
+      this.jsterm.inputNode.focus();
+    }
+  },
+
+  /**
+   * Logs a message to the Web Console that originates from the remote Web
+   * Console instance.
+   *
+   * @param object aMessage
+   *        The message received from the remote Web Console instance.
+   *        console service. This object needs to hold:
+   *          - hudId - the Web Console ID.
+   *          - apiMessage - a representation of the object sent by the console
+   *          storage service. This object holds the console message level, the
+   *          arguments that were passed to the console method and other
+   *          information.
+   *          - argumentsToString - the array of arguments passed to the console
+   *          method, each converted to a string.
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
+   */
+  logConsoleAPIMessage: function HUD_logConsoleAPIMessage(aMessage)
+  {
+    let body = null;
+    let clipboardText = null;
+    let sourceURL = null;
+    let sourceLine = 0;
+    let level = aMessage.apiMessage.level;
+    let args = aMessage.apiMessage.arguments;
+    let argsToString = aMessage.argumentsToString;
+
+    switch (level) {
+      case "log":
+      case "info":
+      case "warn":
+      case "error":
+      case "debug":
+        body = argsToString.join(" ");
+        sourceURL = aMessage.apiMessage.filename;
+        sourceLine = aMessage.apiMessage.lineNumber;
+        break;
+
+      case "trace":
+        let filename = WebConsoleUtils.abbreviateSourceURL(args[0].filename);
+        let functionName = args[0].functionName ||
+                           l10n.getStr("stacktrace.anonymousFunction");
+        let lineNumber = args[0].lineNumber;
+
+        body = l10n.getFormatStr("stacktrace.outputMessage",
+                                 [filename, functionName, lineNumber]);
+
+        sourceURL = args[0].filename;
+        sourceLine = args[0].lineNumber;
+
+        clipboardText = "";
+
+        args.forEach(function(aFrame) {
+          clipboardText += aFrame.filename + " :: " +
+                           aFrame.functionName + " :: " +
+                           aFrame.lineNumber + "\n";
+        });
+
+        clipboardText = clipboardText.trimRight();
+        break;
+
+      case "dir":
+        body = {
+          cacheId: aMessage.objectsCacheId,
+          resultString: argsToString[0],
+          remoteObject: args[0],
+          remoteObjectProvider:
+            this.jsterm.remoteObjectProvider.bind(this.jsterm),
+        };
+        clipboardText = body.resultString;
+        sourceURL = aMessage.apiMessage.filename;
+        sourceLine = aMessage.apiMessage.lineNumber;
+        break;
+
+      case "group":
+      case "groupCollapsed":
+        clipboardText = body = args;
+        sourceURL = aMessage.apiMessage.filename;
+        sourceLine = aMessage.apiMessage.lineNumber;
+        this.groupDepth++;
+        break;
+
+      case "groupEnd":
+        if (this.groupDepth > 0) {
+          this.groupDepth--;
+        }
+        return;
+
+      case "time":
+        if (!args) {
+          return;
+        }
+        if (args.error) {
+          Cu.reportError(l10n.getStr(args.error));
+          return;
+        }
+        body = l10n.getFormatStr("timerStarted", [args.name]);
+        clipboardText = body;
+        sourceURL = aMessage.apiMessage.filename;
+        sourceLine = aMessage.apiMessage.lineNumber;
+        break;
+
+      case "timeEnd":
+        if (!args) {
+          return;
+        }
+        body = l10n.getFormatStr("timeEnd", [args.name, args.duration]);
+        clipboardText = body;
+        sourceURL = aMessage.apiMessage.filename;
+        sourceLine = aMessage.apiMessage.lineNumber;
+        break;
+
+      default:
+        Cu.reportError("Unknown Console API log level: " + level);
+        return;
+    }
+
+    let node = this.createMessageNode(CATEGORY_WEBDEV, LEVELS[level], body,
+                                      sourceURL, sourceLine, clipboardText,
+                                      level, aMessage.timeStamp);
+
+    // Make the node bring up the property panel, to allow the user to inspect
+    // the stack trace.
+    if (level == "trace") {
+      node._stacktrace = args;
+
+      this.makeOutputMessageLink(node, function _traceNodeClickCallback() {
+        if (node._panelOpen) {
+          return;
+        }
+
+        let options = {
+          anchor: node,
+          data: { object: node._stacktrace },
+        };
+
+        let propPanel = this.jsterm.openPropertyPanel(options);
+        propPanel.panel.setAttribute("hudId", this.hudId);
+      }.bind(this));
+    }
+
+    if (level == "dir") {
+      // Make sure the cached evaluated object will be purged when the node is
+      // removed.
+      node._evalCacheId = aMessage.objectsCacheId;
+
+      // Initialize the inspector message node, by setting the PropertyTreeView
+      // object on the tree view. This has to be done *after* the node is
+      // shown, because the tree binding must be attached first.
+      node._onOutput = function _onMessageOutput() {
+        node.querySelector("tree").view = node.propertyTreeView;
+      };
+    }
+
+    return node;
+  },
+
+  /**
+   * Reports an error in the page source, either JavaScript or CSS.
+   *
+   * @param nsIScriptError aScriptError
+   *        The error message to report.
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
+   */
+  reportPageError: function HUD_reportPageError(aCategory, aScriptError)
+  {
+    // Warnings and legacy strict errors become warnings; other types become
+    // errors.
+    let severity = SEVERITY_ERROR;
+    if ((aScriptError.flags & aScriptError.warningFlag) ||
+        (aScriptError.flags & aScriptError.strictFlag)) {
+      severity = SEVERITY_WARNING;
+    }
+
+    let node = this.createMessageNode(aCategory, severity,
+                                      aScriptError.errorMessage,
+                                      aScriptError.sourceName,
+                                      aScriptError.lineNumber, null, null,
+                                      aScriptError.timeStamp);
+    return node;
+  },
+
+  /**
+   * Determine the category of a given nsIScriptError.
+   *
+   * @param nsIScriptError aScriptError
+   *        The script error you want to determine the category for.
+   * @return CATEGORY_JS|CATEGORY_CSS
+   *         Depending on the script error CATEGORY_JS or CATEGORY_CSS can be
+   *         returned.
+   */
+  categoryForScriptError: function HUD_categoryForScriptError(aScriptError)
+  {
+    switch (aScriptError.category) {
+      case "CSS Parser":
+      case "CSS Loader":
+        return CATEGORY_CSS;
+
+      default:
+        return CATEGORY_JS;
+    }
+  },
+
+  /**
+   * Log network activity.
+   *
+   * @param object aHttpActivity
+   *        The HTTP activity to log.
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
+   */
+  logNetActivity: function HUD_logNetActivity(aConnectionId)
+  {
+    let networkInfo = this._networkRequests[aConnectionId];
+    if (!networkInfo) {
+      return;
+    }
+
+    let entry = networkInfo.httpActivity.log.entries[0];
+    let request = entry.request;
+
+    let msgNode = this.document.createElementNS(XUL_NS, "hbox");
+
+    let methodNode = this.document.createElementNS(XUL_NS, "label");
+    methodNode.setAttribute("value", request.method);
+    methodNode.classList.add("webconsole-msg-body-piece");
+    msgNode.appendChild(methodNode);
+
+    let linkNode = this.document.createElementNS(XUL_NS, "hbox");
+    linkNode.setAttribute("flex", "1");
+    linkNode.classList.add("webconsole-msg-body-piece");
+    linkNode.classList.add("webconsole-msg-link");
+    msgNode.appendChild(linkNode);
+
+    let urlNode = this.document.createElementNS(XUL_NS, "label");
+    urlNode.setAttribute("crop", "center");
+    urlNode.setAttribute("flex", "1");
+    urlNode.setAttribute("title", request.url);
+    urlNode.setAttribute("value", request.url);
+    urlNode.classList.add("hud-clickable");
+    urlNode.classList.add("webconsole-msg-body-piece");
+    urlNode.classList.add("webconsole-msg-url");
+    linkNode.appendChild(urlNode);
+
+    let statusNode = this.document.createElementNS(XUL_NS, "label");
+    statusNode.setAttribute("value", "");
+    statusNode.classList.add("hud-clickable");
+    statusNode.classList.add("webconsole-msg-body-piece");
+    statusNode.classList.add("webconsole-msg-status");
+    linkNode.appendChild(statusNode);
+
+    let clipboardText = request.method + " " + request.url;
+
+    let messageNode = this.createMessageNode(CATEGORY_NETWORK, SEVERITY_LOG,
+                                             msgNode, null, null, clipboardText);
+
+    messageNode._connectionId = entry.connection;
+
+    this.makeOutputMessageLink(messageNode, function HUD_net_message_link() {
+      if (!messageNode._panelOpen) {
+        this.openNetworkPanel(messageNode, networkInfo.httpActivity);
+      }
+    }.bind(this));
+
+    networkInfo.node = messageNode;
+
+    this._updateNetMessage(entry.connection);
+
+    return messageNode;
+  },
+
+  /**
+   * Opens a NetworkPanel.
+   *
+   * @param nsIDOMNode aNode
+   *        The message node you want the panel to be anchored to.
+   * @param object aHttpActivity
+   *        The HTTP activity object that holds network request and response
+   *        information. This object is given to the NetworkPanel constructor.
+   * @return object
+   *         The new NetworkPanel instance.
+   */
+  openNetworkPanel: function WCF_openNetworkPanel(aNode, aHttpActivity)
+  {
+    let netPanel = new NetworkPanel(this.popupset, aHttpActivity);
+    netPanel.linkNode = aNode;
+    aNode._netPanel = netPanel;
+
+    let panel = netPanel.panel;
+    panel.openPopup(aNode, "after_pointer", 0, 0, false, false);
+    panel.sizeTo(450, 500);
+    panel.setAttribute("hudId", aHttpActivity.hudId);
+
+    panel.addEventListener("popuphiding", function WCF_netPanel_onHide() {
+      panel.removeEventListener("popuphiding", WCF_netPanel_onHide);
+
+      aNode._panelOpen = false;
+      aNode._netPanel = null;
+    });
+
+    aNode._panelOpen = true;
+
+    return netPanel;
+  },
+
+  /**
+   * Log file activity.
+   *
+   * @param string aFileURI
+   *        The file URI that was loaded.
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
+   */
+  logFileActivity: function HUD_logFileActivity(aFileURI)
+  {
+    let urlNode = this.document.createElementNS(XUL_NS, "label");
+    urlNode.setAttribute("crop", "center");
+    urlNode.setAttribute("flex", "1");
+    urlNode.setAttribute("title", aFileURI);
+    urlNode.setAttribute("value", aFileURI);
+    urlNode.classList.add("hud-clickable");
+    urlNode.classList.add("webconsole-msg-url");
+
+    let outputNode = this.createMessageNode(CATEGORY_NETWORK, SEVERITY_LOG,
+                                            urlNode, null, null, aFileURI);
+
+    this.makeOutputMessageLink(outputNode, function HUD__onFileClick() {
+      let viewSourceUtils = this.owner.gViewSourceUtils;
+      viewSourceUtils.viewSource(aFileURI, null, this.document);
+    }.bind(this));
+
+    return outputNode;
+  },
+
+  /**
+   * Inform user that the Web Console API has been replaced by a script
+   * in a content page.
+   *
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
+   */
+  logWarningAboutReplacedAPI: function HUD_logWarningAboutReplacedAPI()
+  {
+    return this.createMessageNode(CATEGORY_JS, SEVERITY_WARNING,
+                                  l10n.getStr("ConsoleAPIDisabled"));
+  },
+
+  ERRORS: {
+    HUD_BOX_DOES_NOT_EXIST: "Heads Up Display does not exist",
+    TAB_ID_REQUIRED: "Tab DOM ID is required",
+    PARENTNODE_NOT_FOUND: "parentNode element not found"
+  },
+
+  /**
+   * Handle the "WebConsole:NetworkActivity" message coming from the remote Web
+   * Console.
+   *
+   * @param object aMessage
+   *        The HTTP activity object. This object needs to hold two properties:
+   *        - meta - some metadata about the request log:
+   *          - stages - the stages the network request went through.
+   *          - discardRequestBody and discardResponseBody - booleans that tell
+   *          if the network request/response body was discarded or not.
+   *        - log - the request and response information. This is a HAR-like
+   *        object. See HUDService-content.js
+   *        NetworkMonitor.createActivityObject().
+   */
+  handleNetworkActivity: function HUD_handleNetworkActivity(aMessage)
+  {
+    let stage = aMessage.meta.stages[aMessage.meta.stages.length - 1];
+    let entry = aMessage.log.entries[0];
+
+    if (stage == "REQUEST_HEADER") {
+      let networkInfo = {
+        node: null,
+        httpActivity: aMessage,
+      };
+
+      this._networkRequests[entry.connection] = networkInfo;
+      this.outputMessage(CATEGORY_NETWORK, this.logNetActivity,
+                         [entry.connection]);
+      return;
+    }
+    else if (!(entry.connection in this._networkRequests)) {
+      return;
+    }
+
+    let networkInfo = this._networkRequests[entry.connection];
+    networkInfo.httpActivity = aMessage;
+
+    if (networkInfo.node) {
+      this._updateNetMessage(entry.connection);
+    }
+
+    // For unit tests we pass the HTTP activity object to the test callback,
+    // once requests complete.
+    if (this.owner.lastFinishedRequestCallback &&
+        aMessage.meta.stages.indexOf("REQUEST_STOP") > -1 &&
+        aMessage.meta.stages.indexOf("TRANSACTION_CLOSE") > -1) {
+      this.owner.lastFinishedRequestCallback(aMessage);
+    }
+  },
+
+  /**
+   * Update an output message to reflect the latest state of a network request,
+   * given a network connection ID.
+   *
+   * @private
+   * @param string aConnectionId
+   *        The connection ID to update.
+   */
+  _updateNetMessage: function HUD__updateNetMessage(aConnectionId)
+  {
+    let networkInfo = this._networkRequests[aConnectionId];
+    if (!networkInfo || !networkInfo.node) {
+      return;
+    }
+
+    let messageNode = networkInfo.node;
+    let httpActivity = networkInfo.httpActivity;
+    let stages = httpActivity.meta.stages;
+    let hasTransactionClose = stages.indexOf("TRANSACTION_CLOSE") > -1;
+    let hasResponseHeader = stages.indexOf("RESPONSE_HEADER") > -1;
+    let entry = httpActivity.log.entries[0];
+    let request = entry.request;
+    let response = entry.response;
+
+    if (hasTransactionClose || hasResponseHeader) {
+      let status = [];
+      if (response.httpVersion && response.status) {
+        status = [response.httpVersion, response.status, response.statusText];
+      }
+      if (hasTransactionClose) {
+        status.push(l10n.getFormatStr("NetworkPanel.durationMS", [entry.time]));
+      }
+      let statusText = "[" + status.join(" ") + "]";
+
+      let linkNode = messageNode.querySelector(".webconsole-msg-link");
+      let statusNode = linkNode.querySelector(".webconsole-msg-status");
+      statusNode.setAttribute("value", statusText);
+
+      messageNode.clipboardText = [request.method, request.url, statusText]
+                                  .join(" ");
+
+      if (hasResponseHeader && response.status >= MIN_HTTP_ERROR_CODE &&
+          response.status <= MAX_HTTP_ERROR_CODE) {
+        this.setMessageType(messageNode, CATEGORY_NETWORK, SEVERITY_ERROR);
+      }
+    }
+
+    if (messageNode._netPanel) {
+      messageNode._netPanel.update();
+    }
+  },
+
+  /**
+   * Make a link given an output element.
+   *
+   * @param nsIDOMNode aNode
+   *        The message element you want to make a link for.
+   * @param function aCallback
+   *        The function you want invoked when the user clicks on the message
+   *        element.
+   */
+  makeOutputMessageLink: function HUD_makeOutputMessageLink(aNode, aCallback)
+  {
+    let linkNode;
+    if (aNode.category === CATEGORY_NETWORK) {
+      linkNode = aNode.querySelector(".webconsole-msg-link, .webconsole-msg-url");
+    }
+    else {
+      linkNode = aNode.querySelector(".webconsole-msg-body");
+      linkNode.classList.add("hud-clickable");
+    }
+
+    linkNode.setAttribute("aria-haspopup", "true");
+
+    aNode.addEventListener("mousedown", function(aEvent) {
+      this._startX = aEvent.clientX;
+      this._startY = aEvent.clientY;
+    }, false);
+
+    aNode.addEventListener("click", function(aEvent) {
+      if (aEvent.detail != 1 || aEvent.button != 0 ||
+          (this._startX != aEvent.clientX &&
+           this._startY != aEvent.clientY)) {
+        return;
+      }
+
+      aCallback(this, aEvent);
+    }, false);
+  },
+
+  /**
+   * Output a message node. This filters a node appropriately, then sends it to
+   * the output, regrouping and pruning output as necessary.
+   *
+   * Note: this call is async - the given message node may not be displayed when
+   * you call this method.
+   *
+   * @param integer aCategory
+   *        The category of the message you want to output. See the CATEGORY_*
+   *        constants.
+   * @param function|nsIDOMElement aMethodOrNode
+   *        The method that creates the message element to send to the output or
+   *        the actual element. If a method is given it will be bound to the HUD
+   *        object and the arguments will be |aArguments|.
+   * @param array [aArguments]
+   *        If a method is given to output the message element then the method
+   *        will be invoked with the list of arguments given here.
+   */
+  outputMessage: function HUD_outputMessage(aCategory, aMethodOrNode, aArguments)
+  {
+    if (!this._outputQueue.length) {
+      // If the queue is empty we consider that now was the last output flush.
+      // This avoid an immediate output flush when the timer executes.
+      this._lastOutputFlush = Date.now();
+    }
+
+    this._outputQueue.push([aCategory, aMethodOrNode, aArguments]);
+
+    if (!this._outputTimeout) {
+      this._outputTimeout =
+        this.window.setTimeout(this._flushMessageQueue.bind(this),
+                               OUTPUT_INTERVAL);
+    }
+  },
+
+  /**
+   * Try to flush the output message queue. This takes the messages in the
+   * output queue and displays them. Outputting stops at MESSAGES_IN_INTERVAL.
+   * Further output is queued to happen later - see OUTPUT_INTERVAL.
+   *
+   * @private
+   */
+  _flushMessageQueue: function HUD__flushMessageQueue()
+  {
+    let timeSinceFlush = Date.now() - this._lastOutputFlush;
+    if (this._outputQueue.length > MESSAGES_IN_INTERVAL &&
+        timeSinceFlush < THROTTLE_UPDATES) {
+      this._outputTimeout =
+        this.window.setTimeout(this._flushMessageQueue.bind(this),
+                               OUTPUT_INTERVAL);
+      return;
+    }
+
+    // Determine how many messages we can display now.
+    let toDisplay = Math.min(this._outputQueue.length, MESSAGES_IN_INTERVAL);
+    if (toDisplay < 1) {
+      this._outputTimeout = null;
+      return;
+    }
+
+    // Try to prune the message queue.
+    let shouldPrune = false;
+    if (this._outputQueue.length > toDisplay && this._pruneOutputQueue()) {
+      toDisplay = Math.min(this._outputQueue.length, toDisplay);
+      shouldPrune = true;
+    }
+
+    let batch = this._outputQueue.splice(0, toDisplay);
+    if (!batch.length) {
+      this._outputTimeout = null;
+      return;
+    }
+
+    let outputNode = this.outputNode;
+    let lastVisibleNode = null;
+    let scrolledToBottom = ConsoleUtils.isOutputScrolledToBottom(outputNode);
+    let scrollBox = outputNode.scrollBoxObject.element;
+
+    let hudIdSupportsString = WebConsoleUtils.supportsString(this.hudId);
+
+    // Output the current batch of messages.
+    for (let item of batch) {
+      let node = this._outputMessageFromQueue(hudIdSupportsString, item);
+      if (node) {
+        lastVisibleNode = node;
+      }
+    }
+
+    let oldScrollHeight = 0;
+
+    // Prune messages if needed. We do not do this for every flush call to
+    // improve performance.
+    let removedNodes = 0;
+    if (shouldPrune || !this._outputQueue.length) {
+      oldScrollHeight = scrollBox.scrollHeight;
+
+      let categories = Object.keys(this._pruneCategoriesQueue);
+      categories.forEach(function _pruneOutput(aCategory) {
+        removedNodes += this.pruneOutputIfNecessary(aCategory);
+      }, this);
+      this._pruneCategoriesQueue = {};
+    }
+
+    // Regroup messages at the end of the queue.
+    if (!this._outputQueue.length) {
+      this.regroupOutput();
+    }
+
+    let isInputOutput = lastVisibleNode &&
+      (lastVisibleNode.classList.contains("webconsole-msg-input") ||
+       lastVisibleNode.classList.contains("webconsole-msg-output"));
+
+    // Scroll to the new node if it is not filtered, and if the output node is
+    // scrolled at the bottom or if the new node is a jsterm input/output
+    // message.
+    if (lastVisibleNode && (scrolledToBottom || isInputOutput)) {
+      ConsoleUtils.scrollToVisible(lastVisibleNode);
+    }
+    else if (!scrolledToBottom && removedNodes > 0 &&
+             oldScrollHeight != scrollBox.scrollHeight) {
+      // If there were pruned messages and if scroll is not at the bottom, then
+      // we need to adjust the scroll location.
+      scrollBox.scrollTop -= oldScrollHeight - scrollBox.scrollHeight;
+    }
+
+    // If the queue is not empty, schedule another flush.
+    if (this._outputQueue.length > 0) {
+      this._outputTimeout =
+        this.window.setTimeout(this._flushMessageQueue.bind(this),
+                               OUTPUT_INTERVAL);
+    }
+    else {
+      this._outputTimeout = null;
+    }
+
+    this._lastOutputFlush = Date.now();
+  },
+
+  /**
+   * Output a message from the queue.
+   *
+   * @private
+   * @param nsISupportsString aHudIdSupportsString
+   *        The HUD ID as an nsISupportsString.
+   * @param array aItem
+   *        An item from the output queue - this item represents a message.
+   * @return nsIDOMElement|undefined
+   *         The DOM element of the message if the message is visible, undefined
+   *         otherwise.
+   */
+  _outputMessageFromQueue:
+  function HUD__outputMessageFromQueue(aHudIdSupportsString, aItem)
+  {
+    let [category, methodOrNode, args] = aItem;
+
+    let node = typeof methodOrNode == "function" ?
+               methodOrNode.apply(this, args || []) :
+               methodOrNode;
+    if (!node) {
+      return;
+    }
+
+    let afterNode = node._outputAfterNode;
+    if (afterNode) {
+      delete node._outputAfterNode;
+    }
+
+    let isFiltered = this.filterMessageNode(node);
+
+    let isRepeated = false;
+    if (node.classList.contains("webconsole-msg-cssparser")) {
+      isRepeated = this.filterRepeatedCSS(node);
+    }
+
+    if (!isRepeated &&
+        !node.classList.contains("webconsole-msg-network") &&
+        (node.classList.contains("webconsole-msg-console") ||
+         node.classList.contains("webconsole-msg-exception") ||
+         node.classList.contains("webconsole-msg-error"))) {
+      isRepeated = this.filterRepeatedConsole(node);
+    }
+
+    let lastVisible = !isRepeated && !isFiltered;
+    if (!isRepeated) {
+      this.outputNode.insertBefore(node,
+                                   afterNode ? afterNode.nextSibling : null);
+      this._pruneCategoriesQueue[node.category] = true;
+      if (afterNode) {
+        lastVisible = this.outputNode.lastChild == node;
+      }
+    }
+
+    if (node._onOutput) {
+      node._onOutput();
+      delete node._onOutput;
+    }
+
+    let nodeID = node.getAttribute("id");
+    Services.obs.notifyObservers(aHudIdSupportsString,
+                                 "web-console-message-created", nodeID);
+
+    return lastVisible ? node : null;
+  },
+
+  /**
+   * Prune the queue of messages to display. This avoids displaying messages
+   * that will be removed at the end of the queue anyway.
+   * @private
+   */
+  _pruneOutputQueue: function HUD__pruneOutputQueue()
+  {
+    let nodes = {};
+
+    // Group the messages per category.
+    this._outputQueue.forEach(function(aItem, aIndex) {
+      let [category] = aItem;
+      if (!(category in nodes)) {
+        nodes[category] = [];
+      }
+      nodes[category].push(aIndex);
+    }, this);
+
+    let pruned = 0;
+
+    // Loop through the categories we found and prune if needed.
+    for (let category in nodes) {
+      let limit = this.logLimitForCategory(category);
+      let indexes = nodes[category];
+      if (indexes.length > limit) {
+        let n = Math.max(0, indexes.length - limit);
+        pruned += n;
+        for (let i = n - 1; i >= 0; i--) {
+          this._pruneItemFromQueue(this._outputQueue[indexes[i]]);
+          this._outputQueue.splice(indexes[i], 1);
+        }
+      }
+    }
+
+    return pruned;
+  },
+
+  /**
+   * Prune an item from the output queue.
+   *
+   * @private
+   * @param array aItem
+   *        The item you want to remove from the output queue.
+   */
+  _pruneItemFromQueue: function HUD__pruneItemFromQueue(aItem)
+  {
+    let [category, methodOrNode, args] = aItem;
+    if (typeof methodOrNode != "function" &&
+        methodOrNode._evalCacheId && !methodOrNode._panelOpen) {
+      this.jsterm.clearObjectCache(methodOrNode._evalCacheId);
+    }
+
+    if (category == CATEGORY_NETWORK) {
+      let connectionId = null;
+      if (methodOrNode == this.logNetActivity) {
+        connectionId = args[0];
+      }
+      else if (typeof methodOrNode != "function") {
+        connectionId = methodOrNode._connectionId;
+      }
+      if (connectionId && connectionId in this._networkRequests) {
+        delete this._networkRequests[connectionId];
+      }
+    }
+    else if (category == CATEGORY_WEBDEV &&
+             methodOrNode == this.logConsoleAPIMessage) {
+      let level = args[0].apiMessage.level;
+      if (level == "dir") {
+        this.jsterm.clearObjectCache(args[0].objectsCacheId);
+      }
+    }
+  },
+
+  /**
+   * Retrieve the limit of messages for a specific category.
+   *
+   * @param number aCategory
+   *        The category of messages you want to retrieve the limit for. See the
+   *        CATEGORY_* constants.
+   * @return number
+   *         The number of messages allowed for the specific category.
+   */
+  logLimitForCategory: function HUD_logLimitForCategory(aCategory)
+  {
+    let logLimit = DEFAULT_LOG_LIMIT;
+
+    try {
+      let prefName = CATEGORY_CLASS_FRAGMENTS[aCategory];
+      logLimit = Services.prefs.getIntPref("devtools.hud.loglimit." + prefName);
+      logLimit = Math.max(logLimit, 1);
+    }
+    catch (e) { }
+
+    return logLimit;
+  },
+
+  /**
+   * Ensures that the number of message nodes of type aCategory don't exceed that
+   * category's line limit by removing old messages as needed.
+   *
+   * @param integer aCategory
+   *        The category of message nodes to limit.
+   * @return number
+   *         The number of removed nodes.
+   */
+  pruneOutputIfNecessary: function WCF_pruneOutputIfNecessary(aCategory)
+  {
+    let outputNode = this.outputNode;
+    let logLimit = this.logLimitForCategory(aCategory);
+
+    let messageNodes = outputNode.getElementsByClassName("webconsole-msg-" +
+        CATEGORY_CLASS_FRAGMENTS[aCategory]);
+    let n = Math.max(0, messageNodes.length - logLimit);
+    let toRemove = Array.prototype.slice.call(messageNodes, 0, n);
+    toRemove.forEach(this.removeOutputMessage, this);
+
+    return n;
+  },
+
+  /**
+   * Remove a given message from the output.
+   *
+   * @param nsIDOMNode aNode
+   *        The message node you want to remove.
+   */
+  removeOutputMessage: function HUD_removeOutputMessage(aNode)
+  {
+    if (aNode._evalCacheId && !aNode._panelOpen) {
+      this.jsterm.clearObjectCache(aNode._evalCacheId);
+    }
+
+    if (aNode.classList.contains("webconsole-msg-cssparser")) {
+      let desc = aNode.childNodes[2].textContent;
+      let location = "";
+      if (aNode.childNodes[4]) {
+        location = aNode.childNodes[4].getAttribute("title");
+      }
+      delete this._cssNodes[desc + location];
+    }
+    else if (aNode.classList.contains("webconsole-msg-network")) {
+      delete this._networkRequests[aNode._connectionId];
+    }
+    else if (aNode.classList.contains("webconsole-msg-inspector")) {
+      this.pruneConsoleDirNode(aNode);
+      return;
+    }
+
+    if (aNode.parentNode) {
+      aNode.parentNode.removeChild(aNode);
+    }
+  },
+
+  /**
+   * Splits the given console messages into groups based on their timestamps.
+   */
+  regroupOutput: function WCF_regroupOutput()
+  {
+    // Go through the nodes and adjust the placement of "webconsole-new-group"
+    // classes.
+    let nodes = this.outputNode.querySelectorAll(".hud-msg-node" +
+      ":not(.hud-filtered-by-string):not(.hud-filtered-by-type)");
+    let lastTimestamp;
+    for (let i = 0, n = nodes.length; i < n; i++) {
+      let thisTimestamp = nodes[i].timestamp;
+      if (lastTimestamp != null &&
+          thisTimestamp >= lastTimestamp + NEW_GROUP_DELAY) {
+        nodes[i].classList.add("webconsole-new-group");
+      }
+      else {
+        nodes[i].classList.remove("webconsole-new-group");
+      }
+      lastTimestamp = thisTimestamp;
+    }
+  },
+
+  /**
+   * Turns the display of log nodes on and off appropriately to reflect the
+   * adjustment of the message type filter named by @aPrefKey.
+   *
+   * @param string aHUDId
+   *        The ID of the HUD to alter.
+   * @param string aPrefKey
+   *        The preference key for the message type being filtered: one of the
+   *        values in the MESSAGE_PREFERENCE_KEYS table.
+   * @param boolean aState
+   *        True if the filter named by @aMessageType is being turned on; false
+   *        otherwise.
+   * @returns void
+   */
+  adjustVisibilityForMessageType:
+  function WCF_adjustVisibilityForMessageType(aPrefKey, aState)
+  {
+    let outputNode = this.outputNode;
+    let doc = this.document;
+
+    // Look for message nodes ("hud-msg-node") with the given preference key
+    // ("hud-msg-error", "hud-msg-cssparser", etc.) and add or remove the
+    // "hud-filtered-by-type" class, which turns on or off the display.
+
+    let xpath = ".//*[contains(@class, 'hud-msg-node') and " +
+      "contains(concat(@class, ' '), 'hud-" + aPrefKey + " ')]";
+    let result = doc.evaluate(xpath, outputNode, null,
+      Ci.nsIDOMXPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
+    for (let i = 0; i < result.snapshotLength; i++) {
+      let node = result.snapshotItem(i);
+      if (aState) {
+        node.classList.remove("hud-filtered-by-type");
+      }
+      else {
+        node.classList.add("hud-filtered-by-type");
+      }
+    }
+
+    this.regroupOutput();
+  },
+
+  /**
+   * Turns the display of log nodes on and off appropriately to reflect the
+   * adjustment of the search string.
+   */
+  adjustVisibilityOnSearchStringChange:
+  function WCF_adjustVisibilityOnSearchStringChange()
+  {
+    let nodes = this.outputNode.getElementsByClassName("hud-msg-node");
+    let searchString = this.filterBox.value;
+
+    for (let i = 0, n = nodes.length; i < n; ++i) {
+      let node = nodes[i];
+
+      // hide nodes that match the strings
+      let text = node.clipboardText;
+
+      // if the text matches the words in aSearchString...
+      if (this.stringMatchesFilters(text, searchString)) {
+        node.classList.remove("hud-filtered-by-string");
+      }
+      else {
+        node.classList.add("hud-filtered-by-string");
+      }
+    }
+
+    this.regroupOutput();
+  },
+
+  /**
+   * Applies the user's filters to a newly-created message node via CSS
+   * classes.
+   *
+   * @param nsIDOMNode aNode
+   *        The newly-created message node.
+   * @return boolean
+   *         True if the message was filtered or false otherwise.
+   */
+  filterMessageNode: function WCF_filterMessageNode(aNode)
+  {
+    let isFiltered = false;
+
+    // Filter by the message type.
+    let prefKey = MESSAGE_PREFERENCE_KEYS[aNode.category][aNode.severity];
+    if (prefKey && !this.getFilterState(prefKey)) {
+      // The node is filtered by type.
+      aNode.classList.add("hud-filtered-by-type");
+      isFiltered = true;
+    }
+
+    // Filter on the search string.
+    let search = this.getFilterString();
+    let text = aNode.clipboardText;
+
+    // if string matches the filter text
+    if (!this.stringMatchesFilters(text, search)) {
+      aNode.classList.add("hud-filtered-by-string");
+      isFiltered = true;
+    }
+
+    return isFiltered;
+  },
+
+  /**
+   * Merge the attributes of the two nodes that are about to be filtered.
+   * Increment the number of repeats of aOriginal.
+   *
+   * @param nsIDOMNode aOriginal
+   *        The Original Node. The one being merged into.
+   * @param nsIDOMNode aFiltered
+   *        The node being filtered out because it is repeated.
+   */
+  mergeFilteredMessageNode:
+  function WCF_mergeFilteredMessageNode(aOriginal, aFiltered)
+  {
+    // childNodes[3].firstChild is the node containing the number of repetitions
+    // of a node.
+    let repeatNode = aOriginal.childNodes[3].firstChild;
+    if (!repeatNode) {
+      return; // no repeat node, return early.
+    }
+
+    let occurrences = parseInt(repeatNode.getAttribute("value")) + 1;
+    repeatNode.setAttribute("value", occurrences);
+  },
+
+  /**
+   * Filter the css node from the output node if it is a repeat. CSS messages
+   * are merged with previous messages if they occurred in the past.
+   *
+   * @param nsIDOMNode aNode
+   *        The message node to be filtered or not.
+   * @param nsIDOMNode aOutput
+   *        The outputNode of the HUD.
+   * @returns boolean
+   *         true if the message is filtered, false otherwise.
+   */
+  filterRepeatedCSS: function WCF_filterRepeatedCSS(aNode)
+  {
+    // childNodes[2] is the description node containing the text of the message.
+    let description = aNode.childNodes[2].textContent;
+    let location;
+
+    // childNodes[4] represents the location (source URL) of the error message.
+    // The full source URL is stored in the title attribute.
+    if (aNode.childNodes[4]) {
+      // browser_webconsole_bug_595934_message_categories.js
+      location = aNode.childNodes[4].getAttribute("title");
+    }
+    else {
+      location = "";
+    }
+
+    let dupe = this._cssNodes[description + location];
+    if (!dupe) {
+      // no matching nodes
+      this._cssNodes[description + location] = aNode;
+      return false;
+    }
+
+    this.mergeFilteredMessageNode(dupe, aNode);
+
+    return true;
+  },
+
+  /**
+   * Filter the console node from the output node if it is a repeat. Console
+   * messages are filtered from the output if and only if they match the
+   * immediately preceding message. The output node's last occurrence should
+   * have its timestamp updated.
+   *
+   * @param nsIDOMNode aNode
+   *        The message node to be filtered or not.
+   * @return boolean
+   *         true if the message is filtered, false otherwise.
+   */
+  filterRepeatedConsole: function WCF_filterRepeatedConsole(aNode)
+  {
+    let lastMessage = this.outputNode.lastChild;
+
+    // childNodes[2] is the description element
+    if (lastMessage && lastMessage.childNodes[2] &&
+        !aNode.classList.contains("webconsole-msg-inspector") &&
+        aNode.childNodes[2].textContent ==
+        lastMessage.childNodes[2].textContent) {
+      this.mergeFilteredMessageNode(lastMessage, aNode);
+      return true;
+    }
+
+    return false;
+  },
+
+  /**
+   * Given a category and message body, creates a DOM node to represent an
+   * incoming message. The timestamp is automatically added.
+   *
+   * @param number aCategory
+   *        The category of the message: one of the CATEGORY_* constants.
+   * @param number aSeverity
+   *        The severity of the message: one of the SEVERITY_* constants;
+   * @param string|nsIDOMNode aBody
+   *        The body of the message, either a simple string or a DOM node.
+   * @param number aHUDId
+   *        The HeadsUpDisplay ID.
+   * @param string aSourceURL [optional]
+   *        The URL of the source file that emitted the error.
+   * @param number aSourceLine [optional]
+   *        The line number on which the error occurred. If zero or omitted,
+   *        there is no line number associated with this message.
+   * @param string aClipboardText [optional]
+   *        The text that should be copied to the clipboard when this node is
+   *        copied. If omitted, defaults to the body text. If `aBody` is not
+   *        a string, then the clipboard text must be supplied.
+   * @param number aLevel [optional]
+   *        The level of the console API message.
+   * @param number aTimeStamp [optional]
+   *        The timestamp to use for this message node. If omitted, the current
+   *        date and time is used.
+   * @return nsIDOMNode
+   *         The message node: a XUL richlistitem ready to be inserted into
+   *         the Web Console output node.
+   */
+  createMessageNode:
+  function WCF_createMessageNode(aCategory, aSeverity, aBody, aSourceURL,
+                                 aSourceLine, aClipboardText, aLevel,
+                                 aTimeStamp)
+  {
+    if (typeof aBody != "string" && aClipboardText == null && aBody.innerText) {
+      aClipboardText = aBody.innerText;
+    }
+
+    // Make the icon container, which is a vertical box. Its purpose is to
+    // ensure that the icon stays anchored at the top of the message even for
+    // long multi-line messages.
+    let iconContainer = this.document.createElementNS(XUL_NS, "vbox");
+    iconContainer.classList.add("webconsole-msg-icon-container");
+    // Apply the curent group by indenting appropriately.
+    iconContainer.style.marginLeft = this.groupDepth * GROUP_INDENT + "px";
+
+    // Make the icon node. It's sprited and the actual region of the image is
+    // determined by CSS rules.
+    let iconNode = this.document.createElementNS(XUL_NS, "image");
+    iconNode.classList.add("webconsole-msg-icon");
+    iconContainer.appendChild(iconNode);
+
+    // Make the spacer that positions the icon.
+    let spacer = this.document.createElementNS(XUL_NS, "spacer");
+    spacer.setAttribute("flex", "1");
+    iconContainer.appendChild(spacer);
+
+    // Create the message body, which contains the actual text of the message.
+    let bodyNode = this.document.createElementNS(XUL_NS, "description");
+    bodyNode.setAttribute("flex", "1");
+    bodyNode.classList.add("webconsole-msg-body");
+
+    // Store the body text, since it is needed later for the property tree
+    // case.
+    let body = aBody;
+    // If a string was supplied for the body, turn it into a DOM node and an
+    // associated clipboard string now.
+    aClipboardText = aClipboardText ||
+                     (aBody + (aSourceURL ? " @ " + aSourceURL : "") +
+                              (aSourceLine ? ":" + aSourceLine : ""));
+    if (!(aBody instanceof Ci.nsIDOMNode)) {
+      aBody = this.document.createTextNode(aLevel == "dir" ?
+                                           aBody.resultString : aBody);
+    }
+
+    if (!aBody.nodeType) {
+      aBody = this.document.createTextNode(aBody.toString());
+    }
+    if (typeof aBody == "string") {
+      aBody = this.document.createTextNode(aBody);
+    }
+
+    bodyNode.appendChild(aBody);
+
+    let repeatContainer = this.document.createElementNS(XUL_NS, "hbox");
+    repeatContainer.setAttribute("align", "start");
+    let repeatNode = this.document.createElementNS(XUL_NS, "label");
+    repeatNode.setAttribute("value", "1");
+    repeatNode.classList.add("webconsole-msg-repeat");
+    repeatContainer.appendChild(repeatNode);
+
+    // Create the timestamp.
+    let timestampNode = this.document.createElementNS(XUL_NS, "label");
+    timestampNode.classList.add("webconsole-timestamp");
+    let timestamp = aTimeStamp || Date.now();
+    let timestampString = l10n.timestampString(timestamp);
+    timestampNode.setAttribute("value", timestampString);
+
+    // Create the source location (e.g. www.example.com:6) that sits on the
+    // right side of the message, if applicable.
+    let locationNode;
+    if (aSourceURL) {
+      locationNode = this.createLocationNode(aSourceURL, aSourceLine);
+    }
+
+    // Create the containing node and append all its elements to it.
+    let node = this.document.createElementNS(XUL_NS, "richlistitem");
+    node.clipboardText = aClipboardText;
+    node.classList.add("hud-msg-node");
+
+    node.timestamp = timestamp;
+    this.setMessageType(node, aCategory, aSeverity);
+
+    node.appendChild(timestampNode);
+    node.appendChild(iconContainer);
+    // Display the object tree after the message node.
+    if (aLevel == "dir") {
+      // Make the body container, which is a vertical box, for grouping the text
+      // and tree widgets.
+      let bodyContainer = this.document.createElement("vbox");
+      bodyContainer.setAttribute("flex", "1");
+      bodyContainer.appendChild(bodyNode);
+      // Create the tree.
+      let tree = this.document.createElement("tree");
+      tree.setAttribute("hidecolumnpicker", "true");
+      tree.flex = 1;
+
+      let treecols = this.document.createElement("treecols");
+      let treecol = this.document.createElement("treecol");
+      treecol.setAttribute("primary", "true");
+      treecol.setAttribute("hideheader", "true");
+      treecol.setAttribute("ignoreincolumnpicker", "true");
+      treecol.flex = 1;
+      treecols.appendChild(treecol);
+      tree.appendChild(treecols);
+
+      tree.appendChild(this.document.createElement("treechildren"));
+
+      bodyContainer.appendChild(tree);
+      node.appendChild(bodyContainer);
+      node.classList.add("webconsole-msg-inspector");
+      // Create the treeView object.
+      let treeView = node.propertyTreeView = new PropertyTreeView();
+
+      treeView.data = {
+        rootCacheId: body.cacheId,
+        panelCacheId: body.cacheId,
+        remoteObject: body.remoteObject,
+        remoteObjectProvider: body.remoteObjectProvider,
+      };
+
+      tree.setAttribute("rows", treeView.rowCount);
+    }
+    else {
+      node.appendChild(bodyNode);
+    }
+    node.appendChild(repeatContainer);
+    if (locationNode) {
+      node.appendChild(locationNode);
+    }
+
+    node.setAttribute("id", "console-msg-" + gSequenceId());
+
+    return node;
+  },
+
+  /**
+   * Adjusts the category and severity of the given message, clearing the old
+   * category and severity if present.
+   *
+   * @param nsIDOMNode aMessageNode
+   *        The message node to alter.
+   * @param number aNewCategory
+   *        The new category for the message; one of the CATEGORY_ constants.
+   * @param number aNewSeverity
+   *        The new severity for the message; one of the SEVERITY_ constants.
+   * @return void
+   */
+  setMessageType:
+  function WCF_setMessageType(aMessageNode, aNewCategory, aNewSeverity)
+  {
+    // Remove the old CSS classes, if applicable.
+    if ("category" in aMessageNode) {
+      let oldCategory = aMessageNode.category;
+      let oldSeverity = aMessageNode.severity;
+      aMessageNode.classList.remove("webconsole-msg-" +
+                                    CATEGORY_CLASS_FRAGMENTS[oldCategory]);
+      aMessageNode.classList.remove("webconsole-msg-" +
+                                    SEVERITY_CLASS_FRAGMENTS[oldSeverity]);
+      let key = "hud-" + MESSAGE_PREFERENCE_KEYS[oldCategory][oldSeverity];
+      aMessageNode.classList.remove(key);
+    }
+
+    // Add in the new CSS classes.
+    aMessageNode.category = aNewCategory;
+    aMessageNode.severity = aNewSeverity;
+    aMessageNode.classList.add("webconsole-msg-" +
+                               CATEGORY_CLASS_FRAGMENTS[aNewCategory]);
+    aMessageNode.classList.add("webconsole-msg-" +
+                               SEVERITY_CLASS_FRAGMENTS[aNewSeverity]);
+    let key = "hud-" + MESSAGE_PREFERENCE_KEYS[aNewCategory][aNewSeverity];
+    aMessageNode.classList.add(key);
+  },
+
+  /**
+   * Creates the XUL label that displays the textual location of an incoming
+   * message.
+   *
+   * @param string aSourceURL
+   *        The URL of the source file responsible for the error.
+   * @param number aSourceLine [optional]
+   *        The line number on which the error occurred. If zero or omitted,
+   *        there is no line number associated with this message.
+   * @return nsIDOMNode
+   *         The new XUL label node, ready to be added to the message node.
+   */
+  createLocationNode: function WCF_createLocationNode(aSourceURL, aSourceLine)
+  {
+    let locationNode = this.document.createElementNS(XUL_NS, "label");
+
+    // Create the text, which consists of an abbreviated version of the URL
+    // plus an optional line number.
+    let text = WebConsoleUtils.abbreviateSourceURL(aSourceURL);
+    if (aSourceLine) {
+      text += ":" + aSourceLine;
+    }
+    locationNode.setAttribute("value", text);
+
+    // Style appropriately.
+    locationNode.setAttribute("crop", "center");
+    locationNode.setAttribute("title", aSourceURL);
+    locationNode.classList.add("webconsole-location");
+    locationNode.classList.add("text-link");
+
+    // Make the location clickable.
+    locationNode.addEventListener("click", function() {
+      if (aSourceURL == "Scratchpad") {
+        let win = Services.wm.getMostRecentWindow("devtools:scratchpad");
+        if (win) {
+          win.focus();
+        }
+        return;
+      }
+      let viewSourceUtils = this.owner.gViewSourceUtils;
+      viewSourceUtils.viewSource(aSourceURL, null, this.document, aSourceLine);
+    }.bind(this), true);
+
+    return locationNode;
+  },
+
+  /**
+   * Copies the selected items to the system clipboard.
+   */
+  copySelectedItems: function WCF_copySelectedItems()
+  {
+    // Gather up the selected items and concatenate their clipboard text.
+    let strings = [];
+    let newGroup = false;
+
+    let children = this.outputNode.children;
+
+    for (let i = 0; i < children.length; i++) {
+      let item = children[i];
+      if (!item.selected) {
+        continue;
+      }
+
+      // Add dashes between groups so that group boundaries show up in the
+      // copied output.
+      if (i > 0 && item.classList.contains("webconsole-new-group")) {
+        newGroup = true;
+      }
+
+      // Ensure the selected item hasn't been filtered by type or string.
+      if (!item.classList.contains("hud-filtered-by-type") &&
+          !item.classList.contains("hud-filtered-by-string")) {
+        let timestampString = l10n.timestampString(item.timestamp);
+        if (newGroup) {
+          strings.push("--");
+          newGroup = false;
+        }
+        strings.push("[" + timestampString + "] " + item.clipboardText);
+      }
+    }
+
+    clipboardHelper.copyString(strings.join("\n"));
+  },
+
+  /**
+   * Destroy the HUD object. Call this method to avoid memory leaks when the Web
+   * Console is closed.
+   */
+  destroy: function WCF_destroy()
+  {
+    if (this.jsterm) {
+      this.jsterm.destroy();
+    }
+  },
+};
+
+/**
+ * Create a JSTerminal (a JavaScript command line). This is attached to an
+ * existing HeadsUpDisplay (a Web Console instance). This code is responsible
+ * with handling command line input, code evaluation and result output.
+ *
+ * @constructor
+ * @param object aHud
+ *        The HeadsUpDisplay object that owns this JSTerm instance.
+ */
+function JSTerm(aHud)
+{
+  this.hud = aHud;
+  this.document = this.hud.document;
+
+  this.hudId = this.hud.hudId;
+
+  this.lastCompletion = { value: null };
+  this.history = [];
+  this.historyIndex = 0;
+  this.historyPlaceHolder = 0;  // this.history.length;
+  this.autocompletePopup = new AutocompletePopup(this.hud.owner.chromeDocument);
+  this.autocompletePopup.onSelect = this.onAutocompleteSelect.bind(this);
+  this.autocompletePopup.onClick = this.acceptProposedCompletion.bind(this);
+  this.init();
+}
+
+JSTerm.prototype = {
+  lastInputValue: "",
+  COMPLETE_FORWARD: 0,
+  COMPLETE_BACKWARD: 1,
+  COMPLETE_HINT_ONLY: 2,
+
+  /**
+   * Initialize the JSTerminal instance.
+   */
+  init: function JST_init()
+  {
+    let doc = this.hud.document;
+    this.completeNode = doc.getElementsByClassName("jsterm-complete-node")[0];
+    this.inputNode = doc.getElementsByClassName("jsterm-input-node")[0];
+
+    this._keyPress = this.keyPress.bind(this);
+    this._inputEventHandler = this.inputEventHandler.bind(this);
+
+    this.inputNode.addEventListener("keypress", this._keyPress, false);
+    this.inputNode.addEventListener("input", this._inputEventHandler, false);
+    this.inputNode.addEventListener("keyup", this._inputEventHandler, false);
+  },
+
+  get outputNode() this.hud.outputNode,
+
+  /**
+   * Asynchronously evaluate a string in the content process sandbox.
+   *
+   * @param string aString
+   *        String to evaluate in the content process JavaScript sandbox.
+   * @param function [aCallback]
+   *        Optional function to be invoked when the evaluation result is
+   *        received.
+   */
+  evalInContentSandbox: function JST_evalInContentSandbox(aString, aCallback)
+  {
+    let message = {
+      str: aString,
+      resultCacheId: "HUDEval-" + gSequenceId(),
+    };
+
+    this.hud.owner.sendMessageToContent("JSTerm:EvalRequest", message, aCallback);
+
+    return message;
+  },
+
+  /**
+   * The "JSTerm:EvalResult" message handler. This is the JSTerm execution
+   * result callback which is invoked whenever JavaScript code evaluation
+   * results come from the content process.
+   *
+   * @private
+   * @param object aResponse
+   *        The JSTerm:EvalResult message received from the content process. See
+   *        JSTerm.handleEvalRequest() in HUDService-content.js for further
+   *        details.
+   * @param object aRequest
+   *        The JSTerm:EvalRequest message we sent to the content process.
+   * @see JSTerm.handleEvalRequest() in HUDService-content.js
+   */
+  _executeResultCallback:
+  function JST__executeResultCallback(aResponse, aRequest)
+  {
+    let errorMessage = aResponse.errorMessage;
+    let resultString = aResponse.resultString;
+
+    // Hide undefined results coming from JSTerm helper functions.
+    if (!errorMessage &&
+        resultString == "undefined" &&
+        aResponse.helperResult &&
+        !aResponse.inspectable &&
+        !aResponse.helperRawOutput) {
+      return;
+    }
+
+    let afterNode = aRequest.outputNode;
+
+    if (aResponse.errorMessage) {
+      this.writeOutput(aResponse.errorMessage, CATEGORY_OUTPUT, SEVERITY_ERROR,
+                       afterNode, aResponse.timestamp);
+    }
+    else if (aResponse.inspectable) {
+      let node = this.writeOutputJS(aResponse.resultString,
+                                    this._evalOutputClick.bind(this, aResponse),
+                                    afterNode, aResponse.timestamp);
+      node._evalCacheId = aResponse.childrenCacheId;
+    }
+    else {
+      this.writeOutput(aResponse.resultString, CATEGORY_OUTPUT, SEVERITY_LOG,
+                       afterNode, aResponse.timestamp);
+    }
+  },
+
+  /**
+   * Execute a string. Execution happens asynchronously in the content process.
+   *
+   * @param string [aExecuteString]
+   *        The string you want to execute. If this is not provided, the current
+   *        user input is used - taken from |this.inputNode.value|.
+   */
+  execute: function JST_execute(aExecuteString)
+  {
+    // attempt to execute the content of the inputNode
+    aExecuteString = aExecuteString || this.inputNode.value;
+    if (!aExecuteString) {
+      this.writeOutput("no value to execute", CATEGORY_OUTPUT, SEVERITY_LOG);
+      return;
+    }
+
+    let node = this.writeOutput(aExecuteString, CATEGORY_INPUT, SEVERITY_LOG);
+
+    let messageToContent =
+      this.evalInContentSandbox(aExecuteString,
+                                this._executeResultCallback.bind(this));
+    messageToContent.outputNode = node;
+
+    this.history.push(aExecuteString);
+    this.historyIndex++;
+    this.historyPlaceHolder = this.history.length;
+    this.setInputValue("");
+    this.clearCompletion();
+  },
+
+  /**
+   * Opens a new property panel that allows the inspection of the given object.
+   * The object information can be retrieved both async and sync, depending on
+   * the given options.
+   *
+   * @param object aOptions
+   *        Property panel options:
+   *        - title:
+   *        Panel title.
+   *        - anchor:
+   *        The DOM element you want the panel to be anchored to.
+   *        - updateButtonCallback:
+   *        An optional function you want invoked when the user clicks the
+   *        Update button. If this function is not provided the Update button is
+   *        not shown.
+   *        - data:
+   *        An object that represents the object you want to inspect. Please see
+   *        the PropertyPanel documentation - this object is passed to the
+   *        PropertyPanel constructor
+   * @return object
+   *         The new instance of PropertyPanel.
+   */
+  openPropertyPanel: function JST_openPropertyPanel(aOptions)
+  {
+    // The property panel has one button:
+    //    `Update`: reexecutes the string executed on the command line. The
+    //    result will be inspected by this panel.
+    let buttons = [];
+
+    if (aOptions.updateButtonCallback) {
+      buttons.push({
+        label: l10n.getStr("update.button"),
+        accesskey: l10n.getStr("update.accesskey"),
+        oncommand: aOptions.updateButtonCallback,
+      });
+    }
+
+    let parent = this.hud.popupset;
+    let title = aOptions.title ?
+                l10n.getFormatStr("jsPropertyInspectTitle", [aOptions.title]) :
+                l10n.getStr("jsPropertyTitle");
+
+    let propPanel = new PropertyPanel(parent, title, aOptions.data, buttons);
+
+    propPanel.panel.openPopup(aOptions.anchor, "after_pointer", 0, 0, false, false);
+    propPanel.panel.sizeTo(350, 450);
+
+    if (aOptions.anchor) {
+      propPanel.panel.addEventListener("popuphiding", function onPopupHide() {
+        propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
+        aOptions.anchor._panelOpen = false;
+      }, false);
+      aOptions.anchor._panelOpen = true;
+    }
+
+    return propPanel;
+  },
+
+  /**
+   * Writes a JS object to the JSTerm outputNode.
+   *
+   * @param string aOutputMessage
+   *        The message to display.
+   * @param function [aCallback]
+   *        Optional function to invoke when users click the message.
+   * @param nsIDOMNode [aNodeAfter]
+   *        Optional DOM node after which you want to insert the new message.
+   *        This is used when execution results need to be inserted immediately
+   *        after the user input.
+   * @param number [aTimestamp]
+   *        Optional timestamp to show for the output message (millisconds since
+   *        the UNIX epoch). If no timestamp is provided then Date.now() is
+   *        used.
+   * @return nsIDOMNode
+   *         The new message node.
+   */
+  writeOutputJS:
+  function JST_writeOutputJS(aOutputMessage, aCallback, aNodeAfter, aTimestamp)
+  {
+    let node = this.writeOutput(aOutputMessage, CATEGORY_OUTPUT, SEVERITY_LOG,
+                                aNodeAfter, aTimestamp);
+    if (aCallback) {
+      this.hud.makeOutputMessageLink(node, aCallback);
+    }
+    return node;
+  },
+
+  /**
+   * Writes a message to the HUD that originates from the interactive
+   * JavaScript console.
+   *
+   * @param string aOutputMessage
+   *        The message to display.
+   * @param number aCategory
+   *        The category of message: one of the CATEGORY_ constants.
+   * @param number aSeverity
+   *        The severity of message: one of the SEVERITY_ constants.
+   * @param nsIDOMNode [aNodeAfter]
+   *        Optional DOM node after which you want to insert the new message.
+   *        This is used when execution results need to be inserted immediately
+   *        after the user input.
+   * @param number [aTimestamp]
+   *        Optional timestamp to show for the output message (millisconds since
+   *        the UNIX epoch). If no timestamp is provided then Date.now() is
+   *        used.
+   * @return nsIDOMNode
+   *         The new message node.
+   */
+  writeOutput:
+  function JST_writeOutput(aOutputMessage, aCategory, aSeverity, aNodeAfter,
+                           aTimestamp)
+  {
+    let node = this.hud.createMessageNode(aCategory, aSeverity, aOutputMessage,
+                                          null, null, null, null, aTimestamp);
+    node._outputAfterNode = aNodeAfter;
+    this.hud.outputMessage(aCategory, node);
+    return node;
+  },
+
+  /**
+   * Clear the Web Console output.
+   *
+   * @param boolean aClearStorage
+   *        True if you want to clear the console messages storage associated to
+   *        this Web Console.
+   */
+  clearOutput: function JST_clearOutput(aClearStorage)
+  {
+    let hud = this.hud;
+    let outputNode = hud.outputNode;
+    let node;
+    while ((node = outputNode.firstChild)) {
+      hud.removeOutputMessage(node);
+    }
+
+    hud.groupDepth = 0;
+    hud._outputQueue.forEach(hud._pruneItemFromQueue, hud);
+    hud._outputQueue = [];
+    hud._networkRequests = {};
+    hud._cssNodes = {};
+
+    if (aClearStorage) {
+      hud.owner.sendMessageToContent("ConsoleAPI:ClearCache", {});
+    }
+  },
+
+  /**
+   * Updates the size of the input field (command line) to fit its contents.
+   *
+   * @returns void
+   */
+  resizeInput: function JST_resizeInput()
+  {
+    let inputNode = this.inputNode;
+
+    // Reset the height so that scrollHeight will reflect the natural height of
+    // the contents of the input field.
+    inputNode.style.height = "auto";
+
+    // Now resize the input field to fit its contents.
+    let scrollHeight = inputNode.inputField.scrollHeight;
+    if (scrollHeight > 0) {
+      inputNode.style.height = scrollHeight + "px";
+    }
+  },
+
+  /**
+   * Sets the value of the input field (command line), and resizes the field to
+   * fit its contents. This method is preferred over setting "inputNode.value"
+   * directly, because it correctly resizes the field.
+   *
+   * @param string aNewValue
+   *        The new value to set.
+   * @returns void
+   */
+  setInputValue: function JST_setInputValue(aNewValue)
+  {
+    this.inputNode.value = aNewValue;
+    this.lastInputValue = aNewValue;
+    this.completeNode.value = "";
+    this.resizeInput();
+  },
+
+  /**
+   * The inputNode "input" and "keyup" event handler.
+   *
+   * @param nsIDOMEvent aEvent
+   */
+  inputEventHandler: function JSTF_inputEventHandler(aEvent)
+  {
+    if (this.lastInputValue != this.inputNode.value) {
+      this.resizeInput();
+      this.complete(this.COMPLETE_HINT_ONLY);
+      this.lastInputValue = this.inputNode.value;
+    }
+  },
+
+  /**
+   * The inputNode "keypress" event handler.
+   *
+   * @param nsIDOMEvent aEvent
+   */
+  keyPress: function JSTF_keyPress(aEvent)
+  {
+    if (aEvent.ctrlKey) {
+      switch (aEvent.charCode) {
+        case 97:
+          // control-a
+          this.inputNode.setSelectionRange(0, 0);
+          aEvent.preventDefault();
+          break;
+        case 101:
+          // control-e
+          this.inputNode.setSelectionRange(this.inputNode.value.length,
+                                           this.inputNode.value.length);
+          aEvent.preventDefault();
+          break;
+        default:
+          break;
+      }
+      return;
+    }
+    else if (aEvent.shiftKey &&
+        aEvent.keyCode == Ci.nsIDOMKeyEvent.DOM_VK_RETURN) {
+      // shift return
+      // TODO: expand the inputNode height by one line
+      return;
+    }
+
+    let inputUpdated = false;
+
+    switch(aEvent.keyCode) {
+      case Ci.nsIDOMKeyEvent.DOM_VK_ESCAPE:
+        if (this.autocompletePopup.isOpen) {
+          this.clearCompletion();
+          aEvent.preventDefault();
+        }
+        break;
+
+      case Ci.nsIDOMKeyEvent.DOM_VK_RETURN:
+        if (this.autocompletePopup.isOpen && this.autocompletePopup.selectedIndex > -1) {
+          this.acceptProposedCompletion();
+        }
+        else {
+          this.execute();
+        }
+        aEvent.preventDefault();
+        break;
+
+      case Ci.nsIDOMKeyEvent.DOM_VK_UP:
+        if (this.autocompletePopup.isOpen) {
+          inputUpdated = this.complete(this.COMPLETE_BACKWARD);
+        }
+        else if (this.canCaretGoPrevious()) {
+          inputUpdated = this.historyPeruse(HISTORY_BACK);
+        }
+        if (inputUpdated) {
+          aEvent.preventDefault();
+        }
+        break;
+
+      case Ci.nsIDOMKeyEvent.DOM_VK_DOWN:
+        if (this.autocompletePopup.isOpen) {
+          inputUpdated = this.complete(this.COMPLETE_FORWARD);
+        }
+        else if (this.canCaretGoNext()) {
+          inputUpdated = this.historyPeruse(HISTORY_FORWARD);
+        }
+        if (inputUpdated) {
+          aEvent.preventDefault();
+        }
+        break;
+
+      case Ci.nsIDOMKeyEvent.DOM_VK_TAB:
+        // Generate a completion and accept the first proposed value.
+        if (this.complete(this.COMPLETE_HINT_ONLY) &&
+            this.lastCompletion &&
+            this.acceptProposedCompletion()) {
+          aEvent.preventDefault();
+        }
+        else {
+          this.updateCompleteNode(l10n.getStr("Autocomplete.blank"));
+          aEvent.preventDefault();
+        }
+        break;
+
+      default:
+        break;
+    }
+  },
+
+  /**
+   * Go up/down the history stack of input values.
+   *
+   * @param number aDirection
+   *        History navigation direction: HISTORY_BACK or HISTORY_FORWARD.
+   *
+   * @returns boolean
+   *          True if the input value changed, false otherwise.
+   */
+  historyPeruse: function JST_historyPeruse(aDirection)
+  {
+    if (!this.history.length) {
+      return false;
+    }
+
+    // Up Arrow key
+    if (aDirection == HISTORY_BACK) {
+      if (this.historyPlaceHolder <= 0) {
+        return false;
+      }
+
+      let inputVal = this.history[--this.historyPlaceHolder];
+      if (inputVal){
+        this.setInputValue(inputVal);
+      }
+    }
+    // Down Arrow key
+    else if (aDirection == HISTORY_FORWARD) {
+      if (this.historyPlaceHolder == this.history.length - 1) {
+        this.historyPlaceHolder ++;
+        this.setInputValue("");
+      }
+      else if (this.historyPlaceHolder >= (this.history.length)) {
+        return false;
+      }
+      else {
+        let inputVal = this.history[++this.historyPlaceHolder];
+        if (inputVal){
+          this.setInputValue(inputVal);
+        }
+      }
+    }
+    else {
+      throw new Error("Invalid argument 0");
+    }
+
+    return true;
+  },
+
+  /**
+   * Check if the caret is at a location that allows selecting the previous item
+   * in history when the user presses the Up arrow key.
+   *
+   * @return boolean
+   *         True if the caret is at a location that allows selecting the
+   *         previous item in history when the user presses the Up arrow key,
+   *         otherwise false.
+   */
+  canCaretGoPrevious: function JST_canCaretGoPrevious()
+  {
+    let node = this.inputNode;
+    if (node.selectionStart != node.selectionEnd) {
+      return false;
+    }
+
+    let multiline = /[\r\n]/.test(node.value);
+    return node.selectionStart == 0 ? true :
+           node.selectionStart == node.value.length && !multiline;
+  },
+
+  /**
+   * Check if the caret is at a location that allows selecting the next item in
+   * history when the user presses the Down arrow key.
+   *
+   * @return boolean
+   *         True if the caret is at a location that allows selecting the next
+   *         item in history when the user presses the Down arrow key, otherwise
+   *         false.
+   */
+  canCaretGoNext: function JST_canCaretGoNext()
+  {
+    let node = this.inputNode;
+    if (node.selectionStart != node.selectionEnd) {
+      return false;
+    }
+
+    let multiline = /[\r\n]/.test(node.value);
+    return node.selectionStart == node.value.length ? true :
+           node.selectionStart == 0 && !multiline;
+  },
+
+  history: null,
+
+  // Stores the data for the last completion.
+  lastCompletion: null,
+
+  /**
+   * Completes the current typed text in the inputNode. Completion is performed
+   * only if the selection/cursor is at the end of the string. If no completion
+   * is found, the current inputNode value and cursor/selection stay.
+   *
+   * @param int aType possible values are
+   *    - this.COMPLETE_FORWARD: If there is more than one possible completion
+   *          and the input value stayed the same compared to the last time this
+   *          function was called, then the next completion of all possible
+   *          completions is used. If the value changed, then the first possible
+   *          completion is used and the selection is set from the current
+   *          cursor position to the end of the completed text.
+   *          If there is only one possible completion, then this completion
+   *          value is used and the cursor is put at the end of the completion.
+   *    - this.COMPLETE_BACKWARD: Same as this.COMPLETE_FORWARD but if the
+   *          value stayed the same as the last time the function was called,
+   *          then the previous completion of all possible completions is used.
+   *    - this.COMPLETE_HINT_ONLY: If there is more than one possible
+   *          completion and the input value stayed the same compared to the
+   *          last time this function was called, then the same completion is
+   *          used again. If there is only one possible completion, then
+   *          the inputNode.value is set to this value and the selection is set
+   *          from the current cursor position to the end of the completed text.
+   * @param function aCallback
+   *        Optional function invoked when the autocomplete properties are
+   *        updated.
+   * @returns boolean true if there existed a completion for the current input,
+   *          or false otherwise.
+   */
+  complete: function JSTF_complete(aType, aCallback)
+  {
+    let inputNode = this.inputNode;
+    let inputValue = inputNode.value;
+    // If the inputNode has no value, then don't try to complete on it.
+    if (!inputValue) {
+      this.clearCompletion();
+      return false;
+    }
+
+    // Only complete if the selection is empty and at the end of the input.
+    if (inputNode.selectionStart == inputNode.selectionEnd &&
+        inputNode.selectionEnd != inputValue.length) {
+      this.clearCompletion();
+      return false;
+    }
+
+    // Update the completion results.
+    if (this.lastCompletion.value != inputValue) {
+      this._updateCompletionResult(aType, aCallback);
+      return false;
+    }
+
+    let popup = this.autocompletePopup;
+    let accepted = false;
+
+    if (aType != this.COMPLETE_HINT_ONLY && popup.itemCount == 1) {
+      this.acceptProposedCompletion();
+      accepted = true;
+    }
+    else if (aType == this.COMPLETE_BACKWARD) {
+      popup.selectPreviousItem();
+    }
+    else if (aType == this.COMPLETE_FORWARD) {
+      popup.selectNextItem();
+    }
+
+    aCallback && aCallback(this);
+    return accepted || popup.itemCount > 0;
+  },
+
+  /**
+   * Update the completion result. This operation is performed asynchronously by
+   * fetching updated results from the content process.
+   *
+   * @private
+   * @param int aType
+   *        Completion type. See this.complete() for details.
+   * @param function [aCallback]
+   *        Optional, function to invoke when completion results are received.
+   */
+  _updateCompletionResult:
+  function JST__updateCompletionResult(aType, aCallback)
+  {
+    if (this.lastCompletion.value == this.inputNode.value) {
+      return;
+    }
+
+    let message = {
+      id: "HUDComplete-" + gSequenceId(),
+      input: this.inputNode.value,
+    };
+
+    this.lastCompletion = {
+      requestId: message.id,
+      completionType: aType,
+      value: null,
+    };
+    let callback = this._receiveAutocompleteProperties.bind(this, aCallback);
+    this.hud.owner.sendMessageToContent("JSTerm:Autocomplete", message, callback);
+  },
+
+  /**
+   * Handler for the "JSTerm:AutocompleteProperties" message. This method takes
+   * the completion result received from the content process and updates the UI
+   * accordingly.
+   *
+   * @param function [aCallback=null]
+   *        Optional, function to invoke when the completion result is received.
+   * @param object aMessage
+   *        The JSON message which holds the completion results received from
+   *        the content process.
+   */
+  _receiveAutocompleteProperties:
+  function JST__receiveAutocompleteProperties(aCallback, aMessage)
+  {
+    let inputNode = this.inputNode;
+    let inputValue = inputNode.value;
+    if (aMessage.input != inputValue ||
+        this.lastCompletion.value == inputValue ||
+        aMessage.id != this.lastCompletion.requestId) {
+      return;
+    }
+
+    let matches = aMessage.matches;
+    if (!matches.length) {
+      this.clearCompletion();
+      return;
+    }
+
+    let items = matches.map(function(aMatch) {
+      return { label: aMatch };
+    });
+
+    let popup = this.autocompletePopup;
+    popup.setItems(items);
+
+    let completionType = this.lastCompletion.completionType;
+    this.lastCompletion = {
+      value: inputValue,
+      matchProp: aMessage.matchProp,
+    };
+
+    if (items.length > 1 && !popup.isOpen) {
+      popup.openPopup(inputNode);
+    }
+    else if (items.length < 2 && popup.isOpen) {
+      popup.hidePopup();
+    }
+
+    if (items.length == 1) {
+      popup.selectedIndex = 0;
+    }
+
+    this.onAutocompleteSelect();
+
+    if (completionType != this.COMPLETE_HINT_ONLY && popup.itemCount == 1) {
+      this.acceptProposedCompletion();
+    }
+    else if (completionType == this.COMPLETE_BACKWARD) {
+      popup.selectPreviousItem();
+    }
+    else if (completionType == this.COMPLETE_FORWARD) {
+      popup.selectNextItem();
+    }
+
+    aCallback && aCallback(this);
+  },
+
+  onAutocompleteSelect: function JSTF_onAutocompleteSelect()
+  {
+    let currentItem = this.autocompletePopup.selectedItem;
+    if (currentItem && this.lastCompletion.value) {
+      let suffix = currentItem.label.substring(this.lastCompletion.
+                                               matchProp.length);
+      this.updateCompleteNode(suffix);
+    }
+    else {
+      this.updateCompleteNode("");
+    }
+  },
+
+  /**
+   * Clear the current completion information and close the autocomplete popup,
+   * if needed.
+   */
+  clearCompletion: function JSTF_clearCompletion()
+  {
+    this.autocompletePopup.clearItems();
+    this.lastCompletion = { value: null };
+    this.updateCompleteNode("");
+    if (this.autocompletePopup.isOpen) {
+      this.autocompletePopup.hidePopup();
+    }
+  },
+
+  /**
+   * Accept the proposed input completion.
+   *
+   * @return boolean
+   *         True if there was a selected completion item and the input value
+   *         was updated, false otherwise.
+   */
+  acceptProposedCompletion: function JSTF_acceptProposedCompletion()
+  {
+    let updated = false;
+
+    let currentItem = this.autocompletePopup.selectedItem;
+    if (currentItem && this.lastCompletion.value) {
+      let suffix = currentItem.label.substring(this.lastCompletion.
+                                               matchProp.length);
+      this.setInputValue(this.inputNode.value + suffix);
+      updated = true;
+    }
+
+    this.clearCompletion();
+
+    return updated;
+  },
+
+  /**
+   * Update the node that displays the currently selected autocomplete proposal.
+   *
+   * @param string aSuffix
+   *        The proposed suffix for the inputNode value.
+   */
+  updateCompleteNode: function JSTF_updateCompleteNode(aSuffix)
+  {
+    // completion prefix = input, with non-control chars replaced by spaces
+    let prefix = aSuffix ? this.inputNode.value.replace(/[\S]/g, " ") : "";
+    this.completeNode.value = prefix + aSuffix;
+  },
+
+  /**
+   * Clear the object cache from the Web Console content instance.
+   *
+   * @param string aCacheId
+   *        The cache ID you want to clear. Multiple objects are cached into one
+   *        group which is given an ID.
+   */
+  clearObjectCache: function JST_clearObjectCache(aCacheId)
+  {
+    if (this.hud) {
+      this.hud.owner.sendMessageToContent("JSTerm:ClearObjectCache",
+                                          { cacheId: aCacheId });
+    }
+  },
+
+  /**
+   * The remote object provider allows you to retrieve a given object from
+   * a specific cache and have your callback invoked when the desired object is
+   * received from the Web Console content instance.
+   *
+   * @param string aCacheId
+   *        Retrieve the desired object from this cache ID.
+   * @param string aObjectId
+   *        The ID of the object you want.
+   * @param string aResultCacheId
+   *        The ID of the cache where you want any object references to be
+   *        stored into.
+   * @param function aCallback
+   *        The function you want invoked when the desired object is retrieved.
+   */
+  remoteObjectProvider:
+  function JST_remoteObjectProvider(aCacheId, aObjectId, aResultCacheId,
+                                    aCallback) {
+    let message = {
+      cacheId: aCacheId,
+      objectId: aObjectId,
+      resultCacheId: aResultCacheId,
+    };
+
+    this.hud.owner.sendMessageToContent("JSTerm:GetEvalObject", message, aCallback);
+  },
+
+  /**
+   * The "JSTerm:InspectObject" remote message handler. This allows the content
+   * process to open the Property Panel for a given object.
+   *
+   * @param object aRequest
+   *        The request message from the content process. This message includes
+   *        the user input string that was evaluated to inspect an object and
+   *        the result object which is to be inspected.
+   */
+  handleInspectObject: function JST_handleInspectObject(aRequest)
+  {
+    let options = {
+      title: aRequest.input,
+
+      data: {
+        rootCacheId: aRequest.objectCacheId,
+        panelCacheId: aRequest.objectCacheId,
+        remoteObject: aRequest.resultObject,
+        remoteObjectProvider: this.remoteObjectProvider.bind(this),
+      },
+    };
+
+    let propPanel = this.openPropertyPanel(options);
+    propPanel.panel.setAttribute("hudId", this.hudId);
+
+    let onPopupHide = function JST__onPopupHide() {
+      propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
+
+      this.clearObjectCache(options.data.panelCacheId);
+    }.bind(this);
+
+    propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+  },
+
+  /**
+   * The click event handler for evaluation results in the output.
+   *
+   * @private
+   * @param object aResponse
+   *        The JSTerm:EvalResult message received from the content process.
+   * @param nsIDOMNode aLink
+   *        The message node for which we are handling events.
+   */
+  _evalOutputClick: function JST__evalOutputClick(aResponse, aLinkNode)
+  {
+    if (aLinkNode._panelOpen) {
+      return;
+    }
+
+    let options = {
+      title: aResponse.input,
+      anchor: aLinkNode,
+
+      // Data to inspect.
+      data: {
+        // This is where the resultObject children are cached.
+        rootCacheId: aResponse.childrenCacheId,
+        remoteObject: aResponse.resultObject,
+        // This is where all objects retrieved by the panel will be cached.
+        panelCacheId: "HUDPanel-" + gSequenceId(),
+        remoteObjectProvider: this.remoteObjectProvider.bind(this),
+      },
+    };
+
+    options.updateButtonCallback = function JST__evalUpdateButton() {
+      this.evalInContentSandbox(aResponse.input,
+        this._evalOutputUpdatePanelCallback.bind(this, options, propPanel,
+                                                 aResponse));
+    }.bind(this);
+
+    let propPanel = this.openPropertyPanel(options);
+    propPanel.panel.setAttribute("hudId", this.hudId);
+
+    let onPopupHide = function JST__evalInspectPopupHide() {
+      propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
+
+      this.clearObjectCache(options.data.panelCacheId);
+
+      if (!aLinkNode.parentNode && aLinkNode._evalCacheId) {
+        this.clearObjectCache(aLinkNode._evalCacheId);
+      }
+    }.bind(this);
+
+    propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+  },
+
+  /**
+   * The callback used for updating the Property Panel when the user clicks the
+   * Update button.
+   *
+   * @private
+   * @param object aOptions
+   *        The options object used for opening the initial Property Panel.
+   * @param object aPropPanel
+   *        The Property Panel instance.
+   * @param object aOldResponse
+   *        The previous JSTerm:EvalResult message received from the content
+   *        process.
+   * @param object aNewResponse
+   *        The new JSTerm:EvalResult message received after the user clicked
+   *        the Update button.
+   */
+  _evalOutputUpdatePanelCallback:
+  function JST__updatePanelCallback(aOptions, aPropPanel, aOldResponse,
+                                    aNewResponse)
+  {
+    if (aNewResponse.errorMessage) {
+      this.writeOutput(aNewResponse.errorMessage, CATEGORY_OUTPUT,
+                       SEVERITY_ERROR);
+      return;
+    }
+
+    if (!aNewResponse.inspectable) {
+      this.writeOutput(l10n.getStr("JSTerm.updateNotInspectable"), CATEGORY_OUTPUT, SEVERITY_ERROR);
+      return;
+    }
+
+    this.clearObjectCache(aOptions.data.panelCacheId);
+    this.clearObjectCache(aOptions.data.rootCacheId);
+
+    if (aOptions.anchor && aOptions.anchor._evalCacheId) {
+      aOptions.anchor._evalCacheId = aNewResponse.childrenCacheId;
+    }
+
+    // Update the old response object such that when the panel is reopen, the
+    // user sees the new response.
+    aOldResponse.id = aNewResponse.id;
+    aOldResponse.childrenCacheId = aNewResponse.childrenCacheId;
+    aOldResponse.resultObject = aNewResponse.resultObject;
+    aOldResponse.resultString = aNewResponse.resultString;
+
+    aOptions.data.rootCacheId = aNewResponse.childrenCacheId;
+    aOptions.data.remoteObject = aNewResponse.resultObject;
+
+    // TODO: This updates the value of the tree.
+    // However, the states of open nodes is not saved.
+    // See bug 586246.
+    aPropPanel.treeView.data = aOptions.data;
+  },
+
+  /**
+   * Destroy the JSTerm object. Call this method to avoid memory leaks.
+   */
+  destroy: function JST_destroy()
+  {
+    this.clearCompletion();
+    this.clearOutput();
+
+    this.autocompletePopup.destroy();
+
+    this.inputNode.removeEventListener("keypress", this._keyPress, false);
+    this.inputNode.removeEventListener("input", this._inputEventHandler, false);
+    this.inputNode.removeEventListener("keyup", this._inputEventHandler, false);
+  },
+};
+
+/**
+ * ConsoleUtils: a collection of globally used functions
+ *
+ */
+var ConsoleUtils = {
+  /**
+   * Flag to turn on and off scrolling.
+   */
+  scroll: true,
+
+  /**
+   * Scrolls a node so that it's visible in its containing XUL "scrollbox"
+   * element.
+   *
+   * @param nsIDOMNode aNode
+   *        The node to make visible.
+   * @returns void
+   */
+  scrollToVisible: function ConsoleUtils_scrollToVisible(aNode) {
+    if (!this.scroll) {
+      return;
+    }
+
+    // Find the enclosing richlistbox node.
+    let richListBoxNode = aNode.parentNode;
+    while (richListBoxNode.tagName != "richlistbox") {
+      richListBoxNode = richListBoxNode.parentNode;
+    }
+
+    // Use the scroll box object interface to ensure the element is visible.
+    let boxObject = richListBoxNode.scrollBoxObject;
+    let nsIScrollBoxObject = boxObject.QueryInterface(Ci.nsIScrollBoxObject);
+    nsIScrollBoxObject.ensureElementIsVisible(aNode);
+  },
+
+  /**
+   * Check if the given output node is scrolled to the bottom.
+   *
+   * @param nsIDOMNode aOutputNode
+   * @return boolean
+   *         True if the output node is scrolled to the bottom, or false
+   *         otherwise.
+   */
+  isOutputScrolledToBottom:
+  function ConsoleUtils_isOutputScrolledToBottom(aOutputNode)
+  {
+    let lastNodeHeight = aOutputNode.lastChild ?
+                         aOutputNode.lastChild.clientHeight : 0;
+    let scrollBox = aOutputNode.scrollBoxObject.element;
+
+    return scrollBox.scrollTop + scrollBox.clientHeight >=
+           scrollBox.scrollHeight - lastNodeHeight / 2;
+  },
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// CommandController
+///////////////////////////////////////////////////////////////////////////////
+
+/**
+ * A controller (an instance of nsIController) that makes editing actions
+ * behave appropriately in the context of the Web Console.
+ */
+function CommandController(aWebConsole)
+{
+  this.owner = aWebConsole;
+}
+
+CommandController.prototype = {
+  /**
+   * Copies the currently-selected entries in the Web Console output to the
+   * clipboard.
+   */
+  copy: function CommandController_copy()
+  {
+    this.owner.copySelectedItems();
+  },
+
+  /**
+   * Selects all the text in the HUD output.
+   */
+  selectAll: function CommandController_selectAll()
+  {
+    this.owner.outputNode.selectAll();
+  },
+
+  supportsCommand: function CommandController_supportsCommand(aCommand)
+  {
+    return this.isCommandEnabled(aCommand);
+  },
+
+  isCommandEnabled: function CommandController_isCommandEnabled(aCommand)
+  {
+    switch (aCommand) {
+      case "cmd_copy":
+        // Only enable "copy" if nodes are selected.
+        return outputNode.selectedCount > 0;
+      case "cmd_selectAll":
+        return true;
+    }
+  },
+
+  doCommand: function CommandController_doCommand(aCommand)
+  {
+    switch (aCommand) {
+      case "cmd_copy":
+        this.copy();
+        break;
+      case "cmd_selectAll":
+        this.selectAll();
+        break;
+    }
+  }
+};
+
+function gSequenceId()
+{
+  return gSequenceId.n++;
+}
+gSequenceId.n = 0;
+
diff --git a/browser/devtools/webconsole/webconsole.xul b/browser/devtools/webconsole/webconsole.xul
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/webconsole.xul
@@ -0,0 +1,126 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<!DOCTYPE window [
+<!ENTITY % webConsoleDTD SYSTEM "chrome://browser/locale/devtools/webConsole.dtd">
+%webConsoleDTD;
+]>
+<?xml-stylesheet href="chrome://browser/skin/" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/skin/devtools/webconsole.css"
+                 type="text/css"?>
+<?xul-overlay href="chrome://global/content/editMenuOverlay.xul"?>
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        title="&window.title;"
+        windowtype="devtools:webconsole"
+        persist="screenX screenY width height sizemode">
+  <script type="text/javascript" src="chrome://global/content/globalOverlay.js"/>
+  <script type="text/javascript" src="webconsole.js"/>
+
+  <commandset id="editMenuCommands"/>
+  <keyset id="editMenuKeys"/>
+
+  <popupset id="mainPopupSet">
+    <menupopup id="output-contextmenu">
+      <menuitem id="saveBodies" type="checkbox" label="&saveBodies.label;"
+                accesskey="&saveBodies.accesskey;"/>
+      <menuitem id="menu_copy"/>
+      <menuitem id="menu_selectAll"/>
+    </menupopup>
+  </popupset>
+
+  <vbox class="hud-outer-wrapper" flex="1">
+    <vbox class="hud-console-wrapper" flex="1">
+      <toolbar id="viewGroup" class="hud-console-filter-toolbar" mode="full">
+#ifdef XP_MACOSX
+        <toolbarbutton class="webconsole-close-button"/>
+#endif
+
+        <toolbarbutton label="&btnPageNet.label;" type="menu-button"
+                       category="net" class="webconsole-filter-button"
+                       tooltip="&btnPageNet.tooltip;">
+          <menupopup>
+            <menuitem label="&btnConsoleErrors;" type="checkbox" autocheck="false"
+                      prefKey="network"/>
+            <menuitem label="&btnConsoleLog;" type="checkbox" autocheck="false"
+                      prefKey="networkinfo"/>
+          </menupopup>
+        </toolbarbutton>
+        <toolbarbutton label="&btnPageCSS.label;" type="menu-button"
+                       category="css" class="webconsole-filter-button"
+                       tooltip="&btnPageCSS.tooltip;">
+          <menupopup>
+            <menuitem label="&btnConsoleErrors;" type="checkbox" autocheck="false"
+                      prefKey="csserror"/>
+            <menuitem label="&btnConsoleWarnings;" type="checkbox" autocheck="false"
+                      prefKey="cssparser"/>
+          </menupopup>
+        </toolbarbutton>
+        <toolbarbutton label="&btnPageJS.label;" type="menu-button"
+                       category="js" class="webconsole-filter-button"
+                       tooltip="&btnPageJS.tooltip;">
+          <menupopup>
+            <menuitem label="&btnConsoleErrors;" type="checkbox" autocheck="false"
+                      prefKey="exception"/>
+            <menuitem label="&btnConsoleWarnings;" type="checkbox" autocheck="false"
+                      prefKey="jswarn"/>
+          </menupopup>
+        </toolbarbutton>
+        <toolbarbutton label="&btnPageLogging.label;" type="menu-button"
+                       category="logging" class="webconsole-filter-button"
+                       tooltip="&btnPageLogging.tooltip;">
+          <menupopup>
+            <menuitem label="&btnConsoleErrors;" type="checkbox" autocheck="false"
+                      prefKey="error"/>
+            <menuitem label="&btnConsoleWarnings;" type="checkbox" autocheck="false"
+                      prefKey="warn"/>
+            <menuitem label="&btnConsoleInfo;" type="checkbox" autocheck="false"
+                      prefKey="info"/>
+            <menuitem label="&btnConsoleLog;" type="checkbox" autocheck="false"
+                      prefKey="log"/>
+          </menupopup>
+        </toolbarbutton>
+
+        <spacer flex="1"/>
+
+        <toolbarbutton label="&btnPosition.label;" type="menu"
+                       tooltip="&btnPosition.tooltip;">
+          <menupopup>
+            <menuitem label="&positionMenu.above;" type="checkbox" autocheck="false"
+                      consolePosition="above"/>
+            <menuitem label="&positionMenu.below;" type="checkbox" autocheck="false"
+                      consolePosition="below"/>
+            <menuitem label="&positionMenu.window;" type="checkbox" autocheck="false"
+                      consolePosition="window"/>
+          </menupopup>
+        </toolbarbutton>
+
+        <textbox class="compact hud-filter-box" type="search"
+                 placeholder="&filterBox.placeholder;"/>
+        <toolbarbutton class="webconsole-clear-console-button"
+                       label="&btnClear;"/>
+
+#ifndef XP_MACOSX
+        <toolbarbutton class="webconsole-close-button"/>
+#endif
+      </toolbar>
+      <hbox class="gcliterm-display" flex="1">
+        <vbox class="gcliterm-hint-parent" flex="0" pack="end" hidden="true">
+          <vbox class="gcliterm-hint-node"/>
+        </vbox>
+        <richlistbox class="hud-output-node" orient="vertical" flex="1"
+                     seltype="multiple" context="output-contextmenu"
+                     style="direction:ltr;"></richlistbox>
+      </hbox>
+      <hbox class="jsterm-input-container" style="direction:ltr">
+        <stack class="jsterm-stack-node" flex="1">
+          <textbox class="jsterm-complete-node" multiline="true" rows="1"
+                   tabindex="-1"/>
+          <textbox class="jsterm-input-node" multiline="true" rows="1"/>
+        </stack>
+      </hbox>
+    </vbox>
+  </vbox>
+
+  <!-- TODO: check the generic classes and #viewGroup. also test tooltips -->
+</window>
diff --git a/browser/locales/en-US/chrome/browser/devtools/webConsole.dtd b/browser/locales/en-US/chrome/browser/devtools/webConsole.dtd
--- a/browser/locales/en-US/chrome/browser/devtools/webConsole.dtd
+++ b/browser/locales/en-US/chrome/browser/devtools/webConsole.dtd
@@ -3,24 +3,76 @@
    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
 
 <!-- LOCALIZATION NOTE : FILE The correct localization of this file might be to
   - keep it in English, or another language commonly spoken among web developers.
   - You want to make that choice consistent across the developer tools.
   - A good criteria is the language in which you'd find the best
   - documentation on web development on the web. -->
 
+<!ENTITY window.title "Web Console">
+
 <!ENTITY networkPanel.requestURL                  "Request URL">
 <!ENTITY networkPanel.requestMethod               "Request Method">
 <!ENTITY networkPanel.statusCode                  "Status Code">
 
 <!ENTITY networkPanel.requestHeaders              "Request Headers">
 <!ENTITY networkPanel.requestCookie               "Sent Cookie">
 <!ENTITY networkPanel.requestBody                 "Request Body">
 <!ENTITY networkPanel.requestFormData             "Sent Form Data">
 
 <!ENTITY networkPanel.responseHeaders             "Response Headers">
 <!ENTITY networkPanel.responseBody                "Response Body">
 <!ENTITY networkPanel.responseBodyCached          "Cached Data">
 <!ENTITY networkPanel.responseBodyUnknownType     "Unknown Content Type">
 <!ENTITY networkPanel.responseNoBody              "No Response Body">
 <!ENTITY networkPanel.responseImage               "Received Image">
 <!ENTITY networkPanel.responseImageCached         "Cached Image">
+
+<!-- LOCALIZATION NOTE (saveBodies.label): You can see this string in the Web
+   - Console context menu. -->
+<!ENTITY saveBodies.label     "Log Request and Response Bodies">
+<!ENTITY saveBodies.accesskey "L">
+
+<!-- LOCALIZATION NOTE (btnPageNet.label): This string is used for the menu
+  -  button that allows users to toggle the network logging output.
+  -  This string and the following strings toggle various kinds of output
+  -  filters. -->
+<!ENTITY btnPageNet.label   "Net">
+<!ENTITY btnPageNet.tooltip "Log network access">
+<!ENTITY btnPageCSS.label   "CSS">
+<!ENTITY btnPageCSS.tooltip "Log CSS parsing errors">
+<!ENTITY btnPageJS.label    "JS">
+<!ENTITY btnPageJS.tooltip  "Log JavaScript exceptions">
+
+<!-- LOCALIZATION NOTE (btnPageLogging): This is used as the text of the
+  -  the toolbar. It shows or hides messages that the web developer inserted on
+  -  the page for debugging purposes, using calls such console.log() and
+  -  console.error(). -->
+<!ENTITY btnPageLogging.label   "Logging">
+<!ENTITY btnPageLogging.tooltip "Log messages sent to the 'console' object">
+<!ENTITY btnConsoleErrors       "Errors">
+<!ENTITY btnConsoleInfo         "Info">
+<!ENTITY btnConsoleWarnings     "Warnings">
+<!ENTITY btnConsoleLog          "Log">
+
+<!-- LOCALIZATION NOTE (btnPosition.label): The label shown for the menu which
+  -  allows the user to toggle between the Web Console positioning types. -->
+<!ENTITY btnPosition.label     "Position">
+
+<!-- LOCALIZATION NOTE (btnPosition.tooltip): The tooltip shown when the user
+  -  hovers the Position button in the Web Console toolbar. -->
+<!ENTITY btnPosition.tooltip   "Position the Web Console above or below the document">
+
+<!-- LOCALIZATION NOTE (positionMenu.above): When this option is selected the
+  -  Web Console interface is displayed above the web page. -->
+<!ENTITY positionMenu.above    "Above">
+
+<!-- LOCALIZATION NOTE (positionMenu.below): When this option is selected the
+  -  Web Console interface is displayed below the web page. -->
+<!ENTITY positionMenu.below    "Below">
+
+<!-- LOCALIZATION NOTE (positionMenu.window): When this option is selected the
+  -  Web Console interface is displayed in a floating panel. -->
+<!ENTITY positionMenu.window   "Window">
+
+<!ENTITY filterBox.placeholder "Filter">
+<!ENTITY btnClear              "Clear">
diff --git a/browser/locales/en-US/chrome/browser/devtools/webconsole.properties b/browser/locales/en-US/chrome/browser/devtools/webconsole.properties
--- a/browser/locales/en-US/chrome/browser/devtools/webconsole.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/webconsole.properties
@@ -18,52 +18,21 @@ typeStrict=Strict Warning:
 msgCategory=Category: 
 errLine=Line: %S
 btnHide=Hide
 btnPrefs=Preferences
 categoryPage=Page:
 categoryConsole=Console:
 btnMutation=DOM Mutation
 tipMutation=Toggle DOM Mutation event logging
-btnPageNet=Net
-tipPageNet=Log network access
-btnPageCSS=CSS
-tipPageCSS=Log CSS parsing errors
-btnPageJS=JS
-tipPageJS=Log JavaScript exceptions
-# LOCALIZATION NOTE (btnPageLogging):
-#
-# This is used as the text of the "Logging" button on the toolbar. It
-# shows or hides messages that the web developer inserted on the page for
-# debugging purposes, using calls such console.log() and console.error().
-btnPageLogging=Logging
-# LOCALIZATION NOTE (tipPageLogging):
-#
-# This is used as the text of the tool tip for the "Logging" button on
-# the toolbar.
-tipPageLogging=Log messages sent to the "console" object
-btnConsoleErrors=Errors
-tipConsoleErrors=Log calls to console.error()
-btnConsoleInfo=Info
-tipConsoleInfo=Log calls to console.info()
-btnConsoleWarnings=Warnings
-tipConsoleWarnings=Log calls to console.warn()
-btnConsoleLog=Log
-tipConsoleLog=Log calls to console.log()
 btnGlobal=Global Messages
 tipGlobal=Toggle Global Message logging
 localConsole=Local Console
 clearConsoleCmd.label=Clear Console
 clearConsoleCmd.accesskey=e
-# LOCALIZATION NOTE (btnClear):
-#
-# This is used as the text of the "Clear" button for the toolbar. It clears the
-# contents of the console.
-btnClear=Clear
-stringFilter=Filter
 close.button=Close
 close.accesskey=C
 update.button=Update
 update.accesskey=U
 # LOCALIZATION NOTE FOR `jsPropertyTitle` AND `jsPropertyInspectTitle`:
 #
 # The "PropertyPanel" is used to display a JS object to the user.
 # If it is clear which object is being inspected (e.g., window, document object)
@@ -80,22 +49,16 @@ jsPropertyTitle=Object Inspector
 # The %S is replaced by the evaluated code the user clicked on in the console.
 #
 # Example: The user executed `window.document` in the WebConsole. The `document`
 # object is written to the output. If the user clicks on the `document` output
 # in the console, a PropertyPanel will show up. The title of the PropertyPanel
 # is set to `Inspect: window.document` because the clicked `document` object was
 # evaluated based on the `window.document` string.
 jsPropertyInspectTitle=Inspect: %S
-saveBodies.label=Log Request and Response Bodies
-saveBodies.accesskey=L
-copyCmd.label=Copy
-copyCmd.accesskey=C
-selectAllCmd.label=Select All
-selectAllCmd.accesskey=A
 # LOCALIZATION NOTE (timestampFormat): %1$02S = hours (24-hour clock),
 # %2$02S = minutes, %3$02S = seconds, %4$03S = milliseconds.
 timestampFormat=%02S:%02S:%02S.%03S
 
 helperFuncUnsupportedTypeError=Can't call pprint on this type of object.
 NetworkPanel.label=Inspect Network Request
 # LOCALIZATION NOTE (NetworkPanel.deltaDurationMS):
 #
@@ -119,36 +82,16 @@ NetworkPanel.imageSizeDeltaDurationMS=%S
 # flash data received from the server can't be displayed.
 #
 # The %S is replaced by the content type, that can't be displayed, examples are
 #  o application/x-shockwave-flash
 #  o music/crescendo
 NetworkPanel.responseBodyUnableToDisplay.content=Unable to display responses of type "%S"
 ConsoleAPIDisabled=The Web Console logging API (console.log, console.info, console.warn, console.error) has been disabled by a script on this page.
 
-# LOCALIZATION NOTE (webConsolePosition): The label shown for the menu which
-# allows the user to toggle between the Web Console positioning types.
-webConsolePosition=Position
-
-# LOCALIZATION NOTE (webConsolePositionTooltip): The tooltip shown when the user
-# hovers the Position button in the Web Console toolbar.
-webConsolePositionTooltip=Position the Web Console above or below the document
-
-# LOCALIZATION NOTE (webConsolePositionAbove): When this option is selected the
-# Web Console interface is displayed above the web page.
-webConsolePositionAbove=Above
-
-# LOCALIZATION NOTE (webConsolePositionBelow): When this option is selected the
-# Web Console interface is displayed below the web page.
-webConsolePositionBelow=Below
-
-# LOCALIZATION NOTE (webConsolePositionWindow): When this option is selected the
-# Web Console interface is displayed in a floating panel.
-webConsolePositionWindow=Window
-
 # LOCALIZATION NOTE (webConsoleWindowTitleAndURL): The Web Console floating
 # panel title, followed by the web page URL.
 # For RTL languages you need to set the LRM in the string to give the URL
 # the correct direction.
 webConsoleWindowTitleAndURL=Web Console - %S
 
 # LOCALIZATION NOTE (scratchpad.linkText):
 # The text used in the right hand side of the web console command line when
diff --git a/browser/themes/gnomestripe/browser.css b/browser/themes/gnomestripe/browser.css
--- a/browser/themes/gnomestripe/browser.css
+++ b/browser/themes/gnomestripe/browser.css
@@ -2518,8 +2518,34 @@ stack[anonid=browserStack][responsivemod
 
 .devtools-responsiveui-resizehandle {
   width: 16px;
   height: 16px;
   cursor: se-resize;
   -moz-transform: translate(12px, 12px);
   background-image: url("chrome://browser/skin/devtools/responsive-se-resizer.png");
 }
+
+/* Web Console */
+
+.hud-box {
+  border-bottom: 1px solid #aaa;
+  text-shadow: none;
+}
+
+.hud-box.animated {
+  -moz-transition: height 100ms;
+}
+
+.hud-splitter {
+  box-shadow: 0 -1px 0 0 ThreeDShadow inset, 0 0 0 10px -moz-Dialog inset;
+}
+
+.web-console-panel {
+  -moz-appearance: none;
+  background-color: white;
+}
+
+.web-console-panel > .hud-box {
+  height: 100%;
+  width: 100%;
+  background-color: white;
+}
diff --git a/browser/themes/gnomestripe/devtools/webconsole.css b/browser/themes/gnomestripe/devtools/webconsole.css
--- a/browser/themes/gnomestripe/devtools/webconsole.css
+++ b/browser/themes/gnomestripe/devtools/webconsole.css
@@ -1,25 +1,12 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-.hud-box {
-  border-bottom: 1px solid #aaa;
-  text-shadow: none;
-}
-
-.hud-box.animated {
-  -moz-transition: height 100ms;
-}
-
-.hud-splitter {
-  box-shadow: 0 -1px 0 0 ThreeDShadow inset, 0 0 0 10px -moz-Dialog inset;
-}
-
 .hud-outer-wrapper {
   width: 100%;
   height: 100%;
 }
 
 .hud-console-wrapper {
   width: 100%;
   overflow: auto;
@@ -267,19 +254,8 @@
 
 .jsterm-complete-node > .textbox-input-box > .textbox-textarea {
   color: GrayText;
 }
 
 .jsterm-output-line {
   font-size: 1em;
 }
-
-.web-console-panel {
-  -moz-appearance: none;
-  background-color: white;
-}
-
-.web-console-panel > .hud-box {
-  height: 100%;
-  width: 100%;
-  background-color: white;
-}
diff --git a/browser/themes/pinstripe/browser.css b/browser/themes/pinstripe/browser.css
--- a/browser/themes/pinstripe/browser.css
+++ b/browser/themes/pinstripe/browser.css
@@ -3259,8 +3259,36 @@ stack[anonid=browserStack][responsivemod
 
 .devtools-responsiveui-resizehandle {
   width: 16px;
   height: 16px;
   cursor: se-resize;
   -moz-transform: translate(12px, 12px);
   background-image: url("chrome://browser/skin/devtools/responsive-se-resizer.png");
 }
+
+/* Web Console */
+
+.hud-box {
+  border-bottom: 1px solid #aaa;
+  text-shadow: none;
+}
+
+.hud-box.animated {
+  -moz-transition: height 100ms;
+}
+
+.hud-splitter {
+  border-bottom: solid #a5a5a5 1px;
+  background: url("chrome://global/skin/splitter/dimple.png") no-repeat center,
+    -moz-linear-gradient(top, #fcfcfc, #dfdfdf);
+}
+
+.web-console-panel {
+  -moz-appearance: none;
+  background-color: white;
+}
+
+.web-console-panel > .hud-box {
+  height: 100%;
+  width: 100%;
+  background-color: white;
+}
diff --git a/browser/themes/pinstripe/devtools/webconsole.css b/browser/themes/pinstripe/devtools/webconsole.css
--- a/browser/themes/pinstripe/devtools/webconsole.css
+++ b/browser/themes/pinstripe/devtools/webconsole.css
@@ -1,29 +1,14 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 %include ../shared.inc
 
-.hud-box {
-  border-bottom: 1px solid #aaa;
-  text-shadow: none;
-}
-
-.hud-box.animated {
-  -moz-transition: height 100ms;
-}
-
-.hud-splitter {
-  border-bottom: solid #a5a5a5 1px;
-  background: url("chrome://global/skin/splitter/dimple.png") no-repeat center,
-    -moz-linear-gradient(top, #fcfcfc, #dfdfdf);
-}
-
 .hud-outer-wrapper {
   width: 100%;
   height: 100%;
 }
 
 .hud-console-wrapper {
   width: 100%;
   overflow: auto;
@@ -348,19 +333,8 @@
   padding: 0px 1px;
   -moz-appearance: none;
   -moz-box-align: center;
 }
 
 .hud-console-filter-toolbar:-moz-lwtheme {
   border-top: @scopeBarSeparatorBorder@;
 }
-
-.web-console-panel {
-  -moz-appearance: none;
-  background-color: white;
-}
-
-.web-console-panel > .hud-box {
-  height: 100%;
-  width: 100%;
-  background-color: white;
-}
diff --git a/browser/themes/winstripe/browser.css b/browser/themes/winstripe/browser.css
--- a/browser/themes/winstripe/browser.css
+++ b/browser/themes/winstripe/browser.css
@@ -3192,8 +3192,34 @@ stack[anonid=browserStack][responsivemod
 
 .devtools-responsiveui-resizehandle {
   width: 16px;
   height: 16px;
   cursor: se-resize;
   -moz-transform: translate(12px, 12px);
   background-image: url("chrome://browser/skin/devtools/responsive-se-resizer.png");
 }
+
+/* Web Console */
+
+.hud-box {
+  border-bottom: 1px solid #aaa;
+  text-shadow: none;
+}
+
+.hud-box.animated {
+  -moz-transition: height 100ms;
+}
+
+.hud-splitter {
+  border-top: none;
+}
+
+.web-console-panel {
+  -moz-appearance: none;
+  background-color: white;
+}
+
+.web-console-panel > .hud-box {
+  height: 100%;
+  width: 100%;
+  background-color: white;
+}
diff --git a/browser/themes/winstripe/devtools/webconsole.css b/browser/themes/winstripe/devtools/webconsole.css
--- a/browser/themes/winstripe/devtools/webconsole.css
+++ b/browser/themes/winstripe/devtools/webconsole.css
@@ -1,25 +1,12 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-.hud-box {
-  border-bottom: 1px solid #aaa;
-  text-shadow: none;
-}
-
-.hud-box.animated {
-  -moz-transition: height 100ms;
-}
-
-.hud-splitter {
-  border-top: none;
-}
-
 .hud-outer-wrapper {
   width: 100%;
   height: 100%;
 }
 
 .hud-console-wrapper {
   width: 100%;
   overflow: auto;
@@ -292,19 +279,8 @@
 
 .hud-console-filter-toolbar {
   padding: 1px 2px;
   -moz-box-align: center;
   -moz-appearance: none;
   background-color: -moz-dialog;
   border-top: none;
 }
-
-.web-console-panel {
-  -moz-appearance: none;
-  background-color: white;
-}
-
-.web-console-panel > .hud-box {
-  height: 100%;
-  width: 100%;
-  background-color: white;
-}
