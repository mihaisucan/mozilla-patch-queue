# HG changeset patch
# Parent 34a25346759274669f0042eb992818a0a55d1dfb
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1394052072 -7200

diff --git a/toolkit/devtools/server/actors/webapps.js b/toolkit/devtools/server/actors/webapps.js
--- a/toolkit/devtools/server/actors/webapps.js
+++ b/toolkit/devtools/server/actors/webapps.js
@@ -822,17 +822,17 @@ WebappsActor.prototype = {
       childTransport.ready();
 
       this.conn.setForwarding(prefix, childTransport);
 
       debug("establishing forwarding for app with prefix " + prefix);
 
       this._appActorsMap.set(mm, actor);
 
-      netMonitor = new NetworkMonitorManager(mm);
+      netMonitor = new NetworkMonitorManager(aFrame);
 
       deferred.resolve(actor);
     }).bind(this);
     mm.addMessageListener("debug:actor", onActorCreated);
 
     let onMessageManagerDisconnect = DevToolsUtils.makeInfallible(function (subject, topic, data) {
       if (subject == mm) {
         Services.obs.removeObserver(onMessageManagerDisconnect, topic);
diff --git a/toolkit/devtools/webconsole/network-helper.js b/toolkit/devtools/webconsole/network-helper.js
--- a/toolkit/devtools/webconsole/network-helper.js
+++ b/toolkit/devtools/webconsole/network-helper.js
@@ -187,30 +187,47 @@ let NetworkHelper = {
     }
     return null;
   },
 
   /**
    * Gets the web appId that is associated with aRequest.
    *
    * @param nsIHttpChannel aRequest
-   * @returns number
+   * @returns number|null
    *          The appId for the given request.
    */
   getAppIdForRequest: function NH_getAppIdForRequest(aRequest)
   {
     try {
       return this.getRequestLoadContext(aRequest).appId;
     } catch (ex) {
       // request loadContent is not always available.
     }
     return null;
   },
 
   /**
+   * Gets the topFrameElement that is associated with aRequest.
+   *
+   * @param nsIHttpChannel aRequest
+   * @returns nsIDOMElement|null
+   *          The top frame element for the given request.
+   */
+  getTopFrameForRequest: function NH_getTopFrameForRequest(aRequest)
+  {
+    try {
+      return this.getRequestLoadContext(aRequest).topFrameElement;
+    } catch (ex) {
+      // request loadContent is not always available.
+    }
+    return null;
+  },
+
+  /**
    * Gets the nsIDOMWindow that is associated with aRequest.
    *
    * @param nsIHttpChannel aRequest
    * @returns nsIDOMWindow or null
    */
   getWindowForRequest: function NH_getWindowForRequest(aRequest)
   {
     try {
diff --git a/toolkit/devtools/webconsole/network-monitor.js b/toolkit/devtools/webconsole/network-monitor.js
--- a/toolkit/devtools/webconsole/network-monitor.js
+++ b/toolkit/devtools/webconsole/network-monitor.js
@@ -342,20 +342,20 @@ NetworkResponseListener.prototype = {
  *        This method is invoked once for every new network request and it is
  *        given the following arguments: the initial network request
  *        information, and the channel. The third argument is the NetworkMonitor
  *        instance.
  *        onNetworkEvent() must return an object which holds several add*()
  *        methods which are used to add further network request/response
  *        information.
  */
-function NetworkMonitor(aWindow, aAppId, aOwner)
+function NetworkMonitor(aWindow, aFrame, aOwner)
 {
   this.window = aWindow;
-  this.appId = aAppId;
+  this.frame = aFrame;
   this.owner = aOwner;
   this.openRequests = {};
   this.openResponses = {};
   this._httpResponseExaminer =
     DevToolsUtils.makeInfallible(this._httpResponseExaminer).bind(this);
 }
 exports.NetworkMonitor = NetworkMonitor;
 
@@ -442,20 +442,20 @@ NetworkMonitor.prototype = {
     if (this.window) {
       // Try to get the source window of the request.
       let win = NetworkHelper.getWindowForRequest(channel);
       if (!win || win.top !== this.window) {
         return;
       }
     }
 
-    if (this.appId) {
-      // Try to get the source appId of the request.
-      let appId = NetworkHelper.getAppIdForRequest(channel);
-      if (!appId || appId != this.appId) {
+    if (this.frame) {
+      // Try to get the source frame of the request.
+      let frame = NetworkHelper.getTopFrameForRequest(channel);
+      if (!frame || frame != this.frame) {
         return;
       }
     }
 
     let response = {
       id: gSequenceId(),
       channel: channel,
       headers: [],
@@ -591,20 +591,20 @@ NetworkMonitor.prototype = {
   {
     let win = NetworkHelper.getWindowForRequest(aChannel);
 
     // Try to get the source window of the request.
     if (this.window && (!win || win.top !== this.window)) {
       return;
     }
 
-    if (this.appId) {
-      // Try to get the source appId of the request.
-      let appId = NetworkHelper.getAppIdForRequest(aChannel);
-      if (!appId || appId != this.appId) {
+    if (this.frame) {
+      // Try to get the source frame of the request.
+      let frame = NetworkHelper.getTopFrameForRequest(aChannel);
+      if (!frame || frame != this.frame) {
         return;
       }
     }
 
     let httpActivity = this.createActivityObject(aChannel);
 
     // see NM__onRequestBodySent()
     httpActivity.charset = win ? win.document.characterSet : null;
@@ -1109,43 +1109,49 @@ NetworkEventActorProxy.prototype = {
  * The NetworkMonitor manager used by the Webapps actor in the main process.
  * This object uses the message manager to listen for requests from the child
  * process to start/stop the network monitor.
  *
  * @constructor
  * @param nsIMessageManager messageManager
  *        The message manager to work with.
  */
-function NetworkMonitorManager(messageManager)
+function NetworkMonitorManager(frame)
 {
-  this.messageManager = messageManager;
+  let mm = frame.QueryInterface(Ci.nsIFrameLoaderOwner).frameLoader.messageManager;
+
+  this.frame = frame;
+  this.messageManager = mm;
   this.onNetMonitorMessage = this.onNetMonitorMessage.bind(this);
   this.onNetworkEvent = this.onNetworkEvent.bind(this);
-  messageManager.addMessageListener("debug:netmonitor", this.onNetMonitorMessage);
+
+  mm.addMessageListener("debug:netmonitor", this.onNetMonitorMessage);
 }
 exports.NetworkMonitorManager = NetworkMonitorManager;
 
 NetworkMonitorManager.prototype = {
   netMonitor: null,
+  frame: null,
+  messageManager: null,
 
   /**
    * Handler for "debug:monitor" messages received through the message manager
    * from the content process.
    *
    * @param object msg
    *        Message from the content.
    */
   onNetMonitorMessage: DevToolsUtils.makeInfallible(function _onNetMonitorMessage(msg) {
     let { action, appId } = msg.json;
 
     // Pipe network monitor data from parent to child via the message manager.
     switch (action) {
       case "start": {
         if (!this.netMonitor) {
-          this.netMonitor = new NetworkMonitor(null, appId, this);
+          this.netMonitor = new NetworkMonitor(null, this.frame, this);
           this.netMonitor.init();
         }
         break;
       }
 
       case "setPreferences": {
         let {preferences} = msg.json;
         for (let key of Object.keys(preferences)) {
