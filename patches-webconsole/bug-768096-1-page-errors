# HG changeset patch
# Parent 72f7bb8b859226fcd9e8233b1540a15b20eb742c
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1348679277 -3600

Bug 768096 - Web Console remote debugging protocol support - Part 1: page errors; try: -b do -p linux,linuxqt,linux64,macosx64,win32,win64,macosx -u mochitest-o -t none

diff --git a/browser/devtools/webconsole/HUDService-content.js b/browser/devtools/webconsole/HUDService-content.js
--- a/browser/devtools/webconsole/HUDService-content.js
+++ b/browser/devtools/webconsole/HUDService-content.js
@@ -6,30 +6,31 @@
 
 "use strict";
 
 // This code is appended to the browser content script.
 (function _HUDServiceContent() {
 let Cc = Components.classes;
 let Ci = Components.interfaces;
 let Cu = Components.utils;
+const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
 
 let tempScope = {};
 Cu.import("resource://gre/modules/XPCOMUtils.jsm", tempScope);
 Cu.import("resource://gre/modules/Services.jsm", tempScope);
 Cu.import("resource://gre/modules/ConsoleAPIStorage.jsm", tempScope);
-Cu.import("resource:///modules/WebConsoleUtils.jsm", tempScope);
+Cu.import("resource://gre/modules/devtools/WebConsoleUtils.jsm", tempScope);
 Cu.import("resource:///modules/NetworkHelper.jsm", tempScope);
 Cu.import("resource://gre/modules/NetUtil.jsm", tempScope);
 
 let XPCOMUtils = tempScope.XPCOMUtils;
 let Services = tempScope.Services;
 let gConsoleStorage = tempScope.ConsoleAPIStorage;
 let WebConsoleUtils = tempScope.WebConsoleUtils;
-let l10n = WebConsoleUtils.l10n;
+let l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 let JSPropertyProvider = tempScope.JSPropertyProvider;
 let NetworkHelper = tempScope.NetworkHelper;
 let NetUtil = tempScope.NetUtil;
 tempScope = null;
 
 let activityDistributor = Cc["@mozilla.org/network/http-activity-distributor;1"].getService(Ci.nsIHttpActivityDistributor);
 
 let _alive = true; // Track if this content script should still be alive.
@@ -180,16 +181,18 @@ let Manager = {
       aMessage.features.forEach(function(aFeature) {
         this.enableFeature(aFeature, aMessage[aFeature]);
       }, this);
     }
 
     if (aMessage.cachedMessages) {
       this._sendCachedMessages(aMessage.cachedMessages);
     }
+
+    this.sendMessage("WebConsole:Initialized", {});
   },
 
   /**
    * Add a remote message handler. This is used by other components of the Web
    * Console content script.
    *
    * @param string aName
    *        Message name to listen for.
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -13,22 +13,20 @@ const Cu = Components.utils;
 const CONSOLEAPI_CLASS_ID = "{b49c18f8-3379-4fc0-8c90-d7772c1a9ff3}";
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Services",
                                   "resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
-                                  "resource:///modules/WebConsoleUtils.jsm");
+                                  "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
-XPCOMUtils.defineLazyGetter(this, "l10n", function() {
-  return WebConsoleUtils.l10n;
-});
-
+const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
+let l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 
 var EXPORTED_SYMBOLS = ["HUDService"];
 
 function LogFactory(aMessagePrefix)
 {
   function log(aMessage) {
     var _msg = aMessagePrefix + " " + aMessage + "\n";
     dump(_msg);
@@ -167,17 +165,20 @@ HUD_SERVICE.prototype =
 
     if (!aAnimated) {
       this.storeHeight(hudId);
     }
 
     let hud = this.getHudReferenceById(hudId);
     let document = hud.chromeDocument;
 
-    hud.destroy();
+    hud.destroy(function() {
+      let id = WebConsoleUtils.supportsString(hudId);
+      Services.obs.notifyObservers(id, "web-console-destroyed", null);
+    });
 
     delete this.hudReferences[hudId];
 
     if (Object.keys(this.hudReferences).length == 0) {
       let autocompletePopup = document.
                               getElementById("webConsole_autocompletePopup");
       if (autocompletePopup) {
         autocompletePopup.parentNode.removeChild(autocompletePopup);
@@ -194,19 +195,16 @@ HUD_SERVICE.prototype =
 
       this.suspend();
     }
 
     let contentWindow = aTab.linkedBrowser.contentWindow;
     contentWindow.focus();
 
     HeadsUpDisplayUICommands.refreshCommand();
-
-    let id = WebConsoleUtils.supportsString(hudId);
-    Services.obs.notifyObservers(id, "web-console-destroyed", null);
   },
 
   /**
    * get a unique ID from the sequence generator
    *
    * @returns integer
    */
   sequenceId: function HS_sequencerId()
@@ -534,17 +532,17 @@ WebConsole.prototype = {
   /**
    * Message names that the HUD listens for. These messages come from the remote
    * Web Console content script.
    *
    * @private
    * @type array
    */
   _messageListeners: ["JSTerm:EvalObject", "WebConsole:ConsoleAPI",
-    "WebConsole:CachedMessages", "WebConsole:PageError", "JSTerm:EvalResult",
+    "WebConsole:CachedMessages", "WebConsole:Initialized", "JSTerm:EvalResult",
     "JSTerm:AutocompleteProperties", "JSTerm:ClearOutput",
     "JSTerm:InspectObject", "WebConsole:NetworkActivity",
     "WebConsole:FileActivity", "WebConsole:LocationChange",
     "JSTerm:NonNativeConsoleAPI"],
 
   /**
    * The xul:panel that holds the Web Console when it is positioned as a window.
    * @type nsIDOMElement
@@ -921,44 +919,30 @@ WebConsole.prototype = {
   {
     this.messageManager.loadFrameScript(CONTENT_SCRIPT_URL, true);
 
     this._messageListeners.forEach(function(aName) {
       this.messageManager.addMessageListener(aName, this.ui);
     }, this);
 
     let message = {
-      features: ["ConsoleAPI", "JSTerm", "PageError", "NetworkMonitor",
-                 "LocationChange"],
+      features: ["ConsoleAPI", "JSTerm", "NetworkMonitor", "LocationChange"],
       cachedMessages: ["ConsoleAPI", "PageError"],
       NetworkMonitor: { monitorFileActivity: true },
       JSTerm: { notifyNonNativeConsoleAPI: true },
       preferences: {
         "NetworkMonitor.saveRequestAndResponseBodies":
           this.ui.saveRequestAndResponseBodies,
       },
     };
 
     this.sendMessageToContent("WebConsole:Init", message);
   },
 
   /**
-   * Callback method for when the Web Console initialization is complete. For
-   * now this method sends the web-console-created notification using the
-   * nsIObserverService.
-   *
-   * @private
-   */
-  _onInitComplete: function WC__onInitComplete()
-  {
-    let id = WebConsoleUtils.supportsString(this.hudId);
-    Services.obs.notifyObservers(id, "web-console-created", null);
-  },
-
-  /**
    * Handler for messages that have an associated callback function. The
    * this.sendMessageToContent() allows one to provide a function to be invoked
    * when the content script replies to the message previously sent. This is the
    * method that invokes the callback.
    *
    * @see this.sendMessageToContent
    * @private
    * @param object aResponse
@@ -1046,18 +1030,22 @@ WebConsole.prototype = {
   openLink: function WC_openLink(aLink)
   {
     this.chromeWindow.openUILinkIn(aLink, "tab");
   },
 
   /**
    * Destroy the object. Call this method to avoid memory leaks when the Web
    * Console is closed.
+   *
+   * @param function [aOnDestroy]
+   *        Optional function to invoke when the Web Console instance is
+   *        destroyed.
    */
-  destroy: function WC_destroy()
+  destroy: function WC_destroy(aOnDestroy)
   {
     this.sendMessageToContent("WebConsole:Destroy", {});
 
     this._messageListeners.forEach(function(aName) {
       this.messageManager.removeMessageListener(aName, this.ui);
     }, this);
 
     // Make sure that the console panel does not try to call
@@ -1067,34 +1055,41 @@ WebConsole.prototype = {
     let popupset = this.mainPopupSet;
     let panels = popupset.querySelectorAll("panel[hudId=" + this.hudId + "]");
     for (let panel of panels) {
       if (panel != this.consolePanel) {
         panel.hidePopup();
       }
     }
 
+    let onDestroy = function WC_onDestroyUI() {
+      // Remove the iframe and the consolePanel if the Web Console is inside a
+      // floating panel.
+      if (this.consolePanel && this.consolePanel.parentNode) {
+        this.consolePanel.hidePopup();
+        this.consolePanel.parentNode.removeChild(this.consolePanel);
+        this.consolePanel = null;
+      }
+
+      if (this.iframe.parentNode) {
+        this.iframe.parentNode.removeChild(this.iframe);
+      }
+
+      if (this.splitter.parentNode) {
+        this.splitter.parentNode.removeChild(this.splitter);
+      }
+
+      aOnDestroy && aOnDestroy();
+    }.bind(this);
+
     if (this.ui) {
-      this.ui.destroy();
+      this.ui.destroy(onDestroy);
     }
-
-    // Remove the iframe and the consolePanel if the Web Console is inside a
-    // floating panel.
-    if (this.consolePanel && this.consolePanel.parentNode) {
-      this.consolePanel.hidePopup();
-      this.consolePanel.parentNode.removeChild(this.consolePanel);
-      this.consolePanel = null;
-    }
-
-    if (this.iframe.parentNode) {
-      this.iframe.parentNode.removeChild(this.iframe);
-    }
-
-    if (this.splitter.parentNode) {
-      this.splitter.parentNode.removeChild(this.splitter);
+    else {
+      onDestroy();
     }
   },
 };
 
 //////////////////////////////////////////////////////////////////////////
 // HeadsUpDisplayUICommands
 //////////////////////////////////////////////////////////////////////////
 
diff --git a/browser/devtools/webconsole/Makefile.in b/browser/devtools/webconsole/Makefile.in
--- a/browser/devtools/webconsole/Makefile.in
+++ b/browser/devtools/webconsole/Makefile.in
@@ -11,14 +11,13 @@ VPATH		= @srcdir@
 include $(DEPTH)/config/autoconf.mk
 
 EXTRA_JS_MODULES = \
 		HUDService.jsm \
 		PropertyPanel.jsm \
 		NetworkHelper.jsm \
 		NetworkPanel.jsm \
 		AutocompletePopup.jsm \
-		WebConsoleUtils.jsm \
 		$(NULL)
 
 TEST_DIRS = test
 
 include $(topsrcdir)/config/rules.mk
diff --git a/browser/devtools/webconsole/NetworkPanel.jsm b/browser/devtools/webconsole/NetworkPanel.jsm
--- a/browser/devtools/webconsole/NetworkPanel.jsm
+++ b/browser/devtools/webconsole/NetworkPanel.jsm
@@ -17,21 +17,20 @@ XPCOMUtils.defineLazyServiceGetter(this,
 
 XPCOMUtils.defineLazyModuleGetter(this, "NetworkHelper",
                                   "resource:///modules/NetworkHelper.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "NetUtil",
                                   "resource://gre/modules/NetUtil.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
-                                  "resource:///modules/WebConsoleUtils.jsm");
+                                  "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
-XPCOMUtils.defineLazyGetter(this, "l10n", function() {
-  return WebConsoleUtils.l10n;
-});
+const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
+let l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 
 var EXPORTED_SYMBOLS = ["NetworkPanel"];
 
 /**
  * Creates a new NetworkPanel.
  *
  * @param nsIDOMNode aParent
  *        Parent node to append the created panel to.
diff --git a/browser/devtools/webconsole/PropertyPanel.jsm b/browser/devtools/webconsole/PropertyPanel.jsm
--- a/browser/devtools/webconsole/PropertyPanel.jsm
+++ b/browser/devtools/webconsole/PropertyPanel.jsm
@@ -8,17 +8,17 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
-                                  "resource:///modules/WebConsoleUtils.jsm");
+                                  "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
 var EXPORTED_SYMBOLS = ["PropertyPanel", "PropertyTreeView"];
 
 ///////////////////////////////////////////////////////////////////////////
 //// PropertyTreeView.
 
 /**
  * This is an implementation of the nsITreeView interface. For comments on the
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_580454_timestamp_l10n.js b/browser/devtools/webconsole/test/browser_webconsole_bug_580454_timestamp_l10n.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_580454_timestamp_l10n.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_580454_timestamp_l10n.js
@@ -16,17 +16,17 @@ function test() {
   addTab(TEST_URI);
   browser.addEventListener("DOMContentLoaded", testTimestamp, false);
 
   function testTimestamp()
   {
     browser.removeEventListener("DOMContentLoaded", testTimestamp, false);
     const TEST_TIMESTAMP = 12345678;
     let date = new Date(TEST_TIMESTAMP);
-    let localizedString = WebConsoleUtils.l10n.timestampString(TEST_TIMESTAMP);
+    let localizedString = WCU_l10n.timestampString(TEST_TIMESTAMP);
     isnot(localizedString.indexOf(date.getHours()), -1, "the localized " +
           "timestamp contains the hours");
     isnot(localizedString.indexOf(date.getMinutes()), -1, "the localized " +
           "timestamp contains the minutes");
     isnot(localizedString.indexOf(date.getSeconds()), -1, "the localized " +
           "timestamp contains the seconds");
     isnot(localizedString.indexOf(date.getMilliseconds()), -1, "the localized " +
           "timestamp contains the milliseconds");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js b/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
@@ -76,16 +76,16 @@ function testContextMenuCopy() {
   let selectedNode = outputNode.getItemAtIndex(0);
 
   HUD = outputNode = null;
   waitForClipboard(getExpectedClipboardText(selectedNode), clipboardSetup,
     finishTest, finishTest);
 }
 
 function getExpectedClipboardText(aItem) {
-  return "[" + WebConsoleUtils.l10n.timestampString(aItem.timestamp) + "] " +
+  return "[" + WCU_l10n.timestampString(aItem.timestamp) + "] " +
          aItem.clipboardText;
 }
 
 function clipboardSetup() {
   goDoCommand("cmd_copy");
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_597103_deactivateHUDForContext_unfocused_window.js b/browser/devtools/webconsole/test/browser_webconsole_bug_597103_deactivateHUDForContext_unfocused_window.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_597103_deactivateHUDForContext_unfocused_window.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_597103_deactivateHUDForContext_unfocused_window.js
@@ -9,80 +9,110 @@
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 let tab1, tab2, win1, win2;
 let noErrors = true;
 
 function tab1Loaded(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
+  browser.removeEventListener(aEvent.type, tab1Loaded, true);
 
   win2 = OpenBrowserWindow();
   win2.addEventListener("load", win2Loaded, true);
 }
 
 function win2Loaded(aEvent) {
-  win2.removeEventListener(aEvent.type, arguments.callee, true);
+  win2.removeEventListener(aEvent.type, win2Loaded, true);
 
-  tab2 = win2.gBrowser.addTab();
+  tab2 = win2.gBrowser.addTab(TEST_URI);
   win2.gBrowser.selectedTab = tab2;
   tab2.linkedBrowser.addEventListener("load", tab2Loaded, true);
-  tab2.linkedBrowser.contentWindow.location = TEST_URI;
 }
 
 function tab2Loaded(aEvent) {
-  tab2.linkedBrowser.removeEventListener(aEvent.type, arguments.callee, true);
+  tab2.linkedBrowser.removeEventListener(aEvent.type, tab2Loaded, true);
 
-  waitForFocus(function() {
+  let consolesOpened = 0;
+  function onWebConsoleOpen() {
+    consolesOpened++;
+    if (consolesOpened == 2) {
+      Services.obs.removeObserver(onWebConsoleOpen, "web-console-created");
+      executeSoon(closeConsoles);
+    }
+  }
+
+  Services.obs.addObserver(onWebConsoleOpen, "web-console-created", false);
+
+  function openConsoles() {
     try {
       HUDService.activateHUDForContext(tab1);
     }
     catch (ex) {
       ok(false, "HUDService.activateHUDForContext(tab1) exception: " + ex);
       noErrors = false;
     }
 
     try {
       HUDService.activateHUDForContext(tab2);
     }
     catch (ex) {
       ok(false, "HUDService.activateHUDForContext(tab2) exception: " + ex);
       noErrors = false;
     }
+  }
+
+  let consolesClosed = 0;
+  function onWebConsoleClose()
+  {
+    consolesClosed++;
+    if (consolesClosed == 2) {
+      Services.obs.removeObserver(onWebConsoleClose, "web-console-destroyed");
+      executeSoon(testEnd);
+    }
+  }
+
+  function closeConsoles() {
+    Services.obs.addObserver(onWebConsoleClose, "web-console-destroyed", false);
 
     try {
       HUDService.deactivateHUDForContext(tab1);
     }
     catch (ex) {
       ok(false, "HUDService.deactivateHUDForContext(tab1) exception: " + ex);
       noErrors = false;
     }
 
     try {
       HUDService.deactivateHUDForContext(tab2);
     }
     catch (ex) {
       ok(false, "HUDService.deactivateHUDForContext(tab2) exception: " + ex);
       noErrors = false;
     }
+  }
 
-    if (noErrors) {
-      ok(true, "there were no errors");
-    }
+  function testEnd() {
+    ok(noErrors, "there were no errors");
 
-    win2.gBrowser.removeTab(tab2);
+    Array.forEach(win1.gBrowser.tabs, function(aTab) {
+      win1.gBrowser.removeTab(aTab);
+    });
+    Array.forEach(win2.gBrowser.tabs, function(aTab) {
+      win2.gBrowser.removeTab(aTab);
+    });
 
     executeSoon(function() {
       win2.close();
       tab1 = tab2 = win1 = win2 = null;
       finishTest();
     });
+  }
 
-  }, tab2.linkedBrowser.contentWindow);
+  waitForFocus(openConsoles, tab2.linkedBrowser.contentWindow);
 }
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", tab1Loaded, true);
   tab1 = gBrowser.selectedTab;
   win1 = window;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_601909_remember_height.js b/browser/devtools/webconsole/test/browser_webconsole_bug_601909_remember_height.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_601909_remember_height.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_601909_remember_height.js
@@ -11,83 +11,97 @@
 // Minimum console height, in pixels.
 const MINIMUM_CONSOLE_HEIGHT = 150;
 
 // Minimum page height, in pixels. This prevents the Web Console from
 // remembering a height that covers the whole page.
 const MINIMUM_PAGE_HEIGHT = 50;
 const HEIGHT_PREF = "devtools.hud.height";
 
-let hud, newHeight, height, innerHeight;
+let hud, newHeight, height, innerHeight, testDriver;
 
-function performTests(aWebConsole)
+function testGen()
 {
-  hud = aWebConsole.iframe;
   height = parseInt(hud.style.height);
 
   toggleConsole();
+  yield;
 
   is(newHeight, height, "same height after reopening the console");
   is(Services.prefs.getIntPref(HEIGHT_PREF), HUDService.lastConsoleHeight,
     "pref is correct");
 
   setHeight(Math.ceil(innerHeight * 0.5));
   toggleConsole();
+  yield;
 
   is(newHeight, height, "same height after reopening the console");
   is(Services.prefs.getIntPref(HEIGHT_PREF), HUDService.lastConsoleHeight,
     "pref is correct");
 
   setHeight(MINIMUM_CONSOLE_HEIGHT - 1);
   toggleConsole();
+  yield;
 
   is(newHeight, MINIMUM_CONSOLE_HEIGHT, "minimum console height is respected");
   is(Services.prefs.getIntPref(HEIGHT_PREF), HUDService.lastConsoleHeight,
     "pref is correct");
 
   setHeight(innerHeight - MINIMUM_PAGE_HEIGHT + 1);
   toggleConsole();
+  yield;
 
   is(newHeight, innerHeight - MINIMUM_PAGE_HEIGHT,
     "minimum page height is respected");
   is(Services.prefs.getIntPref(HEIGHT_PREF), HUDService.lastConsoleHeight,
     "pref is correct");
 
   setHeight(Math.ceil(innerHeight * 0.6));
   Services.prefs.setIntPref(HEIGHT_PREF, -1);
   toggleConsole();
+  yield;
 
   is(newHeight, height, "same height after reopening the console");
   is(Services.prefs.getIntPref(HEIGHT_PREF), -1, "pref is not updated");
 
   closeConsole();
   HUDService.lastConsoleHeight = 0;
   Services.prefs.setIntPref(HEIGHT_PREF, 0);
 
+  hud = testDriver = null;
   executeSoon(finishTest);
+
+  yield;
 }
 
 function toggleConsole()
 {
-  closeConsole();
-  openConsole();
+  closeConsole(null, function() {
+    openConsole(null, function() {
+      let hudId = HUDService.getHudIdByWindow(content);
+      hud = HUDService.hudReferences[hudId].iframe;
+      newHeight = parseInt(hud.style.height);
 
-  let hudId = HUDService.getHudIdByWindow(content);
-  hud = HUDService.hudReferences[hudId].iframe;
-  newHeight = parseInt(hud.style.height);
+      testDriver.next();
+    });
+  });
 }
 
 function setHeight(aHeight)
 {
   height = aHeight;
   hud.style.height = height + "px";
 }
 
 function test()
 {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 601909");
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
     innerHeight = content.innerHeight;
-    openConsole(null, performTests);
+    openConsole(null, function(aHud) {
+      hud = aHud.iframe;
+      testDriver = testGen();
+      testDriver.next();
+    });
   }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_613280_jsterm_copy.js b/browser/devtools/webconsole/test/browser_webconsole_bug_613280_jsterm_copy.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_613280_jsterm_copy.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_613280_jsterm_copy.js
@@ -75,11 +75,11 @@ function performTest(HUD) {
 
   ok(HUD.outputNode.selectedItem, "we have a selected message");
 
   waitForClipboard(getExpectedClipboardText(HUD.outputNode.selectedItem),
     clipboard_setup, clipboard_copy_done, clipboard_copy_done);
 }
 
 function getExpectedClipboardText(aItem) {
-  return "[" + WebConsoleUtils.l10n.timestampString(aItem.timestamp) + "] " +
+  return "[" + WCU_l10n.timestampString(aItem.timestamp) + "] " +
          aItem.clipboardText;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_626484_output_copy_order.js b/browser/devtools/webconsole/test/browser_webconsole_bug_626484_output_copy_order.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_626484_output_copy_order.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_626484_output_copy_order.js
@@ -53,17 +53,17 @@ function nextTest() {
   }
 }
 
 function getExpectedClipboardText(aItemCount) {
   let expectedClipboardText = [];
   for (let i = 0; i < aItemCount; i++) {
     let item = outputNode.getItemAtIndex(i);
     expectedClipboardText.push("[" +
-      WebConsoleUtils.l10n.timestampString(item.timestamp) + "] " +
+      WCU_l10n.timestampString(item.timestamp) + "] " +
       item.clipboardText);
   }
   return expectedClipboardText.join("\n");
 }
 
 function clipboardSetup() {
   goDoCommand("cmd_copy");
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js b/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
@@ -10,17 +10,17 @@ function test() {
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
     openConsole(null, consoleOpened);
   }, true);
 }
 
 function consoleOpened(HUD) {
   let tmp = {};
-  Cu.import("resource:///modules/WebConsoleUtils.jsm", tmp);
+  Cu.import("resource://gre/modules/devtools/WebConsoleUtils.jsm", tmp);
   let WCU = tmp.WebConsoleUtils;
   let JSPropertyProvider = tmp.JSPropertyProvider;
   tmp = null;
 
   let jsterm = HUD.jsterm;
   let win = content.wrappedJSObject;
 
   // Make sure autocomplete does not walk through iterators and generators.
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js b/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
@@ -18,17 +18,17 @@ var gHUD;
 
 function consoleOpened(aHud) {
   gHUD = aHud;
   let jsterm = gHUD.jsterm;
   let popup = jsterm.autocompletePopup;
   let completeNode = jsterm.completeNode;
 
   let tmp = {};
-  Cu.import("resource:///modules/WebConsoleUtils.jsm", tmp);
+  Cu.import("resource://gre/modules/devtools/WebConsoleUtils.jsm", tmp);
   let WCU = tmp.WebConsoleUtils;
   tmp = null;
 
   ok(!popup.isOpen, "popup is not open");
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_chrome.js b/browser/devtools/webconsole/test/browser_webconsole_chrome.js
--- a/browser/devtools/webconsole/test/browser_webconsole_chrome.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_chrome.js
@@ -1,26 +1,26 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that code completion works properly.
 
 function test() {
-  addTab("about:addons");
+  addTab("about:credits");
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
     openConsole(null, testChrome);
   }, true);
 }
 
 function testChrome(hud) {
   ok(hud, "we have a console");
-  
+
   ok(hud.iframe, "we have the console iframe");
 
   let jsterm = hud.jsterm;
   ok(jsterm, "we have a jsterm");
 
   let input = jsterm.inputNode;
   ok(hud.outputNode, "we have an output node");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_copying_multiple_messages_inserts_newlines_in_between.js b/browser/devtools/webconsole/test/browser_webconsole_copying_multiple_messages_inserts_newlines_in_between.js
--- a/browser/devtools/webconsole/test/browser_webconsole_copying_multiple_messages_inserts_newlines_in_between.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_copying_multiple_messages_inserts_newlines_in_between.js
@@ -47,17 +47,17 @@ function testClipboard() {
 
   outputNode.selectAll();
   outputNode.focus();
 
   let clipboardTexts = [];
   for (let i = 0; i < outputNode.itemCount; i++) {
     let item = outputNode.getItemAtIndex(i);
     clipboardTexts.push("[" +
-                        WebConsoleUtils.l10n.timestampString(item.timestamp) +
+                        WCU_l10n.timestampString(item.timestamp) +
                         "] " + item.clipboardText);
   }
 
   waitForClipboard(clipboardTexts.join("\n"),
                    function() { goDoCommand("cmd_copy"); },
                    finishTest, finishTest);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_network_panel.js b/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
--- a/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
@@ -59,21 +59,16 @@ function checkNodeKeyValue(aPanel, aId, 
 
   ok(false, "content check failed for " + aId + ", key " + aKey);
 }
 
 function testGen() {
   let hud = HUDService.getHudByWindow(content);
   let filterBox = hud.ui.filterBox;
 
-  let tempScope  = {};
-  Cu.import("resource:///modules/WebConsoleUtils.jsm", tempScope);
-  let l10n = tempScope.WebConsoleUtils.l10n;
-  tempScope = null;
-
   let httpActivity = {
     meta: {
       stages: [],
       discardRequestBody: true,
       discardResponseBody: true,
     },
     log: {
       entries: [{
@@ -437,17 +432,17 @@ function testGen() {
     responseBodyCached: false,
     responseBodyUnknownType: true,
     responseNoBody: false,
     responseImage: false,
     responseImageCached: false
   });
 
   let responseString =
-    l10n.getFormatStr("NetworkPanel.responseBodyUnableToDisplay.content",
+    WCU_l10n.getFormatStr("NetworkPanel.responseBodyUnableToDisplay.content",
                       ["application/x-shockwave-flash"]);
   checkNodeContent(networkPanel, "responseBodyUnknownTypeContent", responseString);
   networkPanel.panel.hidePopup();
 
   /*
 
   // This test disabled. See bug 603620.
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_property_provider.js b/browser/devtools/webconsole/test/browser_webconsole_property_provider.js
--- a/browser/devtools/webconsole/test/browser_webconsole_property_provider.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_property_provider.js
@@ -12,17 +12,17 @@ function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", testPropertyProvider, true);
 }
 
 function testPropertyProvider() {
   browser.removeEventListener("load", testPropertyProvider, true);
 
   let tmp = {};
-  Cu.import("resource:///modules/WebConsoleUtils.jsm", tmp);
+  Cu.import("resource://gre/modules/devtools/WebConsoleUtils.jsm", tmp);
   let JSPropertyProvider = tmp.JSPropertyProvider;
   tmp = null;
 
   let completion = JSPropertyProvider(content, "thisIsNotDefined");
   is (completion.matches.length, 0, "no match for 'thisIsNotDefined");
 
   // This is a case the PropertyProvider can't handle. Should return null.
   completion = JSPropertyProvider(content, "window[1].acb");
diff --git a/browser/devtools/webconsole/test/head.js b/browser/devtools/webconsole/test/head.js
--- a/browser/devtools/webconsole/test/head.js
+++ b/browser/devtools/webconsole/test/head.js
@@ -1,18 +1,20 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 let tempScope = {};
 Cu.import("resource:///modules/HUDService.jsm", tempScope);
 let HUDService = tempScope.HUDService;
-Cu.import("resource:///modules/WebConsoleUtils.jsm", tempScope);
+Cu.import("resource://gre/modules/devtools/WebConsoleUtils.jsm", tempScope);
 let WebConsoleUtils = tempScope.WebConsoleUtils;
+const WEBCONSOLE_STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
+let WCU_l10n = new WebConsoleUtils.l10n(WEBCONSOLE_STRINGS_URI);
 
 function log(aMsg)
 {
   dump("*** WebConsoleTest: " + aMsg + "\n");
 }
 
 function pprint(aObj)
 {
@@ -247,17 +249,17 @@ function finishTest()
 }
 
 function tearDown()
 {
   HUDService.deactivateHUDForContext(gBrowser.selectedTab);
   while (gBrowser.tabs.length > 1) {
     gBrowser.removeCurrentTab();
   }
-  tab = browser = hudId = hud = filterBox = outputNode = cs = null;
+  WCU_l10n = tab = browser = hudId = hud = filterBox = outputNode = cs = null;
 }
 
 registerCleanupFunction(tearDown);
 
 waitForExplicitFinish();
 
 /**
  * Polls a given function waiting for it to become true.
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -10,16 +10,22 @@ const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Services",
                                   "resource://gre/modules/Services.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "DebuggerServer",
+                                  "resource://gre/modules/devtools/dbg-server.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "DebuggerClient",
+                                  "resource://gre/modules/devtools/dbg-client.jsm");
+
 XPCOMUtils.defineLazyServiceGetter(this, "clipboardHelper",
                                    "@mozilla.org/widget/clipboardhelper;1",
                                    "nsIClipboardHelper");
 
 XPCOMUtils.defineLazyModuleGetter(this, "PropertyPanel",
                                   "resource:///modules/PropertyPanel.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "PropertyTreeView",
@@ -27,21 +33,20 @@ XPCOMUtils.defineLazyModuleGetter(this, 
 
 XPCOMUtils.defineLazyModuleGetter(this, "NetworkPanel",
                                   "resource:///modules/NetworkPanel.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "AutocompletePopup",
                                   "resource:///modules/AutocompletePopup.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
-                                  "resource:///modules/WebConsoleUtils.jsm");
-
-XPCOMUtils.defineLazyGetter(this, "l10n", function() {
-  return WebConsoleUtils.l10n;
-});
+                                  "resource://gre/modules/devtools/WebConsoleUtils.jsm");
+
+const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
+let l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 
 
 // The XUL namespace.
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 const MIXED_CONTENT_LEARN_MORE = "https://developer.mozilla.org/en/Security/MixedContent";
 
 // The amount of time in milliseconds that must pass between messages to
@@ -182,27 +187,46 @@ function WebConsoleFrame(aWebConsoleOwne
   this._onPositionConsoleCommand = this._onPositionConsoleCommand.bind(this);
 
   this._initDefaultFilterPrefs();
   this._commandController = new CommandController(this);
   this.positionConsole(aPosition, window);
 
   this.jsterm = new JSTerm(this);
   this.jsterm.inputNode.focus();
+
+  this._initConnection();
 }
 
 WebConsoleFrame.prototype = {
   /**
    * The WebConsole instance that owns this frame.
    * @see HUDService.jsm::WebConsole
    * @type object
    */
   owner: null,
 
   /**
+   * Proxy between the Web Console and the remote Web Console instance. This
+   * object holds methods used for connecting, listening and disconnecting from
+   * the remote server, using the remote debugging protocol.
+   *
+   * @see WebConsoleConnectionProxy
+   * @type object
+   */
+  proxy: null,
+
+  /**
+   * Tells if the Web Console initialization via message manager completed.
+   * @private
+   * @type boolean
+   */
+  _messageManagerInitComplete: false,
+
+  /**
    * Getter for the xul:popupset that holds any popups we open.
    * @type nsIDOMElement
    */
   get popupset() this.owner.mainPopupSet,
 
   /**
    * Holds the network requests currently displayed by the Web Console. Each key
    * represents the connection ID and the value is network request information.
@@ -307,16 +331,31 @@ WebConsoleFrame.prototype = {
           this._saveRequestAndResponseBodies,
       },
     };
 
     this.owner.sendMessageToContent("WebConsole:SetPreferences", message);
   },
 
   /**
+   * Connect to the server using the remote debugging protocol.
+   * @private
+   */
+  _initConnection: function WCF__initConnection()
+  {
+    this.proxy = new WebConsoleConnectionProxy(this);
+    this.proxy.initServer();
+    this.proxy.connect(function() {
+      if (this._messageManagerInitComplete) {
+        this._onInitComplete();
+      }
+    }.bind(this));
+  },
+
+  /**
    * Find the Web Console UI elements and setup event listeners as needed.
    * @private
    */
   _initUI: function WCF__initUI()
   {
     let doc = this.document;
 
     this.filterBox = doc.querySelector(".hud-filter-box");
@@ -482,16 +521,29 @@ WebConsoleFrame.prototype = {
         someChecked = someChecked || checked;
       }, this);
 
       aButton.setAttribute("checked", someChecked);
     }, this);
   },
 
   /**
+   * Callback method for when the Web Console initialization is complete. For
+   * now this method sends the web-console-created notification using the
+   * nsIObserverService.
+   *
+   * @private
+   */
+  _onInitComplete: function WC__onInitComplete()
+  {
+    let id = WebConsoleUtils.supportsString(this.hudId);
+    Services.obs.notifyObservers(id, "web-console-created", null);
+  },
+
+  /**
    * Handle the "command" event for the buttons that allow the user to
    * reposition the Web Console UI.
    *
    * @private
    * @param nsIDOMEvent aEvent
    */
   _onPositionConsoleCommand: function WCF__onPositionConsoleCommand(aEvent)
   {
@@ -615,26 +667,21 @@ WebConsoleFrame.prototype = {
         break;
       case "JSTerm:InspectObject":
         this.jsterm.handleInspectObject(aMessage.json);
         break;
       case "WebConsole:ConsoleAPI":
         this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
                            [aMessage.json]);
         break;
-      case "WebConsole:PageError": {
-        let pageError = aMessage.json.pageError;
-        let category = Utils.categoryForScriptError(pageError);
-        this.outputMessage(category, this.reportPageError,
-                           [category, pageError]);
+      case "WebConsole:Initialized":
+        this._onMessageManagerInitComplete();
         break;
-      }
       case "WebConsole:CachedMessages":
         this._displayCachedConsoleMessages(aMessage.json.messages);
-        this.owner._onInitComplete();
         break;
       case "WebConsole:NetworkActivity":
         this.handleNetworkActivity(aMessage.json);
         break;
       case "WebConsole:FileActivity":
         this.outputMessage(CATEGORY_NETWORK, this.logFileActivity,
                            [aMessage.json.uri]);
         break;
@@ -643,16 +690,30 @@ WebConsoleFrame.prototype = {
         break;
       case "JSTerm:NonNativeConsoleAPI":
         this.outputMessage(CATEGORY_JS, this.logWarningAboutReplacedAPI);
         break;
     }
   },
 
   /**
+   * Callback method used to track the Web Console initialization via message
+   * manager.
+   *
+   * @private
+   */
+  _onMessageManagerInitComplete: function WCF__onMessageManagerInitComplete()
+  {
+    this._messageManagerInitComplete = true;
+    if (this.proxy.connected) {
+      this._onInitComplete();
+    }
+  },
+
+  /**
    * The event handler that is called whenever a user switches a filter on or
    * off.
    *
    * @private
    * @param nsIDOMEvent aEvent
    *        The event that triggered the filter change.
    */
   _toggleFilter: function WCF__toggleFilter(aEvent)
@@ -1221,30 +1282,42 @@ WebConsoleFrame.prototype = {
    * @return nsIDOMElement|undefined
    *         The message element to display in the Web Console output.
    */
   reportPageError: function WCF_reportPageError(aCategory, aScriptError)
   {
     // Warnings and legacy strict errors become warnings; other types become
     // errors.
     let severity = SEVERITY_ERROR;
-    if ((aScriptError.flags & aScriptError.warningFlag) ||
-        (aScriptError.flags & aScriptError.strictFlag)) {
+    if (aScriptError.warning || aScriptError.strict) {
       severity = SEVERITY_WARNING;
     }
 
     let node = this.createMessageNode(aCategory, severity,
                                       aScriptError.errorMessage,
                                       aScriptError.sourceName,
                                       aScriptError.lineNumber, null, null,
                                       aScriptError.timeStamp);
     return node;
   },
 
   /**
+   * Handle PageError objects received from the server. This method outputs the
+   * given error.
+   *
+   * @param nsIScriptError aPageError
+   *        The error received from the server.
+   */
+  handlePageError: function WCF_handlePageError(aPageError)
+  {
+    let category = Utils.categoryForScriptError(aPageError);
+    this.outputMessage(category, this.reportPageError, [category, aPageError]);
+  },
+
+  /**
    * Log network activity.
    *
    * @param object aHttpActivity
    *        The HTTP activity to log.
    * @return nsIDOMElement|undefined
    *         The message element to display in the Web Console output.
    */
   logNetActivity: function WCF_logNetActivity(aConnectionId)
@@ -2332,19 +2405,27 @@ WebConsoleFrame.prototype = {
     }
 
     this.owner.openLink(item.url);
   },
 
   /**
    * Destroy the HUD object. Call this method to avoid memory leaks when the Web
    * Console is closed.
+   *
+   * @param function [aOnDestroy]
+   *        Optional function to invoke when the Web Console instance is
+   *        destroyed.
    */
-  destroy: function WCF_destroy()
+  destroy: function WCF_destroy(aOnDestroy)
   {
+    if (this.proxy) {
+      this.proxy.disconnect(aOnDestroy);
+    }
+
     if (this.jsterm) {
       this.jsterm.destroy();
     }
   },
 };
 
 /**
  * Create a JSTerminal (a JavaScript command line). This is attached to an
@@ -3530,16 +3611,168 @@ CommandController.prototype = {
         break;
       case "cmd_fontSizeReset":
         this.owner.changeFontSize("");
         break;
     }
   }
 };
 
+///////////////////////////////////////////////////////////////////////////////
+// Web Console connection proxy
+///////////////////////////////////////////////////////////////////////////////
+
+/**
+ * The WebConsoleConnectionProxy handles the connection between the Web Console
+ * and the application we connect to through the remote debug protocol.
+ *
+ * @constructor
+ * @param object aWebConsole
+ *        The Web Console instance that owns this connection proxy.
+ */
+function WebConsoleConnectionProxy(aWebConsole)
+{
+  this.owner = aWebConsole;
+
+  this._onPageError = this._onPageError.bind(this);
+}
+
+WebConsoleConnectionProxy.prototype = {
+  /**
+   * The owning Web Console instance.
+   *
+   * @see WebConsoleFrame
+   * @type object
+   */
+  owner: null,
+
+  /**
+   * The DebuggerClient object.
+   *
+   * @see DebuggerClient
+   * @type object
+   */
+  client: null,
+
+  /**
+   * Tells if the connection is established.
+   * @type boolean
+   */
+  connected: false,
+
+  /**
+   * The WebConsoleActor ID.
+   *
+   * @private
+   * @type string
+   */
+  _consoleActor: null,
+
+  /**
+   * Initialize the debugger server.
+   */
+  initServer: function WCCP_initServer()
+  {
+    if (!DebuggerServer.initialized) {
+      DebuggerServer.init();
+      DebuggerServer.addBrowserActors();
+    }
+  },
+
+  /**
+   * Initialize a debugger client and connect it to the debugger server.
+   *
+   * @param function [aCallback]
+   *        Optional function to invoke when connection is established.
+   */
+  connect: function WCCP_connect(aCallback)
+  {
+    let transport = DebuggerServer.connectPipe();
+    let client = this.client = new DebuggerClient(transport);
+
+    client.addListener("pageError", this._onPageError);
+
+    let listeners = ["PageError"];
+
+    client.connect(function(aType, aTraits) {
+      client.listTabs(function(aResponse) {
+        let tab = aResponse.tabs[aResponse.selected];
+        this._consoleActor = tab.consoleActor;
+        client.attachConsole(tab.consoleActor, listeners,
+                             this._onAttachConsole.bind(this, aCallback));
+      }.bind(this));
+    }.bind(this));
+  },
+
+  /**
+   * The "attachConsole" response handler.
+   *
+   * @private
+   * @param function [aCallback]
+   *        Optional function to invoke once the connection is established.
+   * @param object aResponse
+   *        The JSON response object received from the server.
+   * @param object aWebConsoleClient
+   *        The WebConsoleClient instance for the attached console, for the
+   *        specific tab we work with.
+   */
+  _onAttachConsole:
+  function WCCP__onAttachConsole(aCallback, aResponse, aWebConsoleClient)
+  {
+    if (aResponse.error) {
+      Cu.reportError("attachConsole failed: " + aResponse.error + " " +
+                     aResponse.message);
+      return;
+    }
+
+    this.webConsoleClient = aWebConsoleClient;
+
+    this.connected = true;
+    aCallback && aCallback();
+  },
+
+  /**
+   * The "pageError" message type handler. We redirect any page errors to the UI
+   * for displaying.
+   *
+   * @private
+   * @param string aType
+   *        Message type.
+   * @param object aPacket
+   *        The message received from the server.
+   */
+  _onPageError: function WCCP__onPageError(aType, aPacket)
+  {
+    if (this.owner && aPacket.from == this._consoleActor) {
+      this.owner.handlePageError(aPacket.pageError);
+    }
+  },
+
+  /**
+   * Disconnect the Web Console from the remote server.
+   *
+   * @param function [aOnDisconnect]
+   *        Optional function to invoke when the connection is dropped.
+   */
+  disconnect: function WCCP_disconnect(aOnDisconnect)
+  {
+    if (!this.client) {
+      aOnDisconnect && aOnDisconnect();
+      return;
+    }
+
+    this.client.removeListener("pageError", this._onPageError);
+    this.client.close(aOnDisconnect);
+
+    this.client = null;
+    this.webConsoleClient = null;
+    this.connected = false;
+  },
+};
+
 function gSequenceId()
 {
   return gSequenceId.n++;
 }
 gSequenceId.n = 0;
 
 
 function goUpdateConsoleCommands() {
diff --git a/toolkit/devtools/Makefile.in b/toolkit/devtools/Makefile.in
--- a/toolkit/devtools/Makefile.in
+++ b/toolkit/devtools/Makefile.in
@@ -7,14 +7,15 @@ topsrcdir = @top_srcdir@
 srcdir    = @srcdir@
 VPATH     = @srcdir@
 
 include $(topsrcdir)/config/config.mk
 
 PARALLEL_DIRS += \
   debugger \
   sourcemap \
+  webconsole \
   $(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
 libs::
 	$(NSINSTALL) $(srcdir)/*.jsm $(FINAL_TARGET)/modules/devtools
diff --git a/toolkit/devtools/debugger/dbg-client.jsm b/toolkit/devtools/debugger/dbg-client.jsm
--- a/toolkit/devtools/debugger/dbg-client.jsm
+++ b/toolkit/devtools/debugger/dbg-client.jsm
@@ -17,16 +17,19 @@ var EXPORTED_SYMBOLS = ["DebuggerTranspo
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/NetUtil.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "socketTransportService",
                                    "@mozilla.org/network/socket-transport-service;1",
                                    "nsISocketTransportService");
 
+XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleClient",
+                                  "resource://gre/modules/devtools/WebConsoleClient.jsm");
+
 let wantLogging = Services.prefs.getBoolPref("devtools.debugger.log");
 
 function dumpn(str)
 {
   if (wantLogging) {
     dump("DBG-CLIENT: " + str + "\n");
   }
 }
@@ -162,16 +165,17 @@ const ThreadStateTypes = {
 /**
  * Set of protocol messages that are sent by the server without a prior request
  * by the client.
  */
 const UnsolicitedNotifications = {
   "newScript": "newScript",
   "tabDetached": "tabDetached",
   "tabNavigated": "tabNavigated",
+  "pageError": "pageError",
   "profilerStateChanged": "profilerStateChanged"
 };
 
 /**
  * Set of pause types that are sent by the server and not as an immediate
  * response to a client request.
  */
 const UnsolicitedPauses = {
@@ -189,16 +193,17 @@ const ROOT_ACTOR_NAME = "root";
  * required by the protocol in a traditional JavaScript API.
  */
 function DebuggerClient(aTransport)
 {
   this._transport = aTransport;
   this._transport.hooks = this;
   this._threadClients = {};
   this._tabClients = {};
+  this._consoleClients = {};
 
   this._pendingRequests = [];
   this._activeRequests = {};
   this._eventsEnabled = true;
 }
 
 DebuggerClient.prototype = {
   /**
@@ -244,20 +249,42 @@ DebuggerClient.prototype = {
     let detachTab = function _detachTab() {
       if (this.activeTab) {
         this.activeTab.detach(closeTransport);
       } else {
         closeTransport();
       }
     }.bind(this);
 
-    if (this.activeThread) {
-      this.activeThread.detach(detachTab);
-    } else {
-      detachTab();
+    let detachThread = function _detachThread() {
+      if (this.activeThread) {
+        this.activeThread.detach(detachTab);
+      } else {
+        detachTab();
+      }
+    }.bind(this);
+
+    let consolesClosed = 0;
+    let consolesToClose = 0;
+
+    let onConsoleClose = function _onConsoleClose() {
+      consolesClosed++;
+      if (consolesClosed >= consolesToClose) {
+        this._consoleClients = {};
+        detachThread();
+      }
+    }.bind(this);
+
+    for each (let client in this._consoleClients) {
+      consolesToClose++;
+      client.close(onConsoleClose);
+    }
+
+    if (!consolesToClose) {
+      detachThread();
     }
   },
 
   /**
    * List the open tabs.
    *
    * @param function aOnResponse
    *        Called with the response packet.
@@ -277,26 +304,57 @@ DebuggerClient.prototype = {
    * @param function aOnResponse
    *        Called with the response packet and a TabClient
    *        (which will be undefined on error).
    */
   attachTab: function DC_attachTab(aTabActor, aOnResponse) {
     let self = this;
     let packet = { to: aTabActor, type: "attach" };
     this.request(packet, function(aResponse) {
+      let tabClient;
       if (!aResponse.error) {
-        var tabClient = new TabClient(self, aTabActor);
+        tabClient = new TabClient(self, aTabActor);
         self._tabClients[aTabActor] = tabClient;
         self.activeTab = tabClient;
       }
       aOnResponse(aResponse, tabClient);
     });
   },
 
   /**
+   * Attach to a Web Console actor.
+   *
+   * @param string aConsoleActor
+   *        The ID for the console actor to attach to.
+   * @param array aListeners
+   *        The console listeners you want to start.
+   * @param function aOnResponse
+   *        Called with the response packet and a WebConsoleClient
+   *        instance (which will be undefined on error).
+   */
+  attachConsole:
+  function DC_attachConsole(aConsoleActor, aListeners, aOnResponse) {
+    let self = this;
+    let packet = {
+      to: aConsoleActor,
+      type: "startListeners",
+      listeners: aListeners,
+    };
+
+    this.request(packet, function(aResponse) {
+      let consoleClient;
+      if (!aResponse.error) {
+        consoleClient = new WebConsoleClient(self, aConsoleActor);
+        self._consoleClients[aConsoleActor] = consoleClient;
+      }
+      aOnResponse(aResponse, consoleClient);
+    });
+  },
+
+  /**
    * Attach to a thread actor.
    *
    * @param string aThreadActor
    *        The actor ID for the thread to attach.
    * @param function aOnResponse
    *        Called with the response packet and a ThreadClient
    *        (which will be undefined on error).
    */
diff --git a/toolkit/devtools/debugger/server/dbg-server.js b/toolkit/devtools/debugger/server/dbg-server.js
--- a/toolkit/devtools/debugger/server/dbg-server.js
+++ b/toolkit/devtools/debugger/server/dbg-server.js
@@ -178,16 +178,18 @@ var DebuggerServer = {
     loadSubScript.call(this, aURL);
   },
 
   /**
    * Install Firefox-specific actors.
    */
   addBrowserActors: function DH_addBrowserActors() {
     this.addActors("chrome://global/content/devtools/dbg-browser-actors.js");
+    this.addActors("chrome://global/content/devtools/dbg-webconsole-actors.js");
+    this.addTabActor(this.WebConsoleActor, "consoleActor");
     if ("nsIProfiler" in Ci)
       this.addActors("chrome://global/content/devtools/dbg-profiler-actors.js");
   },
 
   /**
    * Listens on the given port for remote debugger connections.
    *
    * @param aPort int
diff --git a/toolkit/devtools/jar.mn b/toolkit/devtools/jar.mn
--- a/toolkit/devtools/jar.mn
+++ b/toolkit/devtools/jar.mn
@@ -2,9 +2,10 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 toolkit.jar:
   content/global/devtools/dbg-transport.js        (debugger/dbg-transport.js)
   content/global/devtools/dbg-server.js        		(debugger/server/dbg-server.js)
   content/global/devtools/dbg-script-actors.js    (debugger/server/dbg-script-actors.js)
   content/global/devtools/dbg-browser-actors.js   (debugger/server/dbg-browser-actors.js)
+  content/global/devtools/dbg-webconsole-actors.js (webconsole/dbg-webconsole-actors.js)
   content/global/devtools/dbg-profiler-actors.js  (debugger/server/dbg-profiler-actors.js)
diff --git a/toolkit/devtools/webconsole/Makefile.in b/toolkit/devtools/webconsole/Makefile.in
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/webconsole/Makefile.in
@@ -0,0 +1,17 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DEPTH = ../../..
+topsrcdir = @top_srcdir@
+srcdir = @srcdir@
+VPATH = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+#TEST_DIRS += tests
+
+include $(topsrcdir)/config/rules.mk
+
+libs::
+	$(INSTALL) $(IFLAGS1) $(srcdir)/*.jsm $(FINAL_TARGET)/modules/devtools
diff --git a/toolkit/devtools/webconsole/WebConsoleClient.jsm b/toolkit/devtools/webconsole/WebConsoleClient.jsm
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/webconsole/WebConsoleClient.jsm
@@ -0,0 +1,103 @@
+/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cu = Components.utils;
+
+var EXPORTED_SYMBOLS = ["WebConsoleClient"];
+
+/**
+ * A WebConsoleClient is used as a front end for the WebConsoleActor that is
+ * created on the server, hiding implementation details.
+ *
+ * @param object aDebuggerClient
+ *        The DebuggerClient instance we live for.
+ * @param string aActor
+ *        The WebConsoleActor ID.
+ */
+function WebConsoleClient(aDebuggerClient, aActor)
+{
+  this._actor = aActor;
+  this._client = aDebuggerClient;
+}
+
+WebConsoleClient.prototype = {
+  /**
+   * Retrieve the cached messages from the server.
+   *
+   * @see this.CACHED_MESSAGES
+   * @param array aTypes
+   *        The array of message types you want from the server. See
+   *        this.CACHED_MESSAGES for known types.
+   * @param function aOnResponse
+   *        The function invoked when the response is received.
+   */
+  getCachedMessages: function WCC_getCachedMessages(aTypes, aOnResponse)
+  {
+    let packet = {
+      to: this._actor,
+      type: "getCachedMessages",
+      messageTypes: aTypes,
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Start the given Web Console listeners.
+   *
+   * @see this.LISTENERS
+   * @param array aListeners
+   *        Array of listeners you want to start. See this.LISTENERS for
+   *        known listeners.
+   * @param function aOnResponse
+   *        Function to invoke when the server response is received.
+   */
+  startListeners: function WCC_startListeners(aListeners, aOnResponse)
+  {
+    let packet = {
+      to: this._actor,
+      type: "startListeners",
+      listeners: aListeners,
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Stop the given Web Console listeners.
+   *
+   * @see this.LISTENERS
+   * @param array aListeners
+   *        Array of listeners you want to stop. See this.LISTENERS for
+   *        known listeners.
+   * @param function aOnResponse
+   *        Function to invoke when the server response is received.
+   */
+  stopListeners: function WCC_stopListeners(aListeners, aOnResponse)
+  {
+    let packet = {
+      to: this._actor,
+      type: "stopListeners",
+      listeners: aListeners,
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Close the WebConsoleClient. This stops all the listeners on the server and
+   * detaches from the console actor.
+   *
+   * @param function aOnResponse
+   *        Function to invoke when the server response is received.
+   */
+  close: function WCC_close(aOnResponse)
+  {
+    this.stopListeners(null, aOnResponse);
+    this._client = null;
+  },
+};
diff --git a/browser/devtools/webconsole/WebConsoleUtils.jsm b/toolkit/devtools/webconsole/WebConsoleUtils.jsm
rename from browser/devtools/webconsole/WebConsoleUtils.jsm
rename to toolkit/devtools/webconsole/WebConsoleUtils.jsm
--- a/browser/devtools/webconsole/WebConsoleUtils.jsm
+++ b/toolkit/devtools/webconsole/WebConsoleUtils.jsm
@@ -10,19 +10,18 @@ const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Services",
                                   "resource://gre/modules/Services.jsm");
 
-var EXPORTED_SYMBOLS = ["WebConsoleUtils", "JSPropertyProvider"];
-
-const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
+var EXPORTED_SYMBOLS = ["WebConsoleUtils", "JSPropertyProvider",
+                        "PageErrorListener"];
 
 const TYPES = { OBJECT: 0,
                 FUNCTION: 1,
                 ARRAY: 2,
                 OTHER: 3,
                 ITERATOR: 4,
                 GETTER: 5,
                 GENERATOR: 6,
@@ -640,17 +639,32 @@ var WebConsoleUtils = {
     }
   },
 };
 
 //////////////////////////////////////////////////////////////////////////
 // Localization
 //////////////////////////////////////////////////////////////////////////
 
-WebConsoleUtils.l10n = {
+WebConsoleUtils.l10n = function WCU_l10n(aBundleURI)
+{
+  this._bundleUri = aBundleURI;
+};
+
+WebConsoleUtils.l10n.prototype = {
+  _stringBundle: null,
+
+  get stringBundle()
+  {
+    if (!this._stringBundle) {
+      this._stringBundle = Services.strings.createBundle(this._bundleUri);
+    }
+    return this._stringBundle;
+  },
+
   /**
    * Generates a formatted timestamp string for displaying in console messages.
    *
    * @param integer [aMilliseconds]
    *        Optional, allows you to specify the timestamp in milliseconds since
    *        the UNIX epoch.
    * @return string
    *         The timestamp formatted for display.
@@ -705,20 +719,16 @@ WebConsoleUtils.l10n = {
     catch (ex) {
       Cu.reportError("Failed to format string: " + aName);
       throw ex;
     }
     return result;
   },
 };
 
-XPCOMUtils.defineLazyGetter(WebConsoleUtils.l10n, "stringBundle", function() {
-  return Services.strings.createBundle(STRINGS_URI);
-});
-
 
 //////////////////////////////////////////////////////////////////////////
 // JS Completer
 //////////////////////////////////////////////////////////////////////////
 
 var JSPropertyProvider = (function _JSPP(WCU) {
 const STATE_NORMAL = 0;
 const STATE_QUOTE = 2;
@@ -1007,8 +1017,149 @@ function getMatchedProps(aObj, aOptions 
   }
 
   return names;
 }
 
 
 return JSPropertyProvider;
 })(WebConsoleUtils);
+
+///////////////////////////////////////////////////////////////////////////////
+// The page errors listener
+///////////////////////////////////////////////////////////////////////////////
+
+/**
+ * The nsIConsoleService listener. This is used to send all the page errors
+ * (JavaScript, CSS and more) to the remote Web Console instance.
+ *
+ * @constructor
+ * @param nsIDOMWindow aWindow
+ *        The window object for which we are created.
+ * @param object aListener
+ *        The listener object must have a method: onPageError. This method is
+ *        invoked with one argument, the nsIScriptError, whenever a relevant
+ *        page error is received.
+ */
+function PageErrorListener(aWindow, aListener)
+{
+  this.window = aWindow;
+  this.listener = aListener;
+}
+
+PageErrorListener.prototype =
+{
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIConsoleListener]),
+
+  /**
+   * The content window for which we listen to page errors.
+   * @type nsIDOMWindow
+   */
+  window: null,
+
+  /**
+   * The listener object which is notified of page errors. It must have
+   * a onPageError method which is invoked with one argument: the nsIScriptError.
+   * @type object
+   */
+  listener: null,
+
+  /**
+   * Initialize the nsIConsoleService listener.
+   */
+  init: function PEL_init()
+  {
+    Services.console.registerListener(this);
+  },
+
+  /**
+   * The nsIConsoleService observer. This method takes all the script error
+   * messages belonging to the current window and sends them to the remote Web
+   * Console instance.
+   *
+   * @param nsIScriptError aScriptError
+   *        The script error object coming from the nsIConsoleService.
+   */
+  observe: function PEL_observe(aScriptError)
+  {
+    if (!this.window || !this.listener ||
+        !(aScriptError instanceof Ci.nsIScriptError) ||
+        !aScriptError.outerWindowID) {
+      return;
+    }
+
+    if (!this.isCategoryAllowed(aScriptError.category)) {
+      return;
+    }
+
+    let errorWindow =
+      WebConsoleUtils.getWindowByOuterId(aScriptError.outerWindowID, this.window);
+    if (!errorWindow || errorWindow.top != this.window) {
+      return;
+    }
+
+    this.listener.onPageError(aScriptError);
+  },
+
+  /**
+   * Check if the given script error category is allowed to be tracked or not.
+   * We ignore chrome-originating errors as we only care about content.
+   *
+   * @param string aCategory
+   *        The nsIScriptError category you want to check.
+   * @return boolean
+   *         True if the category is allowed to be logged, false otherwise.
+   */
+  isCategoryAllowed: function PEL_isCategoryAllowed(aCategory)
+  {
+    switch (aCategory) {
+      case "XPConnect JavaScript":
+      case "component javascript":
+      case "chrome javascript":
+      case "chrome registration":
+      case "XBL":
+      case "XBL Prototype Handler":
+      case "XBL Content Sink":
+      case "xbl javascript":
+        return false;
+    }
+
+    return true;
+  },
+
+  /**
+   * Get the cached page errors for the current inner window.
+   *
+   * @return array
+   *         The array of cached messages. Each element is an nsIScriptError
+   *         with an added _type property so the remote Web Console instance can
+   *         tell the difference between various types of cached messages.
+   */
+  getCachedMessages: function PEL_getCachedMessages()
+  {
+    let innerWindowId = WebConsoleUtils.getInnerWindowId(this.window);
+    let result = [];
+    let errors = {};
+    Services.console.getMessageArray(errors, {});
+
+    (errors.value || []).forEach(function(aError) {
+      if (!(aError instanceof Ci.nsIScriptError) ||
+          aError.innerWindowID != innerWindowId ||
+          !this.isCategoryAllowed(aError.category)) {
+        return;
+      }
+
+      let remoteMessage = WebConsoleUtils.cloneObject(aError);
+      result.push(remoteMessage);
+    }, this);
+
+    return result;
+  },
+
+  /**
+   * Remove the nsIConsoleService listener.
+   */
+  destroy: function PEL_destroy()
+  {
+    Services.console.unregisterListener(this);
+    this.listener = this.window = null;
+  },
+};
diff --git a/toolkit/devtools/webconsole/dbg-webconsole-actors.js b/toolkit/devtools/webconsole/dbg-webconsole-actors.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/webconsole/dbg-webconsole-actors.js
@@ -0,0 +1,193 @@
+/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+let Cc = Components.classes;
+let Ci = Components.interfaces;
+let Cu = Components.utils;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "Services",
+                                  "resource://gre/modules/Services.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "PageErrorListener",
+                                  "resource://gre/modules/devtools/WebConsoleUtils.jsm");
+
+/**
+ * The WebConsoleActor implements capabilities needed for the Web Console
+ * feature.
+ *
+ * @constructor
+ * @param object aConnection
+ *        The connection to the client, DebuggerServerConnection.
+ * @param object aTabActor
+ *        The parent tab actor.
+ */
+function WebConsoleActor(aConnection, aTabActor)
+{
+  this.conn = aConnection;
+  this._browser = aTabActor.browser;
+}
+
+WebConsoleActor.prototype =
+{
+  /**
+   * The xul:browser we work with.
+   * @private
+   * @type nsIDOMElement
+   */
+  _browser: null,
+
+  /**
+   * The debugger server connection instance.
+   * @type object
+   */
+  conn: null,
+
+  /**
+   * The content window we work with.
+   * @type nsIDOMWindow
+   */
+  get window() this._browser.contentWindow,
+
+  /**
+   * The PageErrorListener instance.
+   * @type object
+   */
+  pageErrorListener: null,
+
+  actorPrefix: "console",
+
+  grip: function WCA_grip()
+  {
+    return { actor: this.actorID };
+  },
+
+  /**
+   * Destroy the current WebConsoleActor instance.
+   */
+  disconnect: function WCA_disconnect()
+  {
+    if (this.pageErrorListener) {
+      this.pageErrorListener.destroy();
+      this.pageErrorListener = null;
+    }
+    this.conn = this._browser = null;
+  },
+
+  /**
+   * Handler for the "startListeners" request.
+   *
+   * @param object aRequest
+   *        The JSON request object received from the Web Console client.
+   * @return object
+   *         The response object which holds the startedListeners array.
+   */
+  onStartListeners: function WCA_onStartListeners(aRequest)
+  {
+    let startedListeners = [];
+
+    while (aRequest.listeners.length > 0) {
+      let listener = aRequest.listeners.shift();
+      switch (listener) {
+        case "PageError":
+          if (!this.pageErrorListener) {
+            this.pageErrorListener =
+              new PageErrorListener(this.window, this);
+            this.pageErrorListener.init();
+          }
+          startedListeners.push(listener);
+          break;
+      }
+    }
+    return { startedListeners: startedListeners };
+  },
+
+  /**
+   * Handler for the "stopListeners" request.
+   *
+   * @param object aRequest
+   *        The JSON request object received from the Web Console client.
+   * @return object
+   *         The response packet to send to the client: holds the
+   *         stoppedListeners array.
+   */
+  onStopListeners: function WCA_onStopListeners(aRequest)
+  {
+    let stoppedListeners = [];
+
+    // If no specific listeners are requested to be detached, we stop all
+    // listeners.
+    let toDetach = aRequest.listeners || ["PageError"];
+
+    while (toDetach.length > 0) {
+      let listener = toDetach.shift();
+      switch (listener) {
+        case "PageError":
+          if (this.pageErrorListener) {
+            this.pageErrorListener.destroy();
+            this.pageErrorListener = null;
+          }
+          stoppedListeners.push(listener);
+          break;
+      }
+    }
+
+    return { stoppedListeners: stoppedListeners };
+  },
+
+  /**
+   * Handler for page errors received from the PageErrorListener. This method
+   * sends the nsIScriptError to the remote Web Console client.
+   *
+   * @param nsIScriptError aPageError
+   *        The page error we need to send to the client.
+   */
+  onPageError: function WCA_onPageError(aPageError)
+  {
+    let packet = {
+      from: this.actorID,
+      type: "pageError",
+      pageError: this.preparePageErrorForRemote(aPageError),
+    };
+    this.conn.send(packet);
+  },
+
+  /**
+   * Prepare an nsIScriptError to be sent to the client.
+   *
+   * @param nsIScriptError aPageError
+   *        The page error we need to send to the client.
+   * @return object
+   *         The object you can send to the remote client.
+   */
+  preparePageErrorForRemote: function WCA_preparePageErrorForRemote(aPageError)
+  {
+    return {
+      message: aPageError.message,
+      errorMessage: aPageError.errorMessage,
+      sourceName: aPageError.sourceName,
+      lineText: aPageError.sourceLine,
+      lineNumber: aPageError.lineNumber,
+      columnNumber: aPageError.columnNumber,
+      category: aPageError.category,
+      timeStamp: aPageError.timeStamp,
+      warning: !!(aPageError.flags & aPageError.warningFlag),
+      error: !!(aPageError.flags & aPageError.errorFlag),
+      exception: !!(aPageError.flags & aPageError.exceptionFlag),
+      strict: !!(aPageError.flags & aPageError.strictFlag),
+    };
+  },
+};
+
+WebConsoleActor.prototype.requestTypes =
+{
+  startListeners: WebConsoleActor.prototype.onStartListeners,
+  stopListeners: WebConsoleActor.prototype.onStopListeners,
+};
+
