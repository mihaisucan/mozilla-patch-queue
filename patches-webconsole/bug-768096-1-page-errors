# HG changeset patch
# Parent 925c01ab7b2097439cd716de4a374638bd1f85ca
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1340997960 -10800

Bug 768096 (webconsole-rdbgp) - Part 1: page errors

diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -12,16 +12,22 @@ const Cu = Components.utils;
 
 const CONSOLEAPI_CLASS_ID = "{b49c18f8-3379-4fc0-8c90-d7772c1a9ff3}";
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
 var EXPORTED_SYMBOLS = ["HUDService"];
 
+XPCOMUtils.defineLazyModuleGetter(this, "DebuggerServer",
+                                  "resource://gre/modules/devtools/dbg-server.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "DebuggerClient",
+                                  "resource://gre/modules/devtools/dbg-client.jsm");
+
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
                                   "resource:///modules/WebConsoleUtils.jsm");
 
 XPCOMUtils.defineLazyGetter(this, "l10n", function() {
   return WebConsoleUtils.l10n;
 });
 
 function LogFactory(aMessagePrefix)
@@ -581,16 +587,18 @@ WebConsole.prototype = {
   {
     this.chromeDocument = this.tab.ownerDocument;
     this.chromeWindow = this.chromeDocument.defaultView;
     this.messageManager = this.tab.linkedBrowser.messageManager;
     this.hudId = "hud_" + this.tab.linkedPanel;
     this.notificationBox = this.chromeDocument
                            .getElementById(this.tab.linkedPanel);
 
+    this.proxy = new WebConsoleConnectionProxy(this);
+    this.proxy.initServer();
     this._initUI();
   },
 
   /**
    * Initialize the Web Console UI. This method sets up the iframe.
    * @private
    */
   _initUI: function WC__initUI()
@@ -618,16 +626,17 @@ WebConsole.prototype = {
    */
   _onIframeLoad: function WC__onIframeLoad()
   {
     this.iframe.removeEventListener("load", this._onIframeLoad, true);
 
     this.iframeWindow = this.iframe.contentWindow.wrappedJSObject;
     this.ui = new this.iframeWindow.WebConsoleFrame(this, this._currentUIPosition);
     this._setupMessageManager();
+    this.proxy.connect();
   },
 
   /**
    * Create a panel to open the web console if it should float above
    * the content in its own window.
    * @private
    */
   _createOwnWindowPanel: function WC__createOwnWindowPanel()
@@ -1072,16 +1081,97 @@ WebConsole.prototype = {
     }
 
     if (this.splitter.parentNode) {
       this.splitter.parentNode.removeChild(this.splitter);
     }
   },
 };
 
+/**
+ * The WebConsoleConnectionProxy handles the connection between the Web Console
+ * and the application we connect to through the remote debug protocol.
+ *
+ * @constructor
+ * @param object aWebConsole
+ *        The Web Console instance that owns this connection proxy.
+ */
+function WebConsoleConnectionProxy(aWebConsole)
+{
+  this.owner = aWebConsole;
+
+  this._onTabNavigated = this._onTabNavigated.bind(this);
+  this._onTabDetached = this._onTabDetached.bind(this);
+  this._onCachedMessages = this._onCachedMessages.bind(this);
+  this._onPageError = this._onPageError.bind(this);
+}
+
+WebConsoleConnectionProxy.prototype = {
+  /**
+   * Initialize the debugger server.
+   */
+  initServer: function WCCP_initServer()
+  {
+    dump("initServer\n");
+    if (!DebuggerServer.initialized) {
+      // Always allow connections from nsIPipe transports.
+      DebuggerServer.init(function () { return true; });
+      DebuggerServer.addBrowserActors();
+    }
+    dump("initServer end\n");
+  },
+
+  /**
+   * Initialize a debugger client and connects it to the debugger server.
+   */
+  connect: function WCCP_connect()
+  {
+    dump("WCCP_connect\n");
+    let transport = DebuggerServer.connectPipe();
+    let client = this.client = new DebuggerClient(transport);
+
+    client.addListener("tabNavigated", this._onTabNavigated);
+    client.addListener("tabDetached", this._onTabDetached);
+    client.addListener("cachedMessages", this._onCachedMessages);
+    client.addListener("pageError", this._onPageError);
+
+    client.connect(function(aType, aTraits) {
+      dump("onConnect\n");
+      client.listTabs(function(aResponse) {
+        dump("onListTabs\n");
+        let tab = aResponse.tabs[aResponse.selected];
+        client.attachTab(tab.actor, function(aResponse, aTabClient) {
+          this.tabClient = aTabClient;
+          dump("onAttachTab\n");
+        }.bind(this));
+      }.bind(this));
+    }.bind(this));
+  },
+
+  _onTabNavigated: function WCCP__onTabNavigated()
+  {
+    dump("WCCP__onTabNavigated\n");
+  },
+
+  _onTabDetached: function WCCP__onTabDetached()
+  {
+    dump("WCCP__onTabDetached\n");
+  },
+
+  _onCachedMessages: function WCCP__onCachedMessages()
+  {
+    dump("WCCP__onCachedMessages\n");
+  },
+
+  _onPageError: function WCCP__onPageError()
+  {
+    dump("WCCP__onPageError\n");
+  },
+};
+
 //////////////////////////////////////////////////////////////////////////
 // HeadsUpDisplayUICommands
 //////////////////////////////////////////////////////////////////////////
 
 var HeadsUpDisplayUICommands = {
   refreshCommand: function UIC_refreshCommand() {
     var window = HUDService.currentContext();
     if (!window) {
diff --git a/toolkit/devtools/Makefile.in b/toolkit/devtools/Makefile.in
--- a/toolkit/devtools/Makefile.in
+++ b/toolkit/devtools/Makefile.in
@@ -6,11 +6,12 @@ DEPTH     = ../..
 topsrcdir = @top_srcdir@
 srcdir    = @srcdir@
 VPATH     = @srcdir@
 
 include $(topsrcdir)/config/config.mk
 
 PARALLEL_DIRS += \
   debugger \
+  webconsole \
   $(NULL)
 
 include $(topsrcdir)/config/rules.mk
diff --git a/toolkit/devtools/debugger/dbg-client.jsm b/toolkit/devtools/debugger/dbg-client.jsm
--- a/toolkit/devtools/debugger/dbg-client.jsm
+++ b/toolkit/devtools/debugger/dbg-client.jsm
@@ -169,17 +169,18 @@ const ThreadStateTypes = {
 
 /**
  * Set of protocol messages that are sent by the server without a prior request
  * by the client.
  */
 const UnsolicitedNotifications = {
   "newScript": "newScript",
   "tabDetached": "tabDetached",
-  "tabNavigated": "tabNavigated"
+  "tabNavigated": "tabNavigated",
+  "pageError": "pageError"
 };
 
 /**
  * Set of debug protocol request types that specify the protocol request being
  * sent to the server.
  */
 const DebugProtocolTypes = {
   "assign": "assign",
@@ -192,17 +193,18 @@ const DebugProtocolTypes = {
   "listTabs": "listTabs",
   "nameAndParameters": "nameAndParameters",
   "ownPropertyNames": "ownPropertyNames",
   "property": "property",
   "prototype": "prototype",
   "prototypeAndProperties": "prototypeAndProperties",
   "resume": "resume",
   "scripts": "scripts",
-  "setBreakpoint": "setBreakpoint"
+  "setBreakpoint": "setBreakpoint",
+  "getCachedMessages": "getCachedMessages",
 };
 
 const ROOT_ACTOR_NAME = "root";
 
 /**
  * Creates a client for the remote debugging protocol server. This client
  * provides the means to communicate with the server and exchange the messages
  * required by the protocol in a traditional JavaScript API.
@@ -297,17 +299,17 @@ DebuggerClient.prototype = {
    *        Called with the response packet and a TabClient
    *        (which will be undefined on error).
    */
   attachTab: function DC_attachTab(aTabActor, aOnResponse) {
     let self = this;
     let packet = { to: aTabActor, type: DebugProtocolTypes.attach };
     this.request(packet, function(aResponse) {
       if (!aResponse.error) {
-        var tabClient = new TabClient(self, aTabActor);
+        var tabClient = new TabClient(self, aTabActor, aResponse);
         self._tabClients[aTabActor] = tabClient;
         self.activeTab = tabClient;
       }
       aOnResponse(aResponse, tabClient);
     });
   },
 
   /**
@@ -443,23 +445,35 @@ eventSource(DebuggerClient.prototype);
  * Creates a tab client for the remote debugging protocol server. This client
  * is a front to the tab actor created in the server side, hiding the protocol
  * details in a traditional JavaScript API.
  *
  * @param aClient DebuggerClient
  *        The debugger client parent.
  * @param aActor string
  *        The actor ID for this tab.
+ * @param aWebConsoleActor object
+ *        The WebConsoleActor grip object.
  */
-function TabClient(aClient, aActor) {
+function TabClient(aClient, aActor, aWebConsoleActor) {
   this._client = aClient;
   this._actor = aActor;
+  this._webConsoleActor = aWebConsoleActor;
 }
 
 TabClient.prototype = {
+  _webConsoleClient: null,
+
+  get webConsoleClient() {
+    if (!this._webConsoleClient) {
+      this._webConsoleClient = new WebConsoleClient(this._webConsoleActor, this);
+    }
+    return this._webConsoleClient;
+  },
+
   /**
    * Detach the client from the tab actor.
    *
    * @param function aOnResponse
    *        Called with the response packet.
    */
   detach: function TabC_detach(aOnResponse) {
     let self = this;
@@ -473,16 +487,33 @@ TabClient.prototype = {
         aOnResponse(aResponse);
       }
     });
   }
 };
 
 eventSource(TabClient.prototype);
 
+function WebConsoleClient(aActorGrip, aTabClient) {
+  this._actor = aActorGrip.actor;
+  this._pageErrorActor = aActorGrip.pageErrorActor;
+  this._tabClient = aTabClient;
+}
+
+WebConsoleClient.prototype = {
+  getCachedMessages:
+  function WCC_getCachedMessages(aOnResponse) {
+    let packet = {
+      to: this.actor,
+      type: DebugProtocolTypes.getCachedMessages,
+    };
+    this._client.request(packet, aOnResponse);
+  },
+};
+
 /**
  * Creates a thread client for the remote debugging protocol server. This client
  * is a front to the thread actor created in the server side, hiding the
  * protocol details in a traditional JavaScript API.
  *
  * @param aClient DebuggerClient
  *        The debugger client parent.
  * @param aActor string
diff --git a/toolkit/devtools/debugger/server/dbg-browser-actors.js b/toolkit/devtools/debugger/server/dbg-browser-actors.js
--- a/toolkit/devtools/debugger/server/dbg-browser-actors.js
+++ b/toolkit/devtools/debugger/server/dbg-browser-actors.js
@@ -4,16 +4,18 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 /**
  * Browser-specific actors.
  */
 
+Cu.import("resource://gre/modules/devtools/dbg-webconsole-actors.jsm");
+
 var windowMediator = Cc["@mozilla.org/appshell/window-mediator;1"]
   .getService(Ci.nsIWindowMediator);
 
 function createRootActor(aConnection)
 {
   return new BrowserRootActor(aConnection);
 }
 
@@ -299,16 +301,22 @@ BrowserTabActor.prototype = {
     dbg_assert(!this._contextPool, "Can't push multiple contexts");
 
     this._contextPool = new ActorPool(this.conn);
     this.conn.addActorPool(this._contextPool);
 
     this.threadActor = new ThreadActor(this);
     this._addDebuggees(this.browser.contentWindow.wrappedJSObject);
     this._contextPool.addActor(this.threadActor);
+
+    this.webConsoleActor = new WebConsoleActor(this);
+    this._contextPool.addActor(this.webConsoleActor);
+    for (let actor of this.webConsoleActor.consoleActors) {
+      this._contextPool.addActor(actor);
+    }
   },
 
   /**
    * Add the provided window and all windows in its frame tree as debuggees.
    */
   _addDebuggees: function BTA__addDebuggees(aWindow) {
     this.threadActor.addDebuggee(aWindow);
     let frames = aWindow.frames;
@@ -323,16 +331,18 @@ BrowserTabActor.prototype = {
    */
   _popContext: function BTA_popContext() {
     dbg_assert(!!this._contextPool, "No context to pop.");
 
     this.conn.removeActorPool(this._contextPool);
     this._contextPool = null;
     this.threadActor.exit();
     this.threadActor = null;
+    this.webConsoleActor.exit();
+    this.webConsoleActor = null;
   },
 
   /**
    * Does the actual work of detaching from a tab.
    */
   _detach: function BTA_detach() {
     if (!this.attached) {
       return;
@@ -353,17 +363,21 @@ BrowserTabActor.prototype = {
 
   onAttach: function BTA_onAttach(aRequest) {
     if (this.exited) {
       return { type: "exited" };
     }
 
     this._attach();
 
-    return { type: "tabAttached", threadActor: this.threadActor.actorID };
+    return {
+      type: "tabAttached",
+      threadActor: this.threadActor.actorID,
+      webConsoleActor: this.webConsoleActor.grip(),
+    };
   },
 
   onDetach: function BTA_onDetach(aRequest) {
     if (!this.attached) {
       return { error: "wrongState" };
     }
 
     this._detach();
diff --git a/toolkit/devtools/webconsole/Makefile.in b/toolkit/devtools/webconsole/Makefile.in
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/webconsole/Makefile.in
@@ -0,0 +1,18 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DEPTH = ../../..
+topsrcdir = @top_srcdir@
+srcdir = @srcdir@
+VPATH = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+TEST_DIRS += tests
+
+include $(topsrcdir)/config/rules.mk
+
+libs::
+	$(INSTALL) $(IFLAGS1) $(srcdir)/*.jsm $(FINAL_TARGET)/modules/devtools
+	$(INSTALL) $(IFLAGS1) $(srcdir)/server/*.jsm $(FINAL_TARGET)/modules/devtools
diff --git a/toolkit/devtools/webconsole/server/dbg-webconsole-actors.jsm b/toolkit/devtools/webconsole/server/dbg-webconsole-actors.jsm
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/webconsole/server/dbg-webconsole-actors.jsm
@@ -0,0 +1,270 @@
+/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cu = Components.utils;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "Services",
+                                  "resource://gre/modules/Services.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "DebuggerServer",
+                                  "resource://gre/modules/devtools/dbg-server.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
+                                  "resource:///modules/WebConsoleUtils.jsm");
+
+var EXPORTED_SYMBOLS = ["WebConsoleActor"];
+
+function WebConsoleActor(aTabActor)
+{
+  this.tabActor = aTabActor;
+  this.pageErrorActor = new PageErrorActor(this);
+}
+
+WebConsoleActor.prototype =
+{
+  get contentWindow() this.tabActor.browser.contentWindow,
+  get conn() this.tabActor.conn,
+
+  actorPrefix: "webConsole",
+
+  grip: function WCA_grip()
+  {
+    return {
+      actor: this.actorID,
+      pageErrorActor: this.pageErrorActor.actorID,
+    };
+  },
+
+  exit: function WCA_exit()
+  {
+    this.pageErrorActor.exit();
+    delete this.pageErrorActor;
+  },
+
+  consoleActors: function WCA_consoleActors()
+  {
+    return {
+      pageErrorActor: this.pageErrorActor,
+    };
+  },
+
+  /**
+   * Handler for the "getCachedMessages" request. This method sends the cached
+   * error messages and the window.console API calls to the client.
+   *
+   */
+  // TODO: update comment
+  onGetCachedMessages: function WCA_onGetCachedMessages(aRequest)
+  {
+    let pageErrorActor = this.pageErrorActor;
+    let consoleAPIActor = this.consoleAPIActor;
+    let types = aRequest.messageTypes;
+    let messages = [];
+
+    while (types.length > 0) {
+      switch (types.shift()) {
+        case "ConsoleAPI":
+          if (consoleAPIActor) {
+            messages.push.apply(messages,
+                                consoleAPIActor.listener.getCachedMessages());
+          }
+          break;
+        case "PageError":
+          if (pageErrorActor) {
+            messages.push.apply(messages,
+                                pageErrorActor.listener.getCachedMessages());
+          }
+          break;
+      }
+    }
+
+    messages.sort(function(a, b) { return a.timeStamp - b.timeStamp; });
+
+    return {
+      from: this.actorID,
+      type: "cachedMessages",
+      messages: messages,
+    };
+  },
+};
+
+WebConsoleActor.prototype.requestTypes =
+{
+  getCachedMessages: WebConsoleActor.prototype.onGetCachedMessages,
+};
+
+function PageErrorActor(aWebConsoleActor)
+{
+  this.webConsoleActor = aWebConsoleActor;
+}
+
+PageErrorActor.prototype =
+{
+  get contentWindow() this.webConsoleActor.contentWindow,
+  get conn() this.webConsoleActor.conn,
+
+  actorPrefix: "PageError",
+  grip: function PEA_grip()
+  {
+    return { actor: this.actorID };
+  },
+
+  onSubscribe: function PEA_onSubscribe(aRequest)
+  {
+    this.listener = new PageErrorListener(this.contentWindow, this);
+    return { subscribe: this.actorID };
+  },
+
+  onUnsubscribe: function PEA_onUnsubscribe(aRequest)
+  {
+    this.listener.destroy();
+    this.listener = null;
+    return { unsubscribe: this.actorID };
+  },
+
+  onPageError: function PEA_onPageError(aPageError)
+  {
+    let packet = {
+      from: this.actorID,
+      type: "pageError",
+      pageError: aPageError,
+    };
+    this.conn.send(packet);
+  },
+};
+
+PageErrorActor.prototype.requestTypes =
+{
+  subscribe: PageErrorActor.prototype.onSubscribe,
+  unsubscribe: PageErrorActor.prototype.onUnsubscribe,
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// The page errors listener
+///////////////////////////////////////////////////////////////////////////////
+
+/**
+ * The nsIConsoleService listener. This is used to send all the page errors
+ * (JavaScript, CSS and more) to the remote Web Console instance.
+ * @constructor
+ */
+function PageErrorListener(aWindow, aListener)
+{
+  this.window = aWindow;
+  this.listener = aListener;
+}
+
+PageErrorListener.prototype =
+{
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIConsoleListener]),
+
+  /**
+   * Initialize the nsIConsoleService listener.
+   */
+  init: function PEL_init()
+  {
+    Services.console.registerListener(this);
+  },
+
+  /**
+   * The nsIConsoleService observer. This method takes all the script error
+   * messages belonging to the current window and sends them to the remote Web
+   * Console instance.
+   *
+   * @param nsIScriptError aScriptError
+   *        The script error object coming from the nsIConsoleService.
+   */
+  observe: function PEL_observe(aScriptError)
+  {
+    if (!this.window || !this.listener ||
+        !(aScriptError instanceof Ci.nsIScriptError) ||
+        !aScriptError.outerWindowID) {
+      return;
+    }
+
+    if (!this.isCategoryAllowed(aScriptError.category)) {
+      return;
+    }
+
+    let errorWindow =
+      WebConsoleUtils.getWindowByOuterId(aScriptError.outerWindowID, this.window);
+    if (!errorWindow || errorWindow.top != this.window) {
+      return;
+    }
+
+    this.listener.onPageError(aScriptError);
+  },
+
+  /**
+   * Check if the given script error category is allowed to be tracked or not.
+   * We ignore chrome-originating errors as we only care about content.
+   *
+   * @param string aCategory
+   *        The nsIScriptError category you want to check.
+   * @return boolean
+   *         True if the category is allowed to be logged, false otherwise.
+   */
+  isCategoryAllowed: function PEL_isCategoryAllowed(aCategory)
+  {
+    switch (aCategory) {
+      case "XPConnect JavaScript":
+      case "component javascript":
+      case "chrome javascript":
+      case "chrome registration":
+      case "XBL":
+      case "XBL Prototype Handler":
+      case "XBL Content Sink":
+      case "xbl javascript":
+        return false;
+    }
+
+    return true;
+  },
+
+  /**
+   * Get the cached page errors for the current inner window.
+   *
+   * @return array
+   *         The array of cached messages. Each element is an nsIScriptError
+   *         with an added _type property so the remote Web Console instance can
+   *         tell the difference between various types of cached messages.
+   */
+  getCachedMessages: function PEL_getCachedMessages()
+  {
+    let innerWindowId = WebConsoleUtils.getInnerWindowId(this.window);
+    let result = [];
+    let errors = {};
+    Services.console.getMessageArray(errors, {});
+
+    (errors.value || []).forEach(function(aError) {
+      if (!(aError instanceof Ci.nsIScriptError) ||
+          aError.innerWindowID != innerWindowId ||
+          !this.isCategoryAllowed(aError.category)) {
+        return;
+      }
+
+      let remoteMessage = WebConsoleUtils.cloneObject(aError);
+      remoteMessage._type = "PageError";
+      result.push(remoteMessage);
+    }, this);
+
+    return result;
+  },
+
+  /**
+   * Remove the nsIConsoleService listener.
+   */
+  destroy: function PEL_destroy()
+  {
+    Services.console.unregisterListener(this);
+  },
+};
