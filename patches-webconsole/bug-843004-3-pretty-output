# HG changeset patch
# Parent 7133d773329b77508ba741dac02bb7a56c36800b
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1386697688 -7200

Bug 843004 - Part 3: VariablesView ObjectActor pretty output; r=benvie,vporof

diff --git a/browser/devtools/shared/widgets/VariablesView.jsm b/browser/devtools/shared/widgets/VariablesView.jsm
--- a/browser/devtools/shared/widgets/VariablesView.jsm
+++ b/browser/devtools/shared/widgets/VariablesView.jsm
@@ -2343,17 +2343,20 @@ Variable.prototype = Heritage.extend(Sco
       return;
     }
 
     let prevGrip = this._valueGrip;
     if (prevGrip) {
       this._valueLabel.classList.remove(VariablesView.getClass(prevGrip));
     }
     this._valueGrip = aGrip;
-    this._valueString = VariablesView.getString(aGrip, true);
+    this._valueString = VariablesView.getString(aGrip, {
+      concise: true,
+      noEllipsis: true,
+    });
     this._valueClassName = VariablesView.getClass(aGrip);
 
     this._valueLabel.classList.add(this._valueClassName);
     this._valueLabel.setAttribute("value", this._valueString);
   },
 
   /**
    * Initializes this variable's id, view and binds event listeners.
@@ -3084,55 +3087,406 @@ VariablesView.getGrip = function(aValue)
   }
 };
 
 /**
  * Returns a custom formatted property string for a grip.
  *
  * @param any aGrip
  *        @see Variable.setGrip
- * @param boolean aConciseFlag
- *        Return a concisely formatted property string.
+ * @param object aOptions
+ *        Options:
+ *        - concise: boolean that tells you want a concisely formatted string.
+ *        - noStringQuotes: boolean that tells to not quote strings.
+ *        - noEllipsis: boolean that tells to not add an ellipsis after the
+ *        initial text of a longString.
  * @return string
  *         The formatted property string.
  */
-VariablesView.getString = function(aGrip, aConciseFlag) {
+VariablesView.getString = function(aGrip, aOptions = {}) {
   if (aGrip && typeof aGrip == "object") {
     switch (aGrip.type) {
       case "undefined":
       case "null":
       case "NaN":
       case "Infinity":
       case "-Infinity":
       case "-0":
         return aGrip.type;
-      case "longString":
-        return "\"" + aGrip.initial + "\"";
       default:
-        if (!aConciseFlag) {
-          return "[" + aGrip.type + " " + aGrip.class + "]";
+        let stringifier = VariablesView.stringifiers.byType[aGrip.type];
+        if (stringifier) {
+          let result = stringifier(aGrip, aOptions);
+          if (result) {
+            return result;
+          }
         }
-        return aGrip.class;
+
+        if (aGrip.displayString) {
+          return VariablesView.getString(aGrip.displayString, aOptions);
+        }
+
+        if (aGrip.type == "object" && aOptions.concise) {
+          return aGrip.class;
+        }
+
+        return "[" + aGrip.type + " " + aGrip.class + "]";
     }
   }
+
   switch (typeof aGrip) {
     case "string":
-      return "\"" + aGrip + "\"";
+      return VariablesView.stringifiers.byType.string(aGrip, aOptions);
     case "boolean":
       return aGrip ? "true" : "false";
     case "number":
       if (!aGrip && 1 / aGrip === -Infinity) {
         return "-0";
       }
     default:
       return aGrip + "";
   }
 };
 
 /**
+ * The VariablesView stringifiers are used by VariablesView.getString(). These
+ * are organized by object type, object class and by object actor preview kind.
+ * Some objects share identical ways for previews, for example Arrays, Sets and
+ * NodeLists.
+ *
+ * Any stringifier function must return a string. If a falsy result is returned,
+ * then the default stringifier will be used. When invoked, the stringifier is
+ * given the same two arguments as those given to VariablesView.getString().
+ */
+VariablesView.stringifiers = {};
+
+VariablesView.stringifiers.byType = {
+  string: function(aGrip, {noStringQuotes}) {
+    if (noStringQuotes) {
+      return aGrip;
+    }
+    return uneval(aGrip);
+  },
+
+  longString: function({initial}, {noStringQuotes, noEllipsis}) {
+    let ellipsis = noEllipsis ? "" : "\u2026";
+    if (noStringQuotes) {
+      return initial + ellipsis;
+    }
+    return uneval(initial) + ellipsis;
+  },
+
+  object: function(aGrip, aOptions) {
+    let {preview} = aGrip;
+    let stringifier;
+    if (preview && preview.kind) {
+      stringifier = VariablesView.stringifiers.byObjectKind[preview.kind];
+    }
+    if (!stringifier && aGrip.class) {
+      stringifier = VariablesView.stringifiers.byObjectClass[aGrip.class];
+    }
+    if (stringifier) {
+      return stringifier(aGrip, aOptions);
+    }
+    return null;
+  },
+}; // VariablesView.stringifiers.byType
+
+VariablesView.stringifiers.byObjectClass = {
+  Function: function(aGrip, {concise}) {
+    // TODO: Bug 948484 - support arrow functions and ES6 generators
+
+    let name = aGrip.userDisplayName || aGrip.displayName || aGrip.name || "";
+    name = VariablesView.getString(name, { noStringQuotes: true });
+
+    // TODO: Bug 948489 - Support functions with destructured parameters and
+    // rest parameters
+    let params = aGrip.parameterNames || "";
+    if (!concise) {
+      return "function " + name + "(" + params + ")";
+    }
+    return (name || "function") + "(" + params + ")";
+  },
+
+  RegExp: function({displayString}) {
+    return VariablesView.getString(displayString, { noStringQuotes: true });
+  },
+
+  Date: function({preview}) {
+    if (!preview || !("timestamp" in preview)) {
+      return null;
+    }
+
+    if (typeof preview.timestamp != "number") {
+      return new Date(preview.timestamp).toString(); // invalid date
+    }
+
+    return "Date " + new Date(preview.timestamp).toISOString();
+  },
+}; // VariablesView.stringifiers.byObjectClass
+
+VariablesView.stringifiers.byObjectKind = {
+  ArrayLike: function(aGrip, {concise}) {
+    let {preview} = aGrip;
+    if (concise) {
+      return aGrip.class + "[" + preview.length + "]";
+    }
+
+    if (!preview.items) {
+      return null;
+    }
+
+    let result = [];
+    for (let item of preview.items) {
+      result.push(VariablesView.getString(item, { concise: true }));
+    }
+
+    if (result.length < preview.length) {
+      result.push((preview.length - result.length) + " more\u2026"); // TODO: localize
+    }
+
+    let prefix = aGrip.class == "Array" ? "" : aGrip.class + " ";
+    return prefix + "[" + result.join(", ") + "]";
+  },
+
+  MapLike: function(aGrip, {concise}) {
+    let {preview} = aGrip;
+    if (concise || !preview.entries) {
+      let size = typeof preview.size == "number" ?
+                   "[" + preview.size + "]" : "";
+      return aGrip.class + size;
+    }
+
+    let entries = [];
+    for (let [key, value] of preview.entries) {
+      key = VariablesView.getString(key, {
+        concise: true,
+        noStringQuotes: true,
+      });
+      value = VariablesView.getString(value, { concise: true });
+      entries.push(key + ": " + value);
+    }
+
+    if (typeof preview.size == "number" && preview.size > entries.length) {
+      entries.push((preview.size - entries.length) + " more\u2026");
+    }
+
+    return aGrip.class + " {" + entries.join(", ") + "}";
+  },
+
+  // Stringifier for any kind of object.
+  Object: function(aGrip, {concise}) {
+    if (concise) {
+      return aGrip.class;
+    }
+
+    let {preview} = aGrip;
+    let props = [];
+    for (let key of Object.keys(preview.ownProperties || {})) {
+      let value = preview.ownProperties[key];
+      let valueString = "";
+      if (value.get) {
+        valueString = "Getter";
+      } else if (value.set) {
+        valueString = "Setter";
+      } else {
+        valueString = VariablesView.getString(value.value, { concise: true });
+      }
+      props.push(key + ": " + valueString);
+    }
+
+    for (let key of Object.keys(preview.safeGetterValues || {})) {
+      let value = preview.safeGetterValues[key];
+      let valueString = VariablesView.getString(value.getterValue,
+                                                { concise: true });
+      props.push(key + ": " + valueString);
+    }
+
+    if (!props.length) {
+      return null;
+    }
+
+    if (preview.ownPropertiesLength) {
+      let previewLength = Object.keys(preview.ownProperties).length;
+      let diff = preview.ownPropertiesLength - previewLength;
+      if (diff > 0) {
+        props.push(diff + " more\u2026"); // TODO: localize
+      }
+    }
+
+    let prefix = aGrip.class != "Object" ? aGrip.class + " " : "";
+    return prefix + "{" + props.join(", ") + "}";
+  }, // Object
+
+  Error: function(aGrip, {concise}) {
+    if (concise) {
+      return aGrip.class;
+    }
+
+    let {preview} = aGrip;
+    let msg = VariablesView.getString(preview.name, { noStringQuotes: true }) +
+              ": " +
+              VariablesView.getString(preview.message, { noStringQuotes: true });
+    if (!VariablesView.isFalsy({ value: preview.stack })) {
+      msg += "\nStack trace:\n" + preview.stack; // TODO: localize
+    }
+
+    return msg;
+  },
+
+  DOMException: function(aGrip, {concise}) {
+    let {preview} = aGrip;
+    if (concise) {
+      return preview.name || aGrip.class;
+    }
+
+    let msg = aGrip.class + " [" + preview.name + ": " +
+              VariablesView.getString(preview.message) + "\n" +
+              "code: " + preview.code + "\n" +
+              "nsresult: 0x" + (+preview.result).toString(16);
+
+    if (preview.filename) {
+      msg += "\nlocation: " + preview.filename;
+      if (preview.lineNumber) {
+        msg += "@" + preview.lineNumber;
+      }
+    }
+
+    return msg + "]";
+  },
+
+  DOMEvent: function(aGrip, {concise}) {
+    let {preview} = aGrip;
+    if (!preview.type) {
+      return null;
+    }
+
+    if (concise) {
+      return aGrip.class + " " + preview.type;
+    }
+
+    let result = preview.type;
+
+    if (preview.eventKind == "key" && preview.modifiers &&
+        preview.modifiers.length) {
+      result += " " + preview.modifiers.join("-");
+    }
+
+    let props = [];
+    if (preview.target) {
+      let target = VariablesView.getString(preview.target, { concise: true });
+      props.push("target: " + target);
+    }
+
+    for (let prop in preview.properties) {
+      let value = preview.properties[prop];
+      props.push(prop + ": " + VariablesView.getString(value, { concise: true }));
+    }
+
+    return result + " {" + props.join(", ") + "}";
+  }, // DOMEvent
+
+  CSSStyleSheet: function(aGrip, {concise}) {
+    let result = aGrip.class;
+    let href = aGrip.preview.href;
+    if (!VariablesView.isFalsy({ value: href })) {
+      result += " " + WebConsoleUtils.abbreviateSourceURL(href,
+                                                          { onlyCropQuery: !concise });
+    }
+    return result;
+  },
+
+  CSSStyleRule: function(aGrip, {concise}) {
+    if (concise) {
+      return aGrip.class;
+    }
+    let str = VariablesView.getString(aGrip.preview.selectorText);
+    return aGrip.class + " " + str;
+  },
+
+  CSSMediaRule: function(aGrip, {concise}) {
+    if (concise) {
+      return aGrip.class;
+    }
+
+    // XXX: we could introduce a new preview.kind = "ObjectWithText" or
+    // something, one that we would reuse for CSSStyleRule and CSSMediaRule.
+    let str = VariablesView.getString(aGrip.preview.conditionText);
+    return aGrip.class + " " + str;
+  },
+
+  DOMWindow: function(aGrip, {concise}) {
+    let location = WebConsoleUtils.abbreviateSourceURL(aGrip.preview.location,
+                                                       { onlyCropQuery: !concise });
+    return aGrip.class + " " + location;
+  },
+
+  DOMNode: function(aGrip, {concise}) {
+    let {preview} = aGrip;
+
+    switch (preview.nodeType) {
+      case Ci.nsIDOMNode.DOCUMENT_NODE: {
+        let location = WebConsoleUtils.abbreviateSourceURL(preview.location,
+                                                           { onlyCropQuery: !concise });
+        return aGrip.class + " " + location;
+      }
+
+      case Ci.nsIDOMNode.ATTRIBUTE_NODE: {
+        // TODO: escape html entities.
+        let value = VariablesView.getString(preview.value);
+        return preview.nodeName + "=" + value;
+      }
+
+      case Ci.nsIDOMNode.TEXT_NODE:
+        return preview.nodeName + " " +
+               VariablesView.getString(preview.textContent);
+
+      case Ci.nsIDOMNode.COMMENT_NODE: {
+        let comment = VariablesView.getString(preview.textContent,
+                                              { noStringQuotes: true });
+        return "<!--" + comment + "-->";
+      }
+
+      case Ci.nsIDOMNode.ELEMENT_NODE: {
+        let attrs = preview.attributes;
+        if (!concise) {
+          let n = 0, result = "<" + preview.nodeName;
+          for (let name in attrs) {
+            // TODO: escape html entities.
+            let value = VariablesView.getString(attrs[name],
+                                                { noStringQuotes: true });
+            result += " " + name + "=" + value;
+            n++;
+          }
+          if (preview.attributesLength > n) {
+            result += " \u2026";
+          }
+          return result + ">";
+        }
+
+        let result = "<" + preview.nodeName;
+        if (attrs.id) {
+          result += "#" + attrs.id;
+        }
+        return result + ">";
+      }
+
+      default:
+        return null;
+    }
+  }, // DOMNode
+}; // VariablesView.stringifiers.byObjectKind
+
+// XXX: here we could also add a new preview.kind ObjectWithURL for reuse.
+// thoughts?
+VariablesView.stringifiers.byObjectKind.DOMLocation =
+  VariablesView.stringifiers.byObjectKind.CSSImportRule =
+  VariablesView.stringifiers.byObjectKind.CSSStyleSheet;
+
+/**
  * Returns a custom class style for a grip.
  *
  * @param any aGrip
  *        @see Variable.setGrip
  * @return string
  *         The custom class style.
  */
 VariablesView.getClass = function(aGrip) {
diff --git a/browser/devtools/webconsole/console-output.js b/browser/devtools/webconsole/console-output.js
--- a/browser/devtools/webconsole/console-output.js
+++ b/browser/devtools/webconsole/console-output.js
@@ -992,20 +992,21 @@ Messages.Extended.prototype = Heritage.e
       }
       if (piece.type == "longString") {
         let widget = new Widgets.LongString(this, piece).render();
         return widget.element;
       }
     }
 
     let result = this.document.createDocumentFragment();
-    if (!isPrimitive || (!this._quoteStrings && typeof piece == "string")) {
+    if (isPrimitive) {
+      result.textContent = VariablesView.getString(piece,
+                           { noStringQuotes: !this._quoteStrings });
+    } else {
       result.textContent = piece;
-    } else {
-      result.textContent = VariablesView.getString(piece);
     }
 
     return result;
   },
 }); // Messages.Extended.prototype
 
 
 
@@ -1268,21 +1269,18 @@ Widgets.LongString.prototype = Heritage.
   /**
    * Render the long string in the widget element.
    * @private
    * @param string str
    *        The string to display.
    */
   _renderString: function(str)
   {
-    if (this.message._quoteStrings) {
-      this.element.textContent = VariablesView.getString(str);
-    } else {
-      this.element.textContent = str;
-    }
+    this.element.textContent = VariablesView.getString(str,
+                               { noStringQuotes: !this.message._quoteStrings });
   },
 
   /**
    * Render the anchor ellipsis that allows the user to expand the long string.
    *
    * @private
    * @return Element
    */
diff --git a/toolkit/devtools/server/actors/script.js b/toolkit/devtools/server/actors/script.js
--- a/toolkit/devtools/server/actors/script.js
+++ b/toolkit/devtools/server/actors/script.js
@@ -435,25 +435,30 @@ function ThreadActor(aHooks, aGlobal)
   this.findGlobals = this.globalManager.findGlobals.bind(this);
   this.onNewGlobal = this.globalManager.onNewGlobal.bind(this);
   this.onNewSource = this.onNewSource.bind(this);
   this._allEventsListener = this._allEventsListener.bind(this);
 
   this._options = {
     useSourceMaps: false
   };
+
+  this._gripDepth = 0;
 }
 
 /**
  * The breakpoint store must be shared across instances of ThreadActor so that
  * page reloads don't blow away all of our breakpoints.
  */
 ThreadActor.breakpointStore = new BreakpointStore();
 
 ThreadActor.prototype = {
+  // Used by the ObjectActor to keep track of the depth of grip() calls.
+  _gripDepth: null,
+
   actorPrefix: "context",
 
   get state() { return this._state; },
   get attached() this.state == "attached" ||
                  this.state == "running" ||
                  this.state == "paused",
 
   get breakpointStore() { return ThreadActor.breakpointStore; },
@@ -2815,20 +2820,16 @@ let stringifiers = {
  *        The debuggee object.
  * @param aThreadActor ThreadActor
  *        The parent thread actor for this object.
  */
 function ObjectActor(aObj, aThreadActor)
 {
   this.obj = aObj;
   this.threadActor = aThreadActor;
-
-  if (!("_gripDepth" in this.threadActor)) {
-    this.threadActor._gripDepth = 0;
-  }
 }
 
 ObjectActor.prototype = {
   actorPrefix: "obj",
 
   /**
    * Returns a grip for this actor for returning in a protocol message.
    */
@@ -3050,17 +3051,17 @@ ObjectActor.prototype = {
     }
 
     let getters = new Set();
     let names = [];
     try {
       names = aObject.getOwnPropertyNames()
     } catch (ex) {
       // Calling getOwnPropertyNames() on wrapped native prototypes is not
-      // allowed: "cannot modify properties of a WrappedNative".
+      // allowed: "cannot modify properties of a WrappedNative". See bug 560072.
     }
 
     for (let name of names) {
       let desc = null;
       try {
         desc = aObject.getOwnPropertyDescriptor(name);
       } catch (e) {
         // Calling getOwnPropertyDescriptor on wrapped native prototypes is not
@@ -3118,18 +3119,25 @@ ObjectActor.prototype = {
     return { from: this.actorID,
              displayString: this.threadActor.createValueGrip(string) };
   },
 
   /**
    * A helper method that creates a property descriptor for the provided object,
    * properly formatted for sending in a protocol response.
    *
+   * @private
    * @param string aName
    *        The property that the descriptor is generated for.
+   * @param boolean aOnlyEnumerable
+   *        True if you want a descriptor only for an enumerable property, false
+   *        otherwise.
+   * @return object|undefined
+   *         The property descriptor, or undefined if this is not an enumerable
+   *         property and aOnlyEnumerable=true.
    */
   _propertyDescriptor: function (aName, aOnlyEnumerable) {
     let desc;
     try {
       desc = this.obj.getOwnPropertyDescriptor(aName);
     } catch (e) {
       // Calling getOwnPropertyDescriptor on wrapped native prototypes is not
       // allowed (bug 560072). Inform the user with a bogus, but hopefully
@@ -3268,62 +3276,68 @@ const OBJECT_PREVIEW_MAX_ITEMS = 10;
  */
 DebuggerServer.ObjectActorPreviewers = {
   Function: [function({obj, threadActor}, aGrip) {
     if (obj.name) {
       aGrip.name = obj.name;
     }
 
     if (obj.displayName) {
-      aGrip.displayName = obj.displayName;
-    }
-
+      aGrip.displayName = obj.displayName.substr(0, 500);
+    }
+
+    // TODO: handle fancy params
     if (obj.parameterNames) {
       aGrip.parameterNames = obj.parameterNames;
     }
 
     // Check if the developer has added a de-facto standard displayName
     // property for us to use.
+    let userDisplayName;
     try {
-      let desc = obj.getOwnPropertyDescriptor("displayName");
-      if (desc && desc.value && typeof desc.value == "string") {
-        aGrip.userDisplayName = threadActor.createValueGrip(desc.value);
-      }
+      userDisplayName = obj.getOwnPropertyDescriptor("displayName");
     } catch (e) {
       // Calling getOwnPropertyDescriptor with displayName might throw
       // with "permission denied" errors for some functions.
       dumpn(e);
     }
 
+    if (userDisplayName && userDisplayName.value &&
+        typeof userDisplayName.value == "string") {
+      aGrip.userDisplayName = threadActor.createValueGrip(userDisplayName.value);
+    }
+
     return true;
   }], // Function
 
   RegExp: [function({obj, threadActor}, aGrip) {
+    // Avoid having any special preview for the RegExp.prototype itself.
     if (!obj.proto || obj.proto.class != "RegExp") {
       return false;
     }
 
-    let raw = obj.unsafeDereference();
-    let str = RegExp.prototype.toString.call(raw);
+    let str = RegExp.prototype.toString.call(obj.unsafeDereference());
     aGrip.displayString = threadActor.createValueGrip(str);
     return true;
   }],
 
   Date: [function({obj, threadActor}, aGrip) {
+    if (!obj.proto || obj.proto.class != "Date") {
+      return false;
+    }
+
     let time = Date.prototype.getTime.call(obj.unsafeDereference());
-    if (isNaN(time)) {
-      return false;
-    }
 
     aGrip.preview = {
       timestamp: threadActor.createValueGrip(time),
     };
     return true;
   }],
 
+  // TODO: add typed arrays
   Array: [function({obj, threadActor}, aGrip) {
     let length = DevToolsUtils.getProperty(obj, "length");
     if (typeof length != "number") {
       return false;
     }
 
     aGrip.preview = {
       kind: "ArrayLike",
@@ -3332,16 +3346,17 @@ DebuggerServer.ObjectActorPreviewers = {
 
     if (threadActor._gripDepth > 1) {
       return true;
     }
 
     let raw = obj.unsafeDereference();
     let items = aGrip.preview.items = [];
 
+    // TODO: handle array holes.
     Array.some(raw, (item) => {
       let value = item;
       if (value && typeof value == "object") {
         value = obj.makeDebuggeeValue(item);
       }
       items.push(threadActor.createValueGrip(value));
 
       // Stop iterating the array once we have enough items.
@@ -3419,25 +3434,24 @@ DebuggerServer.ObjectActorPreviewers = {
   DOMStringMap: [function({obj, threadActor}, aGrip, aRawObj) {
     if (!aRawObj) {
       return false;
     }
 
     let keys = obj.getOwnPropertyNames();
     aGrip.preview = {
       kind: "MapLike",
-      entries: [],
       size: keys.length,
     };
 
     if (threadActor._gripDepth > 1) {
-      return false;
-    }
-
-    let entries = aGrip.preview.entries;
+      return true;
+    }
+
+    let entries = aGrip.preview.entries = [];
     for (let key of keys) {
       let value = aRawObj[key];
       if (value && typeof value == "object") {
         value = obj.makeDebuggeeValue(value);
       }
       entries.push([key, threadActor.createValueGrip(value)]);
       if (entries.length == OBJECT_PREVIEW_MAX_ITEMS) {
         break;
@@ -3591,20 +3605,20 @@ DebuggerServer.ObjectActorPreviewers.Obj
 
   function CSSStyleDeclaration({obj, threadActor}, aGrip, aRawObj) {
     if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMCSSStyleDeclaration)) {
       return false;
     }
 
     aGrip.preview = {
       kind: "MapLike",
-      entries: [],
       size: aRawObj.length,
     };
-    let entries = aGrip.preview.entries;
+
+    let entries = aGrip.preview.entries = [];
 
     for (let i = 0; i < OBJECT_PREVIEW_MAX_ITEMS &&
                     i < aRawObj.length; i++) {
       let prop = aRawObj[i];
       let value = aRawObj.getPropertyValue(prop);
       entries.push([prop, threadActor.createValueGrip(value)]);
     }
 
@@ -3761,24 +3775,25 @@ DebuggerServer.ObjectActorPreviewers.Obj
   function GenericObject(aObjectActor, aGrip) {
     let {obj, threadActor} = aObjectActor;
     if (aGrip.preview || aGrip.displayString || threadActor._gripDepth > 1) {
       return false;
     }
 
     let i = 0, names = [];
     let preview = aGrip.preview = {
+      kind: "Object",
       ownProperties: Object.create(null),
     };
 
     try {
       names = obj.getOwnPropertyNames();
     } catch (ex) {
       // Calling getOwnPropertyNames() on wrapped native prototypes is not
-      // allowed: "cannot modify properties of a WrappedNative".
+      // allowed: "cannot modify properties of a WrappedNative". See bug 560072.
     }
 
     preview.ownPropertiesLength = names.length;
 
     for (let name of names) {
       let desc = aObjectActor._propertyDescriptor(name, true);
       if (!desc) {
         continue;
diff --git a/toolkit/devtools/webconsole/utils.js b/toolkit/devtools/webconsole/utils.js
--- a/toolkit/devtools/webconsole/utils.js
+++ b/toolkit/devtools/webconsole/utils.js
@@ -183,20 +183,26 @@ let WebConsoleUtils = {
   },
 
   /**
    * Abbreviates the given source URL so that it can be displayed flush-right
    * without being too distracting.
    *
    * @param string aSourceURL
    *        The source URL to shorten.
+   * @param object [aOptions]
+   *        Options:
+   *        - onlyCropQuery: boolean that tells if the URL abbreviation function
+   *        should only remove the query parameters and the hash fragment from
+   *        the given URL.
    * @return string
    *         The abbreviated form of the source URL.
    */
-  abbreviateSourceURL: function WCU_abbreviateSourceURL(aSourceURL)
+  abbreviateSourceURL:
+  function WCU_abbreviateSourceURL(aSourceURL, aOptions = {})
   {
     if (aSourceURL.substr(0, 5) == "data:") {
       let commaIndex = aSourceURL.indexOf(",");
       if (commaIndex > -1) {
         aSourceURL = "data:" + aSourceURL.substring(commaIndex + 1);
       }
     }
 
@@ -209,23 +215,25 @@ let WebConsoleUtils = {
     // Remove any hash fragments.
     let hashIndex = aSourceURL.indexOf("#");
     if (hashIndex > -1) {
       aSourceURL = aSourceURL.substring(0, hashIndex);
     }
 
     // Remove a trailing "/".
     if (aSourceURL[aSourceURL.length - 1] == "/") {
-      aSourceURL = aSourceURL.substring(0, aSourceURL.length - 1);
+      aSourceURL = aSourceURL.replace(/\/+$/, "");
     }
 
     // Remove all but the last path component.
-    let slashIndex = aSourceURL.lastIndexOf("/");
-    if (slashIndex > -1) {
-      aSourceURL = aSourceURL.substring(slashIndex + 1);
+    if (!aOptions.onlyCropQuery) {
+      let slashIndex = aSourceURL.lastIndexOf("/");
+      if (slashIndex > -1) {
+        aSourceURL = aSourceURL.substring(slashIndex + 1);
+      }
     }
 
     return aSourceURL;
   },
 
   /**
    * Tells if the given function is native or not.
    *
