# HG changeset patch
# Parent 7133d773329b77508ba741dac02bb7a56c36800b
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1386710910 -7200

Bug 843004 - Part 3: VariablesView ObjectActor pretty output; r=benvie,vporof

diff --git a/browser/devtools/shared/widgets/VariablesView.jsm b/browser/devtools/shared/widgets/VariablesView.jsm
--- a/browser/devtools/shared/widgets/VariablesView.jsm
+++ b/browser/devtools/shared/widgets/VariablesView.jsm
@@ -2343,17 +2343,20 @@ Variable.prototype = Heritage.extend(Sco
       return;
     }
 
     let prevGrip = this._valueGrip;
     if (prevGrip) {
       this._valueLabel.classList.remove(VariablesView.getClass(prevGrip));
     }
     this._valueGrip = aGrip;
-    this._valueString = VariablesView.getString(aGrip, true);
+    this._valueString = VariablesView.getString(aGrip, {
+      concise: true,
+      noEllipsis: true,
+    });
     this._valueClassName = VariablesView.getClass(aGrip);
 
     this._valueLabel.classList.add(this._valueClassName);
     this._valueLabel.setAttribute("value", this._valueString);
   },
 
   /**
    * Initializes this variable's id, view and binds event listeners.
@@ -3084,55 +3087,381 @@ VariablesView.getGrip = function(aValue)
   }
 };
 
 /**
  * Returns a custom formatted property string for a grip.
  *
  * @param any aGrip
  *        @see Variable.setGrip
- * @param boolean aConciseFlag
- *        Return a concisely formatted property string.
+ * @param object aOptions
+ *        Options:
+ *        - concise: boolean that tells you want a concisely formatted string.
+ *        - noStringQuotes: boolean that tells to not quote strings.
+ *        - noEllipsis: boolean that tells to not add an ellipsis after the
+ *        initial text of a longString.
  * @return string
  *         The formatted property string.
  */
-VariablesView.getString = function(aGrip, aConciseFlag) {
+VariablesView.getString = function(aGrip, aOptions = {}) {
   if (aGrip && typeof aGrip == "object") {
     switch (aGrip.type) {
       case "undefined":
       case "null":
       case "NaN":
       case "Infinity":
       case "-Infinity":
       case "-0":
         return aGrip.type;
-      case "longString":
-        return "\"" + aGrip.initial + "\"";
       default:
-        if (!aConciseFlag) {
-          return "[" + aGrip.type + " " + aGrip.class + "]";
+        let stringifier = VariablesView.stringifiers.byType[aGrip.type];
+        if (stringifier) {
+          let result = stringifier(aGrip, aOptions);
+          if (result) {
+            return result;
+          }
         }
-        return aGrip.class;
+
+        if (aGrip.displayString) {
+          return VariablesView.getString(aGrip.displayString, aOptions);
+        }
+
+        if (aGrip.type == "object" && aOptions.concise) {
+          return aGrip.class;
+        }
+
+        return "[" + aGrip.type + " " + aGrip.class + "]";
     }
   }
+
   switch (typeof aGrip) {
     case "string":
-      return "\"" + aGrip + "\"";
+      return VariablesView.stringifiers.byType.string(aGrip, aOptions);
     case "boolean":
       return aGrip ? "true" : "false";
     case "number":
       if (!aGrip && 1 / aGrip === -Infinity) {
         return "-0";
       }
     default:
       return aGrip + "";
   }
 };
 
 /**
+ * The VariablesView stringifiers are used by VariablesView.getString(). These
+ * are organized by object type, object class and by object actor preview kind.
+ * Some objects share identical ways for previews, for example Arrays, Sets and
+ * NodeLists.
+ *
+ * Any stringifier function must return a string. If a falsy result is returned,
+ * then the default stringifier will be used. When invoked, the stringifier is
+ * given the same two arguments as those given to VariablesView.getString().
+ */
+VariablesView.stringifiers = {};
+
+VariablesView.stringifiers.byType = {
+  string: function(aGrip, {noStringQuotes}) {
+    if (noStringQuotes) {
+      return aGrip;
+    }
+    return uneval(aGrip);
+  },
+
+  longString: function({initial}, {noStringQuotes, noEllipsis}) {
+    let ellipsis = noEllipsis ? "" : "\u2026";
+    if (noStringQuotes) {
+      return initial + ellipsis;
+    }
+    return uneval(initial) + ellipsis;
+  },
+
+  object: function(aGrip, aOptions) {
+    let {preview} = aGrip;
+    let stringifier;
+    if (preview && preview.kind) {
+      stringifier = VariablesView.stringifiers.byObjectKind[preview.kind];
+    }
+    if (!stringifier && aGrip.class) {
+      stringifier = VariablesView.stringifiers.byObjectClass[aGrip.class];
+    }
+    if (stringifier) {
+      return stringifier(aGrip, aOptions);
+    }
+    return null;
+  },
+}; // VariablesView.stringifiers.byType
+
+VariablesView.stringifiers.byObjectClass = {
+  Function: function(aGrip, {concise}) {
+    // TODO: Bug 948484 - support arrow functions and ES6 generators
+
+    let name = aGrip.userDisplayName || aGrip.displayName || aGrip.name || "";
+    name = VariablesView.getString(name, { noStringQuotes: true });
+
+    // TODO: Bug 948489 - Support functions with destructured parameters and
+    // rest parameters
+    let params = aGrip.parameterNames || "";
+    if (!concise) {
+      return "function " + name + "(" + params + ")";
+    }
+    return (name || "function") + "(" + params + ")";
+  },
+
+  RegExp: function({displayString}) {
+    return VariablesView.getString(displayString, { noStringQuotes: true });
+  },
+
+  Date: function({preview}) {
+    if (!preview || !("timestamp" in preview)) {
+      return null;
+    }
+
+    if (typeof preview.timestamp != "number") {
+      return new Date(preview.timestamp).toString(); // invalid date
+    }
+
+    return "Date " + new Date(preview.timestamp).toISOString();
+  },
+}; // VariablesView.stringifiers.byObjectClass
+
+VariablesView.stringifiers.byObjectKind = {
+  ArrayLike: function(aGrip, {concise}) {
+    let {preview} = aGrip;
+    if (concise) {
+      return aGrip.class + "[" + preview.length + "]";
+    }
+
+    if (!preview.items) {
+      return null;
+    }
+
+    let result = [];
+    for (let item of preview.items) {
+      result.push(VariablesView.getString(item, { concise: true }));
+    }
+
+    if (result.length < preview.length) {
+      result.push((preview.length - result.length) + " more\u2026"); // TODO: localize
+    }
+
+    let prefix = aGrip.class == "Array" ? "" : aGrip.class + " ";
+    return prefix + "[" + result.join(", ") + "]";
+  },
+
+  MapLike: function(aGrip, {concise}) {
+    let {preview} = aGrip;
+    if (concise || !preview.entries) {
+      let size = typeof preview.size == "number" ?
+                   "[" + preview.size + "]" : "";
+      return aGrip.class + size;
+    }
+
+    let entries = [];
+    for (let [key, value] of preview.entries) {
+      key = VariablesView.getString(key, {
+        concise: true,
+        noStringQuotes: true,
+      });
+      value = VariablesView.getString(value, { concise: true });
+      entries.push(key + ": " + value);
+    }
+
+    if (typeof preview.size == "number" && preview.size > entries.length) {
+      entries.push((preview.size - entries.length) + " more\u2026");
+    }
+
+    return aGrip.class + " {" + entries.join(", ") + "}";
+  },
+
+  ObjectWithText: function(aGrip, {concise}) {
+    if (concise) {
+      return aGrip.class;
+    }
+
+    return aGrip.class + " " + VariablesView.getString(aGrip.preview.text);
+  },
+
+  ObjectWithURL: function(aGrip, {concise}) {
+    let result = aGrip.class;
+    let url = aGrip.preview.url;
+    if (!VariablesView.isFalsy({ value: url })) {
+      result += " " + WebConsoleUtils.abbreviateSourceURL(url,
+                                                          { onlyCropQuery: !concise });
+    }
+    return result;
+  },
+
+  // Stringifier for any kind of object.
+  Object: function(aGrip, {concise}) {
+    if (concise) {
+      return aGrip.class;
+    }
+
+    let {preview} = aGrip;
+    let props = [];
+    for (let key of Object.keys(preview.ownProperties || {})) {
+      let value = preview.ownProperties[key];
+      let valueString = "";
+      if (value.get) {
+        valueString = "Getter";
+      } else if (value.set) {
+        valueString = "Setter";
+      } else {
+        valueString = VariablesView.getString(value.value, { concise: true });
+      }
+      props.push(key + ": " + valueString);
+    }
+
+    for (let key of Object.keys(preview.safeGetterValues || {})) {
+      let value = preview.safeGetterValues[key];
+      let valueString = VariablesView.getString(value.getterValue,
+                                                { concise: true });
+      props.push(key + ": " + valueString);
+    }
+
+    if (!props.length) {
+      return null;
+    }
+
+    if (preview.ownPropertiesLength) {
+      let previewLength = Object.keys(preview.ownProperties).length;
+      let diff = preview.ownPropertiesLength - previewLength;
+      if (diff > 0) {
+        props.push(diff + " more\u2026"); // TODO: localize
+      }
+    }
+
+    let prefix = aGrip.class != "Object" ? aGrip.class + " " : "";
+    return prefix + "{" + props.join(", ") + "}";
+  }, // Object
+
+  Error: function(aGrip, {concise}) {
+    if (concise) {
+      return aGrip.class;
+    }
+
+    let {preview} = aGrip;
+    let msg = VariablesView.getString(preview.name, { noStringQuotes: true }) +
+              ": " +
+              VariablesView.getString(preview.message, { noStringQuotes: true });
+    if (!VariablesView.isFalsy({ value: preview.stack })) {
+      msg += "\nStack trace:\n" + preview.stack; // TODO: localize
+    }
+
+    return msg;
+  },
+
+  DOMException: function(aGrip, {concise}) {
+    let {preview} = aGrip;
+    if (concise) {
+      return preview.name || aGrip.class;
+    }
+
+    let msg = aGrip.class + " [" + preview.name + ": " +
+              VariablesView.getString(preview.message) + "\n" +
+              "code: " + preview.code + "\n" +
+              "nsresult: 0x" + (+preview.result).toString(16);
+
+    if (preview.filename) {
+      msg += "\nlocation: " + preview.filename;
+      if (preview.lineNumber) {
+        msg += "@" + preview.lineNumber;
+      }
+    }
+
+    return msg + "]";
+  },
+
+  DOMEvent: function(aGrip, {concise}) {
+    let {preview} = aGrip;
+    if (!preview.type) {
+      return null;
+    }
+
+    if (concise) {
+      return aGrip.class + " " + preview.type;
+    }
+
+    let result = preview.type;
+
+    if (preview.eventKind == "key" && preview.modifiers &&
+        preview.modifiers.length) {
+      result += " " + preview.modifiers.join("-");
+    }
+
+    let props = [];
+    if (preview.target) {
+      let target = VariablesView.getString(preview.target, { concise: true });
+      props.push("target: " + target);
+    }
+
+    for (let prop in preview.properties) {
+      let value = preview.properties[prop];
+      props.push(prop + ": " + VariablesView.getString(value, { concise: true }));
+    }
+
+    return result + " {" + props.join(", ") + "}";
+  }, // DOMEvent
+
+  DOMNode: function(aGrip, {concise}) {
+    let {preview} = aGrip;
+
+    switch (preview.nodeType) {
+      case Ci.nsIDOMNode.DOCUMENT_NODE: {
+        let location = WebConsoleUtils.abbreviateSourceURL(preview.location,
+                                                           { onlyCropQuery: !concise });
+        return aGrip.class + " " + location;
+      }
+
+      case Ci.nsIDOMNode.ATTRIBUTE_NODE: {
+        let value = VariablesView.getString(preview.value, { noStringQuotes: true });
+        return preview.nodeName + '="' + escapeHTML(value) + '"';
+      }
+
+      case Ci.nsIDOMNode.TEXT_NODE:
+        return preview.nodeName + " " +
+               VariablesView.getString(preview.textContent);
+
+      case Ci.nsIDOMNode.COMMENT_NODE: {
+        let comment = VariablesView.getString(preview.textContent,
+                                              { noStringQuotes: true });
+        return "<!--" + comment + "-->";
+      }
+
+      case Ci.nsIDOMNode.ELEMENT_NODE: {
+        let attrs = preview.attributes;
+        if (!concise) {
+          let n = 0, result = "<" + preview.nodeName;
+          for (let name in attrs) {
+            let value = VariablesView.getString(attrs[name],
+                                                { noStringQuotes: true });
+            result += " " + name + '="' + escapeHTML(value) + '"';
+            n++;
+          }
+          if (preview.attributesLength > n) {
+            result += " \u2026";
+          }
+          return result + ">";
+        }
+
+        let result = "<" + preview.nodeName;
+        if (attrs.id) {
+          result += "#" + attrs.id;
+        }
+        return result + ">";
+      }
+
+      default:
+        return null;
+    }
+  }, // DOMNode
+}; // VariablesView.stringifiers.byObjectKind
+
+/**
  * Returns a custom class style for a grip.
  *
  * @param any aGrip
  *        @see Variable.setGrip
  * @return string
  *         The custom class style.
  */
 VariablesView.getClass = function(aGrip) {
@@ -3174,16 +3503,29 @@ VariablesView.getClass = function(aGrip)
  */
 let generateId = (function() {
   let count = 0;
   return function(aName = "") {
     return aName.toLowerCase().trim().replace(/\s+/g, "-") + (++count);
   };
 })();
 
+/**
+ * Escape HTML special characters.
+ *
+ * @param string aString
+ * @return string
+ */
+function escapeHTML(aString) {
+  return aString.replace(/&/g, "&amp;")
+                .replace(/"/g, "&quot;")
+                .replace(/</g, "&lt;")
+                .replace(/>/g, "&gt;");
+}
+
 
 /**
  * An Editable encapsulates the UI of an edit box that overlays a label,
  * allowing the user to edit the value.
  *
  * @param Variable aVariable
  *        The Variable or Property to make editable.
  * @param object aOptions
diff --git a/browser/devtools/webconsole/console-output.js b/browser/devtools/webconsole/console-output.js
--- a/browser/devtools/webconsole/console-output.js
+++ b/browser/devtools/webconsole/console-output.js
@@ -992,20 +992,22 @@ Messages.Extended.prototype = Heritage.e
       }
       if (piece.type == "longString") {
         let widget = new Widgets.LongString(this, piece).render();
         return widget.element;
       }
     }
 
     let result = this.document.createDocumentFragment();
-    if (!isPrimitive || (!this._quoteStrings && typeof piece == "string")) {
+    if (isPrimitive) {
+      result.textContent = VariablesView.getString(piece, {
+        noStringQuotes: !this._quoteStrings,
+      });
+    } else {
       result.textContent = piece;
-    } else {
-      result.textContent = VariablesView.getString(piece);
     }
 
     return result;
   },
 }); // Messages.Extended.prototype
 
 
 
@@ -1268,21 +1270,20 @@ Widgets.LongString.prototype = Heritage.
   /**
    * Render the long string in the widget element.
    * @private
    * @param string str
    *        The string to display.
    */
   _renderString: function(str)
   {
-    if (this.message._quoteStrings) {
-      this.element.textContent = VariablesView.getString(str);
-    } else {
-      this.element.textContent = str;
-    }
+    this.element.textContent = VariablesView.getString(str, {
+      noStringQuotes: !this.message._quoteStrings,
+      noEllipsis: true,
+    });
   },
 
   /**
    * Render the anchor ellipsis that allows the user to expand the long string.
    *
    * @private
    * @return Element
    */
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -1178,20 +1178,16 @@ WebConsoleFrame.prototype = {
         node = msg.init(this.output).render().element;
         break;
       }
       case "dir": {
         body = { arguments: args };
         let clipboardArray = [];
         args.forEach((aValue) => {
           clipboardArray.push(VariablesView.getString(aValue));
-          if (aValue && typeof aValue == "object" &&
-              aValue.type == "longString") {
-            clipboardArray.push(l10n.getStr("longStringEllipsis"));
-          }
         });
         clipboardText = clipboardArray.join(" ");
         break;
       }
 
       case "trace": {
         let filename = WebConsoleUtils.abbreviateSourceURL(aMessage.filename);
         let functionName = aMessage.functionName ||
diff --git a/toolkit/devtools/server/actors/script.js b/toolkit/devtools/server/actors/script.js
--- a/toolkit/devtools/server/actors/script.js
+++ b/toolkit/devtools/server/actors/script.js
@@ -1,16 +1,24 @@
 /* -*- Mode: javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2; js-indent-level: 2; -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
+const TYPED_ARRAY_CLASSES = ["Uint8Array", "Uint8ClampedArray", "Uint16Array",
+      "Uint32Array", "Int8Array", "Int16Array", "Int32Array", "Float32Array",
+      "Float64Array"];
+
+// Number of items to preview in objects, arrays, maps, sets, lists,
+// collections, etc.
+const OBJECT_PREVIEW_MAX_ITEMS = 10;
+
 /**
  * BreakpointStore objects keep track of all breakpoints that get set so that we
  * can reset them when the same script is introduced to the thread again (such
  * as after a refresh).
  */
 function BreakpointStore() {
   // If we have a whole-line breakpoint set at LINE in URL, then
   //
@@ -435,25 +443,30 @@ function ThreadActor(aHooks, aGlobal)
   this.findGlobals = this.globalManager.findGlobals.bind(this);
   this.onNewGlobal = this.globalManager.onNewGlobal.bind(this);
   this.onNewSource = this.onNewSource.bind(this);
   this._allEventsListener = this._allEventsListener.bind(this);
 
   this._options = {
     useSourceMaps: false
   };
+
+  this._gripDepth = 0;
 }
 
 /**
  * The breakpoint store must be shared across instances of ThreadActor so that
  * page reloads don't blow away all of our breakpoints.
  */
 ThreadActor.breakpointStore = new BreakpointStore();
 
 ThreadActor.prototype = {
+  // Used by the ObjectActor to keep track of the depth of grip() calls.
+  _gripDepth: null,
+
   actorPrefix: "context",
 
   get state() { return this._state; },
   get attached() this.state == "attached" ||
                  this.state == "running" ||
                  this.state == "paused",
 
   get breakpointStore() { return ThreadActor.breakpointStore; },
@@ -2815,20 +2828,16 @@ let stringifiers = {
  *        The debuggee object.
  * @param aThreadActor ThreadActor
  *        The parent thread actor for this object.
  */
 function ObjectActor(aObj, aThreadActor)
 {
   this.obj = aObj;
   this.threadActor = aThreadActor;
-
-  if (!("_gripDepth" in this.threadActor)) {
-    this.threadActor._gripDepth = 0;
-  }
 }
 
 ObjectActor.prototype = {
   actorPrefix: "obj",
 
   /**
    * Returns a grip for this actor for returning in a protocol message.
    */
@@ -3050,17 +3059,17 @@ ObjectActor.prototype = {
     }
 
     let getters = new Set();
     let names = [];
     try {
       names = aObject.getOwnPropertyNames()
     } catch (ex) {
       // Calling getOwnPropertyNames() on wrapped native prototypes is not
-      // allowed: "cannot modify properties of a WrappedNative".
+      // allowed: "cannot modify properties of a WrappedNative". See bug 560072.
     }
 
     for (let name of names) {
       let desc = null;
       try {
         desc = aObject.getOwnPropertyDescriptor(name);
       } catch (e) {
         // Calling getOwnPropertyDescriptor on wrapped native prototypes is not
@@ -3118,18 +3127,25 @@ ObjectActor.prototype = {
     return { from: this.actorID,
              displayString: this.threadActor.createValueGrip(string) };
   },
 
   /**
    * A helper method that creates a property descriptor for the provided object,
    * properly formatted for sending in a protocol response.
    *
+   * @private
    * @param string aName
    *        The property that the descriptor is generated for.
+   * @param boolean aOnlyEnumerable
+   *        True if you want a descriptor only for an enumerable property, false
+   *        otherwise.
+   * @return object|undefined
+   *         The property descriptor, or undefined if this is not an enumerable
+   *         property and aOnlyEnumerable=true.
    */
   _propertyDescriptor: function (aName, aOnlyEnumerable) {
     let desc;
     try {
       desc = this.obj.getOwnPropertyDescriptor(aName);
     } catch (e) {
       // Calling getOwnPropertyDescriptor on wrapped native prototypes is not
       // allowed (bug 560072). Inform the user with a bogus, but hopefully
@@ -3241,19 +3257,16 @@ ObjectActor.prototype.requestTypes = {
   "property": ObjectActor.prototype.onProperty,
   "displayString": ObjectActor.prototype.onDisplayString,
   "ownPropertyNames": ObjectActor.prototype.onOwnPropertyNames,
   "decompile": ObjectActor.prototype.onDecompile,
   "release": ObjectActor.prototype.onRelease,
   "scope": ObjectActor.prototype.onScope,
 };
 
-// Number of items to preview in objects, arrays, maps, sets, lists,
-// collections, etc.
-const OBJECT_PREVIEW_MAX_ITEMS = 10;
 
 /**
  * Functions for adding information to ObjectActor grips for the purpose of
  * having customized output. This object holds arrays mapped by
  * DebuggerObject.class.
  *
  * In each array you can add functions that take two
  * arguments:
@@ -3268,55 +3281,59 @@ const OBJECT_PREVIEW_MAX_ITEMS = 10;
  */
 DebuggerServer.ObjectActorPreviewers = {
   Function: [function({obj, threadActor}, aGrip) {
     if (obj.name) {
       aGrip.name = obj.name;
     }
 
     if (obj.displayName) {
-      aGrip.displayName = obj.displayName;
+      aGrip.displayName = obj.displayName.substr(0, 500);
     }
 
     if (obj.parameterNames) {
       aGrip.parameterNames = obj.parameterNames;
     }
 
     // Check if the developer has added a de-facto standard displayName
     // property for us to use.
+    let userDisplayName;
     try {
-      let desc = obj.getOwnPropertyDescriptor("displayName");
-      if (desc && desc.value && typeof desc.value == "string") {
-        aGrip.userDisplayName = threadActor.createValueGrip(desc.value);
-      }
+      userDisplayName = obj.getOwnPropertyDescriptor("displayName");
     } catch (e) {
       // Calling getOwnPropertyDescriptor with displayName might throw
       // with "permission denied" errors for some functions.
       dumpn(e);
     }
 
+    if (userDisplayName && userDisplayName.value &&
+        typeof userDisplayName.value == "string") {
+      aGrip.userDisplayName = threadActor.createValueGrip(userDisplayName.value);
+    }
+
     return true;
   }], // Function
 
   RegExp: [function({obj, threadActor}, aGrip) {
+    // Avoid having any special preview for the RegExp.prototype itself.
     if (!obj.proto || obj.proto.class != "RegExp") {
       return false;
     }
 
-    let raw = obj.unsafeDereference();
-    let str = RegExp.prototype.toString.call(raw);
+    let str = RegExp.prototype.toString.call(obj.unsafeDereference());
     aGrip.displayString = threadActor.createValueGrip(str);
     return true;
   }],
 
   Date: [function({obj, threadActor}, aGrip) {
+    if (!obj.proto || obj.proto.class != "Date") {
+      return false;
+    }
+
     let time = Date.prototype.getTime.call(obj.unsafeDereference());
-    if (isNaN(time)) {
-      return false;
-    }
 
     aGrip.preview = {
       timestamp: threadActor.createValueGrip(time),
     };
     return true;
   }],
 
   Array: [function({obj, threadActor}, aGrip) {
@@ -3332,26 +3349,26 @@ DebuggerServer.ObjectActorPreviewers = {
 
     if (threadActor._gripDepth > 1) {
       return true;
     }
 
     let raw = obj.unsafeDereference();
     let items = aGrip.preview.items = [];
 
-    Array.some(raw, (item) => {
-      let value = item;
+    for (let [, value] of Array.prototype.entries.call(raw)) {
       if (value && typeof value == "object") {
-        value = obj.makeDebuggeeValue(item);
+        value = obj.makeDebuggeeValue(value);
       }
       items.push(threadActor.createValueGrip(value));
 
-      // Stop iterating the array once we have enough items.
-      return items.length == OBJECT_PREVIEW_MAX_ITEMS;
-    });
+      if (items.length == OBJECT_PREVIEW_MAX_ITEMS) {
+        break;
+      }
+    }
 
     return true;
   }], // Array
 
   Set: [function({obj, threadActor}, aGrip) {
     let size = DevToolsUtils.getProperty(obj, "size");
     if (typeof size != "number") {
       return false;
@@ -3419,25 +3436,24 @@ DebuggerServer.ObjectActorPreviewers = {
   DOMStringMap: [function({obj, threadActor}, aGrip, aRawObj) {
     if (!aRawObj) {
       return false;
     }
 
     let keys = obj.getOwnPropertyNames();
     aGrip.preview = {
       kind: "MapLike",
-      entries: [],
       size: keys.length,
     };
 
     if (threadActor._gripDepth > 1) {
-      return false;
-    }
-
-    let entries = aGrip.preview.entries;
+      return true;
+    }
+
+    let entries = aGrip.preview.entries = [];
     for (let key of keys) {
       let value = aRawObj[key];
       if (value && typeof value == "object") {
         value = obj.makeDebuggeeValue(value);
       }
       entries.push([key, threadActor.createValueGrip(value)]);
       if (entries.length == OBJECT_PREVIEW_MAX_ITEMS) {
         break;
@@ -3445,16 +3461,47 @@ DebuggerServer.ObjectActorPreviewers = {
     }
 
     return true;
   }], // DOMStringMap
 }; // DebuggerServer.ObjectActorPreviewers
 
 // Preview functions that do not rely on the object class.
 DebuggerServer.ObjectActorPreviewers.Object = [
+  function TypedArray({obj, threadActor}, aGrip) {
+    if (TYPED_ARRAY_CLASSES.indexOf(obj.class) == -1) {
+      return false;
+    }
+
+    let length = DevToolsUtils.getProperty(obj, "length");
+    if (typeof length != "number") {
+      return false;
+    }
+
+    aGrip.preview = {
+      kind: "ArrayLike",
+      length: length,
+    };
+
+    if (threadActor._gripDepth > 1) {
+      return true;
+    }
+
+    let raw = obj.unsafeDereference();
+    let global = Cu.getGlobalForObject(DebuggerServer);
+    let classProto = global[obj.class].prototype;
+    let safeView = classProto.subarray.call(raw, 0, OBJECT_PREVIEW_MAX_ITEMS);
+    let items = aGrip.preview.items = [];
+    for (let i = 0; i < safeView.length; i++) {
+      items.push(safeView[i]);
+    }
+
+    return true;
+  }, // TypedArray
+
   function Error({obj, threadActor}, aGrip) {
     switch (obj.class) {
       case "Error":
       case "EvalError":
       case "RangeError":
       case "ReferenceError":
       case "SyntaxError":
       case "TypeError":
@@ -3480,74 +3527,54 @@ DebuggerServer.ObjectActorPreviewers.Obj
     }
   },
 
   function CSSMediaRule({obj, threadActor}, aGrip, aRawObj) {
     if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMCSSMediaRule)) {
       return false;
     }
     aGrip.preview = {
-      kind: "CSSMediaRule",
-      conditionText: threadActor.createValueGrip(aRawObj.conditionText),
+      kind: "ObjectWithText",
+      text: threadActor.createValueGrip(aRawObj.conditionText),
     };
     return true;
   },
 
   function CSSStyleRule({obj, threadActor}, aGrip, aRawObj) {
     if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMCSSStyleRule)) {
       return false;
     }
     aGrip.preview = {
-      kind: "CSSStyleRule",
-      selectorText: threadActor.createValueGrip(aRawObj.selectorText),
+      kind: "ObjectWithText",
+      text: threadActor.createValueGrip(aRawObj.selectorText),
     };
     return true;
   },
 
-  function CSSImportRule({obj, threadActor}, aGrip, aRawObj) {
-    if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMCSSImportRule)) {
+  function ObjectWithURL({obj, threadActor}, aGrip, aRawObj) {
+    if (!aRawObj ||
+        !(aRawObj instanceof Ci.nsIDOMCSSImportRule ||
+          aRawObj instanceof Ci.nsIDOMCSSStyleSheet ||
+          aRawObj instanceof Ci.nsIDOMLocation ||
+          aRawObj instanceof Ci.nsIDOMWindow)) {
       return false;
     }
+
+    let url;
+    if (aRawObj instanceof Ci.nsIDOMWindow) {
+      url = aRawObj.location.href;
+    } else {
+      url = aRawObj.href;
+    }
+
     aGrip.preview = {
-      kind: "CSSImportRule",
-      href: threadActor.createValueGrip(aRawObj.href),
+      kind: "ObjectWithURL",
+      url: threadActor.createValueGrip(url),
     };
-    return true;
-  },
-
-  function CSSStyleSheet({obj, threadActor}, aGrip, aRawObj) {
-    if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMCSSStyleSheet)) {
-      return false;
-    }
-    aGrip.preview = {
-      kind: "CSSStyleSheet",
-      href: threadActor.createValueGrip(aRawObj.href),
-    };
-    return true;
-  },
-
-  function DOMLocation({obj, threadActor}, aGrip, aRawObj) {
-    if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMLocation)) {
-      return false;
-    }
-    aGrip.preview = {
-      kind: "DOMLocation",
-      href: threadActor.createValueGrip(aRawObj.href),
-    };
-    return true;
-  },
-
-  function DOMWindow({obj, threadActor}, aGrip, aRawObj) {
-    if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMWindow)) {
-      return false;
-    }
-    aGrip.preview = {
-      kind: "DOMWindow",
-      location: threadActor.createValueGrip(aRawObj.location.href),
-    };
+
     return true;
   },
 
   function ArrayLike({obj, threadActor}, aGrip, aRawObj) {
     if (!aRawObj ||
         obj.class != "DOMTokenList" &&
         !(aRawObj instanceof Ci.nsIDOMMozNamedAttrMap ||
           aRawObj instanceof Ci.nsIDOMCSSRuleList ||
@@ -3591,20 +3618,20 @@ DebuggerServer.ObjectActorPreviewers.Obj
 
   function CSSStyleDeclaration({obj, threadActor}, aGrip, aRawObj) {
     if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMCSSStyleDeclaration)) {
       return false;
     }
 
     aGrip.preview = {
       kind: "MapLike",
-      entries: [],
       size: aRawObj.length,
     };
-    let entries = aGrip.preview.entries;
+
+    let entries = aGrip.preview.entries = [];
 
     for (let i = 0; i < OBJECT_PREVIEW_MAX_ITEMS &&
                     i < aRawObj.length; i++) {
       let prop = aRawObj[i];
       let value = aRawObj.getPropertyValue(prop);
       entries.push([prop, threadActor.createValueGrip(value)]);
     }
 
@@ -3761,24 +3788,25 @@ DebuggerServer.ObjectActorPreviewers.Obj
   function GenericObject(aObjectActor, aGrip) {
     let {obj, threadActor} = aObjectActor;
     if (aGrip.preview || aGrip.displayString || threadActor._gripDepth > 1) {
       return false;
     }
 
     let i = 0, names = [];
     let preview = aGrip.preview = {
+      kind: "Object",
       ownProperties: Object.create(null),
     };
 
     try {
       names = obj.getOwnPropertyNames();
     } catch (ex) {
       // Calling getOwnPropertyNames() on wrapped native prototypes is not
-      // allowed: "cannot modify properties of a WrappedNative".
+      // allowed: "cannot modify properties of a WrappedNative". See bug 560072.
     }
 
     preview.ownPropertiesLength = names.length;
 
     for (let name of names) {
       let desc = aObjectActor._propertyDescriptor(name, true);
       if (!desc) {
         continue;
diff --git a/toolkit/devtools/server/actors/webconsole.js b/toolkit/devtools/server/actors/webconsole.js
--- a/toolkit/devtools/server/actors/webconsole.js
+++ b/toolkit/devtools/server/actors/webconsole.js
@@ -56,16 +56,17 @@ function WebConsoleActor(aConnection, aP
   this.conn.addActorPool(this._actorPool);
 
   this._prefs = {};
 
   this.dbg = new Debugger();
 
   this._protoChains = new Map();
   this._netEvents = new Map();
+  this._gripDepth = 0;
 
   this._onObserverNotification = this._onObserverNotification.bind(this);
   if (this.parentActor.isRootActor) {
     Services.obs.addObserver(this._onObserverNotification,
                              "last-pb-context-exited", false);
   }
 }
 
@@ -76,16 +77,23 @@ WebConsoleActor.prototype =
   /**
    * Debugger instance.
    *
    * @see jsdebugger.jsm
    */
   dbg: null,
 
   /**
+   * This is used by the ObjectActor to keep track of the depth of grip() calls.
+   * @private
+   * @type number
+   */
+  _gripDepth: null,
+
+  /**
    * Actor pool for all of the actors we send to the client.
    * @private
    * @type object
    * @see ActorPool
    */
   _actorPool: null,
 
   /**
diff --git a/toolkit/devtools/webconsole/utils.js b/toolkit/devtools/webconsole/utils.js
--- a/toolkit/devtools/webconsole/utils.js
+++ b/toolkit/devtools/webconsole/utils.js
@@ -183,20 +183,26 @@ let WebConsoleUtils = {
   },
 
   /**
    * Abbreviates the given source URL so that it can be displayed flush-right
    * without being too distracting.
    *
    * @param string aSourceURL
    *        The source URL to shorten.
+   * @param object [aOptions]
+   *        Options:
+   *        - onlyCropQuery: boolean that tells if the URL abbreviation function
+   *        should only remove the query parameters and the hash fragment from
+   *        the given URL.
    * @return string
    *         The abbreviated form of the source URL.
    */
-  abbreviateSourceURL: function WCU_abbreviateSourceURL(aSourceURL)
+  abbreviateSourceURL:
+  function WCU_abbreviateSourceURL(aSourceURL, aOptions = {})
   {
     if (aSourceURL.substr(0, 5) == "data:") {
       let commaIndex = aSourceURL.indexOf(",");
       if (commaIndex > -1) {
         aSourceURL = "data:" + aSourceURL.substring(commaIndex + 1);
       }
     }
 
@@ -209,23 +215,25 @@ let WebConsoleUtils = {
     // Remove any hash fragments.
     let hashIndex = aSourceURL.indexOf("#");
     if (hashIndex > -1) {
       aSourceURL = aSourceURL.substring(0, hashIndex);
     }
 
     // Remove a trailing "/".
     if (aSourceURL[aSourceURL.length - 1] == "/") {
-      aSourceURL = aSourceURL.substring(0, aSourceURL.length - 1);
+      aSourceURL = aSourceURL.replace(/\/+$/, "");
     }
 
     // Remove all but the last path component.
-    let slashIndex = aSourceURL.lastIndexOf("/");
-    if (slashIndex > -1) {
-      aSourceURL = aSourceURL.substring(slashIndex + 1);
+    if (!aOptions.onlyCropQuery) {
+      let slashIndex = aSourceURL.lastIndexOf("/");
+      if (slashIndex > -1) {
+        aSourceURL = aSourceURL.substring(slashIndex + 1);
+      }
     }
 
     return aSourceURL;
   },
 
   /**
    * Tells if the given function is native or not.
    *
