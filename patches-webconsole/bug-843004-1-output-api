# HG changeset patch
# Parent 7d968603fad1e2a3b8add078639da230f512b115
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1385070874 -7200

Bug 843004 - Part 1: use the ConsoleOutput API for eval results and for console API messages; r=robcee; try: -b do -p linux,linux64,macosx64,win32,win64 -u xpcshell,mochitest-o,mochitest-bc -t none

diff --git a/browser/devtools/webconsole/console-output.js b/browser/devtools/webconsole/console-output.js
--- a/browser/devtools/webconsole/console-output.js
+++ b/browser/devtools/webconsole/console-output.js
@@ -1,18 +1,26 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
+const {Cc, Ci, Cu} = require("chrome");
+
+loader.lazyImporter(this, "VariablesView", "resource:///modules/devtools/VariablesView.jsm");
+
 const Heritage = require("sdk/core/heritage");
 const XHTML_NS = "http://www.w3.org/1999/xhtml";
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
+
+const WebConsoleUtils = require("devtools/toolkit/webconsole/utils").Utils;
+const l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 
 // Constants for compatibility with the Web Console output implementation before
 // bug 778766.
 // TODO: remove these once bug 778766 is fixed.
 const COMPAT = {
   // The various categories of messages.
   CATEGORIES: {
     NETWORK: 0,
@@ -26,18 +34,67 @@ const COMPAT = {
 
   // The possible message severities.
   SEVERITIES: {
     ERROR: 0,
     WARNING: 1,
     INFO: 2,
     LOG: 3,
   },
+
+  // The preference keys to use for each category/severity combination, indexed
+  // first by category (rows) and then by severity (columns).
+  //
+  // Most of these rather idiosyncratic names are historical and predate the
+  // division of message type into "category" and "severity".
+  PREFERENCE_KEYS: [
+    // Error        Warning       Info    Log
+    [ "network",    "netwarn",    null,   "networkinfo", ],  // Network
+    [ "csserror",   "cssparser",  null,   null,          ],  // CSS
+    [ "exception",  "jswarn",     null,   "jslog",       ],  // JS
+    [ "error",      "warn",       "info", "log",         ],  // Web Developer
+    [ null,         null,         null,   null,          ],  // Input
+    [ null,         null,         null,   null,          ],  // Output
+    [ "secerror",   "secwarn",    null,   null,          ],  // Security
+  ],
+
+  // The fragment of a CSS class name that identifies each category.
+  CATEGORY_CLASS_FRAGMENTS: [ "network", "cssparser", "exception", "console",
+                              "input", "output", "security" ],
+
+  // The fragment of a CSS class name that identifies each severity.
+  SEVERITY_CLASS_FRAGMENTS: [ "error", "warn", "info", "log" ],
+
+  // The indent of a console group in pixels.
+  GROUP_INDENT: 12,
 };
 
+// A map from the console API call levels to the Web Console severities.
+const CONSOLE_API_LEVELS_TO_SEVERITIES = {
+  error: "error",
+  warn: "warning",
+  info: "info",
+  log: "log",
+  trace: "log",
+  debug: "log",
+  dir: "log",
+  group: "log",
+  groupCollapsed: "log",
+  groupEnd: "log",
+  time: "log",
+  timeEnd: "log"
+};
+
+// Array of known message source URLs we need to hide from output.
+const IGNORED_SOURCE_URLS = ["debugger eval code", "self-hosted"];
+
+// The maximum length of strings to be displayed by the Web Console.
+const MAX_LONG_STRING_LENGTH = 200000;
+
+
 /**
  * The ConsoleOutput object is used to manage output of messages in the Web
  * Console.
  *
  * @constructor
  * @param object owner
  *        The console output owner. This usually the WebConsoleFrame instance.
  *        Any other object can be used, as long as it has the following
@@ -74,16 +131,24 @@ ConsoleOutput.prototype = {
    * The DOM window that holds the output.
    * @type Window
    */
   get window() {
     return this.owner.window;
   },
 
   /**
+   * Getter for the debugger WebConsoleClient.
+   * @type object
+   */
+  get webConsoleClient() {
+    return this.owner.webConsoleClient;
+  },
+
+  /**
    * Add a message to output.
    *
    * @param object ...args
    *        Any number of Message objects.
    * @return this
    */
   addMessage: function(...args)
   {
@@ -204,16 +269,34 @@ ConsoleOutput.prototype = {
     let selection = this.window.getSelection();
     selection.removeAllRanges();
     let range = this.document.createRange();
     range.selectNodeContents(elem);
     selection.addRange(range);
   },
 
   /**
+   * Open an URL in a new tab.
+   * @see WebConsole.openLink() in hudservice.js
+   */
+  openLink: function()
+  {
+    this.owner.owner.openLink.apply(this.owner.owner, arguments);
+  },
+
+  /**
+   * Open the variables view to inspect an object actor.
+   * @see JSTerm.openVariablesView() in webconsole.js
+   */
+  openVariablesView: function()
+  {
+    this.owner.jsterm.openVariablesView.apply(this.owner.jsterm, arguments);
+  },
+
+  /**
    * Destroy this ConsoleOutput instance.
    */
   destroy: function()
   {
     this.owner = null;
   },
 }; // ConsoleOutput.prototype
 
@@ -227,16 +310,19 @@ let Messages = {};
  * The BaseMessage object is used for all types of messages. Every kind of
  * message should use this object as its base.
  *
  * @constructor
  */
 Messages.BaseMessage = function()
 {
   this.widgets = new Set();
+  this._onClickAnchor = this._onClickAnchor.bind(this);
+  this._repeatID = { uid: gSequenceId() };
+  this.textContent = "";
 };
 
 Messages.BaseMessage.prototype = {
   /**
    * Reference to the ConsoleOutput owner.
    *
    * @type object|null
    *       This is |null| if the message is not yet initialized.
@@ -263,68 +349,99 @@ Messages.BaseMessage.prototype = {
    * Tells if this message is visible or not.
    * @type boolean
    */
   get visible() {
     return this.element && this.element.parentNode;
   },
 
   /**
+   * The owner DOM document.
+   * @type DOMElement
+   */
+  get document() {
+    return this.output.document;
+  },
+
+  /**
    * Holds the text-only representation of the message.
    * @type string
    */
-  textContent: "",
+  textContent: null,
 
   /**
    * Set of widgets included in this message.
    * @type Set
    */
   widgets: null,
 
   // Properties that allow compatibility with the current Web Console output
   // implementation.
   _categoryCompat: null,
   _severityCompat: null,
   _categoryNameCompat: null,
   _severityNameCompat: null,
   _filterKeyCompat: null,
 
   /**
+   * Object that is JSON-ified and used as a non-unique ID for tracking
+   * duplicate messages.
+   * @private
+   * @type object
+   */
+  _repeatID: null,
+
+  /**
    * Initialize the message.
    *
    * @param object output
    *        The ConsoleOutput owner.
    * @param object [parent=null]
    *        Optional: a different message object that owns this instance.
    * @return this
    */
   init: function(output, parent=null)
   {
     this.output = output;
     this.parent = parent;
     return this;
   },
 
   /**
+   * Non-unique ID for this message object used for tracking duplicate messages.
+   * Different message kinds can identify themselves based their own criteria.
+   *
+   * @return string
+   */
+  getRepeatID: function()
+  {
+    return JSON.stringify(this._repeatID);
+  },
+
+  /**
    * Render the message. After this method is invoked the |element| property
    * will point to the DOM element of this message.
    * @return this
    */
   render: function()
   {
     if (!this.element) {
       this.element = this._renderCompat();
     }
     return this;
   },
 
   /**
    * Prepare the message container for the Web Console, such that it is
    * compatible with the current implementation.
-   * TODO: remove this once bug 778766.
+   * TODO: remove this once bug 778766 is fixed.
+   *
+   * @private
+   * @return Element
+   *         The DOM element that wraps the message.
    */
   _renderCompat: function()
   {
     let doc = this.output.document;
     let container = doc.createElementNS(XHTML_NS, "div");
     container.id = "console-msg-" + gSequenceId();
     container.className = "message";
     container.category = this._categoryCompat;
@@ -333,41 +450,81 @@ Messages.BaseMessage.prototype = {
     container.setAttribute("severity", this._severityNameCompat);
     container.setAttribute("filter", this._filterKeyCompat);
     container.clipboardText = this.textContent;
     container.timestamp = this.timestamp;
     container._messageObject = this;
 
     return container;
   },
+
+  /**
+   * Add a click callback to a given DOM element.
+   *
+   * @private
+   * @param Element element
+   *        The DOM element to which you want to add a click event handler.
+   * @param function [callback=this._onClickAnchor]
+   *        Optional click event handler. The default event handler is
+   *        |this._onClickAnchor|.
+   */
+  _addLinkCallback: function(element, callback = this._onClickAnchor)
+  {
+    // This is going into the WebConsoleFrame object instance that owns
+    // the ConsoleOutput object. The WebConsoleFrame owner is the WebConsole
+    // object instance from hudservice.js.
+    // TODO: move _addMessageLinkCallback() into ConsoleOutput once bug 778766
+    // is fixed.
+    this.output.owner._addMessageLinkCallback(element, callback);
+  },
+
+  /**
+   * The default |click| event handler for links in the output. This function
+   * opens the anchor's link in a new tab.
+   *
+   * @private
+   * @param Event event
+   *        The DOM event that invoked this function.
+   */
+  _onClickAnchor: function(event)
+  {
+    this.output.openLink(event.target.href);
+  },
 }; // Messages.BaseMessage.prototype
 
 
 /**
  * The NavigationMarker is used to show a page load event.
  *
  * @constructor
  * @extends Messages.BaseMessage
  * @param string url
  *        The URL to display.
  * @param number timestamp
  *        The message date and time, milliseconds elapsed since 1 January 1970
  *        00:00:00 UTC.
  */
 Messages.NavigationMarker = function(url, timestamp)
 {
-  Messages.BaseMessage.apply(this, arguments);
+  Messages.BaseMessage.call(this);
   this._url = url;
   this.textContent = "------ " + url;
   this.timestamp = timestamp;
 };
 
 Messages.NavigationMarker.prototype = Heritage.extend(Messages.BaseMessage.prototype,
 {
   /**
+   * The address of the loading page.
+   * @private
+   * @type string
+   */
+  _url: null,
+
+  /**
    * Message timestamp.
    *
    * @type number
    *       Milliseconds elapsed since 1 January 1970 00:00:00 UTC.
    */
   timestamp: 0,
 
   _categoryCompat: COMPAT.CATEGORIES.NETWORK,
@@ -394,37 +551,812 @@ Messages.NavigationMarker.prototype = He
 
     let doc = this.output.document;
     let urlnode = doc.createElementNS(XHTML_NS, "a");
     urlnode.className = "url";
     urlnode.textContent = url;
     urlnode.title = this._url;
     urlnode.href = this._url;
     urlnode.draggable = false;
-
-    // This is going into the WebConsoleFrame object instance that owns
-    // the ConsoleOutput object. The WebConsoleFrame owner is the WebConsole
-    // object instance from hudservice.js.
-    // TODO: move _addMessageLinkCallback() into ConsoleOutput once bug 778766
-    // is fixed.
-    this.output.owner._addMessageLinkCallback(urlnode, () => {
-      this.output.owner.owner.openLink(this._url);
-    });
+    this._addLinkCallback(urlnode);
 
     let render = Messages.BaseMessage.prototype.render.bind(this);
     render().element.appendChild(urlnode);
     this.element.classList.add("navigation-marker");
     this.element.url = this._url;
     this.element.appendChild(doc.createTextNode("\n"));
 
     return this;
   },
 }); // Messages.NavigationMarker.prototype
 
 
+/**
+ * The Simple message is used to show any basic message in the Web Console.
+ *
+ * @constructor
+ * @extends Messages.BaseMessage
+ * @param string|Node|function message
+ *        The message to display.
+ * @param object [options]
+ *        Options for this message:
+ *        - category: (string) category that this message belongs to. Defaults
+ *        to no category.
+ *        - severity: (string) severity of the message. Defaults to no severity.
+ *        - timestamp: (number) date and time when the message was recorded.
+ *        Defaults to |Date.now()|.
+ *        - link: (string) if provided, the message will be wrapped in an anchor
+ *        pointing to the given URL here.
+ *        - linkCallback: (function) if provided, the message will be wrapped in
+ *        an anchor. The |linkCallback| function will be added as click event
+ *        handler.
+ *        - location: object that tells the message source: url, line, column
+ *        and lineText.
+ *        - className: (string) additional element class names for styling
+ *        purposes.
+ *        - private: (boolean) mark this as a private message.
+ *        - filterDuplicates: (boolean) true if you do want this message to be
+ *        filtered as a potential duplicate message, false otherwise.
+ */
+Messages.Simple = function(message, options = {})
+{
+  Messages.BaseMessage.call(this);
+
+  this.category = options.category;
+  this.severity = options.severity;
+  this.location = options.location;
+  this.timestamp = options.timestamp || Date.now();
+  this.private = !!options.private;
+
+  this._message = message;
+  this._className = options.className;
+  this._link = options.link;
+  this._linkCallback = options.linkCallback;
+  this._filterDuplicates = options.filterDuplicates;
+};
+
+Messages.Simple.prototype = Heritage.extend(Messages.BaseMessage.prototype,
+{
+  /**
+   * Message category.
+   * @type string
+   */
+  category: null,
+
+  /**
+   * Message severity.
+   * @type string
+   */
+  severity: null,
+
+  /**
+   * Message source location. Properties: url, line, column, lineText.
+   * @type object
+   */
+  location: null,
+
+  /**
+   * Tells if this message comes from a private browsing context.
+   * @type boolean
+   */
+  private: false,
+
+  /**
+   * Custom class name for the DOM element of the message.
+   * @private
+   * @type string
+   */
+  _className: null,
+
+  /**
+   * Message link - if this message is clicked then this URL opens in a new tab.
+   * @private
+   * @type string
+   */
+  _link: null,
+
+  /**
+   * Message click event handler.
+   * @private
+   * @type function
+   */
+  _linkCallback: null,
+
+  /**
+   * Tells if this message should be checked if it is a duplicate of another
+   * message or not.
+   */
+  _filterDuplicates: false,
+
+  /**
+   * The raw message displayed by this Message object. This can be a function,
+   * DOM node or a string.
+   *
+   * @private
+   * @type mixed
+   */
+  _message: null,
+
+  _afterMessage: null,
+  _objectActors: null,
+  _groupDepthCompat: 0,
+
+  /**
+   * Message timestamp.
+   *
+   * @type number
+   *       Milliseconds elapsed since 1 January 1970 00:00:00 UTC.
+   */
+  timestamp: 0,
+
+  get _categoryCompat() {
+    return this.category ?
+           COMPAT.CATEGORIES[this.category.toUpperCase()] : null;
+  },
+  get _severityCompat() {
+    return this.severity ?
+           COMPAT.SEVERITIES[this.severity.toUpperCase()] : null;
+  },
+  get _categoryNameCompat() {
+    return this.category ?
+           COMPAT.CATEGORY_CLASS_FRAGMENTS[this._categoryCompat] : null;
+  },
+  get _severityNameCompat() {
+    return this.severity ?
+           COMPAT.SEVERITY_CLASS_FRAGMENTS[this._severityCompat] : null;
+  },
+
+  get _filterKeyCompat() {
+    return this._categoryCompat !== null && this._severityCompat !== null ?
+           COMPAT.PREFERENCE_KEYS[this._categoryCompat][this._severityCompat] :
+           null;
+  },
+
+  init: function()
+  {
+    Messages.BaseMessage.prototype.init.apply(this, arguments);
+    this._groupDepthCompat = this.output.owner.groupDepth;
+    this._initRepeatID();
+    return this;
+  },
+
+  _initRepeatID: function()
+  {
+    if (!this._filterDuplicates) {
+      return;
+    }
+
+    // Add the properties we care about for identifying duplicate messages.
+    let rid = this._repeatID;
+    delete rid.uid;
+
+    rid.category = this.category;
+    rid.severity = this.severity;
+    rid.private = this.private;
+    rid.location = this.location;
+    rid.link = this._link;
+    rid.linkCallback = this._linkCallback + "";
+    rid.className = this._className;
+    rid.groupDepth = this._groupDepthCompat;
+    rid.textContent = "";
+  },
+
+  getRepeatID: function()
+  {
+    // No point in returning a string that includes other properties when there
+    // is a unique ID.
+    if (this._repeatID.uid) {
+      return JSON.stringify({ uid: this._repeatID.uid });
+    }
+
+    return JSON.stringify(this._repeatID);
+  },
+
+  render: function()
+  {
+    if (this.element) {
+      return this;
+    }
+
+    let timestamp = new Widgets.MessageTimestamp(this, this.timestamp).render();
+
+    let icon = this.document.createElementNS(XHTML_NS, "span");
+    icon.className = "icon";
+
+    let body = this._renderBody();
+    this._repeatID.textContent += "|" + body.textContent;
+
+    let repeatNode = this._renderRepeatNode();
+    let location = this._renderLocation();
+
+    Messages.BaseMessage.prototype.render.call(this);
+    if (this._className) {
+      this.element.className += " " + this._className;
+    }
+
+    this.element.appendChild(timestamp.element);
+    this.element.appendChild(icon);
+    this.element.appendChild(body);
+    if (repeatNode) {
+      this.element.appendChild(repeatNode);
+    }
+    if (location) {
+      this.element.appendChild(location);
+    }
+    this.element.appendChild(this.document.createTextNode("\n"));
+
+    this.element.clipboardText = this.element.textContent;
+
+    if (this.private) {
+      this.element.setAttribute("private", true);
+    }
+
+    if (this._afterMessage) {
+      this.element._outputAfterNode = this._afterMessage.element;
+      this._afterMessage = null;
+    }
+
+    // TODO: handle object releasing in a more elegant way once all console
+    // messages use the new API - bug 778766.
+    this.element._objectActors = this._objectActors;
+    this._objectActors = null;
+
+    return this;
+  },
+
+  /**
+   * Render the message body DOM element.
+   * @private
+   * @return Element
+   */
+  _renderBody: function()
+  {
+    let body = this.document.createElementNS(XHTML_NS, "span");
+    body.className = "body devtools-monospace";
+
+    let anchor, container = body;
+    if (this._link || this._linkCallback) {
+      container = anchor = this.document.createElementNS(XHTML_NS, "a");
+      anchor.href = this._link || "#";
+      anchor.draggable = false;
+      this._addLinkCallback(anchor, this._linkCallback);
+      body.appendChild(anchor);
+    }
+
+    if (typeof this._message == "function") {
+      container.appendChild(this._message(this));
+    } else if (this._message instanceof Ci.nsIDOMNode) {
+      container.appendChild(this._message);
+    } else {
+      container.textContent = this._message;
+    }
+
+    return body;
+  },
+
+  /**
+   * Render the repeat bubble DOM element part of the message.
+   * @private
+   * @return Element
+   */
+  _renderRepeatNode: function()
+  {
+    if (!this._filterDuplicates) {
+      return null;
+    }
+
+    let repeatNode = this.document.createElementNS(XHTML_NS, "span");
+    repeatNode.setAttribute("value", "1");
+    repeatNode.className = "repeats";
+    repeatNode.textContent = 1;
+    repeatNode._uid = this.getRepeatID();
+    return repeatNode;
+  },
+
+  /**
+   * Render the message source location DOM element.
+   * @private
+   * @return Element
+   */
+  _renderLocation: function()
+  {
+    if (!this.location) {
+      return null;
+    }
+
+    let {url, line} = this.location;
+    if (IGNORED_SOURCE_URLS.indexOf(url) != -1) {
+      return null;
+    }
+
+    // The ConsoleOutput owner is a WebConsoleFrame instance from webconsole.js.
+    // TODO: move createLocationNode() into this file when bug 778766 is fixed.
+    return this.output.owner.createLocationNode(url, line);
+  },
+}); // Messages.Simple.prototype
+
+
+/**
+ * The Extended message.
+ *
+ * @constructor
+ * @extends Messages.Simple
+ * @param array messagePieces
+ *        The message to display given as an array of elements. Each array
+ *        element can be a DOM node, function, ObjectActor, LongString or
+ *        a string.
+ * @param object [options]
+ *        Options for rendering this message:
+ *        - quoteStrings: boolean that tells if you want strings to be wrapped
+ *        in quotes or not.
+ */
+Messages.Extended = function(messagePieces, options = {})
+{
+  Messages.Simple.call(this, null, options);
+
+  this._messagePieces = messagePieces;
+
+  if ("quoteStrings" in options) {
+    this._quoteStrings = options.quoteStrings;
+  }
+
+  this._repeatID.quoteStrings = this._quoteStrings;
+  this._repeatID.messagePieces = messagePieces + "";
+  this._repeatID.actors = new Set(); // using a set to avoid duplicates
+};
+
+Messages.Extended.prototype = Heritage.extend(Messages.Simple.prototype,
+{
+  /**
+   * The message pieces displayed by this message instance.
+   * @private
+   * @type array
+   */
+  _messagePieces: null,
+
+  /**
+   * Boolean that tells if the strings displayed in this message are wrapped.
+   * @private
+   * @type boolean
+   */
+  _quoteStrings: true,
+
+  getRepeatID: function()
+  {
+    if (this._repeatID.uid) {
+      return JSON.stringify({ uid: this._repeatID.uid });
+    }
+
+    // Sets are not stringified correctly. Temporarily switching to an array.
+    let actors = this._repeatID.actors;
+    this._repeatID.actors = [...actors];
+    let result = JSON.stringify(this._repeatID);
+    this._repeatID.actors = actors;
+    return result;
+  },
+
+  render: function()
+  {
+    let result = this.document.createDocumentFragment();
+
+    for (let i = 0; i < this._messagePieces.length; i++) {
+      let separator = i > 0 ? this._renderBodyPieceSeparator() : null;
+      if (separator) {
+        result.appendChild(separator);
+      }
+
+      let piece = this._messagePieces[i];
+      result.appendChild(this._renderBodyPiece(piece));
+    }
+
+    this._message = result;
+    this._messagePieces = null;
+    return Messages.Simple.prototype.render.call(this);
+  },
+
+  /**
+   * Render the separator between the pieces of the message.
+   *
+   * @private
+   * @return Element
+   */
+  _renderBodyPieceSeparator: function() { return null; },
+
+  /**
+   * Render one piece/element of the message array.
+   *
+   * @private
+   * @param mixed piece
+   *        Message element to display - this can be a LongString, ObjectActor,
+   *        DOM node or a function to invoke.
+   * @return Element
+   */
+  _renderBodyPiece: function(piece)
+  {
+    if (piece instanceof Ci.nsIDOMNode) {
+      return piece;
+    }
+    if (typeof piece == "function") {
+      return piece(this);
+    }
+
+    let isPrimitive = VariablesView.isPrimitive({ value: piece });
+    let isActorGrip = WebConsoleUtils.isActorGrip(piece);
+
+    if (isActorGrip) {
+      this._repeatID.actors.add(piece.actor);
+
+      if (!isPrimitive) {
+        let widget = new Widgets.JSObject(this, piece).render();
+        return widget.element;
+      }
+      if (piece.type == "longString") {
+        let widget = new Widgets.LongString(this, piece).render();
+        return widget.element;
+      }
+    }
+
+    let result = this.document.createDocumentFragment();
+    if (!isPrimitive || (!this._quoteStrings && typeof piece == "string")) {
+      result.textContent = piece;
+    } else {
+      result.textContent = VariablesView.getString(piece);
+    }
+
+    return result;
+  },
+}); // Messages.Extended.prototype
+
+
+
+/**
+ * The JavaScriptEvalOutput message.
+ *
+ * @constructor
+ * @extends Messages.Extended
+ * @param object evalResponse
+ *        The evaluation response packet received from the server.
+ * @param string [errorMessage]
+ *        Optional error message to display.
+ */
+Messages.JavaScriptEvalOutput = function(evalResponse, errorMessage)
+{
+  let severity = "log", msg, quoteStrings = true;
+
+  if (errorMessage) {
+    severity = "error";
+    msg = errorMessage;
+    quoteStrings = false;
+  } else {
+    msg = evalResponse.result;
+  }
+
+  let options = {
+    timestamp: evalResponse.timestamp,
+    category: "output",
+    severity: severity,
+    quoteStrings: quoteStrings,
+  };
+  Messages.Extended.call(this, [msg], options);
+};
+
+Messages.JavaScriptEvalOutput.prototype = Messages.Extended.prototype;
+
+/**
+ * The ConsoleGeneric message is used for console API calls.
+ *
+ * @constructor
+ * @extends Messages.Extended
+ * @param object packet
+ *        The Console API call packet received from the server.
+ */
+Messages.ConsoleGeneric = function(packet)
+{
+  let options = {
+    timestamp: packet.timeStamp,
+    category: "webdev",
+    severity: CONSOLE_API_LEVELS_TO_SEVERITIES[packet.level],
+    private: packet.private,
+    filterDuplicates: true,
+    location: {
+      url: packet.filename,
+      line: packet.lineNumber,
+    },
+  };
+  Messages.Extended.call(this, packet.arguments, options);
+  this._repeatID.consoleApiLevel = packet.level;
+};
+
+Messages.ConsoleGeneric.prototype = Heritage.extend(Messages.Extended.prototype,
+{
+  _renderBodyPieceSeparator: function()
+  {
+    return this.document.createTextNode(" ");
+  },
+}); // Messages.ConsoleGeneric.prototype
+
+
+let Widgets = {};
+
+/**
+ * The base widget class.
+ *
+ * @constructor
+ * @param object message
+ *        The owning message.
+ */
+Widgets.BaseWidget = function(message)
+{
+  this.message = message;
+};
+
+Widgets.BaseWidget.prototype = {
+  /**
+   * The owning message object.
+   * @type object
+   */
+  message: null,
+
+  /**
+   * The DOM element of the rendered widget.
+   * @type Element
+   */
+  element: null,
+
+  /**
+   * Getter for the DOM document that holds the output.
+   * @type Document
+   */
+  get document() {
+    return this.message.document;
+  },
+
+  /**
+   * The ConsoleOutput instance that owns this widget instance.
+   */
+  get output() {
+    return this.message.output;
+  },
+
+  /**
+   * Render the widget DOM element.
+   * @return this
+   */
+  render: function() { },
+
+  /**
+   * Destroy this widget instance.
+   */
+  destroy: function() { },
+};
+
+/**
+ * The timestamp widget.
+ *
+ * @constructor
+ * @param object message
+ *        The owning message.
+ * @param number timestamp
+ *        The UNIX timestamp to display.
+ */
+Widgets.MessageTimestamp = function(message, timestamp)
+{
+  Widgets.BaseWidget.call(this, message);
+  this.timestamp = timestamp;
+};
+
+Widgets.MessageTimestamp.prototype = Heritage.extend(Widgets.BaseWidget.prototype,
+{
+  /**
+   * The UNIX timestamp.
+   * @type number
+   */
+  timestamp: 0,
+
+  render: function()
+  {
+    if (this.element) {
+      return this;
+    }
+
+    this.element = this.document.createElementNS(XHTML_NS, "span");
+    this.element.className = "timestamp devtools-monospace";
+    this.element.textContent = l10n.timestampString(this.timestamp) + " ";
+
+    // Apply the current group by indenting appropriately.
+    // TODO: remove this once bug 778766 is fixed.
+    this.element.style.marginRight = this.message._groupDepthCompat *
+                                     COMPAT.GROUP_INDENT + "px";
+
+    return this;
+  },
+}); // Widgets.MessageTimestamp.prototype
+
+
+/**
+ * The JavaScript object widget.
+ *
+ * @constructor
+ * @param object message
+ *        The owning message.
+ * @param object objectActor
+ *        The ObjectActor to display.
+ */
+Widgets.JSObject = function(message, objectActor)
+{
+  Widgets.BaseWidget.call(this, message);
+  this.objectActor = objectActor;
+  this._onClick = this._onClick.bind(this);
+};
+
+Widgets.JSObject.prototype = Heritage.extend(Widgets.BaseWidget.prototype,
+{
+  /**
+   * The ObjectActor displayed by the widget.
+   * @type object
+   */
+  objectActor: null,
+
+  render: function()
+  {
+    if (this.element) {
+      return this;
+    }
+
+    let anchor = this.element = this.document.createElementNS(XHTML_NS, "a");
+    anchor.href = "#";
+    anchor.draggable = false;
+    anchor.textContent = VariablesView.getString(this.objectActor);
+    this.message._addLinkCallback(anchor, this._onClick);
+
+    return this;
+  },
+
+  /**
+   * The click event handler for objects shown inline.
+   * @private
+   */
+  _onClick: function()
+  {
+    this.output.openVariablesView({
+      label: this.element.textContent,
+      objectActor: this.objectActor,
+      autofocus: true,
+    });
+  },
+}); // Widgets.JSObject.prototype
+
+/**
+ * The long string widget.
+ *
+ * @constructor
+ * @param object message
+ *        The owning message.
+ * @param object longStringActor
+ *        The LongStringActor to display.
+ */
+Widgets.LongString = function(message, longStringActor)
+{
+  Widgets.BaseWidget.call(this, message);
+  this.longStringActor = longStringActor;
+  this._onClick = this._onClick.bind(this);
+  this._onSubstring = this._onSubstring.bind(this);
+};
+
+Widgets.LongString.prototype = Heritage.extend(Widgets.BaseWidget.prototype,
+{
+  /**
+   * The LongStringActor displayed by the widget.
+   * @type object
+   */
+  longStringActor: null,
+
+  render: function()
+  {
+    if (this.element) {
+      return this;
+    }
+
+    let result = this.element = this.document.createElementNS(XHTML_NS, "span");
+    result.className = "longString";
+    this._renderString(this.longStringActor.initial);
+    result.appendChild(this._renderEllipsis());
+
+    return this;
+  },
+
+  /**
+   * Render the long string in the widget element.
+   * @private
+   * @param string str
+   *        The string to display.
+   */
+  _renderString: function(str)
+  {
+    if (this.message._quoteStrings) {
+      this.element.textContent = VariablesView.getString(str);
+    } else {
+      this.element.textContent = str;
+    }
+  },
+
+  /**
+   * Render the anchor ellipsis that allows the user to expand the long string.
+   *
+   * @private
+   * @return Element
+   */
+  _renderEllipsis: function()
+  {
+    let ellipsis = this.document.createElementNS(XHTML_NS, "a");
+    ellipsis.className = "longStringEllipsis";
+    ellipsis.textContent = l10n.getStr("longStringEllipsis");
+    ellipsis.href = "#";
+    ellipsis.draggable = false;
+    this.message._addLinkCallback(ellipsis, this._onClick);
+
+    return ellipsis;
+  },
+
+  /**
+   * The click event handler for the ellipsis shown after the short string. This
+   * function expands the element to show the full string.
+   * @private
+   */
+  _onClick: function()
+  {
+    let longString = this.output.webConsoleClient.longString(this.longStringActor);
+    let toIndex = Math.min(longString.length, MAX_LONG_STRING_LENGTH);
+
+    longString.substring(longString.initial.length, toIndex, this._onSubstring);
+  },
+
+  /**
+   * The longString substring response callback.
+   *
+   * @private
+   * @param object response
+   *        Response packet.
+   */
+  _onSubstring: function(response)
+  {
+    if (response.error) {
+      Cu.reportError("LongString substring failure: " + response.error);
+      return;
+    }
+
+    this.element.lastChild.remove();
+    this.element.classList.remove("longString");
+
+    this._renderString(this.longStringActor.initial + response.substring);
+
+    this.output.owner.emit("messages-updated", new Set([this.message.element]));
+
+    let toIndex = Math.min(this.longStringActor.length, MAX_LONG_STRING_LENGTH);
+    if (toIndex != this.longStringActor.length) {
+      this._logWarningAboutStringTooLong();
+    }
+  },
+
+  /**
+   * Inform user that the string he tries to view is too long.
+   * @private
+   */
+  _logWarningAboutStringTooLong: function()
+  {
+    let msg = new Messages.Simple(l10n.getStr("longStringTooLong"), {
+      category: "output",
+      severity: "warning",
+    });
+    this.output.addMessage(msg);
+  },
+}); // Widgets.LongString.prototype
+
+
 function gSequenceId()
 {
   return gSequenceId.n++;
 }
 gSequenceId.n = 0;
 
 exports.ConsoleOutput = ConsoleOutput;
 exports.Messages = Messages;
+exports.Widgets = Widgets;
diff --git a/browser/devtools/webconsole/hudservice.js b/browser/devtools/webconsole/hudservice.js
--- a/browser/devtools/webconsole/hudservice.js
+++ b/browser/devtools/webconsole/hudservice.js
@@ -6,24 +6,24 @@
 
 "use strict";
 
 const {Cc, Ci, Cu} = require("chrome");
 
 let WebConsoleUtils = require("devtools/toolkit/webconsole/utils").Utils;
 let Heritage = require("sdk/core/heritage");
 
-loader.lazyGetter(this, "promise", () => require("sdk/core/promise"));
 loader.lazyGetter(this, "Telemetry", () => require("devtools/shared/telemetry"));
 loader.lazyGetter(this, "WebConsoleFrame", () => require("devtools/webconsole/webconsole").WebConsoleFrame);
 loader.lazyImporter(this, "gDevTools", "resource:///modules/devtools/gDevTools.jsm");
 loader.lazyImporter(this, "devtools", "resource://gre/modules/devtools/Loader.jsm");
 loader.lazyImporter(this, "Services", "resource://gre/modules/Services.jsm");
 loader.lazyImporter(this, "DebuggerServer", "resource://gre/modules/devtools/dbg-server.jsm");
 loader.lazyImporter(this, "DebuggerClient", "resource://gre/modules/devtools/dbg-client.jsm");
+loader.lazyImporter(this, "promise", "resource://gre/modules/Promise.jsm", "Promise");
 
 const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
 let l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 
 const BROWSER_CONSOLE_WINDOW_FEATURES = "chrome,titlebar,toolbar,centerscreen,resizable,dialog=no";
 
 // The preference prefix for all of the Browser Console filters.
 const BROWSER_CONSOLE_FILTER_PREFS_PREFIX = "devtools.browserconsole.filter.";
@@ -103,16 +103,17 @@ HUD_SERVICE.prototype =
    *        The window of the browser console owner.
    * @return object
    *         A promise object for the opening of the new BrowserConsole instance.
    */
   openBrowserConsole:
   function HS_openBrowserConsole(aTarget, aIframeWindow, aChromeWindow)
   {
     let hud = new BrowserConsole(aTarget, aIframeWindow, aChromeWindow);
+    this._browserConsoleID = hud.hudId;
     this.consoles.set(hud.hudId, hud);
     return hud.init();
   },
 
   /**
    * Returns the Web Console object associated to a content window.
    *
    * @param nsIDOMWindow aContentWindow
@@ -252,17 +253,16 @@ HUD_SERVICE.prototype =
       });
 
       return deferred.promise;
     }
 
     connect().then(getTarget).then(openWindow).then((aWindow) => {
       this.openBrowserConsole(target, aWindow, aWindow)
         .then((aBrowserConsole) => {
-          this._browserConsoleID = aBrowserConsole.hudId;
           this._browserConsoleDefer.resolve(aBrowserConsole);
           this._browserConsoleDefer = null;
         })
     }, console.error);
 
     return this._browserConsoleDefer.promise;
   },
 
diff --git a/browser/devtools/webconsole/panel.js b/browser/devtools/webconsole/panel.js
--- a/browser/devtools/webconsole/panel.js
+++ b/browser/devtools/webconsole/panel.js
@@ -1,17 +1,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const {Cc, Ci, Cu} = require("chrome");
 
-loader.lazyGetter(this, "promise", () => require("sdk/core/promise"));
+loader.lazyImporter(this, "promise", "resource://gre/modules/Promise.jsm", "Promise");
 loader.lazyGetter(this, "HUDService", () => require("devtools/webconsole/hudservice"));
 loader.lazyGetter(this, "EventEmitter", () => require("devtools/shared/event-emitter"));
 
 /**
  * A DevToolPanel that controls the Web Console.
  */
 function WebConsolePanel(iframeWindow, toolbox)
 {
diff --git a/browser/devtools/webconsole/test/head.js b/browser/devtools/webconsole/test/head.js
--- a/browser/devtools/webconsole/test/head.js
+++ b/browser/devtools/webconsole/test/head.js
@@ -3,17 +3,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 let WebConsoleUtils, gDevTools, TargetFactory, console, promise, require;
 
 (() => {
   gDevTools = Cu.import("resource:///modules/devtools/gDevTools.jsm", {}).gDevTools;
   console = Cu.import("resource://gre/modules/devtools/Console.jsm", {}).console;
-  promise = Cu.import("resource://gre/modules/commonjs/sdk/core/promise.js", {}).Promise;
+  promise = Cu.import("resource://gre/modules/Promise.jsm", {}).Promise;
 
   let tools = Cu.import("resource://gre/modules/devtools/Loader.jsm", {}).devtools;
   let utils = tools.require("devtools/toolkit/webconsole/utils");
   TargetFactory = tools.TargetFactory;
   WebConsoleUtils = utils.Utils;
   require = tools.require;
 })();
 // promise._reportErrors = true; // please never leave me.
@@ -1067,30 +1067,20 @@ function waitForMessages(aOptions)
     if (aRule.consoleGroup && !checkConsoleGroup(aRule, aElement)) {
       return false;
     }
 
     if (aRule.source && !checkSource(aRule, aElement)) {
       return false;
     }
 
-    if (aRule.type) {
-      // The rule tries to match the newer types of messages, based on their
-      // object constructor.
-      if (!aElement._messageObject ||
-          !(aElement._messageObject instanceof aRule.type)) {
-        return false;
-      }
-    }
-    else if (aElement._messageObject) {
-      // If the message element holds a reference to its object, it means this
-      // is a newer message type. All of the older waitForMessages() rules do
-      // not expect this kind of messages. We return false here.
-      // TODO: we keep this behavior until bug 778766 is fixed. After that we
-      // will not require |type| to match newer types of messages.
+    // The rule tries to match the newer types of messages, based on their
+    // object constructor.
+    if (aRule.type && (!aElement._messageObject ||
+                       !(aElement._messageObject instanceof aRule.type))) {
       return false;
     }
 
     let partialMatch = !!(aRule.consoleTrace || aRule.consoleTime ||
                           aRule.consoleTimeEnd || aRule.type);
 
     if ("category" in aRule && aElement.category != aRule.category) {
       if (partialMatch) {
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -9,17 +9,16 @@
 const {Cc, Ci, Cu} = require("chrome");
 
 let WebConsoleUtils = require("devtools/toolkit/webconsole/utils").Utils;
 
 loader.lazyServiceGetter(this, "clipboardHelper",
                          "@mozilla.org/widget/clipboardhelper;1",
                          "nsIClipboardHelper");
 loader.lazyImporter(this, "Services", "resource://gre/modules/Services.jsm");
-loader.lazyGetter(this, "promise", () => require("sdk/core/promise"));
 loader.lazyGetter(this, "EventEmitter", () => require("devtools/shared/event-emitter"));
 loader.lazyGetter(this, "AutocompletePopup",
                   () => require("devtools/shared/autocomplete-popup").AutocompletePopup);
 loader.lazyGetter(this, "ToolSidebar",
                   () => require("devtools/framework/sidebar").ToolSidebar);
 loader.lazyGetter(this, "NetworkPanel",
                   () => require("devtools/webconsole/network-panel").NetworkPanel);
 loader.lazyGetter(this, "ConsoleOutput",
@@ -27,16 +26,17 @@ loader.lazyGetter(this, "ConsoleOutput",
 loader.lazyGetter(this, "Messages",
                   () => require("devtools/webconsole/console-output").Messages);
 loader.lazyImporter(this, "EnvironmentClient", "resource://gre/modules/devtools/dbg-client.jsm");
 loader.lazyImporter(this, "ObjectClient", "resource://gre/modules/devtools/dbg-client.jsm");
 loader.lazyImporter(this, "VariablesView", "resource:///modules/devtools/VariablesView.jsm");
 loader.lazyImporter(this, "VariablesViewController", "resource:///modules/devtools/VariablesViewController.jsm");
 loader.lazyImporter(this, "PluralForm", "resource://gre/modules/PluralForm.jsm");
 loader.lazyImporter(this, "gDevTools", "resource:///modules/devtools/gDevTools.jsm");
+loader.lazyImporter(this, "promise", "resource://gre/modules/Promise.jsm", "Promise");
 
 const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
 let l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 
 const XHTML_NS = "http://www.w3.org/1999/xhtml";
 
 const MIXED_CONTENT_LEARN_MORE = "https://developer.mozilla.org/docs/Security/MixedContent";
 
@@ -47,20 +47,16 @@ const STRICT_TRANSPORT_SECURITY_LEARN_MO
 const HELP_URL = "https://developer.mozilla.org/docs/Tools/Web_Console/Helpers";
 
 const VARIABLES_VIEW_URL = "chrome://browser/content/devtools/widgets/VariablesView.xul";
 
 const CONSOLE_DIR_VIEW_HEIGHT = 0.6;
 
 const IGNORED_SOURCE_URLS = ["debugger eval code", "self-hosted"];
 
-// The amount of time in milliseconds that must pass between messages to
-// trigger the display of a new group.
-const NEW_GROUP_DELAY = 5000;
-
 // The amount of time in milliseconds that we wait before performing a live
 // search.
 const SEARCH_DELAY = 200;
 
 // The number of lines that are displayed in the console output by default, for
 // each category. The user can change this number by adjusting the hidden
 // "devtools.hud.loglimit.{network,cssparser,exception,console}" preferences.
 const DEFAULT_LOG_LIMIT = 200;
@@ -161,19 +157,16 @@ const OUTPUT_INTERVAL = 50; // milliseco
 const THROTTLE_UPDATES = 1000; // milliseconds
 
 // The preference prefix for all of the Web Console filters.
 const FILTER_PREFS_PREFIX = "devtools.webconsole.filter.";
 
 // The minimum font size.
 const MIN_FONT_SIZE = 10;
 
-// The maximum length of strings to be displayed by the Web Console.
-const MAX_LONG_STRING_LENGTH = 200000;
-
 const PREF_CONNECTION_TIMEOUT = "devtools.debugger.remote-timeout";
 const PREF_PERSISTLOG = "devtools.webconsole.persistlog";
 const PREF_MESSAGE_TIMESTAMP = "devtools.webconsole.timestampMessages";
 
 /**
  * A WebConsoleFrame instance is an interactive console initialized *per target*
  * that displays console log data as well as provides an interactive terminal to
  * manipulate the target's document content.
@@ -1157,30 +1150,35 @@ WebConsoleFrame.prototype = {
   {
     let body = null;
     let clipboardText = null;
     let sourceURL = aMessage.filename;
     let sourceLine = aMessage.lineNumber;
     let level = aMessage.level;
     let args = aMessage.arguments;
     let objectActors = new Set();
+    let node = null;
 
     // Gather the actor IDs.
     args.forEach((aValue) => {
       if (WebConsoleUtils.isActorGrip(aValue)) {
         objectActors.add(aValue.actor);
       }
     });
 
     switch (level) {
       case "log":
       case "info":
       case "warn":
       case "error":
-      case "debug":
+      case "debug": {
+        let msg = new Messages.ConsoleGeneric(aMessage);
+        node = msg.init(this.output).render().element;
+        break;
+      }
       case "dir": {
         body = { arguments: args };
         let clipboardArray = [];
         args.forEach((aValue) => {
           clipboardArray.push(VariablesView.getString(aValue));
           if (aValue && typeof aValue == "object" &&
               aValue.type == "longString") {
             clipboardArray.push(l10n.getStr("longStringEllipsis"));
@@ -1278,28 +1276,32 @@ WebConsoleFrame.prototype = {
         }
         objectActors.clear();
     }
 
     if (level == "groupEnd") {
       return null; // no need to continue
     }
 
-    let node = this.createMessageNode(CATEGORY_WEBDEV, LEVELS[level], body,
-                                      sourceURL, sourceLine, clipboardText,
-                                      level, aMessage.timeStamp);
-    if (aMessage.private) {
-      node.setAttribute("private", true);
+    if (!node) {
+      node = this.createMessageNode(CATEGORY_WEBDEV, LEVELS[level], body,
+                                    sourceURL, sourceLine, clipboardText,
+                                    level, aMessage.timeStamp);
+      if (aMessage.private) {
+        node.setAttribute("private", true);
+      }
     }
 
     if (objectActors.size > 0) {
       node._objectActors = objectActors;
 
-      let repeatNode = node.getElementsByClassName("repeats")[0];
-      repeatNode._uid += [...objectActors].join("-");
+      if (!node._messageObject) {
+        let repeatNode = node.getElementsByClassName("repeats")[0];
+        repeatNode._uid += [...objectActors].join("-");
+      }
     }
 
     if (level == "trace") {
       node._stacktrace = aMessage.stacktrace;
     }
 
     return node;
   },
@@ -1312,36 +1314,16 @@ WebConsoleFrame.prototype = {
    *        The console API message received from the server.
    */
   handleConsoleAPICall: function WCF_handleConsoleAPICall(aMessage)
   {
     this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage, [aMessage]);
   },
 
   /**
-   * The click event handler for objects shown inline coming from the
-   * window.console API.
-   *
-   * @private
-   * @param nsIDOMNode aAnchor
-   *        The object inspector anchor element. This is the clickable element
-   *        in the console.log message we display.
-   * @param object aObjectActor
-   *        The object actor grip.
-   */
-  _consoleLogClick: function WCF__consoleLogClick(aAnchor, aObjectActor)
-  {
-    this.jsterm.openVariablesView({
-      label: aAnchor.textContent,
-      objectActor: aObjectActor,
-      autofocus: true,
-    });
-  },
-
-  /**
    * Reports an error in the page source, either JavaScript or CSS.
    *
    * @param nsIScriptError aScriptError
    *        The error message to report.
    * @return nsIDOMElement|undefined
    *         The message element to display in the Web Console output.
    */
   reportPageError: function WCF_reportPageError(aCategory, aScriptError)
@@ -1535,17 +1517,17 @@ WebConsoleFrame.prototype = {
     mixedContentWarningNode.title = MIXED_CONTENT_LEARN_MORE;
     mixedContentWarningNode.href = MIXED_CONTENT_LEARN_MORE;
     mixedContentWarningNode.className = "learn-more-link";
     mixedContentWarningNode.textContent = mixedContentWarning;
     mixedContentWarningNode.draggable = false;
 
     aLinkNode.appendChild(mixedContentWarningNode);
 
-    this._addMessageLinkCallback(mixedContentWarningNode, (aNode, aEvent) => {
+    this._addMessageLinkCallback(mixedContentWarningNode, (aEvent) => {
       aEvent.stopPropagation();
       this.owner.openLink(MIXED_CONTENT_LEARN_MORE);
     });
   },
 
   /**
    * Adds a more info link node to messages based on the nsIScriptError object
    * that we need to report to the console
@@ -1596,17 +1578,17 @@ WebConsoleFrame.prototype = {
 
     let warningNode = this.document.createElementNS(XHTML_NS, "a");
     warningNode.title = aURL;
     warningNode.href = aURL;
     warningNode.draggable = false;
     warningNode.textContent = moreInfoLabel;
     warningNode.className = "learn-more-link";
 
-    this._addMessageLinkCallback(warningNode, (aNode, aEvent) => {
+    this._addMessageLinkCallback(warningNode, (aEvent) => {
       aEvent.stopPropagation();
       this.owner.openLink(aURL);
     });
 
     aNode.appendChild(warningNode);
   },
 
   /**
@@ -1690,26 +1672,16 @@ WebConsoleFrame.prototype = {
   logWarningAboutReplacedAPI: function WCF_logWarningAboutReplacedAPI()
   {
     let node = this.createMessageNode(CATEGORY_JS, SEVERITY_WARNING,
                                       l10n.getStr("ConsoleAPIDisabled"));
     this.outputMessage(CATEGORY_JS, node);
   },
 
   /**
-   * Inform user that the string he tries to view is too long.
-   */
-  logWarningAboutStringTooLong: function WCF_logWarningAboutStringTooLong()
-  {
-    let node = this.createMessageNode(CATEGORY_JS, SEVERITY_WARNING,
-                                      l10n.getStr("longStringTooLong"));
-    this.outputMessage(CATEGORY_JS, node);
-  },
-
-  /**
    * Handle the network events coming from the remote Web Console.
    *
    * @param object aActor
    *        The NetworkEventActor grip.
    */
   handleNetworkEvent: function WCF_handleNetworkEvent(aActor)
   {
     let networkInfo = {
@@ -2297,24 +2269,40 @@ WebConsoleFrame.prototype = {
    * Prune an item from the output queue.
    *
    * @private
    * @param array aItem
    *        The item you want to remove from the output queue.
    */
   _pruneItemFromQueue: function WCF__pruneItemFromQueue(aItem)
   {
+    // TODO: handle object releasing in a more elegant way once all console
+    // messages use the new API - bug 778766.
+
     let [category, methodOrNode, args] = aItem;
     if (typeof methodOrNode != "function" && methodOrNode._objectActors) {
       for (let actor of methodOrNode._objectActors) {
         this._releaseObject(actor);
       }
       methodOrNode._objectActors.clear();
     }
 
+    if (methodOrNode == this.output._flushMessageQueue &&
+        args[0]._objectActors) {
+      for (let arg of args) {
+        if (!arg._objectActors) {
+          continue;
+        }
+        for (let actor of arg._objectActors) {
+          this._releaseObject(actor);
+        }
+        arg._objectActors.clear();
+      }
+    }
+
     if (category == CATEGORY_NETWORK) {
       let connectionId = null;
       if (methodOrNode == this.logNetEvent) {
         connectionId = args[0];
       }
       else if (typeof methodOrNode != "function") {
         connectionId = methodOrNode._connectionId;
       }
@@ -2477,20 +2465,16 @@ WebConsoleFrame.prototype = {
     if (aBody instanceof Ci.nsIDOMNode) {
       bodyNode.appendChild(aBody);
     }
     else {
       let str = undefined;
       if (aLevel == "dir") {
         str = VariablesView.getString(aBody.arguments[0]);
       }
-      else if (["log", "info", "warn", "error", "debug"].indexOf(aLevel) > -1 &&
-               typeof aBody == "object") {
-        this._makeConsoleLogMessageBody(node, bodyNode, aBody);
-      }
       else {
         str = aBody;
       }
 
       if (str !== undefined) {
         aBody = this.document.createTextNode(str);
         bodyNode.appendChild(aBody);
       }
@@ -2557,136 +2541,16 @@ WebConsoleFrame.prototype = {
       node.appendChild(locationNode);
     }
     node.appendChild(this.document.createTextNode("\n"));
 
     return node;
   },
 
   /**
-   * Make the message body for console.log() calls.
-   *
-   * @private
-   * @param nsIDOMElement aMessage
-   *        The message element that holds the output for the given call.
-   * @param nsIDOMElement aContainer
-   *        The specific element that will hold each part of the console.log
-   *        output.
-   * @param object aBody
-   *        The object given by this.logConsoleAPIMessage(). This object holds
-   *        the call information that we need to display - mainly the arguments
-   *        array of the given API call.
-   */
-  _makeConsoleLogMessageBody:
-  function WCF__makeConsoleLogMessageBody(aMessage, aContainer, aBody)
-  {
-    Object.defineProperty(aMessage, "_panelOpen", {
-      get: function() {
-        let nodes = aContainer.getElementsByTagName("a");
-        return Array.prototype.some.call(nodes, function(aNode) {
-          return aNode._panelOpen;
-        });
-      },
-      enumerable: true,
-      configurable: false
-    });
-
-    aBody.arguments.forEach(function(aItem) {
-      if (aContainer.firstChild) {
-        aContainer.appendChild(this.document.createTextNode(" "));
-      }
-
-      let text = VariablesView.getString(aItem);
-      let inspectable = !VariablesView.isPrimitive({ value: aItem });
-
-      if (aItem && typeof aItem != "object" || !inspectable) {
-        aContainer.appendChild(this.document.createTextNode(text));
-
-        if (aItem.type && aItem.type == "longString") {
-          let ellipsis = this.document.createElementNS(XHTML_NS, "a");
-          ellipsis.classList.add("longStringEllipsis");
-          ellipsis.textContent = l10n.getStr("longStringEllipsis");
-          ellipsis.href = "#";
-          ellipsis.draggable = false;
-
-          let formatter = function(s) '"' + s + '"';
-
-          this._addMessageLinkCallback(ellipsis,
-            this._longStringClick.bind(this, aMessage, aItem, formatter));
-
-          aContainer.appendChild(ellipsis);
-        }
-        return;
-      }
-
-      // For inspectable objects.
-      let elem = this.document.createElementNS(XHTML_NS, "a");
-      elem.setAttribute("aria-haspopup", "true");
-      elem.textContent = text;
-      elem.href = "#";
-      elem.draggable = false;
-
-      this._addMessageLinkCallback(elem,
-        this._consoleLogClick.bind(this, elem, aItem));
-
-      aContainer.appendChild(elem);
-    }, this);
-  },
-
-  /**
-   * Click event handler for the ellipsis shown immediately after a long string.
-   * This method retrieves the full string and updates the console output to
-   * show it.
-   *
-   * @private
-   * @param nsIDOMElement aMessage
-   *        The message element.
-   * @param object aActor
-   *        The LongStringActor instance we work with.
-   * @param [function] aFormatter
-   *        Optional function you can use to format the string received from the
-   *        server, before being displayed in the console.
-   * @param nsIDOMElement aEllipsis
-   *        The DOM element the user can click on to expand the string.
-   */
-  _longStringClick:
-  function WCF__longStringClick(aMessage, aActor, aFormatter, aEllipsis)
-  {
-    if (!aFormatter) {
-      aFormatter = function(s) s;
-    }
-
-    let longString = this.webConsoleClient.longString(aActor);
-    let toIndex = Math.min(longString.length, MAX_LONG_STRING_LENGTH);
-    longString.substring(longString.initial.length, toIndex,
-      function WCF__onSubstring(aResponse) {
-        if (aResponse.error) {
-          Cu.reportError("WCF__longStringClick substring failure: " +
-                         aResponse.error);
-          return;
-        }
-
-        let node = aEllipsis.previousSibling;
-        node.textContent = aFormatter(longString.initial + aResponse.substring);
-        aEllipsis.parentNode.removeChild(aEllipsis);
-
-        if (aMessage.category == CATEGORY_WEBDEV ||
-            aMessage.category == CATEGORY_OUTPUT) {
-          aMessage.clipboardText = aMessage.textContent;
-        }
-
-        this.emit("messages-updated", new Set([aMessage]));
-
-        if (toIndex != longString.length) {
-          this.logWarningAboutStringTooLong();
-        }
-      }.bind(this));
-  },
-
-  /**
    * Creates the anchor that displays the textual location of an incoming
    * message.
    *
    * @param string aSourceURL
    *        The URL of the source file responsible for the error.
    * @param number aSourceLine [optional]
    *        The line number on which the error occurred. If zero or omitted,
    *        there is no line number associated with this message.
@@ -2802,17 +2666,17 @@ WebConsoleFrame.prototype = {
 
       // If this event started with a mousedown event and it ends at a different
       // location, we consider this text selection.
       if (mousedown && this._startX != aEvent.clientX &&
           this._startY != aEvent.clientY) {
         return;
       }
 
-      aCallback(this, aEvent);
+      aCallback.call(this, aEvent);
     }, false);
   },
 
   /**
    * Handler for the pref-changed event coming from the toolbox.
    * Currently this function only handles the timestamps preferences.
    *
    * @private
@@ -3183,57 +3047,52 @@ JSTerm.prototype = {
 
     this.lastInputValue && this.setInputValue(this.lastInputValue);
   },
 
   /**
    * The JavaScript evaluation response handler.
    *
    * @private
-   * @param nsIDOMElement [aAfterNode]
-   *        Optional DOM element after which the evaluation result will be
+   * @param object [aAfterMessage]
+   *        Optional message after which the evaluation result will be
    *        inserted.
    * @param function [aCallback]
    *        Optional function to invoke when the evaluation result is added to
    *        the output.
    * @param object aResponse
    *        The message received from the server.
    */
   _executeResultCallback:
-  function JST__executeResultCallback(aAfterNode, aCallback, aResponse)
+  function JST__executeResultCallback(aAfterMessage, aCallback, aResponse)
   {
     if (!this.hud) {
       return;
     }
     if (aResponse.error) {
       Cu.reportError("Evaluation error " + aResponse.error + ": " +
                      aResponse.message);
       return;
     }
     let errorMessage = aResponse.exceptionMessage;
     let result = aResponse.result;
-    let inspectable = false;
-    if (result && !VariablesView.isPrimitive({ value: result })) {
-      inspectable = true;
-    }
     let helperResult = aResponse.helperResult;
     let helperHasRawOutput = !!(helperResult || {}).rawOutput;
-    let resultString = VariablesView.getString(result);
 
     if (helperResult && helperResult.type) {
       switch (helperResult.type) {
         case "clearOutput":
           this.clearOutput();
           break;
         case "inspectObject":
-          if (aAfterNode) {
-            if (!aAfterNode._objectActors) {
-              aAfterNode._objectActors = new Set();
+          if (aAfterMessage) {
+            if (!aAfterMessage._objectActors) {
+              aAfterMessage._objectActors = new Set();
             }
-            aAfterNode._objectActors.add(helperResult.object.actor);
+            aAfterMessage._objectActors.add(helperResult.object.actor);
           }
           this.openVariablesView({
             label: VariablesView.getString(helperResult.object),
             objectActor: helperResult.object,
           });
           break;
         case "error":
           try {
@@ -3252,76 +3111,42 @@ JSTerm.prototype = {
     // Hide undefined results coming from JSTerm helper functions.
     if (!errorMessage && result && typeof result == "object" &&
         result.type == "undefined" &&
         helperResult && !helperHasRawOutput) {
       aCallback && aCallback();
       return;
     }
 
-    let node;
-
-    if (errorMessage) {
-      node = this.writeOutput(errorMessage, CATEGORY_OUTPUT, SEVERITY_ERROR,
-                              aAfterNode, aResponse.timestamp);
-    }
-    else if (inspectable) {
-      node = this.writeOutputJS(resultString,
-                                this._evalOutputClick.bind(this, aResponse),
-                                aAfterNode, aResponse.timestamp);
-    }
-    else {
-      node = this.writeOutput(resultString, CATEGORY_OUTPUT, SEVERITY_LOG,
-                              aAfterNode, aResponse.timestamp);
-    }
+    let msg = new Messages.JavaScriptEvalOutput(aResponse, errorMessage);
+    this.hud.output.addMessage(msg);
 
     if (aCallback) {
       let oldFlushCallback = this.hud._flushCallback;
       this.hud._flushCallback = () => {
-        aCallback(node);
+        aCallback(msg.element);
         if (oldFlushCallback) {
           oldFlushCallback();
           this.hud._flushCallback = oldFlushCallback;
         }
         else {
           this.hud._flushCallback = null;
         }
       };
     }
 
-    node._objectActors = new Set();
-
-    let error = aResponse.exception;
-    if (WebConsoleUtils.isActorGrip(error)) {
-      node._objectActors.add(error.actor);
+    msg._afterMessage = aAfterMessage;
+    msg._objectActors = new Set();
+
+    if (WebConsoleUtils.isActorGrip(aResponse.exception)) {
+      msg._objectActors.add(aResponse.exception.actor);
     }
 
     if (WebConsoleUtils.isActorGrip(result)) {
-      node._objectActors.add(result.actor);
-
-      if (result.type == "longString") {
-        // Add an ellipsis to expand the short string if the object is not
-        // inspectable.
-
-        let body = node.getElementsByClassName("body")[0];
-        let ellipsis = this.hud.document.createElementNS(XHTML_NS, "a");
-        ellipsis.classList.add("longStringEllipsis");
-        ellipsis.textContent = l10n.getStr("longStringEllipsis");
-        ellipsis.href = "#";
-        ellipsis.draggable = false;
-
-        let formatter = function(s) '"' + s + '"';
-        let onclick = this.hud._longStringClick.bind(this.hud, node, result,
-                                                    formatter);
-        this.hud._addMessageLinkCallback(ellipsis, onclick);
-
-        body.appendChild(ellipsis);
-
-        node.clipboardText += " " + ellipsis.textContent;
-      }
+      msg._objectActors.add(result.actor);
     }
   },
 
   /**
    * Execute a string. Execution happens asynchronously in the content process.
    *
    * @param string [aExecuteString]
    *        The string you want to execute. If this is not provided, the current
@@ -3332,18 +3157,22 @@ JSTerm.prototype = {
   execute: function JST_execute(aExecuteString, aCallback)
   {
     // attempt to execute the content of the inputNode
     aExecuteString = aExecuteString || this.inputNode.value;
     if (!aExecuteString) {
       return;
     }
 
-    let node = this.writeOutput(aExecuteString, CATEGORY_INPUT, SEVERITY_LOG);
-    let onResult = this._executeResultCallback.bind(this, node, aCallback);
+    let message = new Messages.Simple(aExecuteString, {
+      category: "input",
+      severity: "log",
+    });
+    this.hud.output.addMessage(message);
+    let onResult = this._executeResultCallback.bind(this, message, aCallback);
 
     let options = { frame: this.SELECTED_FRAME };
     this.requestEvaluation(aExecuteString, options).then(onResult, onResult);
 
     // Append a new value in the history of executed code, or overwrite the most
     // recent entry. The most recent entry may contain the last edited input
     // value that was not evaluated yet.
     this.history[this.historyIndex++] = aExecuteString;
@@ -3769,24 +3598,26 @@ JSTerm.prototype = {
     if (aResponse.error) {
       Cu.reportError("Web Console evaluation failed. " + aResponse.error + ":" +
                      aResponse.message);
 
       aCallback && aCallback(aResponse);
       return;
     }
 
-    let exception = aResponse.exception;
-    if (exception) {
-      let node = this.writeOutput(aResponse.exceptionMessage,
-                                  CATEGORY_OUTPUT, SEVERITY_ERROR,
-                                  null, aResponse.timestamp);
-      node._objectActors = new Set();
-      if (WebConsoleUtils.isActorGrip(exception)) {
-        node._objectActors.add(exception.actor);
+    if (aResponse.exceptionMessage) {
+      let message = new Messages.Simple(aResponse.exceptionMessage, {
+        category: "output",
+        severity: "error",
+        timestamp: aResponse.timestamp,
+      });
+      this.hud.output.addMessage(message);
+      message._objectActors = new Set();
+      if (WebConsoleUtils.isActorGrip(aResponse.exception)) {
+        message._objectActors.add(aResponse.exception.actor);
       }
     }
 
     let helper = aResponse.helperResult || { type: null };
     let helperGrip = null;
     if (helper.type == "inspectObject") {
       helperGrip = helper.object;
     }
@@ -3797,84 +3628,16 @@ JSTerm.prototype = {
         this.hud._releaseObject(grip.actor);
       }
     }
 
     aCallback && aCallback(aResponse);
   },
 
 
-
-  /**
-   * Writes a JS object to the JSTerm outputNode.
-   *
-   * @param string aOutputMessage
-   *        The message to display.
-   * @param function [aCallback]
-   *        Optional function to invoke when users click the message.
-   * @param nsIDOMNode [aNodeAfter]
-   *        Optional DOM node after which you want to insert the new message.
-   *        This is used when execution results need to be inserted immediately
-   *        after the user input.
-   * @param number [aTimestamp]
-   *        Optional timestamp to show for the output message (millisconds since
-   *        the UNIX epoch). If no timestamp is provided then Date.now() is
-   *        used.
-   * @return nsIDOMNode
-   *         The new message node.
-   */
-  writeOutputJS:
-  function JST_writeOutputJS(aOutputMessage, aCallback, aNodeAfter, aTimestamp)
-  {
-    let link = null;
-    if (aCallback) {
-      link = this.hud.document.createElementNS(XHTML_NS, "a");
-      link.setAttribute("aria-haspopup", true);
-      link.textContent = aOutputMessage;
-      link.href = "#";
-      link.draggable = false;
-      this.hud._addMessageLinkCallback(link, aCallback);
-    }
-
-    return this.writeOutput(link || aOutputMessage, CATEGORY_OUTPUT,
-                            SEVERITY_LOG, aNodeAfter, aTimestamp);
-  },
-
-  /**
-   * Writes a message to the HUD that originates from the interactive
-   * JavaScript console.
-   *
-   * @param nsIDOMNode|string aOutputMessage
-   *        The message to display.
-   * @param number aCategory
-   *        The category of message: one of the CATEGORY_ constants.
-   * @param number aSeverity
-   *        The severity of message: one of the SEVERITY_ constants.
-   * @param nsIDOMNode [aNodeAfter]
-   *        Optional DOM node after which you want to insert the new message.
-   *        This is used when execution results need to be inserted immediately
-   *        after the user input.
-   * @param number [aTimestamp]
-   *        Optional timestamp to show for the output message (millisconds since
-   *        the UNIX epoch). If no timestamp is provided then Date.now() is
-   *        used.
-   * @return nsIDOMNode
-   *         The new message node.
-   */
-  writeOutput:
-  function JST_writeOutput(aOutputMessage, aCategory, aSeverity, aNodeAfter,
-                           aTimestamp)
-  {
-    let node = this.hud.createMessageNode(aCategory, aSeverity, aOutputMessage,
-                                          null, null, null, null, aTimestamp);
-    node._outputAfterNode = aNodeAfter;
-    this.hud.outputMessage(aCategory, node);
-    return node;
-  },
-
   /**
    * Clear the Web Console output.
    *
    * This method emits the "messages-cleared" notification.
    *
    * @param boolean aClearStorage
    *        True if you want to clear the console messages storage associated to
    *        this Web Console.
@@ -4567,31 +4330,16 @@ JSTerm.prototype = {
    */
   updateCompleteNode: function JSTF_updateCompleteNode(aSuffix)
   {
     // completion prefix = input, with non-control chars replaced by spaces
     let prefix = aSuffix ? this.inputNode.value.replace(/[\S]/g, " ") : "";
     this.completeNode.value = prefix + aSuffix;
   },
 
-  /**
-   * The click event handler for evaluation results in the output.
-   *
-   * @private
-   * @param object aResponse
-   *        The JavaScript evaluation response received from the server.
-   */
-  _evalOutputClick: function JST__evalOutputClick(aResponse)
-  {
-    this.openVariablesView({
-      label: VariablesView.getString(aResponse.result),
-      objectActor: aResponse.result,
-      autofocus: true,
-    });
-  },
 
   /**
    * Destroy the sidebar.
    * @private
    */
   _sidebarDestroy: function JST__sidebarDestroy()
   {
     if (this._variablesView) {
