# HG changeset patch
# Parent 75a080f3f46e63a9c8063d7e2a8ea682d3b76fe0
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1373899827 -10800
Bug 877262 - Part 1: merge HUDConsoleUI into HUDService and prepare for the jetpack loader; r=robcee

diff --git a/browser/base/content/browser-sets.inc b/browser/base/content/browser-sets.inc
--- a/browser/base/content/browser-sets.inc
+++ b/browser/base/content/browser-sets.inc
@@ -91,17 +91,17 @@
     <command id="Browser:RestoreLastSession" oncommand="restoreLastSession();" disabled="true"/>
 
     <command id="Tools:Search" oncommand="BrowserSearch.webSearch();"/>
     <command id="Tools:Downloads" oncommand="BrowserDownloadsUI();"/>
     <command id="Tools:DevToolbox" oncommand="gDevToolsBrowser.toggleToolboxCommand(gBrowser);"/>
     <command id="Tools:DevToolbar" oncommand="DeveloperToolbar.toggle();" disabled="true" hidden="true"/>
     <command id="Tools:DevToolbarFocus" oncommand="DeveloperToolbar.focusToggle();" disabled="true"/>
     <command id="Tools:ChromeDebugger" oncommand="BrowserDebuggerProcess.init();" disabled="true" hidden="true"/>
-    <command id="Tools:BrowserConsole" oncommand="HUDConsoleUI.toggleBrowserConsole();"/>
+    <command id="Tools:BrowserConsole" oncommand="HUDService.toggleBrowserConsole();"/>
     <command id="Tools:Scratchpad" oncommand="Scratchpad.openScratchpad();" disabled="true" hidden="true"/>
     <command id="Tools:ResponsiveUI" oncommand="ResponsiveUI.toggle();" disabled="true" hidden="true"/>
     <command id="Tools:Addons" oncommand="BrowserOpenAddonsMgr();"/>
     <command id="Tools:ErrorConsole" oncommand="toJavaScriptConsole()" disabled="true" hidden="true"/>
     <command id="Tools:DevToolsConnect" oncommand="gDevToolsBrowser.openConnectScreen(gBrowser)" disabled="true" hidden="true"/>
     <command id="Tools:Sanitize"
      oncommand="Cc['@mozilla.org/browser/browserglue;1'].getService(Ci.nsIBrowserGlue).sanitize(window);"/>
     <command id="Tools:PrivateBrowsing"
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -7119,19 +7119,18 @@ var TabContextMenu = {
 };
 
 XPCOMUtils.defineLazyModuleGetter(this, "gDevTools",
                                   "resource:///modules/devtools/gDevTools.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "gDevToolsBrowser",
                                   "resource:///modules/devtools/gDevTools.jsm");
 
-XPCOMUtils.defineLazyGetter(this, "HUDConsoleUI", function () {
-  return Cu.import("resource:///modules/HUDService.jsm", {}).HUDService.consoleUI;
-});
+XPCOMUtils.defineLazyModuleGetter(this, "HUDService",
+                                  "resource:///modules/HUDService.jsm");
 
 // Prompt user to restart the browser in safe mode
 function safeModeRestart()
 {
   // prompt the user to confirm
   let promptTitle = gNavigatorBundle.getString("safeModeRestartPromptTitle");
   let promptMessage =
     gNavigatorBundle.getString("safeModeRestartPromptMessage");
diff --git a/browser/devtools/commandline/test/browser_cmd_calllog.js b/browser/devtools/commandline/test/browser_cmd_calllog.js
--- a/browser/devtools/commandline/test/browser_cmd_calllog.js
+++ b/browser/devtools/commandline/test/browser_cmd_calllog.js
@@ -1,15 +1,13 @@
 /* Any copyright is dedicated to the Public Domain.
 * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests that the calllog commands works as they should
 
-let HUDService = (Cu.import("resource:///modules/HUDService.jsm", {})).HUDService;
-
 const TEST_URI = "data:text/html;charset=utf-8,gcli-calllog";
 
 let tests = {};
 
 function test() {
   helpers.addTabWithToolbar(TEST_URI, function(options) {
     return helpers.runTests(options, tests);
   }).then(finish);
@@ -50,17 +48,17 @@ tests.testCallLogStatus = function(optio
 tests.testCallLogExec = function(options) {
   var deferred = promise.defer();
 
   var onWebConsoleOpen = function(subject) {
     Services.obs.removeObserver(onWebConsoleOpen, "web-console-created");
 
     subject.QueryInterface(Ci.nsISupportsString);
     let hud = HUDService.getHudReferenceById(subject.data);
-    ok(hud.hudId in HUDService.hudReferences, "console open");
+    ok(hud, "console open");
 
     helpers.audit(options, [
       {
         setup: "calllog stop",
         exec: {
           output: /Stopped call logging/,
         }
       },
diff --git a/browser/devtools/commandline/test/browser_cmd_calllog_chrome.js b/browser/devtools/commandline/test/browser_cmd_calllog_chrome.js
--- a/browser/devtools/commandline/test/browser_cmd_calllog_chrome.js
+++ b/browser/devtools/commandline/test/browser_cmd_calllog_chrome.js
@@ -1,15 +1,13 @@
 /* Any copyright is dedicated to the Public Domain.
 * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests that the calllog commands works as they should
 
-let HUDService = (Cu.import("resource:///modules/HUDService.jsm", {})).HUDService;
-
 const TEST_URI = "data:text/html;charset=utf-8,cmd-calllog-chrome";
 
 let tests = {};
 
 function test() {
   helpers.addTabWithToolbar(TEST_URI, function(options) {
     return helpers.runTests(options, tests);
   }).then(finish);
@@ -51,17 +49,17 @@ tests.testCallLogStatus = function(optio
 tests.testCallLogExec = function(options) {
   let deferred = promise.defer();
 
   function onWebConsoleOpen(subject) {
     Services.obs.removeObserver(onWebConsoleOpen, "web-console-created");
 
     subject.QueryInterface(Ci.nsISupportsString);
     let hud = HUDService.getHudReferenceById(subject.data);
-    ok(hud.hudId in HUDService.hudReferences, "console open");
+    ok(hud, "console open");
 
     helpers.audit(options, [
       {
         setup: "calllog chromestop",
         exec: {
           output: /Stopped call logging/,
         }
       },
diff --git a/browser/devtools/commandline/test/browser_cmd_commands.js b/browser/devtools/commandline/test/browser_cmd_commands.js
--- a/browser/devtools/commandline/test/browser_cmd_commands.js
+++ b/browser/devtools/commandline/test/browser_cmd_commands.js
@@ -1,15 +1,13 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test various GCLI commands
 
-let HUDService = (Cu.import("resource:///modules/HUDService.jsm", {})).HUDService;
-
 const TEST_URI = "data:text/html;charset=utf-8,gcli-commands";
 
 let tests = {};
 
 function test() {
   helpers.addTabWithToolbar(TEST_URI, function(options) {
     return helpers.runTests(options, tests);
   }).then(finish);
@@ -19,51 +17,56 @@ tests.testConsole = function(options) {
   let deferred = promise.defer();
   let hud = null;
 
   let onWebConsoleOpen = function(subject) {
     Services.obs.removeObserver(onWebConsoleOpen, "web-console-created");
 
     subject.QueryInterface(Ci.nsISupportsString);
     hud = HUDService.getHudReferenceById(subject.data);
-    ok(hud.hudId in HUDService.hudReferences, "console open");
+    ok(hud, "console open");
 
     hud.jsterm.execute("pprint(window)", onExecute);
   }
   Services.obs.addObserver(onWebConsoleOpen, "web-console-created", false);
 
-  let onExecute = function() {
+  function onExecute () {
     let labels = hud.outputNode.querySelectorAll(".webconsole-msg-output");
     ok(labels.length > 0, "output for pprint(window)");
 
+    hud.jsterm.once("messages-cleared", onClear);
+
     helpers.audit(options, [
       {
         setup: "console clear",
         exec: {
           output: ""
         },
-        post: function() {
-          let labels = hud.outputNode.querySelectorAll(".webconsole-msg-output");
-          // Bug 845827 - The GCLI "console clear" command doesn't always work
-          // is(labels.length, 0, "no output in console");
-        }
-      },
+      }
+    ]);
+  }
+
+  function onClear() {
+    let labels = hud.outputNode.querySelectorAll(".webconsole-msg-output");
+    is(labels.length, 0, "no output in console");
+
+    helpers.audit(options, [
       {
         setup: "console close",
         exec: {
           output: ""
         },
         post: function() {
-          ok(!(hud.hudId in HUDService.hudReferences), "console closed");
+          ok(!HUDService.getHudReferenceById(hud.hudId), "console closed");
         }
       }
     ]).then(function() {
       deferred.resolve();
     });
-  };
+  }
 
   helpers.audit(options, [
     {
       setup: "console open",
       exec: { }
     }
   ]);
 
diff --git a/browser/devtools/jar.mn b/browser/devtools/jar.mn
--- a/browser/devtools/jar.mn
+++ b/browser/devtools/jar.mn
@@ -8,17 +8,17 @@ browser.jar:
     content/browser/devtools/markup-view.xhtml                         (markupview/markup-view.xhtml)
     content/browser/devtools/markup-view.css                           (markupview/markup-view.css)
     content/browser/devtools/netmonitor.xul                            (netmonitor/netmonitor.xul)
     content/browser/devtools/netmonitor.css                            (netmonitor/netmonitor.css)
     content/browser/devtools/netmonitor-controller.js                  (netmonitor/netmonitor-controller.js)
     content/browser/devtools/netmonitor-view.js                        (netmonitor/netmonitor-view.js)
     content/browser/devtools/NetworkPanel.xhtml                        (webconsole/NetworkPanel.xhtml)
     content/browser/devtools/webconsole.js                             (webconsole/webconsole.js)
-*   content/browser/devtools/webconsole.xul                            (webconsole/webconsole.xul)
+    content/browser/devtools/webconsole.xul                            (webconsole/webconsole.xul)
 *   content/browser/devtools/scratchpad.xul                            (scratchpad/scratchpad.xul)
     content/browser/devtools/scratchpad.js                             (scratchpad/scratchpad.js)
     content/browser/devtools/splitview.css                             (shared/splitview.css)
     content/browser/devtools/theme-switching.js                        (shared/theme-switching.js)
     content/browser/devtools/styleeditor.xul                           (styleeditor/styleeditor.xul)
     content/browser/devtools/styleeditor.css                           (styleeditor/styleeditor.css)
     content/browser/devtools/computedview.xhtml                        (styleinspector/computedview.xhtml)
     content/browser/devtools/cssruleview.xhtml                         (styleinspector/cssruleview.xhtml)
diff --git a/browser/devtools/profiler/test/head.js b/browser/devtools/profiler/test/head.js
--- a/browser/devtools/profiler/test/head.js
+++ b/browser/devtools/profiler/test/head.js
@@ -14,19 +14,16 @@ Cu.import("resource:///modules/devtools/
 let gDevTools = temp.gDevTools;
 
 Cu.import("resource://gre/modules/devtools/Loader.jsm", temp);
 let TargetFactory = temp.devtools.TargetFactory;
 
 Cu.import("resource://gre/modules/devtools/dbg-server.jsm", temp);
 let DebuggerServer = temp.DebuggerServer;
 
-Cu.import("resource:///modules/HUDService.jsm", temp);
-let HUDService = temp.HUDService;
-
 // Import the GCLI test helper
 let testDir = gTestPath.substr(0, gTestPath.lastIndexOf("/"));
 Services.scriptloader.loadSubScript(testDir + "../../../commandline/test/helpers.js", this);
 
 registerCleanupFunction(function () {
   helpers = null;
   Services.prefs.clearUserPref(PROFILER_ENABLED);
   Services.prefs.clearUserPref(REMOTE_ENABLED);
diff --git a/browser/devtools/scratchpad/test/browser_scratchpad_bug_661762_wrong_window_focus.js b/browser/devtools/scratchpad/test/browser_scratchpad_bug_661762_wrong_window_focus.js
--- a/browser/devtools/scratchpad/test/browser_scratchpad_bug_661762_wrong_window_focus.js
+++ b/browser/devtools/scratchpad/test/browser_scratchpad_bug_661762_wrong_window_focus.js
@@ -1,16 +1,12 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
-let tempScope = {};
-Cu.import("resource:///modules/HUDService.jsm", tempScope);
-let HUDService = tempScope.HUDService;
-
 function test()
 {
   waitForExplicitFinish();
 
   // To test for this bug we open a Scratchpad window, save its
   // reference and then open another one. This way the first window
   // loses its focus.
   //
@@ -38,17 +34,17 @@ function test()
           let hud = HUDService.getHudReferenceById(subj.data);
           hud.jsterm.clearOutput(true);
           executeSoon(testFocus.bind(null, sw, hud));
         }
 
         Services.obs.
           addObserver(onWebConsoleOpen, "web-console-created", false);
 
-        HUDService.consoleUI.toggleHUD();
+        HUDService.toggleWebConsole();
       });
     });
   }, true);
 
   content.location = "data:text/html;charset=utf8,<p>test window focus for Scratchpad.";
 }
 
 function testFocus(sw, hud) {
diff --git a/browser/devtools/shared/test/browser_toolbar_webconsole_errors_count.js b/browser/devtools/shared/test/browser_toolbar_webconsole_errors_count.js
--- a/browser/devtools/shared/test/browser_toolbar_webconsole_errors_count.js
+++ b/browser/devtools/shared/test/browser_toolbar_webconsole_errors_count.js
@@ -2,18 +2,16 @@
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests that the developer toolbar errors count works properly.
 
 function test() {
   const TEST_URI = "http://example.com/browser/browser/devtools/shared/test/" +
                    "browser_toolbar_webconsole_errors_count.html";
 
-  let HUDService = Cu.import("resource:///modules/HUDService.jsm",
-                             {}).HUDService;
   let gDevTools = Cu.import("resource:///modules/devtools/gDevTools.jsm",
                              {}).gDevTools;
 
   let webconsole = document.getElementById("developer-toolbar-toolbox-button");
   let tab1, tab2;
 
   Services.prefs.setBoolPref("javascript.options.strict", true);
 
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -48,35 +48,41 @@ const BROWSER_CONSOLE_FILTER_PREFS_PREFI
 
 this.EXPORTED_SYMBOLS = ["HUDService"];
 
 ///////////////////////////////////////////////////////////////////////////
 //// The HUD service
 
 function HUD_SERVICE()
 {
-  this.hudReferences = {};
+  this.consoles = new Map();
+  this.lastFinishedRequest = { callback: null };
 }
 
 HUD_SERVICE.prototype =
 {
-  /**
-   * Keeps a reference for each HeadsUpDisplay that is created
-   * @type object
-   */
-  hudReferences: null,
+  _browserConsoleID: null,
+  _browserConsoleDefer: null,
 
   /**
-   * getter for UI commands to be used by the frontend
+   * Keeps a reference for each Web Console / Browser Console that is created.
+   * @type Map
+   */
+  consoles: null,
+
+  /**
+   * Assign a function to this property to listen for every request that
+   * completes. Used by unit tests. The callback takes one argument: the HTTP
+   * activity object as received from the remote Web Console.
    *
-   * @returns object
+   * @type object
+   *       Includes a property named |callback|. Assign the function to the
+   *       |callback| property of this object.
    */
-  get consoleUI() {
-    return HeadsUpDisplayUICommands;
-  },
+  lastFinishedRequest: null,
 
   /**
    * Firefox-specific current tab getter
    *
    * @returns nsIDOMWindow
    */
   currentContext: function HS_currentContext() {
     return Services.wm.getMostRecentWindow("navigator:browser");
@@ -95,91 +101,206 @@ HUD_SERVICE.prototype =
    *        The window of the web console owner.
    * @return object
    *         A promise object for the opening of the new WebConsole instance.
    */
   openWebConsole:
   function HS_openWebConsole(aTarget, aIframeWindow, aChromeWindow)
   {
     let hud = new WebConsole(aTarget, aIframeWindow, aChromeWindow);
-    this.hudReferences[hud.hudId] = hud;
+    this.consoles.set(hud.hudId, hud);
     return hud.init();
   },
 
   /**
    * Open a Browser Console for the given target.
    *
-   * @see devtools/framework/Target.jsm for details about targets.
+   * @see devtools/framework/target.js for details about targets.
    *
    * @param object aTarget
    *        The target that the browser console will connect to.
    * @param nsIDOMWindow aIframeWindow
    *        The window where the browser console UI is already loaded.
    * @param nsIDOMWindow aChromeWindow
    *        The window of the browser console owner.
    * @return object
    *         A promise object for the opening of the new BrowserConsole instance.
    */
   openBrowserConsole:
   function HS_openBrowserConsole(aTarget, aIframeWindow, aChromeWindow)
   {
     let hud = new BrowserConsole(aTarget, aIframeWindow, aChromeWindow);
-    this.hudReferences[hud.hudId] = hud;
+    this.consoles.set(hud.hudId, hud);
     return hud.init();
   },
 
   /**
-   * Returns the HeadsUpDisplay object associated to a content window.
+   * Returns the Web Console object associated to a content window.
    *
    * @param nsIDOMWindow aContentWindow
    * @returns object
    */
   getHudByWindow: function HS_getHudByWindow(aContentWindow)
   {
-    for each (let hud in this.hudReferences) {
+    for (let [hudId, hud] of this.consoles) {
       let target = hud.target;
       if (target && target.tab && target.window === aContentWindow) {
         return hud;
       }
     }
     return null;
   },
 
   /**
-   * Returns the hudId that is corresponding to the hud activated for the
-   * passed aContentWindow. If there is no matching hudId null is returned.
-   *
-   * @param nsIDOMWindow aContentWindow
-   * @returns string or null
-   */
-  getHudIdByWindow: function HS_getHudIdByWindow(aContentWindow)
-  {
-    let hud = this.getHudByWindow(aContentWindow);
-    return hud ? hud.hudId : null;
-  },
-
-  /**
-   * Returns the hudReference for a given id.
+   * Returns the console instance for a given id.
    *
    * @param string aId
    * @returns Object
    */
   getHudReferenceById: function HS_getHudReferenceById(aId)
   {
-    return aId in this.hudReferences ? this.hudReferences[aId] : null;
+    return this.consoles.get(aId);
   },
 
   /**
-   * Assign a function to this property to listen for every request that
-   * completes. Used by unit tests. The callback takes one argument: the HTTP
-   * activity object as received from the remote Web Console.
+   * Toggle the Web Console for the current tab.
    *
-   * @type function
+   * @return object
+   *         A promise for either the opening of the toolbox that holds the Web
+   *         Console, or a Promise for the closing of the toolbox.
    */
-  lastFinishedRequestCallback: null,
+  toggleWebConsole: function HS_toggleWebConsole()
+  {
+    let window = this.currentContext();
+    let target = devtools.TargetFactory.forTab(window.gBrowser.selectedTab);
+    let toolbox = gDevTools.getToolbox(target);
+
+    return toolbox && toolbox.currentToolId == "webconsole" ?
+        toolbox.destroy() :
+        gDevTools.showToolbox(target, "webconsole");
+  },
+
+  /**
+   * Find if there is a Web Console open for the current tab and return the
+   * instance.
+   * @return object|null
+   *         The WebConsole object or null if the active tab has no open Web
+   *         Console.
+   */
+  getOpenWebConsole: function HS_getOpenWebConsole()
+  {
+    let tab = this.currentContext().gBrowser.selectedTab;
+    if (!tab || !devtools.TargetFactory.isKnownTab(tab)) {
+      return null;
+    }
+    let target = devtools.TargetFactory.forTab(tab);
+    let toolbox = gDevTools.getToolbox(target);
+    let panel = toolbox ? toolbox.getPanel("webconsole") : null;
+    return panel ? panel.hud : null;
+  },
+
+  /**
+   * Toggle the Browser Console.
+   */
+  toggleBrowserConsole: function HS_toggleBrowserConsole()
+  {
+    if (this._browserConsoleID) {
+      let hud = this.getHudReferenceById(this._browserConsoleID);
+      return hud.destroy();
+    }
+
+    if (this._browserConsoleDefer) {
+      return this._browserConsoleDefer.promise;
+    }
+
+    this._browserConsoleDefer = promise.defer();
+
+    function connect()
+    {
+      let deferred = promise.defer();
+
+      if (!DebuggerServer.initialized) {
+        DebuggerServer.init();
+        DebuggerServer.addBrowserActors();
+      }
+
+      let client = new DebuggerClient(DebuggerServer.connectPipe());
+      client.connect(() =>
+        client.listTabs((aResponse) => {
+          // Add Global Process debugging...
+          let globals = JSON.parse(JSON.stringify(aResponse));
+          delete globals.tabs;
+          delete globals.selected;
+          // ...only if there are appropriate actors (a 'from' property will
+          // always be there).
+          if (Object.keys(globals).length > 1) {
+            deferred.resolve({ form: globals, client: client, chrome: true });
+          } else {
+            deferred.reject("Global console not found!");
+          }
+        }));
+
+      return deferred.promise;
+    }
+
+    let target;
+    function getTarget(aConnection)
+    {
+      let options = {
+        form: aConnection.form,
+        client: aConnection.client,
+        chrome: true,
+      };
+
+      return devtools.TargetFactory.forRemoteTab(options);
+    }
+
+    function openWindow(aTarget)
+    {
+      target = aTarget;
+
+      let deferred = promise.defer();
+
+      let win = Services.ww.openWindow(null, devtools.Tools.webConsole.url, "_blank",
+                                       BROWSER_CONSOLE_WINDOW_FEATURES, null);
+      win.addEventListener("DOMContentLoaded", function onLoad() {
+        win.removeEventListener("DOMContentLoaded", onLoad);
+
+        // Set the correct Browser Console title.
+        let root = win.document.documentElement;
+        root.setAttribute("title", root.getAttribute("browserConsoleTitle"));
+
+        deferred.resolve(win);
+      });
+
+      return deferred.promise;
+    }
+
+    connect().then(getTarget).then(openWindow).then((aWindow) =>
+      this.openBrowserConsole(target, aWindow, aWindow)
+        .then((aBrowserConsole) => {
+          this._browserConsoleID = aBrowserConsole.hudId;
+          this._browserConsoleDefer.resolve(aBrowserConsole);
+          this._browserConsoleDefer = null;
+        }));
+
+    return this._browserConsoleDefer.promise;
+  },
+
+  /**
+   * Get the Browser Console instance, if open.
+   *
+   * @return object|null
+   *         A BrowserConsole instance or null if the Browser Console is not
+   *         open.
+   */
+  getBrowserConsole: function HS_getBrowserConsole()
+  {
+    return this.getHudReferenceById(this._browserConsoleID);
+  },
 };
 
 
 /**
  * A WebConsole instance is an interactive console initialized *per target*
  * that displays console log data as well as provides an interactive terminal to
  * manipulate the target's document content.
  *
@@ -218,22 +339,23 @@ WebConsole.prototype = {
   browserWindow: null,
   hudId: null,
   target: null,
   ui: null,
   _browserConsole: false,
   _destroyer: null,
 
   /**
-   * Getter for HUDService.lastFinishedRequestCallback.
+   * Getter for a function to to listen for every request that completes. Used
+   * by unit tests. The callback takes one argument: the HTTP activity object as
+   * received from the remote Web Console.
    *
-   * @see HUDService.lastFinishedRequestCallback
    * @type function
    */
-  get lastFinishedRequestCallback() HUDService.lastFinishedRequestCallback,
+  get lastFinishedRequestCallback() HUDService.lastFinishedRequest.callback,
 
   /**
    * Getter for the xul:popupset that holds any popups we open.
    * @type nsIDOMElement
    */
   get mainPopupSet()
   {
     return this.browserWindow.document.getElementById("mainPopupSet");
@@ -466,17 +588,17 @@ WebConsole.prototype = {
    *         A promise object that is resolved once the Web Console is closed.
    */
   destroy: function WC_destroy()
   {
     if (this._destroyer) {
       return this._destroyer.promise;
     }
 
-    delete HUDService.hudReferences[this.hudId];
+    HUDService.consoles.delete(this.hudId);
 
     this._destroyer = promise.defer();
 
     let popupset = this.mainPopupSet;
     let panels = popupset.querySelectorAll("panel[hudId=" + this.hudId + "]");
     for (let panel of panels) {
       panel.hidePopup();
     }
@@ -587,158 +709,18 @@ BrowserConsole.prototype = Heritage.exte
 
     this._telemetry.toolClosed("browserconsole");
 
     this._bc_destroyer = promise.defer();
 
     let chromeWindow = this.chromeWindow;
     this.$destroy().then(() =>
       this.target.client.close(() => {
-        HeadsUpDisplayUICommands._browserConsoleID = null;
+        HUDService._browserConsoleID = null;
         chromeWindow.close();
         this._bc_destroyer.resolve(null);
       }));
 
     return this._bc_destroyer.promise;
   },
 });
 
-
-//////////////////////////////////////////////////////////////////////////
-// HeadsUpDisplayUICommands
-//////////////////////////////////////////////////////////////////////////
-
-var HeadsUpDisplayUICommands = {
-  _browserConsoleID: null,
-  _browserConsoleDefer: null,
-
-  /**
-   * Toggle the Web Console for the current tab.
-   *
-   * @return object
-   *         A promise for either the opening of the toolbox that holds the Web
-   *         Console, or a promise for the closing of the toolbox.
-   */
-  toggleHUD: function UIC_toggleHUD()
-  {
-    let window = HUDService.currentContext();
-    let target = devtools.TargetFactory.forTab(window.gBrowser.selectedTab);
-    let toolbox = gDevTools.getToolbox(target);
-
-    return toolbox && toolbox.currentToolId == "webconsole" ?
-        toolbox.destroy() :
-        gDevTools.showToolbox(target, "webconsole");
-  },
-
-  /**
-   * Find if there is a Web Console open for the current tab and return the
-   * instance.
-   * @return object|null
-   *         The WebConsole object or null if the active tab has no open Web
-   *         Console.
-   */
-  getOpenHUD: function UIC_getOpenHUD()
-  {
-    let tab = HUDService.currentContext().gBrowser.selectedTab;
-    if (!tab || !devtools.TargetFactory.isKnownTab(tab)) {
-      return null;
-    }
-    let target = devtools.TargetFactory.forTab(tab);
-    let toolbox = gDevTools.getToolbox(target);
-    let panel = toolbox ? toolbox.getPanel("webconsole") : null;
-    return panel ? panel.hud : null;
-  },
-
-  /**
-   * Toggle the Browser Console.
-   */
-  toggleBrowserConsole: function UIC_toggleBrowserConsole()
-  {
-    if (this._browserConsoleID) {
-      let hud = HUDService.getHudReferenceById(this._browserConsoleID);
-      return hud.destroy();
-    }
-
-    if (this._browserConsoleDefer) {
-      return this._browserConsoleDefer.promise;
-    }
-
-    this._browserConsoleDefer = promise.defer();
-
-    function connect()
-    {
-      let deferred = promise.defer();
-
-      if (!DebuggerServer.initialized) {
-        DebuggerServer.init();
-        DebuggerServer.addBrowserActors();
-      }
-
-      let client = new DebuggerClient(DebuggerServer.connectPipe());
-      client.connect(() =>
-        client.listTabs((aResponse) => {
-          // Add Global Process debugging...
-          let globals = JSON.parse(JSON.stringify(aResponse));
-          delete globals.tabs;
-          delete globals.selected;
-          // ...only if there are appropriate actors (a 'from' property will
-          // always be there).
-          if (Object.keys(globals).length > 1) {
-            deferred.resolve({ form: globals, client: client, chrome: true });
-          } else {
-            deferred.reject("Global console not found!");
-          }
-        }));
-
-      return deferred.promise;
-    }
-
-    let target;
-    function getTarget(aConnection)
-    {
-      let options = {
-        form: aConnection.form,
-        client: aConnection.client,
-        chrome: true,
-      };
-
-      return devtools.TargetFactory.forRemoteTab(options);
-    }
-
-    function openWindow(aTarget)
-    {
-      target = aTarget;
-
-      let deferred = promise.defer();
-
-      let win = Services.ww.openWindow(null, devtools.Tools.webConsole.url, "_blank",
-                                       BROWSER_CONSOLE_WINDOW_FEATURES, null);
-      win.addEventListener("DOMContentLoaded", function onLoad() {
-        win.removeEventListener("DOMContentLoaded", onLoad);
-
-        // Set the correct Browser Console title.
-        let root = win.document.documentElement;
-        root.setAttribute("title", root.getAttribute("browserConsoleTitle"));
-
-        deferred.resolve(win);
-      });
-
-      return deferred.promise;
-    }
-
-    connect().then(getTarget).then(openWindow).then((aWindow) =>
-      HUDService.openBrowserConsole(target, aWindow, aWindow)
-        .then((aBrowserConsole) => {
-          this._browserConsoleID = aBrowserConsole.hudId;
-          this._browserConsoleDefer.resolve(aBrowserConsole);
-          this._browserConsoleDefer = null;
-        }));
-
-    return this._browserConsoleDefer.promise;
-  },
-
-  get browserConsole() {
-    return HUDService.getHudReferenceById(this._browserConsoleID);
-  },
-};
-
 const HUDService = new HUD_SERVICE();
-
diff --git a/browser/devtools/webconsole/test/browser_bug_871156_ctrlw_close_tab.js b/browser/devtools/webconsole/test/browser_bug_871156_ctrlw_close_tab.js
--- a/browser/devtools/webconsole/test/browser_bug_871156_ctrlw_close_tab.js
+++ b/browser/devtools/webconsole/test/browser_bug_871156_ctrlw_close_tab.js
@@ -45,17 +45,17 @@ function test()
 
     EventUtils.synthesizeKey("w", { accelKey: true }, hud.iframeWindow);
   }
 
   function testBrowserConsole()
   {
     info("test the Browser Console");
 
-    HUDConsoleUI.toggleBrowserConsole().then((hud) => {
+    HUDService.toggleBrowserConsole().then((hud) => {
       ok(hud, "Browser Console opened");
 
       Services.obs.addObserver(function onDestroy() {
         Services.obs.removeObserver(onDestroy, "web-console-destroyed");
         ok(true, "the Browser Console closed");
 
         executeSoon(finishTest);
       }, "web-console-destroyed", false);
diff --git a/browser/devtools/webconsole/test/browser_console.js b/browser/devtools/webconsole/test/browser_console.js
--- a/browser/devtools/webconsole/test/browser_console.js
+++ b/browser/devtools/webconsole/test/browser_console.js
@@ -4,26 +4,31 @@
  */
 
 // Test the basic features of the Browser Console, bug 587757.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html?" + Date.now();
 
 function test()
 {
-  let oldFunction = HUDConsoleUI.toggleBrowserConsole;
-  let functionExecuted = false;
-  HUDConsoleUI.toggleBrowserConsole = () => functionExecuted = true;
+  Services.obs.addObserver(function observer(aSubject) {
+    Services.obs.removeObserver(observer, "web-console-created");
+    aSubject.QueryInterface(Ci.nsISupportsString);
+
+    let hud = HUDService.getBrowserConsole();
+    ok(hud, "browser console is open");
+    is(aSubject.data, hud.hudId, "notification hudId is correct");
+
+    executeSoon(() => consoleOpened(hud));
+  }, "web-console-created", false);
+
+  let hud = HUDService.getBrowserConsole();
+  ok(!hud, "browser console is not open");
+  info("wait for the browser console to open with ctrl-shift-j");
   EventUtils.synthesizeKey("j", { accelKey: true, shiftKey: true }, content);
-
-  ok(functionExecuted,
-     "toggleBrowserConsole() was executed by the Ctrl-Shift-J key shortcut");
-
-  HUDConsoleUI.toggleBrowserConsole = oldFunction;
-  HUDConsoleUI.toggleBrowserConsole().then(consoleOpened);
 }
 
 function consoleOpened(hud)
 {
   hud.jsterm.clearOutput(true);
 
   expectUncaughtException();
   executeSoon(() => {
diff --git a/browser/devtools/webconsole/test/browser_console_addonsdk_loader_exception.js b/browser/devtools/webconsole/test/browser_console_addonsdk_loader_exception.js
--- a/browser/devtools/webconsole/test/browser_console_addonsdk_loader_exception.js
+++ b/browser/devtools/webconsole/test/browser_console_addonsdk_loader_exception.js
@@ -19,17 +19,17 @@ function test()
 
     openConsole(null, consoleOpened);
   }, true);
 
   function consoleOpened(hud)
   {
     ok(hud, "web console opened");
     webconsole = hud;
-    HUDConsoleUI.toggleBrowserConsole().then(browserConsoleOpened);
+    HUDService.toggleBrowserConsole().then(browserConsoleOpened);
   }
 
   function browserConsoleOpened(hud)
   {
     ok(hud, "browser console opened");
     browserconsole = hud;
 
     // Cause an exception in a script loaded with the addon-sdk loader.
diff --git a/browser/devtools/webconsole/test/browser_console_consolejsm_output.js b/browser/devtools/webconsole/test/browser_console_consolejsm_output.js
--- a/browser/devtools/webconsole/test/browser_console_consolejsm_output.js
+++ b/browser/devtools/webconsole/test/browser_console_consolejsm_output.js
@@ -8,17 +8,17 @@
 function test()
 {
   let storage = Cu.import("resource://gre/modules/ConsoleAPIStorage.jsm", {}).ConsoleAPIStorage;
   storage.clearEvents();
 
   let console = Cu.import("resource://gre/modules/devtools/Console.jsm", {}).console;
   console.log("bug861338-log-cached");
 
-  HUDConsoleUI.toggleBrowserConsole().then(consoleOpened);
+  HUDService.toggleBrowserConsole().then(consoleOpened);
   let hud = null;
 
   function consoleOpened(aHud)
   {
     hud = aHud;
     waitForMessages({
       webconsole: hud,
       messages: [{
diff --git a/browser/devtools/webconsole/test/browser_console_dead_objects.js b/browser/devtools/webconsole/test/browser_console_dead_objects.js
--- a/browser/devtools/webconsole/test/browser_console_dead_objects.js
+++ b/browser/devtools/webconsole/test/browser_console_dead_objects.js
@@ -10,17 +10,17 @@ const TEST_URI = "data:text/html;charset
 function test()
 {
   let hud = null;
 
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
     info("open the browser console");
-    HUDConsoleUI.toggleBrowserConsole().then(onBrowserConsoleOpen);
+    HUDService.toggleBrowserConsole().then(onBrowserConsoleOpen);
   }, true);
 
   function onBrowserConsoleOpen(aHud)
   {
     hud = aHud;
     ok(hud, "browser console opened");
 
     hud.jsterm.clearOutput();
diff --git a/browser/devtools/webconsole/test/browser_console_error_source_click.js b/browser/devtools/webconsole/test/browser_console_error_source_click.js
--- a/browser/devtools/webconsole/test/browser_console_error_source_click.js
+++ b/browser/devtools/webconsole/test/browser_console_error_source_click.js
@@ -11,17 +11,17 @@ const TEST_URI = "data:text/html;charset
                  "style='test-color: green-please'>click!</button>";
 function test()
 {
   let hud;
 
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    HUDConsoleUI.toggleBrowserConsole().then(browserConsoleOpened);
+    HUDService.toggleBrowserConsole().then(browserConsoleOpened);
   }, true);
 
   function browserConsoleOpened(aHud)
   {
     hud = aHud;
     ok(hud, "browser console opened");
 
     let button = content.document.querySelector("button");
diff --git a/browser/devtools/webconsole/test/browser_console_filters.js b/browser/devtools/webconsole/test/browser_console_filters.js
--- a/browser/devtools/webconsole/test/browser_console_filters.js
+++ b/browser/devtools/webconsole/test/browser_console_filters.js
@@ -40,17 +40,17 @@ function consoleOpened(hud)
   hud.setFilterState("exception", true);
 
   executeSoon(() => closeConsole(null, onWebConsoleClose));
 }
 
 function onWebConsoleClose()
 {
   info("web console closed");
-  HUDConsoleUI.toggleBrowserConsole().then(onBrowserConsoleOpen);
+  HUDService.toggleBrowserConsole().then(onBrowserConsoleOpen);
 }
 
 function onBrowserConsoleOpen(hud)
 {
   ok(hud, "browser console opened");
 
   is(Services.prefs.getBoolPref(BROWSER_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (browser console)");
diff --git a/browser/devtools/webconsole/test/browser_console_iframe_messages.js b/browser/devtools/webconsole/test/browser_console_iframe_messages.js
--- a/browser/devtools/webconsole/test/browser_console_iframe_messages.js
+++ b/browser/devtools/webconsole/test/browser_console_iframe_messages.js
@@ -55,17 +55,17 @@ function consoleOpened(hud)
   }).then(() => {
     closeConsole(null, onWebConsoleClose);
   });
 }
 
 function onWebConsoleClose()
 {
   info("web console closed");
-  HUDConsoleUI.toggleBrowserConsole().then(onBrowserConsoleOpen);
+  HUDService.toggleBrowserConsole().then(onBrowserConsoleOpen);
 }
 
 function onBrowserConsoleOpen(hud)
 {
   ok(hud, "browser console opened");
   Services.console.logStringMessage("test2 for bug859756");
 
   waitForMessages({
diff --git a/browser/devtools/webconsole/test/browser_console_keyboard_accessibility.js b/browser/devtools/webconsole/test/browser_console_keyboard_accessibility.js
--- a/browser/devtools/webconsole/test/browser_console_keyboard_accessibility.js
+++ b/browser/devtools/webconsole/test/browser_console_keyboard_accessibility.js
@@ -49,21 +49,24 @@ function test()
     info("try ctrl-f to focus filter");
     EventUtils.synthesizeKey("F", { accelKey: true });
     ok(!hud.jsterm.inputNode.getAttribute("focused"),
        "jsterm input is not focused");
     is(hud.ui.filterBox.getAttribute("focused"), "true",
        "filter input is focused");
 
     if (Services.appinfo.OS == "Darwin") {
+      ok(hud.ui.getFilterState("network"), "network category is enabled");
       EventUtils.synthesizeKey("t", { ctrlKey: true });
+      ok(!hud.ui.getFilterState("network"), "accesskey for Network works");
+      EventUtils.synthesizeKey("t", { ctrlKey: true });
+      ok(hud.ui.getFilterState("network"), "accesskey for Network works (again)");
     }
     else {
       EventUtils.synthesizeKey("N", { altKey: true });
+      let net = hud.ui.document.querySelector("toolbarbutton[category=net]");
+      is(hud.ui.document.activeElement, net,
+         "accesskey for Network category focuses the Net button");
     }
 
-    let net = hud.ui.document.querySelector("toolbarbutton[category=net]");
-    is(hud.ui.document.activeElement, net,
-       "accesskey for Network category focuses the Net button");
-
     finishTest();
   }
 }
diff --git a/browser/devtools/webconsole/test/browser_console_nsiconsolemessage.js b/browser/devtools/webconsole/test/browser_console_nsiconsolemessage.js
--- a/browser/devtools/webconsole/test/browser_console_nsiconsolemessage.js
+++ b/browser/devtools/webconsole/test/browser_console_nsiconsolemessage.js
@@ -46,17 +46,17 @@ function consoleOpened(hud)
        "nsIConsoleMessages are not displayed (confirmed)");
     closeConsole(null, onWebConsoleClose);
   });
 }
 
 function onWebConsoleClose()
 {
   info("web console closed");
-  HUDConsoleUI.toggleBrowserConsole().then(onBrowserConsoleOpen);
+  HUDService.toggleBrowserConsole().then(onBrowserConsoleOpen);
 }
 
 function onBrowserConsoleOpen(hud)
 {
   ok(hud, "browser console opened");
   Services.console.logStringMessage("test2 for bug859756");
 
   waitForMessages({
diff --git a/browser/devtools/webconsole/test/browser_console_private_browsing.js b/browser/devtools/webconsole/test/browser_console_private_browsing.js
--- a/browser/devtools/webconsole/test/browser_console_private_browsing.js
+++ b/browser/devtools/webconsole/test/browser_console_private_browsing.js
@@ -123,17 +123,17 @@ function test()
     }).then(testBrowserConsole);
   }
 
   function testBrowserConsole()
   {
     info("testBrowserConsole()");
     closeConsole(privateTab, () => {
       info("web console closed");
-      privateWindow.HUDConsoleUI.toggleBrowserConsole().then(onBrowserConsoleOpen);
+      privateWindow.HUDService.toggleBrowserConsole().then(onBrowserConsoleOpen);
     });
   }
 
   // Make sure that the cached messages from private tabs are not displayed in
   // the browser console.
   function checkNoPrivateMessages()
   {
     let text = hud.outputNode.textContent;
@@ -162,20 +162,20 @@ function test()
   {
     info("close the private window and check if the private messages are removed");
     hud.jsterm.once("private-messages-cleared", () => {
       isnot(hud.outputNode.textContent.indexOf("bug874061-not-private"), -1,
             "non-private messages are still shown after private window closed");
       checkNoPrivateMessages();
 
       info("close the browser console");
-      privateWindow.HUDConsoleUI.toggleBrowserConsole().then(() => {
+      privateWindow.HUDService.toggleBrowserConsole().then(() => {
         info("reopen the browser console");
         executeSoon(() =>
-          HUDConsoleUI.toggleBrowserConsole().then(onBrowserConsoleReopen));
+          HUDService.toggleBrowserConsole().then(onBrowserConsoleReopen));
       });
     });
     privateWindow.BrowserTryToCloseWindow();
   }
 
   function onBrowserConsoleReopen(aHud)
   {
     hud = aHud;
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
@@ -1,50 +1,49 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-585956-console-trace.html";
 
 function test() {
-  addTab(TEST_URI);
+  addTab("data:text/html;charset=utf8,<p>hello");
   browser.addEventListener("load", tabLoaded, true);
+
+  function tabLoaded() {
+    browser.removeEventListener("load", tabLoaded, true);
+
+    openConsole(null, function(hud) {
+      content.location = TEST_URI;
+
+      waitForMessages({
+        webconsole: hud,
+        messages: [{
+          name: "console.trace output",
+          consoleTrace: {
+            file: "test-bug-585956-console-trace.html",
+            fn: "window.foobar585956c",
+          },
+        }],
+      }).then(performChecks);
+    });
+  }
+
+  function performChecks(results) {
+    let node = [...results[0].matched][0];
+
+    // The expected stack trace object.
+    let stacktrace = [
+      { filename: TEST_URI, lineNumber: 9, functionName: "window.foobar585956c", language: 2 },
+      { filename: TEST_URI, lineNumber: 14, functionName: "foobar585956b", language: 2 },
+      { filename: TEST_URI, lineNumber: 18, functionName: "foobar585956a", language: 2 },
+      { filename: TEST_URI, lineNumber: 21, functionName: null, language: 2 }
+    ];
+
+    ok(node, "found trace log node");
+    ok(node._stacktrace, "found stacktrace object");
+    is(node._stacktrace.toSource(), stacktrace.toSource(), "stacktrace is correct");
+    isnot(node.textContent.indexOf("bug-585956"), -1, "found file name");
+
+    finishTest();
+  }
 }
-
-function tabLoaded() {
-  browser.removeEventListener("load", tabLoaded, true);
-
-  openConsole(null, function(hud) {
-    content.location.reload();
-
-    waitForSuccess({
-      name: "stacktrace message",
-      validatorFn: function()
-      {
-        return hud.outputNode.querySelector(".hud-log");
-      },
-      successFn: performChecks,
-      failureFn: finishTest,
-    });
-  });
-}
-
-function performChecks() {
-  // The expected stack trace object.
-  let stacktrace = [
-    { filename: TEST_URI, lineNumber: 9, functionName: "window.foobar585956c", language: 2 },
-    { filename: TEST_URI, lineNumber: 14, functionName: "foobar585956b", language: 2 },
-    { filename: TEST_URI, lineNumber: 18, functionName: "foobar585956a", language: 2 },
-    { filename: TEST_URI, lineNumber: 21, functionName: null, language: 2 }
-  ];
-
-  let hudId = HUDService.getHudIdByWindow(content);
-  let HUD = HUDService.hudReferences[hudId];
-
-  let node = HUD.outputNode.querySelector(".hud-log");
-  ok(node, "found trace log node");
-  ok(node._stacktrace, "found stacktrace object");
-  is(node._stacktrace.toSource(), stacktrace.toSource(), "stacktrace is correct");
-  isnot(node.textContent.indexOf("bug-585956"), -1, "found file name");
-
-  finishTest();
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js b/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js
@@ -20,43 +20,44 @@ function tabLoaded(aEvent) {
     expectUncaughtException();
     content.location.reload();
   });
 }
 
 function tabReloaded(aEvent) {
   gBrowser.selectedBrowser.removeEventListener(aEvent.type, tabReloaded, true);
 
-  let hudId = HUDService.getHudIdByWindow(content);
-  let HUD = HUDService.hudReferences[hudId];
+  let HUD = HUDService.getHudByWindow(content);
   ok(HUD, "Web Console is open");
 
-  waitForSuccess({
-    name: "error message displayed",
-    validatorFn: function() {
-      return HUD.outputNode.textContent.indexOf("fooBug597756_error") > -1;
-    },
-    successFn: function() {
-      if (newTabIsOpen) {
-        finishTest();
-        return;
-      }
-      closeConsole(gBrowser.selectedTab, function() {
-        gBrowser.removeCurrentTab();
+  waitForMessages({
+    webconsole: HUD,
+    messages: [{
+      name: "error message displayed",
+      text: "fooBug597756_error",
+      category: CATEGORY_JS,
+      severity: SEVERITY_ERROR,
+    }],
+  }).then(() => {
+    if (newTabIsOpen) {
+      finishTest();
+      return;
+    }
 
-        let newTab = gBrowser.addTab();
-        gBrowser.selectedTab = newTab;
+    closeConsole(gBrowser.selectedTab, () => {
+      gBrowser.removeCurrentTab();
 
-        newTabIsOpen = true;
-        gBrowser.selectedBrowser.addEventListener("load", tabLoaded, true);
-        expectUncaughtException();
-        content.location = TEST_URI;
-      });
-    },
-    failureFn: finishTest,
+      let newTab = gBrowser.addTab();
+      gBrowser.selectedTab = newTab;
+
+      newTabIsOpen = true;
+      gBrowser.selectedBrowser.addEventListener("load", tabLoaded, true);
+      expectUncaughtException();
+      content.location = TEST_URI;
+    });
   });
 }
 
 function test() {
   expectUncaughtException();
   addTab(TEST_URI);
   browser.addEventListener("load", tabLoaded, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_599725_response_headers.js b/browser/devtools/webconsole/test/browser_webconsole_bug_599725_response_headers.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_599725_response_headers.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_599725_response_headers.js
@@ -48,27 +48,27 @@ function performTest(aRequest, aConsole)
                       "response", lastFinishedRequest.response,
                       "updates", lastFinishedRequest.updates,
                       "response headers", headers);
       }
 
       executeSoon(finishTest);
     });
 
-  HUDService.lastFinishedRequestCallback = null;
+  HUDService.lastFinishedRequest.callback = null;
 }
 
 function test()
 {
   addTab("data:text/plain;charset=utf8,hello world");
 
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
     openConsole(null, () => {
-      HUDService.lastFinishedRequestCallback = performTest;
+      HUDService.lastFinishedRequest.callback = performTest;
 
       browser.addEventListener("load", function onReload() {
         browser.removeEventListener("load", onReload, true);
         executeSoon(() => content.location.reload());
       }, true);
 
       executeSoon(() => content.location = TEST_URI);
     });
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js b/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
@@ -8,31 +8,31 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-600183-charset.html";
 
 function performTest(lastFinishedRequest, aConsole)
 {
   ok(lastFinishedRequest, "charset test page was loaded and logged");
-  HUDService.lastFinishedRequestCallback = null;
+  HUDService.lastFinishedRequest.callback = null;
 
   executeSoon(() => {
     aConsole.webConsoleClient.getResponseContent(lastFinishedRequest.actor,
       (aResponse) => {
         ok(!aResponse.contentDiscarded, "response body was not discarded");
 
         let body = aResponse.content.text;
         ok(body, "we have the response body");
 
         let chars = "\u7684\u95ee\u5019!"; // 的问候!
         isnot(body.indexOf("<p>" + chars + "</p>"), -1,
           "found the chinese simplified string");
 
-        HUDService.lastFinishedRequestCallback = null;
+        HUDService.lastFinishedRequest.callback = null;
         executeSoon(finishTest);
       });
   });
 }
 
 function test()
 {
   addTab("data:text/html;charset=utf-8,Web Console - bug 600183 test");
@@ -40,14 +40,14 @@ function test()
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
 
     openConsole(null, function(hud) {
       hud.ui.setSaveRequestAndResponseBodies(true).then(() => {
         ok(hud.ui._saveRequestAndResponseBodies,
           "The saveRequestAndResponseBodies property was successfully set.");
 
-        HUDService.lastFinishedRequestCallback = performTest;
+        HUDService.lastFinishedRequest.callback = performTest;
         content.location = TEST_URI;
       });
     });
   }, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_601177_log_levels.js b/browser/devtools/webconsole/test/browser_webconsole_bug_601177_log_levels.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_601177_log_levels.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_601177_log_levels.js
@@ -5,78 +5,71 @@
  *
  * Contributor(s):
  *  Mihai Șucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-601177-log-levels.html";
 
-function performTest()
-{
-  let hudId = HUDService.getHudIdByWindow(content);
-  let HUD = HUDService.hudReferences[hudId];
-
-  findEntry(HUD, "hud-networkinfo", "test-bug-601177-log-levels.html",
-            "found test-bug-601177-log-levels.html");
-
-  findEntry(HUD, "hud-networkinfo", "test-bug-601177-log-levels.js",
-            "found test-bug-601177-log-levels.js");
-
-  findEntry(HUD, "hud-networkinfo", "test-image.png", "found test-image.png");
-
-  findEntry(HUD, "hud-network", "foobar-known-to-fail.png",
-            "found foobar-known-to-fail.png");
-
-  findEntry(HUD, "hud-exception", "foobarBug601177exception",
-            "found exception");
-
-  findEntry(HUD, "hud-jswarn", "undefinedPropertyBug601177",
-            "found strict warning");
-
-  findEntry(HUD, "hud-jswarn", "foobarBug601177strictError",
-            "found strict error");
-
-  executeSoon(finishTest);
-}
-
-function findEntry(aHUD, aClass, aString, aMessage)
-{
-  return testLogEntry(aHUD.outputNode, aString, aMessage, false, false,
-                      aClass);
-}
-
 function test()
 {
   Services.prefs.setBoolPref("javascript.options.strict", true);
-
   registerCleanupFunction(function() {
     Services.prefs.clearUserPref("javascript.options.strict");
   });
 
   addTab("data:text/html;charset=utf-8,Web Console test for bug 601177: log levels");
 
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 
-    openConsole(null, function(hud) {
-      browser.addEventListener("load", function onLoad2() {
-        browser.removeEventListener("load", onLoad2, true);
-        waitForSuccess({
-          name: "all messages displayed",
-          validatorFn: function()
-          {
-            return hud.outputNode.itemCount >= 7;
-          },
-          successFn: performTest,
-          failureFn: function() {
-            info("itemCount: " + hud.outputNode.itemCount);
-            finishTest();
-          },
-        });
-      }, true);
+  function consoleOpened(hud)
+  {
+    expectUncaughtException();
+    content.location = TEST_URI;
 
-      expectUncaughtException();
-      content.location = TEST_URI;
-    });
-  }, true);
+    info("waiting for messages");
+
+    waitForMessages({
+      webconsole: hud,
+      messages: [
+        {
+          text: "test-bug-601177-log-levels.html",
+          category: CATEGORY_NETWORK,
+          severity: SEVERITY_LOG,
+        },
+        {
+          text: "test-bug-601177-log-levels.js",
+          category: CATEGORY_NETWORK,
+          severity: SEVERITY_LOG,
+        },
+        {
+          text: "test-image.png",
+          category: CATEGORY_NETWORK,
+          severity: SEVERITY_LOG,
+        },
+        {
+          text: "foobar-known-to-fail.png",
+          category: CATEGORY_NETWORK,
+          severity: SEVERITY_ERROR,
+        },
+        {
+          text: "foobarBug601177exception",
+          category: CATEGORY_JS,
+          severity: SEVERITY_ERROR,
+        },
+        {
+          text: "undefinedPropertyBug601177",
+          category: CATEGORY_JS,
+          severity: SEVERITY_WARNING,
+        },
+        {
+          text: "foobarBug601177strictError",
+          category: CATEGORY_JS,
+          severity: SEVERITY_WARNING,
+        },
+      ],
+    }).then(finishTest);
+  }
 }
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js b/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
@@ -38,18 +38,17 @@ function test()
     }));
   }, true);
 }
 
 function startTest()
 {
   // Find the relevant elements in the Web Console of tab 2.
   let win2 = tabs[runCount*2 + 1].linkedBrowser.contentWindow;
-  let hudId2 = HUDService.getHudIdByWindow(win2);
-  huds[1] = HUDService.hudReferences[hudId2];
+  huds[1] = HUDService.getHudByWindow(win2);
   info("startTest: iframe2 root height " + huds[1].ui.rootElement.clientHeight);
 
   if (runCount == 0) {
     menuitems[1] = huds[1].ui.rootElement.querySelector("#saveBodies");
   }
   else {
     menuitems[1] = huds[1].ui.rootElement.querySelector("#saveBodiesContextMenu");
   }
@@ -96,18 +95,17 @@ function testpopup2b(aEvent) {
 
     info("menupopups[1] hidden");
 
     // Switch to tab 1 and open the Web Console context menu from there.
     gBrowser.selectedTab = tabs[runCount*2];
     waitForFocus(function() {
       // Find the relevant elements in the Web Console of tab 1.
       let win1 = tabs[runCount*2].linkedBrowser.contentWindow;
-      let hudId1 = HUDService.getHudIdByWindow(win1);
-      huds[0] = HUDService.hudReferences[hudId1];
+      huds[0] = HUDService.getHudByWindow(win1);
 
       info("iframe1 root height " + huds[0].ui.rootElement.clientHeight);
 
       menuitems[0] = huds[0].ui.rootElement.querySelector("#saveBodies");
       menupopups[0] = huds[0].ui.rootElement.querySelector("menupopup");
 
       menupopups[0].addEventListener("popupshown", onpopupshown1, false);
       executeSoon(() => menupopups[0].openPopup());
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
@@ -20,38 +20,37 @@ function test() {
           category: CATEGORY_NETWORK,
           severity: SEVERITY_LOG,
         }],
       }).then(performTest);
     });
   }, true);
 }
 
-function performTest() {
-  let hudId = HUDService.getHudIdByWindow(content);
-  let HUD = HUDService.hudReferences[hudId];
+function performTest(results) {
+  let HUD = HUDService.getHudByWindow(content);
 
-  let networkMessage = HUD.outputNode.querySelector(".webconsole-msg-network");
-  ok(networkMessage, "found network message");
+  let networkMessage = [...results[0].matched][0];
+  ok(networkMessage, "network message element");
 
   let networkLink = networkMessage.querySelector(".webconsole-msg-link");
   ok(networkLink, "found network message link");
 
   let popupset = document.getElementById("mainPopupSet");
   ok(popupset, "found #mainPopupSet");
 
   let popupsShown = 0;
   let hiddenPopups = 0;
 
   let onpopupshown = function() {
     document.removeEventListener("popupshown", onpopupshown, false);
     popupsShown++;
 
     executeSoon(function() {
-      let popups = popupset.querySelectorAll("panel[hudId=" + hudId + "]");
+      let popups = popupset.querySelectorAll("panel[hudId=" + HUD.hudId + "]");
       is(popups.length, 1, "found one popup");
 
       document.addEventListener("popuphidden", onpopuphidden, false);
 
       registerCleanupFunction(function() {
         is(hiddenPopups, 1, "correct number of popups hidden");
         if (hiddenPopups != 1) {
           document.removeEventListener("popuphidden", onpopuphidden, false);
@@ -62,17 +61,17 @@ function performTest() {
     });
   };
 
   let onpopuphidden = function() {
     document.removeEventListener("popuphidden", onpopuphidden, false);
     hiddenPopups++;
 
     executeSoon(function() {
-      let popups = popupset.querySelectorAll("panel[hudId=" + hudId + "]");
+      let popups = popupset.querySelectorAll("panel[hudId=" + HUD.hudId + "]");
       is(popups.length, 0, "no popups found");
 
       executeSoon(finishTest);
     });
   };
 
   document.addEventListener("popupshown", onpopupshown, false);
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js b/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
@@ -20,17 +20,17 @@ function requestDoneCallback(aHttpReques
 
 function consoleOpened(hud)
 {
   webConsoleClient = hud.ui.webConsoleClient;
   hud.ui.setSaveRequestAndResponseBodies(true).then(() => {
     ok(hud.ui._saveRequestAndResponseBodies,
       "The saveRequestAndResponseBodies property was successfully set.");
 
-    HUDService.lastFinishedRequestCallback = requestDoneCallback;
+    HUDService.lastFinishedRequest.callback = requestDoneCallback;
     waitForSuccess(waitForResponses);
     content.location = TEST_URI;
   });
 
   let waitForResponses = {
     name: "301 and 404 responses",
     validatorFn: function()
     {
@@ -39,17 +39,17 @@ function consoleOpened(hud)
     },
     successFn: getHeaders,
     failureFn: finishTest,
   };
 }
 
 function getHeaders()
 {
-  HUDService.lastFinishedRequestCallback = null;
+  HUDService.lastFinishedRequest.callback = null;
 
   ok("301" in lastFinishedRequests, "request 1: 301 Moved Permanently");
   ok("404" in lastFinishedRequests, "request 2: 404 Not found");
 
   webConsoleClient.getResponseHeaders(lastFinishedRequests["301"].actor,
     function (aResponse) {
       lastFinishedRequests["301"].response.headers = aResponse.headers;
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js b/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js
@@ -23,17 +23,17 @@ function test()
   addTab("data:text/html;charset=utf-8,Web Console network logging tests");
 
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
 
     openConsole(null, function(aHud) {
       hud = aHud;
 
-      HUDService.lastFinishedRequestCallback = function(aRequest) {
+      HUDService.lastFinishedRequest.callback = function(aRequest) {
         lastRequest = aRequest;
         if (requestCallback) {
           requestCallback();
         }
       };
 
       executeSoon(testPageLoad);
     });
@@ -165,17 +165,17 @@ function testLiveFilteringOnSearchString
   setStringFilter("'foo'");
   is(countMessageNodes(), 0, "the log nodes are hidden when searching for " +
     "the string 'foo'");
 
   setStringFilter("foo\"bar'baz\"boo'");
   is(countMessageNodes(), 0, "the log nodes are hidden when searching for " +
     "the string \"foo\"bar'baz\"boo'\"");
 
-  HUDService.lastFinishedRequestCallback = null;
+  HUDService.lastFinishedRequest.callback = null;
   lastRequest = null;
   requestCallback = null;
   finishTest();
 }
 
 function countMessageNodes() {
   let messageNodes = hud.outputNode.querySelectorAll(".hud-msg-node");
   let displayedMessageNodes = 0;
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js b/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
@@ -17,21 +17,16 @@ function test() {
 let gHUD;
 
 function consoleOpened(aHud) {
   gHUD = aHud;
   let jsterm = gHUD.jsterm;
   let popup = jsterm.autocompletePopup;
   let completeNode = jsterm.completeNode;
 
-  let tmp = {};
-  Cu.import("resource://gre/modules/devtools/WebConsoleUtils.jsm", tmp);
-  let WCU = tmp.WebConsoleUtils;
-  tmp = null;
-
   ok(!popup.isOpen, "popup is not open");
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
 
     ok(popup.isOpen, "popup is open");
 
     // expected properties:
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_653531_highlighter_console_helper.js b/browser/devtools/webconsole/test/browser_webconsole_bug_653531_highlighter_console_helper.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_653531_highlighter_console_helper.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_653531_highlighter_console_helper.js
@@ -79,56 +79,39 @@ function performTestComparisons()
 
 function performWebConsoleTests(hud)
 {
   let target = TargetFactory.forTab(gBrowser.selectedTab);
   let jsterm = hud.jsterm;
   outputNode = hud.outputNode;
 
   jsterm.clearOutput();
-  jsterm.execute("$0");
+  jsterm.execute("$0", onNodeOutput);
 
-  waitForSuccess({
-    name: "$0 output",
-    validatorFn: function()
-    {
-      return outputNode.querySelector(".webconsole-msg-output");
-    },
-    successFn: function()
-    {
-      let node = outputNode.querySelector(".webconsole-msg-output");
-      isnot(node.textContent.indexOf("[object HTMLHeadingElement"), -1,
-            "correct output for $0");
+  function onNodeOutput()
+  {
+    let node = outputNode.querySelector(".webconsole-msg-output");
+    isnot(node.textContent.indexOf("[object HTMLHeadingElement"), -1,
+          "correct output for $0");
 
-      jsterm.clearOutput();
-      jsterm.execute("$0.textContent = 'bug653531'");
-      waitForSuccess(waitForNodeUpdate);
-    },
-    failureFn: finishUp,
-  });
+    jsterm.clearOutput();
+    jsterm.execute("$0.textContent = 'bug653531'", onNodeUpdate);
+  }
 
-  let waitForNodeUpdate = {
-    name: "$0.textContent update",
-    validatorFn: function()
-    {
-      return outputNode.querySelector(".webconsole-msg-output");
-    },
-    successFn: function()
-    {
-      let node = outputNode.querySelector(".webconsole-msg-output");
-      isnot(node.textContent.indexOf("bug653531"), -1,
-            "correct output for $0.textContent");
-      let inspector = gDevTools.getToolbox(target).getPanel("inspector");
-      is(inspector.selection.node.textContent, "bug653531",
-         "node successfully updated");
+  function onNodeUpdate()
+  {
+    let node = outputNode.querySelector(".webconsole-msg-output");
+    isnot(node.textContent.indexOf("bug653531"), -1,
+          "correct output for $0.textContent");
+    let inspector = gDevTools.getToolbox(target).getPanel("inspector");
+    is(inspector.selection.node.textContent, "bug653531",
+       "node successfully updated");
 
-      executeSoon(finishUp);
-    },
-    failureFn: finishUp,
-  };
+    executeSoon(finishUp);
+  }
 }
 
 function finishUp() {
   finishTest();
 }
 
 function test()
 {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_658368_time_methods.js b/browser/devtools/webconsole/test/browser_webconsole_bug_658368_time_methods.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_658368_time_methods.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_658368_time_methods.js
@@ -54,18 +54,17 @@ function testTimerIndependenceInTabs(hud
       executeSoon(testTimerIndependenceInSameTab);
     }, true);
     content.location = "data:text/html;charset=utf-8,<script type='text/javascript'>" +
            "console.time('bTimer');</script>";
   });
 }
 
 function testTimerIndependenceInSameTab() {
-  let hudId = HUDService.getHudIdByWindow(content);
-  let hud = HUDService.hudReferences[hudId];
+  let hud = HUDService.getHudByWindow(content);
   outputNode = hud.outputNode;
 
   waitForSuccess({
     name: "bTimer started",
     validatorFn: function()
     {
       return outputNode.textContent.indexOf("bTimer: timer started") > -1;
     },
@@ -82,18 +81,17 @@ function testTimerIndependenceInSameTab(
         "<script type='text/javascript'>" +
         "console.timeEnd('bTimer');</script>";
     },
     failureFn: finishTest,
   });
 }
 
 function testTimerIndependenceInSameTabAgain() {
-  let hudId = HUDService.getHudIdByWindow(content);
-  let hud = HUDService.hudReferences[hudId];
+  let hud = HUDService.getHudByWindow(content);
   outputNode = hud.outputNode;
 
   executeSoon(function() {
     testLogEntry(outputNode, "bTimer: timer started", "bTimer was not started",
                  false, true);
 
     closeConsole(gBrowser.selectedTab, function() {
       gBrowser.removeCurrentTab();
diff --git a/browser/devtools/webconsole/test/browser_webconsole_netlogging.js b/browser/devtools/webconsole/test/browser_webconsole_netlogging.js
--- a/browser/devtools/webconsole/test/browser_webconsole_netlogging.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_netlogging.js
@@ -27,17 +27,17 @@ function test()
   addTab("data:text/html;charset=utf-8,Web Console network logging tests");
 
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
 
     openConsole(null, function(aHud) {
       hud = aHud;
 
-      HUDService.lastFinishedRequestCallback = requestCallbackWrapper;
+      HUDService.lastFinishedRequest.callback = requestCallbackWrapper;
 
       executeSoon(testPageLoad);
     });
   }, true);
 }
 
 function requestCallbackWrapper(aRequest)
 {
@@ -199,13 +199,13 @@ function testNetworkPanel()
 
     is(hud.ui.filterBox._netPanel, networkPanel,
        "Network panel stored on anchor node");
     ok(true, "NetworkPanel was opened");
 
     // All tests are done. Shutdown.
     networkPanel.panel.hidePopup();
     lastRequest = null;
-    HUDService.lastFinishedRequestCallback = null;
+    HUDService.lastFinishedRequest.callback = null;
     executeSoon(finishTest);
   }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_notifications.js b/browser/devtools/webconsole/test/browser_webconsole_notifications.js
--- a/browser/devtools/webconsole/test/browser_webconsole_notifications.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_notifications.js
@@ -9,24 +9,24 @@ function test() {
   observer.init();
   addTab(TEST_URI);
   browser.addEventListener("load", onLoad, true);
 }
 
 function webConsoleCreated(aID)
 {
   Services.obs.removeObserver(observer, "web-console-created");
-  ok(HUDService.hudReferences[aID], "We have a hud reference");
+  ok(HUDService.getHudReferenceById(aID), "We have a hud reference");
   content.wrappedJSObject.console.log("adding a log message");
 }
 
 function webConsoleDestroyed(aID)
 {
   Services.obs.removeObserver(observer, "web-console-destroyed");
-  ok(!HUDService.hudReferences[aID], "We do not have a hud reference");
+  ok(!HUDService.getHudReferenceById(aID), "We do not have a hud reference");
   executeSoon(finishTest);
 }
 
 function webConsoleMessage(aID, aNodeID)
 {
   Services.obs.removeObserver(observer, "web-console-message-created");
   ok(aID, "we have a console ID");
   is(typeof aNodeID, "string", "message node id is a string");
@@ -38,20 +38,20 @@ let observer = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
 
   observe: function observe(aSubject, aTopic, aData)
   {
     aSubject = aSubject.QueryInterface(Ci.nsISupportsString);
 
     switch(aTopic) {
       case "web-console-created":
-        webConsoleCreated(aSubject);
+        webConsoleCreated(aSubject.data);
         break;
       case "web-console-destroyed":
-        webConsoleDestroyed(aSubject);
+        webConsoleDestroyed(aSubject.data);
         break;
       case "web-console-message-created":
         webConsoleMessage(aSubject, aData);
         break;
       default:
         break;
     }
   },
diff --git a/browser/devtools/webconsole/test/head.js b/browser/devtools/webconsole/test/head.js
--- a/browser/devtools/webconsole/test/head.js
+++ b/browser/devtools/webconsole/test/head.js
@@ -238,17 +238,17 @@ function waitForContextMenu(aPopup, aBut
 
 /**
  * Dump the output of all open Web Consoles - used only for debugging purposes.
  */
 function dumpConsoles()
 {
   if (gPendingOutputTest) {
     console.log("dumpConsoles start");
-    for each (let hud in HUDService.hudReferences) {
+    for (let hud of HUDService.consoles) {
       if (!hud.outputNode) {
         console.debug("no output content for", hud.hudId);
         continue;
       }
 
       console.debug("output content for", hud.hudId);
       for (let elem of hud.outputNode.childNodes) {
         dumpMessageElement(elem);
@@ -284,24 +284,22 @@ function dumpMessageElement(aMessage)
 }
 
 function finishTest()
 {
   browser = hudId = hud = filterBox = outputNode = cs = null;
 
   dumpConsoles();
 
-  if (HUDConsoleUI.browserConsole) {
-    let hud = HUDConsoleUI.browserConsole;
-
-    if (hud.jsterm) {
-      hud.jsterm.clearOutput(true);
+  let browserConsole = HUDService.getBrowserConsole();
+  if (browserConsole) {
+    if (browserConsole.jsterm) {
+      browserConsole.jsterm.clearOutput(true);
     }
-
-    HUDConsoleUI.toggleBrowserConsole().then(finishTest);
+    HUDService.toggleBrowserConsole().then(finishTest);
     return;
   }
 
   let hud = HUDService.getHudByWindow(content);
   if (!hud) {
     finish();
     return;
   }
@@ -314,18 +312,18 @@ function finishTest()
 
   hud = null;
 }
 
 function tearDown()
 {
   dumpConsoles();
 
-  if (HUDConsoleUI.browserConsole) {
-    HUDConsoleUI.toggleBrowserConsole();
+  if (HUDService.getBrowserConsole()) {
+    HUDService.toggleBrowserConsole();
   }
 
   let target = TargetFactory.forTab(gBrowser.selectedTab);
   gDevTools.closeToolbox(target);
   while (gBrowser.tabs.length > 1) {
     gBrowser.removeCurrentTab();
   }
   WCU_l10n = tab = browser = hudId = hud = filterBox = outputNode = cs = null;
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -186,16 +186,17 @@ const PREF_PERSISTLOG = "devtools.webcon
 /**
  * A WebConsoleFrame instance is an interactive console initialized *per target*
  * that displays console log data as well as provides an interactive terminal to
  * manipulate the target's document content.
  *
  * The WebConsoleFrame is responsible for the actual Web Console UI
  * implementation.
  *
+ * @constructor
  * @param object aWebConsoleOwner
  *        The WebConsole owner object.
  */
 function WebConsoleFrame(aWebConsoleOwner)
 {
   this.owner = aWebConsoleOwner;
   this.hudId = this.owner.hudId;
 
@@ -478,16 +479,18 @@ WebConsoleFrame.prototype = {
     this.rootElement = this.document.documentElement;
 
     this._initDefaultFilterPrefs();
 
     // Register the controller to handle "select all" properly.
     this._commandController = new CommandController(this);
     this.window.controllers.insertControllerAt(0, this._commandController);
 
+    this._contextMenuHandler = new ConsoleContextMenu(this);
+
     let doc = this.document;
 
     this.filterBox = doc.querySelector(".hud-filter-box");
     this.outputNode = doc.querySelector(".hud-output-node");
     this.completeNode = doc.querySelector(".jsterm-complete-node");
     this.inputNode = doc.querySelector(".jsterm-input-node");
 
     this._setFilterTextBoxEvents();
@@ -621,16 +624,22 @@ WebConsoleFrame.prototype = {
 
     if (!this.owner._browserConsole) {
       // The Browser Console displays nsIConsoleMessages which are messages that
       // end up in the JS category, but they are not errors or warnings, they
       // are just log messages. The Web Console does not show such messages.
       let jslog = this.document.querySelector("menuitem[prefKey=jslog]");
       jslog.hidden = true;
     }
+
+    if (Services.appinfo.OS == "Darwin") {
+      let net = this.document.querySelector("toolbarbutton[category=net]");
+      let accesskey = net.getAttribute("accesskeyMacOSX");
+      net.setAttribute("accesskey", accesskey);
+    }
   },
 
   /**
    * Increase, decrease or reset the font size.
    *
    * @param string size
    *        The size of the font change. Accepted values are "+" and "-".
    *        An unmatched size assumes a font reset.
@@ -2748,16 +2757,20 @@ WebConsoleFrame.prototype = {
       this._outputTimer.cancel();
     }
     this._outputTimer = null;
 
     if (this.jsterm) {
       this.jsterm.destroy();
       this.jsterm = null;
     }
+    if (this._contextMenuHandler) {
+      this._contextMenuHandler.destroy();
+      this._contextMenuHandler = null;
+    }
 
     this._commandController = null;
 
     let onDestroy = function() {
       this._destroyer.resolve(null);
     }.bind(this);
 
     if (this.proxy) {
@@ -4998,50 +5011,45 @@ WebConsoleConnectionProxy.prototype = {
 
 function gSequenceId()
 {
   return gSequenceId.n++;
 }
 gSequenceId.n = 0;
 
 
-function goUpdateConsoleCommands() {
-  goUpdateCommand("consoleCmd_openURL");
-  goUpdateCommand("consoleCmd_copyURL");
-}
-
-
-
 ///////////////////////////////////////////////////////////////////////////////
 // Context Menu
 ///////////////////////////////////////////////////////////////////////////////
 
-const CONTEXTMENU_ID = "output-contextmenu";
-
 /*
- * ConsoleContextMenu: This handle to show/hide a context menu item.
+ * ConsoleContextMenu this used to handle the visibility of context menu items.
+ *
+ * @constructor
+ * @param object aOwner
+ *        The WebConsoleFrame instance that owns this object.
  */
-let ConsoleContextMenu = {
+function ConsoleContextMenu(aOwner)
+{
+  this.owner = aOwner;
+  this.popup = this.owner.document.getElementById("output-contextmenu");
+  this.build = this.build.bind(this);
+  this.popup.addEventListener("popupshowing", this.build);
+}
+
+ConsoleContextMenu.prototype = {
   /*
    * Handle to show/hide context menu item.
-   *
-   * @param nsIDOMEvent aEvent
    */
   build: function CCM_build(aEvent)
   {
-    let popup = aEvent.target;
-    if (popup.id !== CONTEXTMENU_ID) {
-      return;
-    }
-
-    let view = document.querySelector(".hud-output-node");
+    let view = this.owner.outputNode;
     let metadata = this.getSelectionMetadata(view);
 
-    for (let i = 0, l = popup.childNodes.length; i < l; ++i) {
-      let element = popup.childNodes[i];
+    for (let element of this.popup.children) {
       element.hidden = this.shouldHideMenuItem(element, metadata);
     }
   },
 
   /*
    * Get selection information from the view.
    *
    * @param nsIDOMElement aView
@@ -5108,9 +5116,20 @@ let ConsoleContextMenu = {
       if (itemData.indexOf(type) !== -1) {
         shouldHide = false;
         break;
       }
     }
 
     return shouldHide;
   },
+
+  /**
+   * Destroy the ConsoleContextMenu object instance.
+   */
+  destroy: function CCM_destroy()
+  {
+    this.popup.removeEventListener("popupshowing", this.build);
+    this.popup = null;
+    this.owner = null;
+  },
 };
+
diff --git a/browser/devtools/webconsole/webconsole.xul b/browser/devtools/webconsole/webconsole.xul
--- a/browser/devtools/webconsole/webconsole.xul
+++ b/browser/devtools/webconsole/webconsole.xul
@@ -18,16 +18,22 @@
         fullscreenbutton="true"
         title="&window.title;"
         browserConsoleTitle="&browserConsole.title;"
         windowtype="devtools:webconsole"
         width="900" height="350"
         persist="screenX screenY width height sizemode">
   <script type="text/javascript" src="chrome://global/content/globalOverlay.js"/>
   <script type="text/javascript" src="webconsole.js"/>
+  <script type="text/javascript"><![CDATA[
+function goUpdateConsoleCommands() {
+  goUpdateCommand("consoleCmd_openURL");
+  goUpdateCommand("consoleCmd_copyURL");
+}
+  // ]]></script>
 
   <commandset id="editMenuCommands"/>
 
   <commandset id="consoleCommands"
               commandupdater="true"
               events="richlistbox-select"
               oncommandupdate="goUpdateConsoleCommands();">
     <command id="consoleCmd_openURL"
@@ -52,18 +58,17 @@
     <key key="&fullZoomResetCmd.commandkey2;" command="cmd_fullZoomReset" modifiers="accel"/>
     <key key="&findCmd.key;" command="cmd_find" modifiers="accel"/>
     <key key="&clearOutputCmd.key;" command="consoleCmd_clearOutput" modifiers="accel"/>
     <key key="&closeCmd.key;" command="cmd_close" modifiers="accel"/>
   </keyset>
   <keyset id="editMenuKeys"/>
 
   <popupset id="mainPopupSet">
-    <menupopup id="output-contextmenu"
-               onpopupshowing="ConsoleContextMenu.build(event);">
+    <menupopup id="output-contextmenu">
       <menuitem id="saveBodiesContextMenu" type="checkbox" label="&saveBodies.label;"
                 accesskey="&saveBodies.accesskey;"/>
       <menuitem id="menu_openURL" label="&openURL.label;"
                 accesskey="&openURL.accesskey;" command="consoleCmd_openURL"
                 selection="network" selectionType="single"/>
       <menuitem id="menu_copyURL" label="&copyURLCmd.label;"
                 accesskey="&copyURLCmd.accesskey;" command="consoleCmd_copyURL"
                 selection="network" selectionType="single"/>
@@ -73,21 +78,18 @@
   </popupset>
 
   <box class="hud-outer-wrapper devtools-responsive-container" flex="1">
     <vbox class="hud-console-wrapper" flex="1">
       <toolbar class="hud-console-filter-toolbar devtools-toolbar" mode="full">
         <toolbarbutton label="&btnPageNet.label;" type="menu-button"
                        category="net" class="devtools-toolbarbutton webconsole-filter-button"
                        tooltiptext="&btnPageNet.tooltip;"
-#ifdef XP_MACOSX
-                       accesskey="&btnPageNet.accesskeyMacOSX;"
-#else
+                       accesskeyMacOSX="&btnPageNet.accesskeyMacOSX;"
                        accesskey="&btnPageNet.accesskey;"
-#endif
                        tabindex="3">
           <menupopup>
             <menuitem label="&btnConsoleErrors;" type="checkbox" autocheck="false"
                       prefKey="network"/>
             <menuitem label="&btnConsoleWarnings;" type="checkbox" autocheck="false"
                       prefKey="netwarn"/>
             <menuitem label="&btnConsoleLog;" type="checkbox" autocheck="false"
                       prefKey="networkinfo"/>
diff --git a/toolkit/devtools/webconsole/WebConsoleUtils.jsm b/toolkit/devtools/webconsole/WebConsoleUtils.jsm
--- a/toolkit/devtools/webconsole/WebConsoleUtils.jsm
+++ b/toolkit/devtools/webconsole/WebConsoleUtils.jsm
@@ -258,17 +258,17 @@ this.WebConsoleUtils = {
    * @return object
    *         Property descriptor.
    */
   getPropertyDescriptor: function WCU_getPropertyDescriptor(aObject, aProp)
   {
     let desc = null;
     while (aObject) {
       try {
-        if (desc = Object.getOwnPropertyDescriptor(aObject, aProp)) {
+        if ((desc = Object.getOwnPropertyDescriptor(aObject, aProp))) {
           break;
         }
       }
       catch (ex if (ex.name == "NS_ERROR_XPC_BAD_CONVERT_JS" ||
                     ex.name == "NS_ERROR_XPC_BAD_OP_ON_WN_PROTO" ||
                     ex.name == "TypeError")) {
         // Native getters throw here. See bug 520882.
         // null throws TypeError.
@@ -1250,22 +1250,22 @@ this.JSTermHelpers = function JSTermHelp
    * @param [optional] nsIDOMNode aContext
    *        Context to run the xPath query on. Uses window.document if not set.
    * @return array of nsIDOMNode
    */
   aOwner.sandbox.$x = function JSTH_$x(aXPath, aContext)
   {
     let nodes = new aOwner.window.wrappedJSObject.Array();
     let doc = aOwner.window.document;
-    let aContext = aContext || doc;
+    aContext = aContext || doc;
 
     let results = doc.evaluate(aXPath, aContext, null,
                                Ci.nsIDOMXPathResult.ANY_TYPE, null);
     let node;
-    while (node = results.iterateNext()) {
+    while ((node = results.iterateNext())) {
       nodes.push(node);
     }
 
     return nodes;
   };
 
   /**
    * Returns the currently selected object in the highlighter.
@@ -1384,17 +1384,17 @@ this.JSTermHelpers = function JSTermHelp
   aOwner.sandbox.pprint = function JSTH_pprint(aObject)
   {
     if (aObject === null || aObject === undefined || aObject === true ||
         aObject === false) {
       aOwner.helperResult = {
         type: "error",
         message: "helperFuncUnsupportedTypeError",
       };
-      return;
+      return null;
     }
 
     aOwner.helperResult = { rawOutput: true };
 
     if (typeof aObject == "function") {
       return aObject + "\n";
     }
 
