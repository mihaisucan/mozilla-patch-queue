# HG changeset patch
# User Girish Sharma <scrapmachines@gmail.com>
# Date 1376596839 -19800
# Node ID 8f5d6257547382ddce3c677f3c6578485da35add
# Parent a90744bf61988eac52056b8dbd53b9b8001490cb
Bug 900415 - Should be able to open the autocompletion popup at an offset from the anchor node

diff --git a/browser/devtools/shared/autocomplete-popup.js b/browser/devtools/shared/autocomplete-popup.js
--- a/browser/devtools/shared/autocomplete-popup.js
+++ b/browser/devtools/shared/autocomplete-popup.js
@@ -122,19 +122,19 @@ AutocompletePopup.prototype = {
   onKeypress: null,
 
   /**
    * Open the autocomplete popup panel.
    *
    * @param nsIDOMNode aAnchor
    *        Optional node to anchor the panel to.
    */
-  openPopup: function AP_openPopup(aAnchor)
+  openPopup: function AP_openPopup(aAnchor, aXOffset = 0, aYOffset = 0)
   {
-    this._panel.openPopup(aAnchor, this.position, 0, 0);
+    this._panel.openPopup(aAnchor, this.position, aXOffset, aYOffset);
 
     if (this.autoSelect) {
       this.selectFirstItem();
     }
     if (!this.fixedWidth) {
       this._updateSize();
     }
   },
@@ -220,16 +220,22 @@ AutocompletePopup.prototype = {
   /**
    * Set the autocomplete items list, in one go.
    *
    * @param array aItems
    *        The list of items you want displayed in the popup list.
    */
   setItems: function AP_setItems(aItems)
   {
+    // If we have to resize the popup, add a margin equivalent of the scrollbar's
+    // width so that we do not see a flickering.
+    if (!this.fixedWidth &&
+        (this.overflowing || aItems.length > this.itemCount)) {
+      this._list.style.marginRight = this._scrollbarWidth + "px";
+    }
     this.clearItems();
     aItems.forEach(this.appendItem, this);
 
     // Make sure that the new content is properly fitted by the XUL richlistbox.
     if (this.isOpen) {
       if (this.autoSelect) {
         this.selectFirstItem();
       }
@@ -265,18 +271,23 @@ AutocompletePopup.prototype = {
       return;
     }
     // Flush the layout so that we get the latest height.
     this._panel.boxObject.height;
     let height = {};
     this._list.scrollBoxObject.getScrolledSize({}, height);
     // Change the width of the popup only if the scrollbar is visible.
     if (height.value > this._panel.clientHeight) {
-       this._list.width = this._panel.clientWidth + this._scrollbarWidth;
+      this._list.width = this._panel.clientWidth;
+      this.overflowing = true;
     }
+    else {
+      this.overflowing = false;
+    }
+    this._list.style.marginRight = "0";
     // Height change is required, otherwise the panel is drawn at an offset
     // the first time.
     this._list.height = this._list.clientHeight;
     // This brings the panel back at right position.
     this._list.top = 0;
     // Move the panel to -1,-1 to realign the popup with its anchor node when
     // decreasing the panel height.
     this._panel.moveTo(-1, -1);
@@ -490,29 +501,34 @@ AutocompletePopup.prototype = {
 
   /**
    * Determine the scrollbar width in the current document.
    *
    * @private
    */
   get _scrollbarWidth()
   {
-    if (this.__scrollbarWidth) {
+    if (this.__scrollbarWidth !== undefined) {
       return this.__scrollbarWidth;
     }
 
     let hbox = this._document.createElementNS(XUL_NS, "hbox");
     hbox.setAttribute("style", "height: 0%; overflow: hidden");
 
     let scrollbar = this._document.createElementNS(XUL_NS, "scrollbar");
     scrollbar.setAttribute("orient", "vertical");
     hbox.appendChild(scrollbar);
 
     this._document.documentElement.appendChild(hbox);
-    this.__scrollbarWidth = scrollbar.clientWidth;
+    if (scrollbar.boxObject.screenX == -1 * scrollbar.boxObject.width) {
+      this.__scrollbarWidth = 0;
+    }
+    else {
+      this.__scrollbarWidth = scrollbar.clientWidth;
+    }
     this._document.documentElement.removeChild(hbox);
 
     return this.__scrollbarWidth;
   },
 
   /**
    * Manages theme switching for the popup based on the devtools.theme pref.
    *
diff --git a/browser/devtools/shared/inplace-editor.js b/browser/devtools/shared/inplace-editor.js
--- a/browser/devtools/shared/inplace-editor.js
+++ b/browser/devtools/shared/inplace-editor.js
@@ -174,16 +174,17 @@ function InplaceEditor(aOptions, aEvent)
 
   this._onBlur = this._onBlur.bind(this);
   this._onKeyPress = this._onKeyPress.bind(this);
   this._onInput = this._onInput.bind(this);
   this._onKeyup = this._onKeyup.bind(this);
 
   this._createInput();
   this._autosize();
+  this.inputCharWidth = this._getInputCharWidth();
 
   // Pull out character codes for advanceChars, listing the
   // characters that should trigger a blur.
   this._advanceCharCodes = {};
   let advanceChars = aOptions.advanceChars || '';
   for (let i = 0; i < advanceChars.length; i++) {
     this._advanceCharCodes[advanceChars.charCodeAt(i)] = true;
   }
@@ -325,16 +326,28 @@ InplaceEditor.prototype = {
       width += 15;
       this._measurement.textContent += "M";
       this.input.style.height = this._measurement.offsetHeight + "px";
     }
 
     this.input.style.width = width + "px";
   },
 
+  /**
+   * Get the width of a single character in the input to properly position the
+   * autocompletion popup.
+   */
+  _getInputCharWidth: function InplaceEditor_getInputCharWidth()
+  {
+    // Just make the text content to be 'x' to get the width of any character in
+    // a monospace font.
+    this._measurement.textContent = "x";
+    return this._measurement.offsetWidth;
+  },
+
    /**
    * Increment property values in rule view.
    *
    * @param {number} increment
    *        The amount to increase/decrease the property value.
    * @return {bool} true if value has been incremented.
    */
   _incrementValue: function InplaceEditor_incrementValue(increment)
@@ -968,19 +981,22 @@ InplaceEditor.prototype = {
           break;
         }
         else if (list[i][0] > startCheckQuery[0]) {
           // We have crossed all possible matches alphabetically.
           break;
         }
       }
 
+      // Calculate the offset for the popup to be opened.
+      let x = (this.input.selectionStart - startCheckQuery.length) *
+              this.inputCharWidth;
       if (finalList.length > 1) {
         this.popup.setItems(finalList);
-        this.popup.openPopup(this.input);
+        this.popup.openPopup(this.input, x);
       } else {
         this.popup.hidePopup();
       }
       // This emit is mainly for the purpose of making the test flow simpler.
       this.emit("after-suggest");
     }, 0);
   }
 };
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -494,16 +494,19 @@ WebConsoleFrame.prototype = {
 
     if (fontSize != 0) {
       fontSize = Math.max(MIN_FONT_SIZE, fontSize);
 
       this.outputNode.style.fontSize = fontSize + "px";
       this.completeNode.style.fontSize = fontSize + "px";
       this.inputNode.style.fontSize = fontSize + "px";
     }
+    // Update the character width and height needed for the popup offset
+    // calculations.
+    this._updateCharSize();
 
     let updateSaveBodiesPrefUI = (aElement) => {
       this.getSaveRequestAndResponseBodies().then(aValue => {
         aElement.setAttribute("checked", aValue);
         this.emit("save-bodies-ui-toggled");
       });
     }
 
@@ -685,16 +688,46 @@ WebConsoleFrame.prototype = {
       this.outputNode.style.fontSize = fontSize;
     }
     else {
       this.completeNode.style.fontSize = "";
       this.inputNode.style.fontSize = "";
       this.outputNode.style.fontSize = "";
       Services.prefs.clearUserPref("devtools.webconsole.fontSize");
     }
+    this._updateCharSize();
+  },
+
+  /**
+   * recalculates the width and height of a single character of the input box.
+   * This will be used in opening the popup at the correct offset.
+   *
+   * @private 
+   */
+  _updateCharSize: function WCF__updateCharSize()
+  {
+    let doc = this.document;
+    let tempLabel = doc.createElementNS("http://www.w3.org/1999/xhtml", "span");
+    let style = tempLabel.style;
+    style.position = "fixed";
+    style.padding = "0";
+    style.margin = "0";
+    style.width = "auto";
+    style.color = "transparent";
+    copyTextStyles(this.inputNode, tempLabel);
+    tempLabel.textContent = "x";
+    doc.documentElement.appendChild(tempLabel);
+    this.inputCharWidth = tempLabel.offsetWidth;
+    this.inputCharHeight = tempLabel.offsetHeight;
+    tempLabel.parentNode.removeChild(tempLabel);
+    tempLabel = null;
+    // Calculate the width of the chevron placed at the beginning of the input
+    // box. Remove 4 more pixels to accomodate the padding of the popup.
+    this.chevronWidth = +doc.defaultView.getComputedStyle(this.inputNode)
+                            .paddingLeft.replace(/[^0-9.]/g, "") - 4;
   },
 
   /**
    * The event handler that is called whenever a user switches a filter on or
    * off.
    *
    * @private
    * @param nsIDOMEvent aEvent
@@ -4307,17 +4340,26 @@ JSTerm.prototype = {
 
     let completionType = this.lastCompletion.completionType;
     this.lastCompletion = {
       value: inputValue,
       matchProp: lastPart,
     };
 
     if (items.length > 1 && !popup.isOpen) {
-      popup.openPopup(inputNode);
+      let x = (this.inputNode.selectionStart - lastPart.length) *
+              this.hud.inputCharWidth;
+      let y = this.inputNode.value.slice(0, this.inputNode.selectionStart)
+                  .split("\n").length - 1;
+      if (y > 0) {
+        x -= (this.inputNode.value
+                 .lastIndexOf("\n", this.inputNode.selectionStart) + y) *
+              this.hud.inputCharWidth;
+      }
+      popup.openPopup(inputNode, x + this.hud.chevronWidth);
       this._autocompletePopupNavigated = false;
     }
     else if (items.length < 2 && popup.isOpen) {
       popup.hidePopup();
       this._autocompletePopupNavigated = false;
     }
 
     if (items.length == 1) {
@@ -5116,16 +5158,25 @@ WebConsoleConnectionProxy.prototype = {
 };
 
 function gSequenceId()
 {
   return gSequenceId.n++;
 }
 gSequenceId.n = 0;
 
+function copyTextStyles(aFrom, aTo)
+{
+  let win = aFrom.ownerDocument.defaultView;
+  let style = win.getComputedStyle(aFrom);
+  aTo.style.fontFamily = style.getPropertyCSSValue("font-family").cssText;
+  aTo.style.fontSize = style.getPropertyCSSValue("font-size").cssText;
+  aTo.style.fontWeight = style.getPropertyCSSValue("font-weight").cssText;
+  aTo.style.fontStyle = style.getPropertyCSSValue("font-style").cssText;
+}
 
 ///////////////////////////////////////////////////////////////////////////////
 // Context Menu
 ///////////////////////////////////////////////////////////////////////////////
 
 /*
  * ConsoleContextMenu this used to handle the visibility of context menu items.
  *
diff --git a/browser/themes/shared/devtools/common.inc.css b/browser/themes/shared/devtools/common.inc.css
--- a/browser/themes/shared/devtools/common.inc.css
+++ b/browser/themes/shared/devtools/common.inc.css
@@ -9,34 +9,39 @@
 
 .devtools-autocomplete-popup {
   -moz-appearance: none !important;
   border: 1px solid hsl(210,11%,10%);
   box-shadow: 0 1px 0 hsla(209,29%,72%,.25) inset;
   background-color: transparent;
   background-image: linear-gradient(to bottom, hsla(209,18%,18%,0.9), hsl(210,11%,16%));
   border-radius: 3px;
+  overflow-x: hidden;
 %ifdef XP_LINUX
   max-height: 32rem;
 %else
   max-height: 40rem;
 %endif
 }
 
 .devtools-autocomplete-listbox {
   -moz-appearance: none !important;
   background-color: transparent;
   border-width: 0px !important;
+  margin-right: 0px;
+  margin-left: 0px;
 }
 
 .devtools-autocomplete-listbox > richlistitem,
 .devtools-autocomplete-listbox > richlistitem[selected] {
   width: 100%;
   background-color: transparent;
   border-radius: 4px;
+  padding-left: 4px;
+  padding-right: 4px;
 }
 
 .devtools-autocomplete-listbox.dark-theme > richlistitem[selected],
 .devtools-autocomplete-listbox.dark-theme > richlistitem:hover {
   background-color: rgba(0,0,0,0.5);
 }
 
 .devtools-autocomplete-listbox.dark-theme > richlistitem[selected] > .autocomplete-value,
