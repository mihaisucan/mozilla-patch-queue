# HG changeset patch
# Parent 3049ead9e504033a951af3227dd1dce6d01df250
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1339010985 -10800

Bug 761257 - Further improve Web Console output performance

diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -170,21 +170,27 @@ const ERRORS = { LOG_MESSAGE_MISSING_ARG
 // The indent of a console group in pixels.
 const GROUP_INDENT = 12;
 
 // The pref prefix for webconsole filters
 const PREFS_PREFIX = "devtools.webconsole.filter.";
 
 // The number of messages to display in a single display update. If we display
 // too many messages at once we slow the Firefox UI too much.
-const MESSAGES_IN_INTERVAL = 30;
-
-// The delay between display updates - tells how often we should push new
-// messages to screen.
-const OUTPUT_INTERVAL = 90; // milliseconds
+const MESSAGES_IN_INTERVAL = DEFAULT_LOG_LIMIT;
+
+// The delay between display updates - tells how often we should *try* to push
+// new messages to screen. This value is optimistic, updates won't always
+// happen. Keep this low so the Web Console output feels live.
+const OUTPUT_INTERVAL = 50; // milliseconds
+
+// When the output queue has more than MESSAGES_IN_INTERVAL items we throttle
+// output updates to this number of milliseconds. So during a lot of output we
+// update every N milliseconds given here.
+const THROTTLE_UPDATES = 1000; // milliseconds
 
 ///////////////////////////////////////////////////////////////////////////
 //// Helper for creating the network panel.
 
 /**
  * Creates a DOMNode and sets all the attributes of aAttributes on the created
  * element.
  *
@@ -1044,34 +1050,25 @@ HeadsUpDisplay.prototype = {
    * Holds the network requests currently displayed by the Web Console. Each key
    * represents the connection ID and the value is network request information.
    * @private
    * @type object
    */
   _networkRequests: null,
 
   /**
-   * Last time when we displayed any message in the output. Timestamp in
-   * milliseconds since the Unix epoch.
+   * Last time when we displayed any message in the output.
    *
    * @private
    * @type number
+   *       Timestamp in milliseconds since the Unix epoch.
    */
   _lastOutputFlush: 0,
 
   /**
-   * The number of messages displayed in the last interval. The interval is
-   * given by OUTPUT_INTERVAL.
-   *
-   * @private
-   * @type number
-   */
-  _messagesDisplayedInInterval: 0,
-
-  /**
    * Message nodes are stored here in a queue for later display.
    *
    * @private
    * @type array
    */
   _outputQueue: null,
 
   /**
@@ -1408,21 +1405,27 @@ HeadsUpDisplay.prototype = {
   function HUD__displayCachedConsoleMessages(aRemoteMessages)
   {
     if (!aRemoteMessages.length) {
       return;
     }
 
     aRemoteMessages.forEach(function(aMessage) {
       switch (aMessage._type) {
-        case "PageError":
-          this.reportPageError(aMessage);
+        case "PageError": {
+          let category = this.categoryForScriptError(aMessage.category);
+          if (category != -1) {
+            this.outputMessage(category, this.reportPageError,
+                               [category, aMessage]);
+          }
           break;
+        }
         case "ConsoleAPI":
-          this.logConsoleAPIMessage(aMessage);
+          this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
+                             [aMessage]);
           break;
       }
     }, this);
   },
 
   /**
    * Shortcut to make XUL nodes
    *
@@ -1882,16 +1885,18 @@ HeadsUpDisplay.prototype = {
    *        console service. This object needs to hold:
    *          - hudId - the Web Console ID.
    *          - apiMessage - a representation of the object sent by the console
    *          storage service. This object holds the console message level, the
    *          arguments that were passed to the console method and other
    *          information.
    *          - argumentsToString - the array of arguments passed to the console
    *          method, each converted to a string.
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
    */
   logConsoleAPIMessage: function HUD_logConsoleAPIMessage(aMessage)
   {
     let body = null;
     let clipboardText = null;
     let sourceURL = null;
     let sourceLine = 0;
     let level = aMessage.apiMessage.level;
@@ -2014,98 +2019,111 @@ HeadsUpDisplay.prototype = {
           data: { object: node._stacktrace },
         };
 
         let propPanel = this.jsterm.openPropertyPanel(options);
         propPanel.panel.setAttribute("hudId", this.hudId);
       }.bind(this));
     }
 
-    ConsoleUtils.outputMessageNode(node, this.hudId);
-
     if (level == "dir") {
+      // Make sure the cached evaluated object will be purged when the node is
+      // removed.
+      node._evalCacheId = aMessage.objectsCacheId;
+
       // Initialize the inspector message node, by setting the PropertyTreeView
       // object on the tree view. This has to be done *after* the node is
       // shown, because the tree binding must be attached first.
-      let tree = node.querySelector("tree");
-      tree.view = node.propertyTreeView;
-
-      // Make sure the cached evaluated object will be purged when the node is
-      // removed.
-      node._evalCacheId = aMessage.objectsCacheId;
+      node._onOutput = function _onMessageOutput() {
+        node.querySelector("tree").view = node.propertyTreeView;
+      };
     }
+
+    return node;
   },
 
   /**
    * Reports an error in the page source, either JavaScript or CSS.
    *
    * @param nsIScriptError aScriptError
    *        The error message to report.
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
    */
-  reportPageError: function HUD_reportPageError(aScriptError)
+  reportPageError: function HUD_reportPageError(aCategory, aScriptError)
   {
     if (!aScriptError.outerWindowID) {
       return;
     }
 
-    let category;
-
+    // Warnings and legacy strict errors become warnings; other types become
+    // errors.
+    let severity = SEVERITY_ERROR;
+    if ((aScriptError.flags & aScriptError.warningFlag) ||
+        (aScriptError.flags & aScriptError.strictFlag)) {
+      severity = SEVERITY_WARNING;
+    }
+
+    let node = ConsoleUtils.createMessageNode(this.chromeDocument,
+                                              aCategory,
+                                              severity,
+                                              aScriptError.errorMessage,
+                                              this.hudId,
+                                              aScriptError.sourceName,
+                                              aScriptError.lineNumber,
+                                              null,
+                                              null,
+                                              aScriptError.timeStamp);
+    return node;
+  },
+
+  /**
+   * Determine the category of a given nsIScriptError.
+   *
+   * @param nsIScriptError aScriptError
+   *        The script error you want to determine the category for.
+   * @return CATEGORY_JS|CATEGORY_CSS|-1
+   *         Depending on the script error CATEGORY_JS or CATEGORY_CSS can be
+   *         returned. If the category is unknown -1 is returned.
+   */
+  categoryForScriptError: function HUD_categoryForScriptError(aScriptError)
+  {
     switch (aScriptError.category) {
       // We ignore chrome-originating errors as we only care about content.
       case "XPConnect JavaScript":
       case "component javascript":
       case "chrome javascript":
       case "chrome registration":
       case "XBL":
       case "XBL Prototype Handler":
       case "XBL Content Sink":
       case "xbl javascript":
-        return;
+        return -1;
 
       case "CSS Parser":
       case "CSS Loader":
-        category = CATEGORY_CSS;
-        break;
+        return CATEGORY_CSS;
 
       default:
-        category = CATEGORY_JS;
-        break;
+        return CATEGORY_JS;
     }
-
-    // Warnings and legacy strict errors become warnings; other types become
-    // errors.
-    let severity = SEVERITY_ERROR;
-    if ((aScriptError.flags & aScriptError.warningFlag) ||
-        (aScriptError.flags & aScriptError.strictFlag)) {
-      severity = SEVERITY_WARNING;
-    }
-
-    let node = ConsoleUtils.createMessageNode(this.chromeDocument,
-                                              category,
-                                              severity,
-                                              aScriptError.errorMessage,
-                                              this.hudId,
-                                              aScriptError.sourceName,
-                                              aScriptError.lineNumber,
-                                              null,
-                                              null,
-                                              aScriptError.timeStamp);
-
-    ConsoleUtils.outputMessageNode(node, this.hudId);
   },
 
   /**
    * Log network activity.
    *
    * @param object aHttpActivity
    *        The HTTP activity to log.
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
    */
-  logNetActivity: function HUD_logNetActivity(aHttpActivity)
+  logNetActivity: function HUD_logNetActivity(aConnectionId)
   {
-    let entry = aHttpActivity.log.entries[0];
+    let networkInfo = this._networkRequests[aConnectionId];
+    let entry = networkInfo.httpActivity.log.entries[0];
     let request = entry.request;
 
     let msgNode = this.chromeDocument.createElementNS(XUL_NS, "hbox");
 
     let methodNode = this.chromeDocument.createElementNS(XUL_NS, "label");
     methodNode.setAttribute("value", request.method);
     methodNode.classList.add("webconsole-msg-body-piece");
     msgNode.appendChild(methodNode);
@@ -2141,37 +2159,36 @@ HeadsUpDisplay.prototype = {
                                                      msgNode,
                                                      this.hudId,
                                                      null,
                                                      null,
                                                      clipboardText);
 
     messageNode._connectionId = entry.connection;
 
-    let networkInfo = {
-      node: messageNode,
-      httpActivity: aHttpActivity,
-    };
-
-    this._networkRequests[entry.connection] = networkInfo;
-
     this.makeOutputMessageLink(messageNode, function HUD_net_message_link() {
       if (!messageNode._panelOpen) {
         HUDService.openNetworkPanel(messageNode, networkInfo.httpActivity);
       }
     }.bind(this));
 
-    ConsoleUtils.outputMessageNode(messageNode, this.hudId);
+    networkInfo.node = messageNode;
+
+    this._updateNetMessage(entry.connection);
+
+    return messageNode;
   },
 
   /**
    * Log file activity.
    *
    * @param string aFileURI
    *        The file URI that was loaded.
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
    */
   logFileActivity: function HUD_logFileActivity(aFileURI)
   {
     let chromeDocument = this.chromeDocument;
 
     let urlNode = chromeDocument.createElementNS(XUL_NS, "label");
     urlNode.setAttribute("crop", "center");
     urlNode.setAttribute("flex", "1");
@@ -2189,30 +2206,33 @@ HeadsUpDisplay.prototype = {
                                                     null,
                                                     aFileURI);
 
     this.makeOutputMessageLink(outputNode, function HUD__onFileClick() {
       let viewSourceUtils = chromeDocument.defaultView.gViewSourceUtils;
       viewSourceUtils.viewSource(aFileURI, null, chromeDocument);
     });
 
-    ConsoleUtils.outputMessageNode(outputNode, this.hudId);
+    return outputNode;
   },
 
   /**
    * Inform user that the Web Console API has been replaced by a script
    * in a content page.
+   *
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
    */
   logWarningAboutReplacedAPI: function HUD_logWarningAboutReplacedAPI()
   {
     let message = l10n.getStr("ConsoleAPIDisabled");
     let node = ConsoleUtils.createMessageNode(this.chromeDocument, CATEGORY_JS,
                                               SEVERITY_WARNING, message,
                                               this.hudId);
-    ConsoleUtils.outputMessageNode(node, this.hudId);
+    return node;
   },
 
   ERRORS: {
     HUD_BOX_DOES_NOT_EXIST: "Heads Up Display does not exist",
     TAB_ID_REQUIRED: "Tab DOM ID is required",
     PARENTNODE_NOT_FOUND: "parentNode element not found"
   },
 
@@ -2268,36 +2288,43 @@ HeadsUpDisplay.prototype = {
         break;
       case "JSTerm:ClearOutput":
         this.jsterm.clearOutput();
         break;
       case "JSTerm:InspectObject":
         this.jsterm.handleInspectObject(aMessage.json);
         break;
       case "WebConsole:ConsoleAPI":
-        this.logConsoleAPIMessage(aMessage.json);
+        this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage, [aMessage.json]);
         break;
-      case "WebConsole:PageError":
-        this.reportPageError(aMessage.json.pageError);
+      case "WebConsole:PageError": {
+        let pageError = aMessage.json.pageError;
+        let category = this.categoryForScriptError(pageError);
+        if (category != -1) {
+          this.outputMessage(category, this.reportPageError,
+                             [category, pageError]);
+        }
         break;
+      }
       case "WebConsole:CachedMessages":
         this._displayCachedConsoleMessages(aMessage.json.messages);
         this._onInitComplete();
         break;
       case "WebConsole:NetworkActivity":
         this.handleNetworkActivity(aMessage.json);
         break;
       case "WebConsole:FileActivity":
-        this.logFileActivity(aMessage.json.uri);
+        this.outputMessage(CATEGORY_NETWORK, this.logFileActivity,
+                           [aMessage.json.uri]);
         break;
       case "WebConsole:LocationChange":
         this.onLocationChange(aMessage.json);
         break;
       case "JSTerm:NonNativeConsoleAPI":
-        this.logWarningAboutReplacedAPI();
+        this.outputMessage(CATEGORY_JS, this.logWarningAboutReplacedAPI);
         break;
     }
   },
 
   /**
    * Callback method for when the Web Console initialization is complete. For
    * now this method sends the web-console-created notification using the
    * nsIObserverService.
@@ -2381,33 +2408,71 @@ HeadsUpDisplay.prototype = {
    *          if the network request/response body was discarded or not.
    *        - log - the request and response information. This is a HAR-like
    *        object. See HUDService-content.js
    *        NetworkMonitor.createActivityObject().
    */
   handleNetworkActivity: function HUD_handleNetworkActivity(aMessage)
   {
     let stage = aMessage.meta.stages[aMessage.meta.stages.length - 1];
+    let entry = aMessage.log.entries[0];
 
     if (stage == "REQUEST_HEADER") {
-      this.logNetActivity(aMessage);
+      let networkInfo = {
+        node: null,
+        httpActivity: aMessage,
+      };
+
+      this._networkRequests[entry.connection] = networkInfo;
+      this.outputMessage(CATEGORY_NETWORK, this.logNetActivity,
+                         [entry.connection]);
       return;
     }
 
-    let entry = aMessage.log.entries[0];
-    let request = entry.request;
-    let response = entry.response;
-
     if (!(entry.connection in this._networkRequests)) {
       return;
     }
 
-    let loggedRequest = this._networkRequests[entry.connection];
-    let messageNode = loggedRequest.node;
-    loggedRequest.httpActivity = aMessage;
+    let networkInfo = this._networkRequests[entry.connection];
+    networkInfo.httpActivity = aMessage;
+
+    if (networkInfo.node) {
+      this._updateNetMessage(entry.connection);
+    }
+
+    // For unit tests we pass the HTTP activity object to the test callback,
+    // once requests complete.
+    if (HUDService.lastFinishedRequestCallback &&
+        aMessage.meta.stages.indexOf("REQUEST_STOP") > -1 &&
+        aMessage.meta.stages.indexOf("TRANSACTION_CLOSE") > -1) {
+      HUDService.lastFinishedRequestCallback(aMessage);
+    }
+  },
+
+  /**
+   * Update an output message to reflect the latest state of a network request,
+   * given a network connection ID.
+   *
+   * @private
+   * @param string aConnectionId
+   *        The connection ID to update.
+   */
+  _updateNetMessage: function HUD__updateNetMessage(aConnectionId)
+  {
+    let networkInfo = this._networkRequests[aConnectionId];
+    if (!networkInfo || !networkInfo.node) {
+      return;
+    }
+
+    let messageNode = networkInfo.node;
+    let httpActivity = networkInfo.httpActivity;
+    let stage = httpActivity.meta.stages[httpActivity.meta.stages.length - 1];
+    let entry = httpActivity.log.entries[0];
+    let request = entry.request;
+    let response = entry.response;
 
     if (stage == "TRANSACTION_CLOSE" || stage == "RESPONSE_HEADER") {
       let status = [response.httpVersion, response.status, response.statusText];
       if (stage == "TRANSACTION_CLOSE") {
         status.push(l10n.getFormatStr("NetworkPanel.durationMS", [entry.time]));
       }
       let statusText = "[" + status.join(" ") + "]";
 
@@ -2424,24 +2489,16 @@ HeadsUpDisplay.prototype = {
         ConsoleUtils.setMessageType(messageNode, CATEGORY_NETWORK,
                                     SEVERITY_ERROR);
       }
     }
 
     if (messageNode._netPanel) {
       messageNode._netPanel.update();
     }
-
-    // For unit tests we pass the HTTP activity object to the test callback,
-    // once requests complete.
-    if (HUDService.lastFinishedRequestCallback &&
-        aMessage.meta.stages.indexOf("REQUEST_STOP") > -1 &&
-        aMessage.meta.stages.indexOf("TRANSACTION_CLOSE") > -1) {
-      HUDService.lastFinishedRequestCallback(aMessage);
-    }
   },
 
   /**
    * Handler for the "WebConsole:LocationChange" message. If the Web Console is
    * opened in a panel the panel title is updated.
    *
    * @param object aMessage
    *        The message received from the content script. It needs to hold two
@@ -2495,92 +2552,103 @@ HeadsUpDisplay.prototype = {
 
   /**
    * Output a message node. This filters a node appropriately, then sends it to
    * the output, regrouping and pruning output as necessary.
    *
    * Note: this call is async - the given message node may not be displayed when
    * you call this method.
    *
-   * @param nsIDOMNode aNode
-   *        The message node to send to the output.
-   * @param nsIDOMNode [aNodeAfter]
-   *        Insert the node after the given aNodeAfter (optional).
+   * @param integer aCategory
+   *        The category of the message you want to output. See the CATEGORY_*
+   *        constants.
+   * @param function|nsIDOMElement aMethodOrNode
+   *        The method that creates the message element to send to the output or
+   *        the actual element. If a method is given it will be bound to the HUD
+   *        object and the arguments will be |aArguments|.
+   * @param array [aArguments]
+   *        If a method is given to output the message element then the method
+   *        will be invoked with the list of arguments given here.
    */
-  outputMessageNode: function HUD_outputMessageNode(aNode, aNodeAfter)
+  outputMessage: function HUD_outputMessage(aCategory, aMethodOrNode, aArguments)
   {
-    this._outputQueue.push([aNode, aNodeAfter]);
-    this._flushMessageQueue();
+    if (!this._outputQueue.length) {
+      // If the queue is empty we consider that now was the last output flush.
+      // This avoid an immediate output flush when the timer executes.
+      this._lastOutputFlush = Date.now();
+    }
+
+    this._outputQueue.push([aCategory, aMethodOrNode, aArguments]);
+
+    if (!this._outputTimeout) {
+      this._outputTimeout =
+        this.chromeWindow.setTimeout(this._flushMessageQueue.bind(this),
+                                     OUTPUT_INTERVAL);
+    }
   },
 
   /**
    * Try to flush the output message queue. This takes the messages in the
    * output queue and displays them. Outputting stops at MESSAGES_IN_INTERVAL.
    * Further output is queued to happen later - see OUTPUT_INTERVAL.
    *
    * @private
    */
   _flushMessageQueue: function HUD__flushMessageQueue()
   {
-    if ((Date.now() - this._lastOutputFlush) >= OUTPUT_INTERVAL) {
-      this._messagesDisplayedInInterval = 0;
+    let timeSinceFlush = Date.now() - this._lastOutputFlush;
+    if (this._outputQueue.length > MESSAGES_IN_INTERVAL &&
+        timeSinceFlush < THROTTLE_UPDATES) {
+      this._outputTimeout =
+        this.chromeWindow.setTimeout(this._flushMessageQueue.bind(this),
+                                     OUTPUT_INTERVAL);
+      return;
     }
 
     // Determine how many messages we can display now.
-    let toDisplay = Math.min(this._outputQueue.length,
-                             MESSAGES_IN_INTERVAL -
-                             this._messagesDisplayedInInterval);
-
-    if (!toDisplay) {
-      if (!this._outputTimeout && this._outputQueue.length > 0) {
-        this._outputTimeout =
-          this.chromeWindow.setTimeout(function() {
-            delete this._outputTimeout;
-            this._flushMessageQueue();
-          }.bind(this), OUTPUT_INTERVAL);
-      }
+    let toDisplay = Math.min(this._outputQueue.length, MESSAGES_IN_INTERVAL);
+    if (toDisplay < 1) {
+      this._outputTimeout = null;
       return;
     }
 
     // Try to prune the message queue.
     let shouldPrune = false;
     if (this._outputQueue.length > toDisplay && this._pruneOutputQueue()) {
       toDisplay = Math.min(this._outputQueue.length, toDisplay);
       shouldPrune = true;
     }
 
     let batch = this._outputQueue.splice(0, toDisplay);
     if (!batch.length) {
+      this._outputTimeout = null;
       return;
     }
 
     let outputNode = this.outputNode;
     let lastVisibleNode = null;
     let scrolledToBottom = ConsoleUtils.isOutputScrolledToBottom(outputNode);
     let scrollBox = outputNode.scrollBoxObject.element;
 
     let hudIdSupportsString = WebConsoleUtils.supportsString(this.hudId);
 
     // Output the current batch of messages.
     for (let item of batch) {
-      if (this._outputMessageFromQueue(hudIdSupportsString, item)) {
-        lastVisibleNode = item[0];
+      let node = this._outputMessageFromQueue(hudIdSupportsString, item);
+      if (node) {
+        lastVisibleNode = node;
       }
     }
 
-    // Keep track of how many messages we displayed, so we do not display too
-    // many at once.
-    this._messagesDisplayedInInterval += batch.length;
-
     let oldScrollHeight = 0;
 
     // Prune messages if needed. We do not do this for every flush call to
     // improve performance.
     let removedNodes = 0;
-    if (shouldPrune || !(this._outputQueue.length % 20)) {
+    if (shouldPrune || !this._outputQueue.length) {
       oldScrollHeight = scrollBox.scrollHeight;
 
       let categories = Object.keys(this._pruneCategoriesQueue);
       categories.forEach(function _pruneOutput(aCategory) {
         removedNodes += pruneConsoleOutputIfNecessary(this.hudId, aCategory);
       }, this);
       this._pruneCategoriesQueue = {};
     }
@@ -2603,42 +2671,55 @@ HeadsUpDisplay.prototype = {
     else if (!scrolledToBottom && removedNodes > 0 &&
              oldScrollHeight != scrollBox.scrollHeight) {
       // If there were pruned messages and if scroll is not at the bottom, then
       // we need to adjust the scroll location.
       scrollBox.scrollTop -= oldScrollHeight - scrollBox.scrollHeight;
     }
 
     // If the queue is not empty, schedule another flush.
-    if (!this._outputTimeout && this._outputQueue.length > 0) {
+    if (this._outputQueue.length > 0) {
       this._outputTimeout =
-        this.chromeWindow.setTimeout(function() {
-          delete this._outputTimeout;
-          this._flushMessageQueue();
-        }.bind(this), OUTPUT_INTERVAL);
+        this.chromeWindow.setTimeout(this._flushMessageQueue.bind(this),
+                                     OUTPUT_INTERVAL);
+    }
+    else {
+      this._outputTimeout = null;
     }
 
     this._lastOutputFlush = Date.now();
   },
 
   /**
    * Output a message from the queue.
    *
    * @private
    * @param nsISupportsString aHudIdSupportsString
    *        The HUD ID as an nsISupportsString.
    * @param array aItem
    *        An item from the output queue - this item represents a message.
-   * @return boolean
-   *         True if the message is visible, false otherwise.
+   * @return nsIDOMElement|null
+   *         The DOM element of the message if the message is visible, null otherwise.
    */
   _outputMessageFromQueue:
   function HUD__outputMessageFromQueue(aHudIdSupportsString, aItem)
   {
-    let [node, afterNode] = aItem;
+    let [category, methodOrNode, args] = aItem;
+
+    let node = typeof methodOrNode == "function" ?
+               methodOrNode.apply(this, args || []) :
+               methodOrNode;
+    if (!node) {
+      return null;
+    }
+
+    let afterNode = node._outputAfterNode;
+    if (afterNode) {
+      delete node._outputAfterNode;
+    }
 
     let isFiltered = ConsoleUtils.filterMessageNode(node, this.hudId);
 
     let isRepeated = false;
     if (node.classList.contains("webconsole-msg-cssparser")) {
       isRepeated = ConsoleUtils.filterRepeatedCSS(node, this.outputNode,
                                                   this.hudId);
     }
@@ -2651,53 +2732,58 @@ HeadsUpDisplay.prototype = {
     }
 
     if (!isRepeated) {
       this.outputNode.insertBefore(node,
                                    afterNode ? afterNode.nextSibling : null);
       this._pruneCategoriesQueue[node.category] = true;
     }
 
+    if (node._onOutput) {
+      node._onOutput();
+      delete node._onOutput;
+    }
+
     let nodeID = node.getAttribute("id");
     Services.obs.notifyObservers(aHudIdSupportsString,
                                  "web-console-message-created", nodeID);
 
-    return !isRepeated && !isFiltered;
+    if (!isRepeated && !isFiltered) {
+      return node;
+    }
   },
 
   /**
    * Prune the queue of messages to display. This avoids displaying messages
    * that will be removed at the end of the queue anyway.
    * @private
    */
   _pruneOutputQueue: function HUD__pruneOutputQueue()
   {
     let nodes = {};
 
     // Group the messages per category.
     this._outputQueue.forEach(function(aItem, aIndex) {
-      let [node] = aItem;
-      let category = node.category;
+      let [category] = aItem;
       if (!(category in nodes)) {
         nodes[category] = [];
       }
       nodes[category].push(aIndex);
     }, this);
 
     let pruned = 0;
 
     // Loop through the categories we found and prune if needed.
     for (let category in nodes) {
       let limit = this.logLimitForCategory(category);
       let indexes = nodes[category];
       if (indexes.length > limit) {
         let n = Math.max(0, indexes.length - limit);
         pruned += n;
         for (let i = n - 1; i >= 0; i--) {
-          let node = this._outputQueue[indexes[i]][0];
           this._outputQueue.splice(indexes[i], 1);
         }
       }
     }
 
     return pruned;
   },
 
@@ -3140,18 +3226,18 @@ JSTerm.prototype = {
   writeOutput:
   function JST_writeOutput(aOutputMessage, aCategory, aSeverity, aNodeAfter,
                            aTimestamp)
   {
     let node = ConsoleUtils.createMessageNode(this.document, aCategory,
                                               aSeverity, aOutputMessage,
                                               this.hudId, null, null, null,
                                               null, aTimestamp);
-
-    ConsoleUtils.outputMessageNode(node, this.hudId, aNodeAfter);
+    node._outputAfterNode = aNodeAfter;
+    this.hud.outputMessage(aCategory, node);
     return node;
   },
 
   /**
    * Clear the Web Console output.
    *
    * @param boolean aClearStorage
    *        True if you want to clear the console messages storage associated to
@@ -3165,16 +3251,17 @@ JSTerm.prototype = {
     let outputNode = hud.outputNode;
     let node;
     while ((node = outputNode.firstChild)) {
       hud.removeOutputMessage(node);
     }
 
     hud.HUDBox.lastTimestamp = 0;
     hud.groupDepth = 0;
+    hud._outputQueue = [];
 
     if (aClearStorage) {
       hud.sendMessageToContent("ConsoleAPI:ClearCache", {});
     }
   },
 
   /**
    * Updates the size of the input field (command line) to fit its contents.
@@ -4273,33 +4360,16 @@ ConsoleUtils = {
       this.mergeFilteredMessageNode(lastMessage, aNode);
       return true;
     }
 
     return false;
   },
 
   /**
-   * Filters a node appropriately, then sends it to the output, regrouping and
-   * pruning output as necessary.
-   *
-   * @param nsIDOMNode aNode
-   *        The message node to send to the output.
-   * @param string aHUDId
-   *        The ID of the HUD in which to insert this node.
-   * @param nsIDOMNode [aNodeAfter]
-   *        Insert the node after the given aNodeAfter (optional).
-   */
-  outputMessageNode:
-  function ConsoleUtils_outputMessageNode(aNode, aHUDId, aNodeAfter) {
-    let hud = HUDService.getHudReferenceById(aHUDId);
-    hud.outputMessageNode(aNode, aNodeAfter);
-  },
-
-  /**
    * Check if the given output node is scrolled to the bottom.
    *
    * @param nsIDOMNode aOutputNode
    * @return boolean
    *         True if the output node is scrolled to the bottom, or false
    *         otherwise.
    */
   isOutputScrolledToBottom:
diff --git a/dom/base/ConsoleAPI.js b/dom/base/ConsoleAPI.js
--- a/dom/base/ConsoleAPI.js
+++ b/dom/base/ConsoleAPI.js
@@ -16,17 +16,20 @@ const MAX_PAGE_TIMERS = 10000;
 const ARGUMENT_PATTERN = /%\d*\.?\d*([osdif])\b/g;
 
 // The maximum stacktrace depth when populating the stacktrace array used for
 // console.trace().
 const DEFAULT_MAX_STACKTRACE_DEPTH = 200;
 
 // The console API methods are async and their action is executed later. This
 // delay tells how much later.
-const CALL_DELAY = 30; // milliseconds
+const CALL_DELAY = 15; // milliseconds
+
+// This constant tells how many messages to process in a single timer execution.
+const MESSAGES_IN_INTERVAL = 1500;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/ConsoleAPIStorage.jsm");
 
 let nsITimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
 
 function ConsoleAPI() {}
@@ -146,19 +149,16 @@ ConsoleAPI.prototype = {
       __mozillaConsole__: { value: true }
     };
 
     Object.defineProperties(contentObj, properties);
     Cu.makeObjectPropsNormal(contentObj);
 
     this._queuedCalls = [];
     this._destroyedWindows = [];
-    this._timerCallback = {
-      notify: this._timerCallbackNotify.bind(this),
-    };
 
     return contentObj;
   },
 
   observe: function CA_observe(aSubject, aTopic, aData)
   {
     if (aTopic == "xpcom-shutdown") {
       Services.obs.removeObserver(this, "xpcom-shutdown");
@@ -191,31 +191,36 @@ ConsoleAPI.prototype = {
       innerID: aMeta.innerID,
       timeStamp: Date.now(),
       stack: this.getStackTrace(aMethod != "trace" ? 1 : null),
     };
 
     this._queuedCalls.push([aMethod, aArguments, metaForCall]);
 
     if (!this._timerInitialized) {
-      nsITimer.initWithCallback(this._timerCallback, CALL_DELAY,
-                                Ci.nsITimer.TYPE_ONE_SHOT);
+      nsITimer.initWithCallback(this._timerCallback.bind(this), CALL_DELAY,
+                                Ci.nsITimer.TYPE_REPEATING_SLACK);
       this._timerInitialized = true;
     }
   },
 
   /**
    * Timer callback used to process each of the queued calls.
    * @private
    */
-  _timerCallbackNotify: function CA__timerCallbackNotify()
+  _timerCallback: function CA__timerCallback()
   {
-    this._timerInitialized = false;
-    this._queuedCalls.splice(0).forEach(this._processQueuedCall, this);
-    this._destroyedWindows = [];
+    this._queuedCalls.splice(0, MESSAGES_IN_INTERVAL)
+      .forEach(this._processQueuedCall, this);
+
+    if (!this._queuedCalls.length) {
+      this._timerInitialized = false;
+      this._destroyedWindows = [];
+      nsITimer.cancel();
+    }
   },
 
   /**
    * Process a queued call to a console method.
    *
    * @private
    * @param array aCall
    *        Array that holds information about the queued call.
