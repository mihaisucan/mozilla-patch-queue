# HG changeset patch
# Parent 8a1414308869a12e442ffc570c01cb0782aa2e5a
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1339500307 -10800

Bug 761257 - Further improve Web Console output performance; try: -b do -p linux,linuxqt,linux64,macosx64,win32,macosx -u mochitest-o -t none

diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -170,21 +170,27 @@ const ERRORS = { LOG_MESSAGE_MISSING_ARG
 // The indent of a console group in pixels.
 const GROUP_INDENT = 12;
 
 // The pref prefix for webconsole filters
 const PREFS_PREFIX = "devtools.webconsole.filter.";
 
 // The number of messages to display in a single display update. If we display
 // too many messages at once we slow the Firefox UI too much.
-const MESSAGES_IN_INTERVAL = 30;
-
-// The delay between display updates - tells how often we should push new
-// messages to screen.
-const OUTPUT_INTERVAL = 90; // milliseconds
+const MESSAGES_IN_INTERVAL = DEFAULT_LOG_LIMIT;
+
+// The delay between display updates - tells how often we should *try* to push
+// new messages to screen. This value is optimistic, updates won't always
+// happen. Keep this low so the Web Console output feels live.
+const OUTPUT_INTERVAL = 50; // milliseconds
+
+// When the output queue has more than MESSAGES_IN_INTERVAL items we throttle
+// output updates to this number of milliseconds. So during a lot of output we
+// update every N milliseconds given here.
+const THROTTLE_UPDATES = 1000; // milliseconds
 
 ///////////////////////////////////////////////////////////////////////////
 //// Helper for creating the network panel.
 
 /**
  * Creates a DOMNode and sets all the attributes of aAttributes on the created
  * element.
  *
@@ -1044,34 +1050,25 @@ HeadsUpDisplay.prototype = {
    * Holds the network requests currently displayed by the Web Console. Each key
    * represents the connection ID and the value is network request information.
    * @private
    * @type object
    */
   _networkRequests: null,
 
   /**
-   * Last time when we displayed any message in the output. Timestamp in
-   * milliseconds since the Unix epoch.
+   * Last time when we displayed any message in the output.
    *
    * @private
    * @type number
+   *       Timestamp in milliseconds since the Unix epoch.
    */
   _lastOutputFlush: 0,
 
   /**
-   * The number of messages displayed in the last interval. The interval is
-   * given by OUTPUT_INTERVAL.
-   *
-   * @private
-   * @type number
-   */
-  _messagesDisplayedInInterval: 0,
-
-  /**
    * Message nodes are stored here in a queue for later display.
    *
    * @private
    * @type array
    */
   _outputQueue: null,
 
   /**
@@ -1408,21 +1405,27 @@ HeadsUpDisplay.prototype = {
   function HUD__displayCachedConsoleMessages(aRemoteMessages)
   {
     if (!aRemoteMessages.length) {
       return;
     }
 
     aRemoteMessages.forEach(function(aMessage) {
       switch (aMessage._type) {
-        case "PageError":
-          this.reportPageError(aMessage);
+        case "PageError": {
+          let category = this.categoryForScriptError(aMessage.category);
+          if (category != -1) {
+            this.outputMessage(category, this.reportPageError,
+                               [category, aMessage]);
+          }
           break;
+        }
         case "ConsoleAPI":
-          this.logConsoleAPIMessage(aMessage);
+          this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
+                             [aMessage]);
           break;
       }
     }, this);
   },
 
   /**
    * Shortcut to make XUL nodes
    *
@@ -1885,16 +1888,18 @@ HeadsUpDisplay.prototype = {
    *        console service. This object needs to hold:
    *          - hudId - the Web Console ID.
    *          - apiMessage - a representation of the object sent by the console
    *          storage service. This object holds the console message level, the
    *          arguments that were passed to the console method and other
    *          information.
    *          - argumentsToString - the array of arguments passed to the console
    *          method, each converted to a string.
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
    */
   logConsoleAPIMessage: function HUD_logConsoleAPIMessage(aMessage)
   {
     let body = null;
     let clipboardText = null;
     let sourceURL = null;
     let sourceLine = 0;
     let level = aMessage.apiMessage.level;
@@ -2017,98 +2022,115 @@ HeadsUpDisplay.prototype = {
           data: { object: node._stacktrace },
         };
 
         let propPanel = this.jsterm.openPropertyPanel(options);
         propPanel.panel.setAttribute("hudId", this.hudId);
       }.bind(this));
     }
 
-    ConsoleUtils.outputMessageNode(node, this.hudId);
-
     if (level == "dir") {
+      // Make sure the cached evaluated object will be purged when the node is
+      // removed.
+      node._evalCacheId = aMessage.objectsCacheId;
+
       // Initialize the inspector message node, by setting the PropertyTreeView
       // object on the tree view. This has to be done *after* the node is
       // shown, because the tree binding must be attached first.
-      let tree = node.querySelector("tree");
-      tree.view = node.propertyTreeView;
-
-      // Make sure the cached evaluated object will be purged when the node is
-      // removed.
-      node._evalCacheId = aMessage.objectsCacheId;
+      node._onOutput = function _onMessageOutput() {
+        node.querySelector("tree").view = node.propertyTreeView;
+      };
     }
+
+    return node;
   },
 
   /**
    * Reports an error in the page source, either JavaScript or CSS.
    *
    * @param nsIScriptError aScriptError
    *        The error message to report.
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
    */
-  reportPageError: function HUD_reportPageError(aScriptError)
+  reportPageError: function HUD_reportPageError(aCategory, aScriptError)
   {
     if (!aScriptError.outerWindowID) {
       return;
     }
 
-    let category;
-
+    // Warnings and legacy strict errors become warnings; other types become
+    // errors.
+    let severity = SEVERITY_ERROR;
+    if ((aScriptError.flags & aScriptError.warningFlag) ||
+        (aScriptError.flags & aScriptError.strictFlag)) {
+      severity = SEVERITY_WARNING;
+    }
+
+    let node = ConsoleUtils.createMessageNode(this.chromeDocument,
+                                              aCategory,
+                                              severity,
+                                              aScriptError.errorMessage,
+                                              this.hudId,
+                                              aScriptError.sourceName,
+                                              aScriptError.lineNumber,
+                                              null,
+                                              null,
+                                              aScriptError.timeStamp);
+    return node;
+  },
+
+  /**
+   * Determine the category of a given nsIScriptError.
+   *
+   * @param nsIScriptError aScriptError
+   *        The script error you want to determine the category for.
+   * @return CATEGORY_JS|CATEGORY_CSS|-1
+   *         Depending on the script error CATEGORY_JS or CATEGORY_CSS can be
+   *         returned. If the category is unknown -1 is returned.
+   */
+  categoryForScriptError: function HUD_categoryForScriptError(aScriptError)
+  {
     switch (aScriptError.category) {
       // We ignore chrome-originating errors as we only care about content.
       case "XPConnect JavaScript":
       case "component javascript":
       case "chrome javascript":
       case "chrome registration":
       case "XBL":
       case "XBL Prototype Handler":
       case "XBL Content Sink":
       case "xbl javascript":
-        return;
+        return -1;
 
       case "CSS Parser":
       case "CSS Loader":
-        category = CATEGORY_CSS;
-        break;
+        return CATEGORY_CSS;
 
       default:
-        category = CATEGORY_JS;
-        break;
+        return CATEGORY_JS;
     }
-
-    // Warnings and legacy strict errors become warnings; other types become
-    // errors.
-    let severity = SEVERITY_ERROR;
-    if ((aScriptError.flags & aScriptError.warningFlag) ||
-        (aScriptError.flags & aScriptError.strictFlag)) {
-      severity = SEVERITY_WARNING;
-    }
-
-    let node = ConsoleUtils.createMessageNode(this.chromeDocument,
-                                              category,
-                                              severity,
-                                              aScriptError.errorMessage,
-                                              this.hudId,
-                                              aScriptError.sourceName,
-                                              aScriptError.lineNumber,
-                                              null,
-                                              null,
-                                              aScriptError.timeStamp);
-
-    ConsoleUtils.outputMessageNode(node, this.hudId);
   },
 
   /**
    * Log network activity.
    *
    * @param object aHttpActivity
    *        The HTTP activity to log.
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
    */
-  logNetActivity: function HUD_logNetActivity(aHttpActivity)
+  logNetActivity: function HUD_logNetActivity(aConnectionId)
   {
-    let entry = aHttpActivity.log.entries[0];
+    let networkInfo = this._networkRequests[aConnectionId];
+    if (!networkInfo) {
+      return;
+    }
+
+    let entry = networkInfo.httpActivity.log.entries[0];
     let request = entry.request;
 
     let msgNode = this.chromeDocument.createElementNS(XUL_NS, "hbox");
 
     let methodNode = this.chromeDocument.createElementNS(XUL_NS, "label");
     methodNode.setAttribute("value", request.method);
     methodNode.classList.add("webconsole-msg-body-piece");
     msgNode.appendChild(methodNode);
@@ -2144,37 +2166,36 @@ HeadsUpDisplay.prototype = {
                                                      msgNode,
                                                      this.hudId,
                                                      null,
                                                      null,
                                                      clipboardText);
 
     messageNode._connectionId = entry.connection;
 
-    let networkInfo = {
-      node: messageNode,
-      httpActivity: aHttpActivity,
-    };
-
-    this._networkRequests[entry.connection] = networkInfo;
-
     this.makeOutputMessageLink(messageNode, function HUD_net_message_link() {
       if (!messageNode._panelOpen) {
         HUDService.openNetworkPanel(messageNode, networkInfo.httpActivity);
       }
     }.bind(this));
 
-    ConsoleUtils.outputMessageNode(messageNode, this.hudId);
+    networkInfo.node = messageNode;
+
+    this._updateNetMessage(entry.connection);
+
+    return messageNode;
   },
 
   /**
    * Log file activity.
    *
    * @param string aFileURI
    *        The file URI that was loaded.
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
    */
   logFileActivity: function HUD_logFileActivity(aFileURI)
   {
     let chromeDocument = this.chromeDocument;
 
     let urlNode = chromeDocument.createElementNS(XUL_NS, "label");
     urlNode.setAttribute("crop", "center");
     urlNode.setAttribute("flex", "1");
@@ -2192,30 +2213,33 @@ HeadsUpDisplay.prototype = {
                                                     null,
                                                     aFileURI);
 
     this.makeOutputMessageLink(outputNode, function HUD__onFileClick() {
       let viewSourceUtils = chromeDocument.defaultView.gViewSourceUtils;
       viewSourceUtils.viewSource(aFileURI, null, chromeDocument);
     });
 
-    ConsoleUtils.outputMessageNode(outputNode, this.hudId);
+    return outputNode;
   },
 
   /**
    * Inform user that the Web Console API has been replaced by a script
    * in a content page.
+   *
+   * @return nsIDOMElement|undefined
+   *         The message element to display in the Web Console output.
    */
   logWarningAboutReplacedAPI: function HUD_logWarningAboutReplacedAPI()
   {
     let message = l10n.getStr("ConsoleAPIDisabled");
     let node = ConsoleUtils.createMessageNode(this.chromeDocument, CATEGORY_JS,
                                               SEVERITY_WARNING, message,
                                               this.hudId);
-    ConsoleUtils.outputMessageNode(node, this.hudId);
+    return node;
   },
 
   ERRORS: {
     HUD_BOX_DOES_NOT_EXIST: "Heads Up Display does not exist",
     TAB_ID_REQUIRED: "Tab DOM ID is required",
     PARENTNODE_NOT_FOUND: "parentNode element not found"
   },
 
@@ -2271,36 +2295,44 @@ HeadsUpDisplay.prototype = {
         break;
       case "JSTerm:ClearOutput":
         this.jsterm.clearOutput();
         break;
       case "JSTerm:InspectObject":
         this.jsterm.handleInspectObject(aMessage.json);
         break;
       case "WebConsole:ConsoleAPI":
-        this.logConsoleAPIMessage(aMessage.json);
+        this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
+                           [aMessage.json]);
         break;
-      case "WebConsole:PageError":
-        this.reportPageError(aMessage.json.pageError);
+      case "WebConsole:PageError": {
+        let pageError = aMessage.json.pageError;
+        let category = this.categoryForScriptError(pageError);
+        if (category != -1) {
+          this.outputMessage(category, this.reportPageError,
+                             [category, pageError]);
+        }
         break;
+      }
       case "WebConsole:CachedMessages":
         this._displayCachedConsoleMessages(aMessage.json.messages);
         this._onInitComplete();
         break;
       case "WebConsole:NetworkActivity":
         this.handleNetworkActivity(aMessage.json);
         break;
       case "WebConsole:FileActivity":
-        this.logFileActivity(aMessage.json.uri);
+        this.outputMessage(CATEGORY_NETWORK, this.logFileActivity,
+                           [aMessage.json.uri]);
         break;
       case "WebConsole:LocationChange":
         this.onLocationChange(aMessage.json);
         break;
       case "JSTerm:NonNativeConsoleAPI":
-        this.logWarningAboutReplacedAPI();
+        this.outputMessage(CATEGORY_JS, this.logWarningAboutReplacedAPI);
         break;
     }
   },
 
   /**
    * Callback method for when the Web Console initialization is complete. For
    * now this method sends the web-console-created notification using the
    * nsIObserverService.
@@ -2384,70 +2416,103 @@ HeadsUpDisplay.prototype = {
    *          if the network request/response body was discarded or not.
    *        - log - the request and response information. This is a HAR-like
    *        object. See HUDService-content.js
    *        NetworkMonitor.createActivityObject().
    */
   handleNetworkActivity: function HUD_handleNetworkActivity(aMessage)
   {
     let stage = aMessage.meta.stages[aMessage.meta.stages.length - 1];
+    let entry = aMessage.log.entries[0];
 
     if (stage == "REQUEST_HEADER") {
-      this.logNetActivity(aMessage);
+      let networkInfo = {
+        node: null,
+        httpActivity: aMessage,
+      };
+
+      this._networkRequests[entry.connection] = networkInfo;
+      this.outputMessage(CATEGORY_NETWORK, this.logNetActivity,
+                         [entry.connection]);
       return;
     }
-
-    let entry = aMessage.log.entries[0];
-    let request = entry.request;
-    let response = entry.response;
-
-    if (!(entry.connection in this._networkRequests)) {
+    else if (!(entry.connection in this._networkRequests)) {
       return;
     }
 
-    let loggedRequest = this._networkRequests[entry.connection];
-    let messageNode = loggedRequest.node;
-    loggedRequest.httpActivity = aMessage;
-
-    if (stage == "TRANSACTION_CLOSE" || stage == "RESPONSE_HEADER") {
-      let status = [response.httpVersion, response.status, response.statusText];
-      if (stage == "TRANSACTION_CLOSE") {
-        status.push(l10n.getFormatStr("NetworkPanel.durationMS", [entry.time]));
-      }
-      let statusText = "[" + status.join(" ") + "]";
-
-      let linkNode = messageNode.querySelector(".webconsole-msg-link");
-      let statusNode = linkNode.querySelector(".webconsole-msg-status");
-      statusNode.setAttribute("value", statusText);
-
-      messageNode.clipboardText = [request.method, request.url, statusText]
-                                  .join(" ");
-
-      if (stage == "RESPONSE_HEADER" &&
-          response.status >= MIN_HTTP_ERROR_CODE &&
-          response.status <= MAX_HTTP_ERROR_CODE) {
-        ConsoleUtils.setMessageType(messageNode, CATEGORY_NETWORK,
-                                    SEVERITY_ERROR);
-      }
-    }
-
-    if (messageNode._netPanel) {
-      messageNode._netPanel.update();
+    let networkInfo = this._networkRequests[entry.connection];
+    networkInfo.httpActivity = aMessage;
+
+    if (networkInfo.node) {
+      this._updateNetMessage(entry.connection);
     }
 
     // For unit tests we pass the HTTP activity object to the test callback,
     // once requests complete.
     if (HUDService.lastFinishedRequestCallback &&
         aMessage.meta.stages.indexOf("REQUEST_STOP") > -1 &&
         aMessage.meta.stages.indexOf("TRANSACTION_CLOSE") > -1) {
       HUDService.lastFinishedRequestCallback(aMessage);
     }
   },
 
   /**
+   * Update an output message to reflect the latest state of a network request,
+   * given a network connection ID.
+   *
+   * @private
+   * @param string aConnectionId
+   *        The connection ID to update.
+   */
+  _updateNetMessage: function HUD__updateNetMessage(aConnectionId)
+  {
+    let networkInfo = this._networkRequests[aConnectionId];
+    if (!networkInfo || !networkInfo.node) {
+      return;
+    }
+
+    let messageNode = networkInfo.node;
+    let httpActivity = networkInfo.httpActivity;
+    let stages = httpActivity.meta.stages;
+    let hasTransactionClose = stages.indexOf("TRANSACTION_CLOSE") > -1;
+    let hasResponseHeader = stages.indexOf("RESPONSE_HEADER") > -1;
+    let entry = httpActivity.log.entries[0];
+    let request = entry.request;
+    let response = entry.response;
+
+    if (hasTransactionClose || hasResponseHeader) {
+      let status = [];
+      if (response.httpVersion && response.status) {
+        status = [response.httpVersion, response.status, response.statusText];
+      }
+      if (hasTransactionClose) {
+        status.push(l10n.getFormatStr("NetworkPanel.durationMS", [entry.time]));
+      }
+      let statusText = "[" + status.join(" ") + "]";
+
+      let linkNode = messageNode.querySelector(".webconsole-msg-link");
+      let statusNode = linkNode.querySelector(".webconsole-msg-status");
+      statusNode.setAttribute("value", statusText);
+
+      messageNode.clipboardText = [request.method, request.url, statusText]
+                                  .join(" ");
+
+      if (hasResponseHeader && response.status >= MIN_HTTP_ERROR_CODE &&
+          response.status <= MAX_HTTP_ERROR_CODE) {
+        ConsoleUtils.setMessageType(messageNode, CATEGORY_NETWORK,
+                                    SEVERITY_ERROR);
+      }
+    }
+
+    if (messageNode._netPanel) {
+      messageNode._netPanel.update();
+    }
+  },
+
+  /**
    * Handler for the "WebConsole:LocationChange" message. If the Web Console is
    * opened in a panel the panel title is updated.
    *
    * @param object aMessage
    *        The message received from the content script. It needs to hold two
    *        properties: location and title.
    */
   onLocationChange: function HUD_onLocationChange(aMessage)
@@ -2498,92 +2563,103 @@ HeadsUpDisplay.prototype = {
 
   /**
    * Output a message node. This filters a node appropriately, then sends it to
    * the output, regrouping and pruning output as necessary.
    *
    * Note: this call is async - the given message node may not be displayed when
    * you call this method.
    *
-   * @param nsIDOMNode aNode
-   *        The message node to send to the output.
-   * @param nsIDOMNode [aNodeAfter]
-   *        Insert the node after the given aNodeAfter (optional).
+   * @param integer aCategory
+   *        The category of the message you want to output. See the CATEGORY_*
+   *        constants.
+   * @param function|nsIDOMElement aMethodOrNode
+   *        The method that creates the message element to send to the output or
+   *        the actual element. If a method is given it will be bound to the HUD
+   *        object and the arguments will be |aArguments|.
+   * @param array [aArguments]
+   *        If a method is given to output the message element then the method
+   *        will be invoked with the list of arguments given here.
    */
-  outputMessageNode: function HUD_outputMessageNode(aNode, aNodeAfter)
+  outputMessage: function HUD_outputMessage(aCategory, aMethodOrNode, aArguments)
   {
-    this._outputQueue.push([aNode, aNodeAfter]);
-    this._flushMessageQueue();
+    if (!this._outputQueue.length) {
+      // If the queue is empty we consider that now was the last output flush.
+      // This avoid an immediate output flush when the timer executes.
+      this._lastOutputFlush = Date.now();
+    }
+
+    this._outputQueue.push([aCategory, aMethodOrNode, aArguments]);
+
+    if (!this._outputTimeout) {
+      this._outputTimeout =
+        this.chromeWindow.setTimeout(this._flushMessageQueue.bind(this),
+                                     OUTPUT_INTERVAL);
+    }
   },
 
   /**
    * Try to flush the output message queue. This takes the messages in the
    * output queue and displays them. Outputting stops at MESSAGES_IN_INTERVAL.
    * Further output is queued to happen later - see OUTPUT_INTERVAL.
    *
    * @private
    */
   _flushMessageQueue: function HUD__flushMessageQueue()
   {
-    if ((Date.now() - this._lastOutputFlush) >= OUTPUT_INTERVAL) {
-      this._messagesDisplayedInInterval = 0;
+    let timeSinceFlush = Date.now() - this._lastOutputFlush;
+    if (this._outputQueue.length > MESSAGES_IN_INTERVAL &&
+        timeSinceFlush < THROTTLE_UPDATES) {
+      this._outputTimeout =
+        this.chromeWindow.setTimeout(this._flushMessageQueue.bind(this),
+                                     OUTPUT_INTERVAL);
+      return;
     }
 
     // Determine how many messages we can display now.
-    let toDisplay = Math.min(this._outputQueue.length,
-                             MESSAGES_IN_INTERVAL -
-                             this._messagesDisplayedInInterval);
-
-    if (!toDisplay) {
-      if (!this._outputTimeout && this._outputQueue.length > 0) {
-        this._outputTimeout =
-          this.chromeWindow.setTimeout(function() {
-            delete this._outputTimeout;
-            this._flushMessageQueue();
-          }.bind(this), OUTPUT_INTERVAL);
-      }
+    let toDisplay = Math.min(this._outputQueue.length, MESSAGES_IN_INTERVAL);
+    if (toDisplay < 1) {
+      this._outputTimeout = null;
       return;
     }
 
     // Try to prune the message queue.
     let shouldPrune = false;
     if (this._outputQueue.length > toDisplay && this._pruneOutputQueue()) {
       toDisplay = Math.min(this._outputQueue.length, toDisplay);
       shouldPrune = true;
     }
 
     let batch = this._outputQueue.splice(0, toDisplay);
     if (!batch.length) {
+      this._outputTimeout = null;
       return;
     }
 
     let outputNode = this.outputNode;
     let lastVisibleNode = null;
     let scrolledToBottom = ConsoleUtils.isOutputScrolledToBottom(outputNode);
     let scrollBox = outputNode.scrollBoxObject.element;
 
     let hudIdSupportsString = WebConsoleUtils.supportsString(this.hudId);
 
     // Output the current batch of messages.
     for (let item of batch) {
-      if (this._outputMessageFromQueue(hudIdSupportsString, item)) {
-        lastVisibleNode = item[0];
+      let node = this._outputMessageFromQueue(hudIdSupportsString, item);
+      if (node) {
+        lastVisibleNode = node;
       }
     }
 
-    // Keep track of how many messages we displayed, so we do not display too
-    // many at once.
-    this._messagesDisplayedInInterval += batch.length;
-
     let oldScrollHeight = 0;
 
     // Prune messages if needed. We do not do this for every flush call to
     // improve performance.
     let removedNodes = 0;
-    if (shouldPrune || !(this._outputQueue.length % 20)) {
+    if (shouldPrune || !this._outputQueue.length) {
       oldScrollHeight = scrollBox.scrollHeight;
 
       let categories = Object.keys(this._pruneCategoriesQueue);
       categories.forEach(function _pruneOutput(aCategory) {
         removedNodes += pruneConsoleOutputIfNecessary(this.hudId, aCategory);
       }, this);
       this._pruneCategoriesQueue = {};
     }
@@ -2606,84 +2682,107 @@ HeadsUpDisplay.prototype = {
     else if (!scrolledToBottom && removedNodes > 0 &&
              oldScrollHeight != scrollBox.scrollHeight) {
       // If there were pruned messages and if scroll is not at the bottom, then
       // we need to adjust the scroll location.
       scrollBox.scrollTop -= oldScrollHeight - scrollBox.scrollHeight;
     }
 
     // If the queue is not empty, schedule another flush.
-    if (!this._outputTimeout && this._outputQueue.length > 0) {
+    if (this._outputQueue.length > 0) {
       this._outputTimeout =
-        this.chromeWindow.setTimeout(function() {
-          delete this._outputTimeout;
-          this._flushMessageQueue();
-        }.bind(this), OUTPUT_INTERVAL);
+        this.chromeWindow.setTimeout(this._flushMessageQueue.bind(this),
+                                     OUTPUT_INTERVAL);
+    }
+    else {
+      this._outputTimeout = null;
     }
 
     this._lastOutputFlush = Date.now();
   },
 
   /**
    * Output a message from the queue.
    *
    * @private
    * @param nsISupportsString aHudIdSupportsString
    *        The HUD ID as an nsISupportsString.
    * @param array aItem
    *        An item from the output queue - this item represents a message.
-   * @return boolean
-   *         True if the message is visible, false otherwise.
+   * @return nsIDOMElement|undefined
+   *         The DOM element of the message if the message is visible, undefined
+   *         otherwise.
    */
   _outputMessageFromQueue:
   function HUD__outputMessageFromQueue(aHudIdSupportsString, aItem)
   {
-    let [node, afterNode] = aItem;
+    let [category, methodOrNode, args] = aItem;
+
+    let node = typeof methodOrNode == "function" ?
+               methodOrNode.apply(this, args || []) :
+               methodOrNode;
+    if (!node) {
+      return;
+    }
+
+    let afterNode = node._outputAfterNode;
+    if (afterNode) {
+      delete node._outputAfterNode;
+    }
 
     let isFiltered = ConsoleUtils.filterMessageNode(node, this.hudId);
 
     let isRepeated = false;
     if (node.classList.contains("webconsole-msg-cssparser")) {
       isRepeated = ConsoleUtils.filterRepeatedCSS(node, this.outputNode,
                                                   this.hudId);
     }
 
     if (!isRepeated &&
+        !node.classList.contains("webconsole-msg-network") &&
         (node.classList.contains("webconsole-msg-console") ||
          node.classList.contains("webconsole-msg-exception") ||
          node.classList.contains("webconsole-msg-error"))) {
       isRepeated = ConsoleUtils.filterRepeatedConsole(node, this.outputNode);
     }
 
+    let lastVisible = !isRepeated && !isFiltered;
     if (!isRepeated) {
       this.outputNode.insertBefore(node,
                                    afterNode ? afterNode.nextSibling : null);
       this._pruneCategoriesQueue[node.category] = true;
+      if (afterNode) {
+        lastVisible = this.outputNode.lastChild == node;
+      }
+    }
+
+    if (node._onOutput) {
+      node._onOutput();
+      delete node._onOutput;
     }
 
     let nodeID = node.getAttribute("id");
     Services.obs.notifyObservers(aHudIdSupportsString,
                                  "web-console-message-created", nodeID);
 
-    return !isRepeated && !isFiltered;
+    return lastVisible ? node : null;
   },
 
   /**
    * Prune the queue of messages to display. This avoids displaying messages
    * that will be removed at the end of the queue anyway.
    * @private
    */
   _pruneOutputQueue: function HUD__pruneOutputQueue()
   {
     let nodes = {};
 
     // Group the messages per category.
     this._outputQueue.forEach(function(aItem, aIndex) {
-      let [node] = aItem;
-      let category = node.category;
+      let [category] = aItem;
       if (!(category in nodes)) {
         nodes[category] = [];
       }
       nodes[category].push(aIndex);
     }, this);
 
     let pruned = 0;
 
@@ -2708,17 +2807,41 @@ HeadsUpDisplay.prototype = {
    * Prune an item from the output queue.
    *
    * @private
    * @param array aItem
    *        The item you want to remove from the output queue.
    */
   _pruneItemFromQueue: function HUD__pruneItemFromQueue(aItem)
   {
-    this.removeOutputMessage(aItem[0]);
+    let [category, methodOrNode, args] = aItem;
+    if (typeof methodOrNode != "function" &&
+        methodOrNode._evalCacheId && !methodOrNode._panelOpen) {
+      this.jsterm.clearObjectCache(methodOrNode._evalCacheId);
+    }
+
+    if (category == CATEGORY_NETWORK) {
+      let connectionId = null;
+      if (methodOrNode == this.logNetActivity) {
+        connectionId = args[0];
+      }
+      else if (typeof methodOrNode != "function") {
+        connectionId = methodOrNode._connectionId;
+      }
+      if (connectionId && connectionId in this._networkRequests) {
+        delete this._networkRequests[connectionId];
+      }
+    }
+    else if (category == CATEGORY_WEBDEV &&
+             methodOrNode == this.logConsoleAPIMessage) {
+      let level = args[0].apiMessage.level;
+      if (level == "dir") {
+        this.jsterm.clearObjectCache(args[0].objectsCacheId);
+      }
+    }
   },
 
   /**
    * Retrieve the limit of messages for a specific category.
    *
    * @param number aCategory
    *        The category of messages you want to retrieve the limit for. See the
    *        CATEGORY_* constants.
@@ -3154,18 +3277,18 @@ JSTerm.prototype = {
   writeOutput:
   function JST_writeOutput(aOutputMessage, aCategory, aSeverity, aNodeAfter,
                            aTimestamp)
   {
     let node = ConsoleUtils.createMessageNode(this.document, aCategory,
                                               aSeverity, aOutputMessage,
                                               this.hudId, null, null, null,
                                               null, aTimestamp);
-
-    ConsoleUtils.outputMessageNode(node, this.hudId, aNodeAfter);
+    node._outputAfterNode = aNodeAfter;
+    this.hud.outputMessage(aCategory, node);
     return node;
   },
 
   /**
    * Clear the Web Console output.
    *
    * @param boolean aClearStorage
    *        True if you want to clear the console messages storage associated to
@@ -4278,44 +4401,28 @@ ConsoleUtils = {
    * @return boolean
    *         true if the message is filtered, false otherwise.
    */
   filterRepeatedConsole:
   function ConsoleUtils_filterRepeatedConsole(aNode, aOutput) {
     let lastMessage = aOutput.lastChild;
 
     // childNodes[2] is the description element
-    if (lastMessage && !aNode.classList.contains("webconsole-msg-inspector") &&
+    if (lastMessage && lastMessage.childNodes[2] &&
+        !aNode.classList.contains("webconsole-msg-inspector") &&
         aNode.childNodes[2].textContent ==
         lastMessage.childNodes[2].textContent) {
       this.mergeFilteredMessageNode(lastMessage, aNode);
       return true;
     }
 
     return false;
   },
 
   /**
-   * Filters a node appropriately, then sends it to the output, regrouping and
-   * pruning output as necessary.
-   *
-   * @param nsIDOMNode aNode
-   *        The message node to send to the output.
-   * @param string aHUDId
-   *        The ID of the HUD in which to insert this node.
-   * @param nsIDOMNode [aNodeAfter]
-   *        Insert the node after the given aNodeAfter (optional).
-   */
-  outputMessageNode:
-  function ConsoleUtils_outputMessageNode(aNode, aHUDId, aNodeAfter) {
-    let hud = HUDService.getHudReferenceById(aHUDId);
-    hud.outputMessageNode(aNode, aNodeAfter);
-  },
-
-  /**
    * Check if the given output node is scrolled to the bottom.
    *
    * @param nsIDOMNode aOutputNode
    * @return boolean
    *         True if the output node is scrolled to the bottom, or false
    *         otherwise.
    */
   isOutputScrolledToBottom:
diff --git a/browser/devtools/webconsole/test/browser_cached_messages.js b/browser/devtools/webconsole/test/browser_cached_messages.js
--- a/browser/devtools/webconsole/test/browser_cached_messages.js
+++ b/browser/devtools/webconsole/test/browser_cached_messages.js
@@ -18,31 +18,53 @@ function test()
   }, true);
 }
 
 function testOpenUI(aTestReopen)
 {
   // test to see if the messages are
   // displayed when the console UI is opened
 
+  let messages = {
+    "log Bazzle" : false,
+    "error Bazzle" : false,
+    "bazBug611032" : false,
+    "cssColorBug611032" : false,
+  };
+
   openConsole(null, function(hud) {
-    testLogEntry(hud.outputNode, "log Bazzle",
-                 "Find a console log entry from before console UI is opened",
-                 false, null);
-
-    testLogEntry(hud.outputNode, "error Bazzle",
-                 "Find a console error entry from before console UI is opened",
-                 false, null);
-
-    testLogEntry(hud.outputNode, "bazBug611032", "Found the JavaScript error");
-    testLogEntry(hud.outputNode, "cssColorBug611032", "Found the CSS error");
-
-    HUDService.deactivateHUDForContext(gBrowser.selectedTab);
-
-    if (aTestReopen) {
-      HUDService.deactivateHUDForContext(gBrowser.selectedTab);
-      executeSoon(testOpenUI);
-    }
-    else {
-      executeSoon(finish);
-    }
+    waitForSuccess({
+      name: "cached messages displayed",
+      validatorFn: function()
+      {
+        let foundAll = true;
+        for (let msg in messages) {
+          let found = messages[msg];
+          if (!found) {
+            found = hud.outputNode.textContent.indexOf(msg) > -1;
+            if (found) {
+              info("found message '" + msg + "'");
+              messages[msg] = found;
+            }
+          }
+          foundAll = foundAll && found;
+        }
+        return foundAll;
+      },
+      successFn: function()
+      {
+        closeConsole(gBrowser.selectedTab, function() {
+          aTestReopen && info("will reopen the Web Console");
+          executeSoon(aTestReopen ? testOpenUI : finishTest);
+        });
+      },
+      failureFn: function()
+      {
+        for (let msg in messages) {
+          if (!messages[msg]) {
+            ok(false, "failed to find '" + msg + "'");
+          }
+        }
+        finishTest();
+      },
+    });
   });
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
@@ -8,25 +8,32 @@ const TEST_URI = "http://example.com/bro
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", tabLoaded, true);
 }
 
 function tabLoaded() {
   browser.removeEventListener("load", tabLoaded, true);
 
-  openConsole(null, function() {
-    browser.addEventListener("load", tabReloaded, true);
+  openConsole(null, function(hud) {
     content.location.reload();
+
+    waitForSuccess({
+      name: "stacktrace message",
+      validatorFn: function()
+      {
+        return hud.outputNode.querySelector(".hud-log");
+      },
+      successFn: performChecks,
+      failureFn: finishTest,
+    });
   });
 }
 
-function tabReloaded() {
-  browser.removeEventListener("load", tabReloaded, true);
-
+function performChecks() {
   // The expected stack trace object.
   let stacktrace = [
     { filename: TEST_URI, lineNumber: 9, functionName: null, language: 2 },
     { filename: TEST_URI, lineNumber: 14, functionName: "foobar585956b", language: 2 },
     { filename: TEST_URI, lineNumber: 18, functionName: "foobar585956a", language: 2 },
     { filename: TEST_URI, lineNumber: 21, functionName: null, language: 2 }
   ];
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
@@ -22,16 +22,29 @@ function testSelectionWhenMovingBetweenB
   let jsterm = hud.jsterm;
 
   // Fill the console with some output.
   jsterm.clearOutput();
   jsterm.execute("1 + 2");
   jsterm.execute("3 + 4");
   jsterm.execute("5 + 6");
 
+  waitForSuccess({
+    name: "execution results displayed",
+    validatorFn: function()
+    {
+      return hud.outputNode.textContent.indexOf("5 + 6") > -1 &&
+             hud.outputNode.textContent.indexOf("11") > -1;
+    },
+    successFn: performTestsAfterOutput.bind(null, hud),
+    failureFn: finishTest,
+  });
+}
+
+function performTestsAfterOutput(hud) {
   let outputNode = hud.outputNode;
 
   ok(outputNode.childNodes.length >= 3, "the output node has children after " +
      "executing some JavaScript");
 
   // Test that the global Firefox "Select All" functionality (e.g. Edit >
   // Select All) works properly in the Web Console.
   let commandController = window.webConsoleCommandController;
@@ -62,9 +75,8 @@ function testSelectionWhenMovingBetweenB
   is(outputNode.selectedCount, outputNode.childNodes.length, "all console " +
      "messages are selected after performing a select-all operation from " +
      "the context menu");
 
   outputNode.selectedIndex = -1;
 
   finishTest();
 }
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js b/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js
@@ -9,47 +9,53 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "data:text/html;charset=utf-8,<div style='font-size:3em;" +
   "foobarCssParser:baz'>test CSS parser filter</div>";
 
 function onContentLoaded()
 {
-  browser.removeEventListener("load", arguments.callee, true);
+  browser.removeEventListener("load", onContentLoaded, true);
 
   let HUD = HUDService.getHudByWindow(content);
   let hudId = HUD.hudId;
   let outputNode = HUD.outputNode;
 
-  let msg = "the unknown CSS property warning is displayed";
-  testLogEntry(outputNode, "foobarCssParser", msg, true);
+  HUD.jsterm.clearOutput();
 
-  HUDService.setFilterState(hudId, "cssparser", false);
+  waitForSuccess({
+    name: "css error displayed",
+    validatorFn: function()
+    {
+      return outputNode.textContent.indexOf("foobarCssParser") > -1;
+    },
+    successFn: function()
+    {
+      HUDService.setFilterState(hudId, "cssparser", false);
 
-  executeSoon(
-    function (){
       let msg = "the unknown CSS property warning is not displayed, " +
                 "after filtering";
       testLogEntry(outputNode, "foobarCssParser", msg, true, true);
 
       HUDService.setFilterState(hudId, "cssparser", true);
       finishTest();
-    }
-  );
+    },
+    failureFn: finishTest,
+  });
 }
 
 /**
  * Unit test for bug 589162:
  * CSS filtering on the console does not work
  */
 function test()
 {
   addTab(TEST_URI);
-  browser.addEventListener("load", function() {
-    browser.removeEventListener("load", arguments.callee, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
 
     openConsole();
     browser.addEventListener("load", onContentLoaded, true);
     content.location.reload();
   }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_593003_iframe_wrong_hud.js b/browser/devtools/webconsole/test/browser_webconsole_bug_593003_iframe_wrong_hud.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_593003_iframe_wrong_hud.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_593003_iframe_wrong_hud.js
@@ -37,26 +37,39 @@ function tab2Loaded(aEvent) {
 }
 
 function tab1Reloaded(aEvent) {
   tab1.linkedBrowser.removeEventListener(aEvent.type, tab1Reloaded, true);
 
   let hud1 = HUDService.getHudByWindow(tab1.linkedBrowser.contentWindow);
   let outputNode1 = hud1.outputNode;
 
-  let msg = "Found the iframe network request in tab1";
-  testLogEntry(outputNode1, TEST_IFRAME_URI, msg, true);
+  waitForSuccess({
+    name: "iframe network request displayed in tab1",
+    validatorFn: function()
+    {
+      let selector = ".webconsole-msg-url[value='" + TEST_IFRAME_URI +"']";
+      return outputNode1.querySelector(selector);
+    },
+    successFn: function()
+    {
+      let hud2 = HUDService.getHudByWindow(tab2.linkedBrowser.contentWindow);
+      let outputNode2 = hud2.outputNode;
 
-  let hud2 = HUDService.getHudByWindow(tab2.linkedBrowser.contentWindow);
-  let outputNode2 = hud2.outputNode;
+      isnot(outputNode1, outputNode2,
+            "the two HUD outputNodes must be different");
 
-  isnot(outputNode1, outputNode2,
-        "the two HUD outputNodes must be different");
+      let msg = "Didn't find the iframe network request in tab2";
+      testLogEntry(outputNode2, TEST_IFRAME_URI, msg, true, true);
 
-  msg = "Didn't find the iframe network request in tab2";
-  testLogEntry(outputNode2, TEST_IFRAME_URI, msg, true, true);
+      testEnd();
+    },
+    failureFn: testEnd,
+  });
+}
 
+function testEnd() {
   closeConsole(tab2, function() {
     gBrowser.removeTab(tab2);
     tab1 = tab2 = null;
     executeSoon(finishTest);
   });
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js b/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
@@ -22,23 +22,33 @@ function consoleOpened(aHud) {
 
   // Reload so we get some output in the console.
   browser.contentWindow.location.reload();
 }
 
 function tabLoad2(aEvent) {
   browser.removeEventListener(aEvent.type, tabLoad2, true);
 
-  outputItem = outputNode.querySelector(".hud-networkinfo .hud-clickable");
-  ok(outputItem, "found a network message");
-  document.addEventListener("popupshown", networkPanelShown, false);
+  waitForSuccess({
+    name: "network message displayed",
+    validatorFn: function()
+    {
+      return outputNode.querySelector(".hud-networkinfo .hud-clickable");
+    },
+    successFn: function() {
+      outputItem = outputNode.querySelector(".hud-networkinfo .hud-clickable");
+      ok(outputItem, "found a network message");
+      document.addEventListener("popupshown", networkPanelShown, false);
 
-  // Send the mousedown and click events such that the network panel opens.
-  EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
-  EventUtils.sendMouseEvent({type: "click"}, outputItem);
+      // Send the mousedown and click events such that the network panel opens.
+      EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
+      EventUtils.sendMouseEvent({type: "click"}, outputItem);
+    },
+    failureFn: finishTest,
+  });
 }
 
 function networkPanelShown(aEvent) {
   document.removeEventListener(aEvent.type, networkPanelShown, false);
 
   document.addEventListener("popupshown", networkPanelShowFailure, false);
 
   // The network panel should not open for the second time.
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_595223_file_uri.js b/browser/devtools/webconsole/test/browser_webconsole_bug_595223_file_uri.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_595223_file_uri.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_595223_file_uri.js
@@ -4,36 +4,47 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_FILE = "test-network.html";
 
 function tabReload(aEvent) {
   browser.removeEventListener(aEvent.type, tabReload, true);
 
   outputNode = hud.outputNode;
-  findLogEntry("test-network.html");
-  findLogEntry("test-image.png");
-  findLogEntry("testscript.js");
-  isnot(outputNode.textContent.indexOf("running network console logging tests"), -1,
-        "found the console.log() message from testscript.js");
 
-  executeSoon(finishTest);
+  waitForSuccess({
+    name: "console.log() message displayed",
+    validatorFn: function()
+    {
+      return outputNode.textContent
+             .indexOf("running network console logging tests") > -1;
+    },
+    successFn: function()
+    {
+      findLogEntry("test-network.html");
+      findLogEntry("test-image.png");
+      findLogEntry("testscript.js");
+      finishTest();
+    },
+    failureFn: finishTest,
+  });
 }
 
 function test() {
   let jar = getJar(getRootDirectory(gTestPath));
   let dir = jar ?
             extractJarToTmp(jar) :
             getChromeDir(getResolvedURI(gTestPath));
   dir.append(TEST_FILE);
 
   let uri = Services.io.newFileURI(dir);
 
   addTab(uri.spec);
   browser.addEventListener("load", function tabLoad() {
     browser.removeEventListener("load", tabLoad, true);
     openConsole(null, function(aHud) {
       hud = aHud;
+      hud.jsterm.clearOutput();
       browser.addEventListener("load", tabReload, true);
       content.location.reload();
     });
   }, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js b/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js
@@ -24,36 +24,39 @@ function tabLoaded(aEvent) {
 
 function tabReloaded(aEvent) {
   gBrowser.selectedBrowser.removeEventListener(aEvent.type, tabReloaded, true);
 
   let hudId = HUDService.getHudIdByWindow(content);
   let HUD = HUDService.hudReferences[hudId];
   ok(HUD, "Web Console is open");
 
-  isnot(HUD.outputNode.textContent.indexOf("fooBug597756_error"), -1,
-    "error message must be in console output");
+  waitForSuccess({
+    name: "error message displayed",
+    validatorFn: function() {
+      return HUD.outputNode.textContent.indexOf("fooBug597756_error") > -1;
+    },
+    successFn: function() {
+      if (newTabIsOpen) {
+        finishTest();
+        return;
+      }
+      closeConsole(gBrowser.selectedTab, function() {
+        gBrowser.removeCurrentTab();
 
-  executeSoon(function() {
-    if (newTabIsOpen) {
-      executeSoon(finishTest);
-      return;
-    }
+        let newTab = gBrowser.addTab();
+        gBrowser.selectedTab = newTab;
 
-    closeConsole(gBrowser.selectedTab, function() {
-      gBrowser.removeCurrentTab();
-
-      let newTab = gBrowser.addTab();
-      gBrowser.selectedTab = newTab;
-
-      newTabIsOpen = true;
-      gBrowser.selectedBrowser.addEventListener("load", tabLoaded, true);
-      expectUncaughtException();
-      content.location = TEST_URI;
-    });
+        newTabIsOpen = true;
+        gBrowser.selectedBrowser.addEventListener("load", tabLoaded, true);
+        expectUncaughtException();
+        content.location = TEST_URI;
+      });
+    },
+    failureFn: finishTest,
   });
 }
 
 function test() {
   expectUncaughtException();
   addTab(TEST_URI);
   browser.addEventListener("load", tabLoaded, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_601177_log_levels.js b/browser/devtools/webconsole/test/browser_webconsole_bug_601177_log_levels.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_601177_log_levels.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_601177_log_levels.js
@@ -5,23 +5,20 @@
  *
  * Contributor(s):
  *  Mihai Șucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-601177-log-levels.html";
 
-let msgs;
-
-function onContentLoaded()
+function performTest()
 {
   let hudId = HUDService.getHudIdByWindow(content);
   let HUD = HUDService.hudReferences[hudId];
-  msgs = HUD.outputNode.querySelectorAll(".hud-msg-node");
 
   findEntry(HUD, "hud-networkinfo", "test-bug-601177-log-levels.html",
             "found test-bug-601177-log-levels.html");
 
   findEntry(HUD, "hud-networkinfo", "test-bug-601177-log-levels.js",
             "found test-bug-601177-log-levels.js");
 
   findEntry(HUD, "hud-networkinfo", "test-image.png", "found test-image.png");
@@ -33,39 +30,53 @@ function onContentLoaded()
             "found exception");
 
   findEntry(HUD, "hud-jswarn", "undefinedPropertyBug601177",
             "found strict warning");
 
   findEntry(HUD, "hud-jswarn", "foobarBug601177strictError",
             "found strict error");
 
-  msgs = null;
-  Services.prefs.setBoolPref("javascript.options.strict", false);
   finishTest();
 }
 
 function findEntry(aHUD, aClass, aString, aMessage)
 {
   return testLogEntry(aHUD.outputNode, aString, aMessage, false, false,
                       aClass);
 }
 
 function test()
 {
+  Services.prefs.setBoolPref("javascript.options.strict", true);
+
+  registerCleanupFunction(function() {
+    Services.prefs.clearUserPref("javascript.options.strict");
+  });
+
   addTab("data:text/html;charset=utf-8,Web Console test for bug 601177: log levels");
 
-  Services.prefs.setBoolPref("javascript.options.strict", true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
 
-  browser.addEventListener("load", function(aEvent) {
-    browser.removeEventListener(aEvent.type, arguments.callee, true);
+    openConsole(null, function(hud) {
+      browser.addEventListener("load", function onLoad2() {
+        browser.removeEventListener("load", onLoad2, true);
+        waitForSuccess({
+          name: "all messages displayed",
+          validatorFn: function()
+          {
+            return hud.outputNode.itemCount >= 7;
+          },
+          successFn: performTest,
+          failureFn: function() {
+            info("itemCount: " + hud.outputNode.itemCount);
+            finishTest();
+          },
+        });
+      }, true);
 
-    openConsole();
-
-    browser.addEventListener("load", function(aEvent) {
-      browser.removeEventListener(aEvent.type, arguments.callee, true);
-      executeSoon(onContentLoaded);
-    }, true);
-    expectUncaughtException();
-    content.location = TEST_URI;
+      expectUncaughtException();
+      content.location = TEST_URI;
+    });
   }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js
@@ -50,20 +50,23 @@ function consoleOpened(HUD) {
 
     finishTest();
   };
 
   waitForSuccess({
     name: "console output displayed",
     validatorFn: function()
     {
-      return HUD.outputNode.itemCount == 103;
+      return HUD.outputNode.itemCount >= 103;
     },
     successFn: performTest,
-    failureFn: finishTest,
+    failureFn: function() {
+      info("itemCount: " + HUD.outputNode.itemCount);
+      finishTest();
+    },
   });
 }
 
 function test() {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 601352");
   browser.addEventListener("load", function tabLoad(aEvent) {
     browser.removeEventListener(aEvent.type, tabLoad, true);
     openConsole(null, consoleOpened);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_613280_jsterm_copy.js b/browser/devtools/webconsole/test/browser_webconsole_bug_613280_jsterm_copy.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_613280_jsterm_copy.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_613280_jsterm_copy.js
@@ -5,25 +5,34 @@
  * Contributor(s):
  *   Mihai Șucan <mihai.sucan@gmail.com>
  */
 
 const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 613280";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", tabLoaded, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, function(HUD) {
+      content.console.log("foobarBazBug613280");
+      waitForSuccess({
+        name: "a message is displayed",
+        validatorFn: function()
+        {
+          return HUD.outputNode.itemCount > 0;
+        },
+        successFn: performTest.bind(null, HUD),
+        failureFn: finishTest,
+      });
+    });
+  }, true);
 }
 
-function tabLoaded() {
-  browser.removeEventListener("load", tabLoaded, true);
-  openConsole();
-
-  let hudId = HUDService.getHudIdByWindow(content);
-  let HUD = HUDService.hudReferences[hudId];
+function performTest(HUD) {
   let input = HUD.jsterm.inputNode;
   let selection = getSelection();
   let contentSelection = browser.contentWindow.wrappedJSObject.getSelection();
 
   let clipboard_setup = function() {
     goDoCommand("cmd_copy");
   };
 
@@ -59,16 +68,18 @@ function tabLoaded() {
   HUD.outputNode.focus();
 
   goUpdateCommand("cmd_copy");
 
   controller = top.document.commandDispatcher.
                getControllerForCommand("cmd_copy");
   is(controller.isCommandEnabled("cmd_copy"), true, "cmd_copy is enabled");
 
+  ok(HUD.outputNode.selectedItem, "we have a selected message");
+
   waitForClipboard(getExpectedClipboardText(HUD.outputNode.selectedItem),
     clipboard_setup, clipboard_copy_done, clipboard_copy_done);
 }
 
 function getExpectedClipboardText(aItem) {
   return "[" + WebConsoleUtils.l10n.timestampString(aItem.timestamp) + "] " +
          aItem.clipboardText;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
@@ -5,26 +5,33 @@
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
 
-    openConsole(null, function() {
+    openConsole(null, function(hud) {
       content.location.reload();
-      browser.addEventListener("load", tabLoaded, true);
+
+      waitForSuccess({
+        name: "network message displayed",
+        validatorFn: function()
+        {
+          return hud.outputNode.querySelector(".webconsole-msg-network");
+        },
+        successFn: performTest,
+        failureFn: finishTest,
+      });
     });
   }, true);
 }
 
-function tabLoaded() {
-  browser.removeEventListener("load", tabLoaded, true);
-
+function performTest() {
   let hudId = HUDService.getHudIdByWindow(content);
   let HUD = HUDService.hudReferences[hudId];
 
   HUD.jsterm.execute("document");
 
   let networkMessage = HUD.outputNode.querySelector(".webconsole-msg-network");
   ok(networkMessage, "found network message");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js
@@ -19,27 +19,33 @@ function test() {
       pb = null;
     });
 
     ok(!pb.privateBrowsingEnabled, "private browsing is not enabled");
 
     togglePBAndThen(function() {
       ok(pb.privateBrowsingEnabled, "private browsing is enabled");
 
-      openConsole(gBrowser.selectedTab, function() {
+      openConsole(gBrowser.selectedTab, function(hud) {
         content.location = TEST_URI;
-        gBrowser.selectedBrowser.addEventListener("load", tabLoaded, true);
+        waitForSuccess({
+          name: "network message displayed",
+          validatorFn: function()
+          {
+            return hud.outputNode.querySelector(".webconsole-msg-network");
+          },
+          successFn: performTest,
+          failureFn: finishTest,
+        });
       });
     });
   }, true);
 }
 
-function tabLoaded() {
-  gBrowser.selectedBrowser.removeEventListener("load", tabLoaded, true);
-
+function performTest() {
   let hudId = HUDService.getHudIdByWindow(content);
   let HUD = HUDService.hudReferences[hudId];
 
   HUD.jsterm.execute("document");
 
   let networkMessage = HUD.outputNode.querySelector(".webconsole-msg-network");
   ok(networkMessage, "found network message");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js b/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js
@@ -111,17 +111,29 @@ function testXhrPost()
 
 function testFormSubmission()
 {
   // Start the form submission test. As the form is submitted, the page is
   // loaded again. Bind to the load event to catch when this is done.
   requestCallback = function() {
     ok(lastRequest, "testFormSubmission() was logged");
     is(lastRequest.request.method, "POST", "Method is correct");
-    executeSoon(testLiveFilteringOnSearchStrings);
+    waitForSuccess({
+      name: "all network request displayed",
+      validatorFn: function() {
+        return hud.outputNode.querySelectorAll(".webconsole-msg-network")
+               .length == 5;
+      },
+      successFn: testLiveFilteringOnSearchStrings,
+      failureFn: function() {
+        let nodes = hud.outputNode.querySelectorAll(".webconsole-msg-network");
+        info("nodes: " + nodes.length + "\n");
+        finishTest();
+      },
+    });
   };
 
   let form = content.document.querySelector("form");
   ok(form, "we have the HTML form");
   form.submit();
 }
 
 function testLiveFilteringOnSearchStrings() {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_642108_pruneTest.js b/browser/devtools/webconsole/test/browser_webconsole_bug_642108_pruneTest.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_642108_pruneTest.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_642108_pruneTest.js
@@ -10,65 +10,84 @@
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>test for bug 642108.";
 const LOG_LIMIT = 20;
 const CATEGORY_CSS = 1;
 const SEVERITY_WARNING = 1;
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testCSSPruning, false);
+  browser.addEventListener("load", function onLoad(){
+    browser.removeEventListener("load", onLoad, false);
+
+    Services.prefs.setIntPref("devtools.hud.loglimit.cssparser", LOG_LIMIT);
+
+    registerCleanupFunction(function() {
+      Services.prefs.clearUserPref("devtools.hud.loglimit.cssparser");
+    });
+
+    openConsole(null, testCSSPruning);
+  }, true);
 }
 
 function populateConsoleRepeats(aHudRef) {
   let hud = aHudRef.HUDBox;
 
   for (let i = 0; i < 5; i++) {
     let node = ConsoleUtils.createMessageNode(hud.ownerDocument,
                                               CATEGORY_CSS,
                                               SEVERITY_WARNING,
                                               "css log x",
                                               aHudRef.hudId);
-    ConsoleUtils.outputMessageNode(node, aHudRef.hudId);
+   aHudRef.outputMessage(CATEGORY_CSS, node);
   }
 }
 
 
 function populateConsole(aHudRef) {
   let hud = aHudRef.HUDBox;
 
   for (let i = 0; i < LOG_LIMIT + 5; i++) {
     let node = ConsoleUtils.createMessageNode(hud.ownerDocument,
                                               CATEGORY_CSS,
                                               SEVERITY_WARNING,
                                               "css log " + i,
                                               aHudRef.hudId);
-    ConsoleUtils.outputMessageNode(node, aHudRef.hudId);
+    aHudRef.outputMessage(CATEGORY_CSS, node);
   }
 }
 
-function testCSSPruning() {
-  let prefBranch = Services.prefs.getBranch("devtools.hud.loglimit.");
-  prefBranch.setIntPref("cssparser", LOG_LIMIT);
+function testCSSPruning(hudRef) {
+  populateConsoleRepeats(hudRef);
 
-  browser.removeEventListener("DOMContentLoaded",testCSSPruning, false);
+  let waitForNoRepeatedNodes = {
+    name:  "number of nodes is LOG_LIMIT",
+    validatorFn: function()
+    {
+      return countMessageNodes() == LOG_LIMIT;
+    },
+    successFn: function()
+    {
+      ok(!hudRef.cssNodes["css log x"], "repeated nodes pruned from cssNodes");
+      finishTest();
+    },
+    failureFn: finishTest,
+  };
 
-  openConsole();
-  let hudRef = HUDService.getHudByWindow(content);
-
-  populateConsoleRepeats(hudRef);
-  ok(hudRef.cssNodes["css log x"], "repeated nodes in cssNodes");
-
-  populateConsole(hudRef);
-
-  is(countMessageNodes(), LOG_LIMIT, "number of nodes is LOG_LIMIT");
-  ok(!hudRef.cssNodes["css log x"], "repeated nodes pruned from cssNodes");
-
-  prefBranch.clearUserPref("loglimit");
-  prefBranch = null;
-
-  finishTest();
+  waitForSuccess({
+    name: "repeated nodes in cssNodes",
+    validatorFn: function()
+    {
+      return hudRef.cssNodes["css log x"];
+    },
+    successFn: function()
+    {
+      populateConsole(hudRef);
+      waitForSuccess(waitForNoRepeatedNodes);
+    },
+    failureFn: finishTest,
+  });
 }
 
 function countMessageNodes() {
   let outputNode = HUDService.getHudByWindow(content).outputNode;
   return outputNode.querySelectorAll(".hud-msg-node").length;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_js_input_and_output_styling.js b/browser/devtools/webconsole/test/browser_webconsole_js_input_and_output_styling.js
--- a/browser/devtools/webconsole/test/browser_webconsole_js_input_and_output_styling.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_js_input_and_output_styling.js
@@ -17,31 +17,32 @@ function test() {
 }
 
 function testJSInputAndOutputStyling(hud) {
   let jsterm = hud.jsterm;
 
   jsterm.clearOutput();
   jsterm.execute("2 + 2");
 
-  let jsInputNode = jsterm.outputNode.querySelector(".hud-msg-node");
-  isnot(jsInputNode.textContent.indexOf("2 + 2"), -1,
-        "JS input node contains '2 + 2'");
-  ok(jsInputNode.classList.contains("webconsole-msg-input"),
-     "JS input node is of the CSS class 'webconsole-msg-input'");
-
   waitForSuccess({
     name: "jsterm output is displayed",
     validatorFn: function()
     {
       return jsterm.outputNode.querySelector(".webconsole-msg-output");
     },
     successFn: function()
     {
-      let node = jsterm.outputNode.querySelector(".webconsole-msg-output");
-      isnot(node.textContent.indexOf("4"), -1,
+      let jsInputNode = jsterm.outputNode.querySelector(".hud-msg-node");
+      isnot(jsInputNode.textContent.indexOf("2 + 2"), -1,
+            "JS input node contains '2 + 2'");
+      ok(jsInputNode.classList.contains("webconsole-msg-input"),
+         "JS input node is of the CSS class 'webconsole-msg-input'");
+
+      let output = jsterm.outputNode.querySelector(".webconsole-msg-output");
+      isnot(output.textContent.indexOf("4"), -1,
             "JS output node contains '4'");
+
       finishTest();
     },
     failureFn: finishTest,
   });
 }
 
diff --git a/dom/base/ConsoleAPI.js b/dom/base/ConsoleAPI.js
--- a/dom/base/ConsoleAPI.js
+++ b/dom/base/ConsoleAPI.js
@@ -16,23 +16,26 @@ const MAX_PAGE_TIMERS = 10000;
 const ARGUMENT_PATTERN = /%\d*\.?\d*([osdif])\b/g;
 
 // The maximum stacktrace depth when populating the stacktrace array used for
 // console.trace().
 const DEFAULT_MAX_STACKTRACE_DEPTH = 200;
 
 // The console API methods are async and their action is executed later. This
 // delay tells how much later.
-const CALL_DELAY = 30; // milliseconds
+const CALL_DELAY = 15; // milliseconds
+
+// This constant tells how many messages to process in a single timer execution.
+const MESSAGES_IN_INTERVAL = 1500;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/ConsoleAPIStorage.jsm");
 
-let nsITimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+let gTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
 
 function ConsoleAPI() {}
 ConsoleAPI.prototype = {
 
   classID: Components.ID("{b49c18f8-3379-4fc0-8c90-d7772c1a9ff3}"),
 
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIDOMGlobalPropertyInitializer]),
 
@@ -146,30 +149,28 @@ ConsoleAPI.prototype = {
       __mozillaConsole__: { value: true }
     };
 
     Object.defineProperties(contentObj, properties);
     Cu.makeObjectPropsNormal(contentObj);
 
     this._queuedCalls = [];
     this._destroyedWindows = [];
-    this._timerCallback = {
-      notify: this._timerCallbackNotify.bind(this),
-    };
 
     return contentObj;
   },
 
   observe: function CA_observe(aSubject, aTopic, aData)
   {
     if (aTopic == "xpcom-shutdown") {
       Services.obs.removeObserver(this, "xpcom-shutdown");
       Services.obs.removeObserver(this, "inner-window-destroyed");
       this._destroyedWindows = [];
       this._queuedCalls = [];
+      gTimer = null;
     }
     else if (aTopic == "inner-window-destroyed") {
       let innerWindowID = aSubject.QueryInterface(Ci.nsISupportsPRUint64).data;
       delete this.timerRegistry[innerWindowID + ""];
       this._destroyedWindows.push(innerWindowID);
     }
   },
 
@@ -191,31 +192,36 @@ ConsoleAPI.prototype = {
       innerID: aMeta.innerID,
       timeStamp: Date.now(),
       stack: this.getStackTrace(aMethod != "trace" ? 1 : null),
     };
 
     this._queuedCalls.push([aMethod, aArguments, metaForCall]);
 
     if (!this._timerInitialized) {
-      nsITimer.initWithCallback(this._timerCallback, CALL_DELAY,
-                                Ci.nsITimer.TYPE_ONE_SHOT);
+      gTimer.initWithCallback(this._timerCallback.bind(this), CALL_DELAY,
+                              Ci.nsITimer.TYPE_REPEATING_SLACK);
       this._timerInitialized = true;
     }
   },
 
   /**
    * Timer callback used to process each of the queued calls.
    * @private
    */
-  _timerCallbackNotify: function CA__timerCallbackNotify()
+  _timerCallback: function CA__timerCallback()
   {
-    this._timerInitialized = false;
-    this._queuedCalls.splice(0).forEach(this._processQueuedCall, this);
-    this._destroyedWindows = [];
+    this._queuedCalls.splice(0, MESSAGES_IN_INTERVAL)
+      .forEach(this._processQueuedCall, this);
+
+    if (!this._queuedCalls.length) {
+      this._timerInitialized = false;
+      this._destroyedWindows = [];
+      gTimer.cancel();
+    }
   },
 
   /**
    * Process a queued call to a console method.
    *
    * @private
    * @param array aCall
    *        Array that holds information about the queued call.
