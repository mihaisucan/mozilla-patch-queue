# HG changeset patch
# User Panos Astithas <past@mozilla.com>
# Date 1360172211 -7200
# Node ID 50e067c733252da7ce6c785477b0ebc6deb3858e
# Parent f4950b5354bf7cb84a9e75771eaeb5b89c6266d6
Bug 820524 - Debugger and Web Console should share the debugger client even for local sessions

diff --git a/browser/devtools/commandline/test/browser_dbg_cmd.js b/browser/devtools/commandline/test/browser_dbg_cmd.js
--- a/browser/devtools/commandline/test/browser_dbg_cmd.js
+++ b/browser/devtools/commandline/test/browser_dbg_cmd.js
@@ -42,23 +42,31 @@ function testCommands(dbg, cmd) {
                   is(output.value, "step over", "debugger stepped over");
                   cmd("dbg step out", function() {
                     is(output.value, "step out", "debugger stepped out");
                     cmd("dbg continue", function() {
                       cmd("dbg continue", function() {
                         is(output.value, "dbg continue", "debugger continued");
                         DeveloperToolbarTest.exec({
                           typed: "dbg close",
+                          completed: false,
                           blankOutput: true
                         });
 
                         let target = TargetFactory.forTab(gBrowser.selectedTab);
-                        ok(!gDevTools.getToolbox(target),
-                          "Debugger was closed.");
-                        finish();
+                        let toolbox = gDevTools.getToolbox(target);
+                        if (!toolbox) {
+                          ok(true, "Debugger was closed.");
+                          finish();
+                        } else {
+                          toolbox.on("destroyed", function () {
+                            ok(true, "Debugger was closed.");
+                            finish();
+                          });
+                        }
                       });
                     });
                   });
                 });
               });
             });
           });
         });
diff --git a/browser/devtools/debugger/DebuggerPanel.jsm b/browser/devtools/debugger/DebuggerPanel.jsm
--- a/browser/devtools/debugger/DebuggerPanel.jsm
+++ b/browser/devtools/debugger/DebuggerPanel.jsm
@@ -17,38 +17,30 @@ XPCOMUtils.defineLazyModuleGetter(this, 
   "resource://gre/modules/devtools/dbg-server.jsm");
 
 function DebuggerPanel(iframeWindow, toolbox) {
   this.panelWin = iframeWindow;
   this._toolbox = toolbox;
 
   this._controller = this.panelWin.DebuggerController;
   this._view = this.panelWin.DebuggerView;
-  this._controller._target = this.target;
   this._bkp = this._controller.Breakpoints;
 
   EventEmitter.decorate(this);
 }
 
 DebuggerPanel.prototype = {
   /**
    * open is effectively an asynchronous constructor
    */
   open: function DebuggerPanel_open() {
     let deferred = Promise.defer();
 
     this._ensureOnlyOneRunningDebugger();
 
-    if (!this.target.isRemote) {
-      if (!DebuggerServer.initialized) {
-        DebuggerServer.init();
-        DebuggerServer.addBrowserActors();
-      }
-    }
-
     let onDebuggerLoaded = function () {
       this.panelWin.removeEventListener("Debugger:Loaded",
                                         onDebuggerLoaded, true);
       this._isReady = true;
       this.emit("ready");
       deferred.resolve(this);
     }.bind(this);
 
@@ -57,17 +49,29 @@ DebuggerPanel.prototype = {
                                         onDebuggerConnected, true);
       this.emit("connected");
     }.bind(this);
 
     this.panelWin.addEventListener("Debugger:Loaded", onDebuggerLoaded, true);
     this.panelWin.addEventListener("Debugger:Connected",
                                    onDebuggerConnected, true);
 
-    return deferred.promise;
+    // Remote debugging gets the debuggee from a RemoteTarget object.
+    if (this.target.isRemote) {
+      this.panelWin._remoteFlag = true;
+      this._controller._target = this.target;
+      return deferred.promise;
+    }
+
+    // Local debugging needs to convert the TabTarget to a RemoteTarget.
+    return this.target.remote().then(function success(aRemoteTarget) {
+        this._controller._target = aRemoteTarget;
+      }.bind(this)).then(function() {
+        return deferred.promise;
+      });
   },
 
   // DevToolPanel API
   get target() this._toolbox.target,
 
   get isReady() this._isReady,
 
   destroy: function() {
diff --git a/browser/devtools/debugger/debugger-controller.js b/browser/devtools/debugger/debugger-controller.js
--- a/browser/devtools/debugger/debugger-controller.js
+++ b/browser/devtools/debugger/debugger-controller.js
@@ -94,17 +94,17 @@ let DebuggerController = {
       window.dispatchEvent("Debugger:Unloaded");
       window._isChromeDebugger && this._quitApp();
     }.bind(this));
   },
 
   /**
    * Prepares the hostname and port number for a remote debugger connection
    * and handles connection retries and timeouts.
-   *
+   * XXX: remove all this (bug 823577)
    * @return boolean
    *         True if connection should proceed normally, false otherwise.
    */
   _prepareConnection: function DC__prepareConnection() {
     // If we exceeded the total number of connection retries, bail.
     if (this._remoteConnectionTry === Prefs.remoteConnectionRetries) {
       Services.prompt.alert(null,
         L10N.getStr("remoteDebuggerPromptTitle"),
@@ -160,71 +160,59 @@ let DebuggerController = {
    * Initializes a debugger client and connects it to the debugger server,
    * wiring event handlers as necessary.
    */
   _connect: function DC__connect() {
     function callback() {
       window.dispatchEvent("Debugger:Connected");
     }
 
-    let client;
-
-    // Remote debugging gets the debuggee from a RemoteTarget object.
-    if (this._target && this._target.isRemote) {
-      window._isRemoteDebugger = true;
-
-      client = this.client = this._target.client;
+    if (!window._isChromeDebugger) {
+      let client = this.client = this._target.client;
       this._target.on("close", this._onTabDetached);
       this._target.on("navigate", this._onTabNavigated);
+      this._target.on("will-navigate", this._onTabNavigated);
 
       if (this._target.chrome) {
         let dbg = this._target.form.chromeDebugger;
         this._startChromeDebugging(client, dbg, callback);
       } else {
         this._startDebuggingTab(client, this._target.form, callback);
       }
       return;
     }
 
-    // Content or chrome debugging can connect directly to the debuggee.
-    // TODO: convert this to use a TabTarget.
-    let transport = window._isChromeDebugger
-      ? debuggerSocketConnect(Prefs.remoteHost, Prefs.remotePort)
-      : DebuggerServer.connectPipe();
+    // Chrome debugging needs to make the connection to the debuggee.
+    let transport = debuggerSocketConnect(Prefs.remoteHost, Prefs.remotePort);
 
-    client = this.client = new DebuggerClient(transport);
+    let client = this.client = new DebuggerClient(transport);
     client.addListener("tabNavigated", this._onTabNavigated);
     client.addListener("tabDetached", this._onTabDetached);
 
     client.connect(function(aType, aTraits) {
       client.listTabs(function(aResponse) {
-        if (window._isChromeDebugger) {
-          let dbg = aResponse.chromeDebugger;
-          this._startChromeDebugging(client, dbg, callback);
-        } else {
-          let tab = aResponse.tabs[aResponse.selected];
-          this._startDebuggingTab(client, tab, callback);
-        }
+        this._startChromeDebugging(client, aResponse.chromeDebugger, callback);
       }.bind(this));
     }.bind(this));
   },
 
   /**
    * Disconnects the debugger client and removes event handlers as necessary.
    */
   _disconnect: function DC__disconnect() {
     // Return early if the client didn't even have a chance to instantiate.
     if (!this.client) {
       return;
     }
     this.client.removeListener("tabNavigated", this._onTabNavigated);
     this.client.removeListener("tabDetached", this._onTabDetached);
 
-    // When remote debugging, the connection is closed by the RemoteTarget.
-    if (!window._isRemoteDebugger) {
+    // When debugging content or a remote instance, the connection is closed by
+    // the RemoteTarget.
+    if (window._isChromeDebugger) {
       this.client.close();
     }
 
     this.client = null;
     this.tabClient = null;
     this.activeThread = null;
   },
 
@@ -407,19 +395,24 @@ ThreadState.prototype = {
   },
 
   /**
    * Update the UI after a thread state change.
    */
   _update: function TS__update(aEvent) {
     DebuggerView.Toolbar.toggleResumeButtonState(this.activeThread.state);
 
-    if (DebuggerController._target &&
-        (aEvent == "paused" || aEvent == "resumed")) {
-      DebuggerController._target.emit("thread-" + aEvent);
+    // Notify the RemoteTarget and any parent TabTarget.
+    let target = DebuggerController._target;
+    if (target && (aEvent == "paused" || aEvent == "resumed")) {
+      let event = "thread-" + aEvent;
+      target.emit(event);
+      if (target._originTabTarget) {
+        target._originTabTarget.emit(event);
+      }
     }
   }
 };
 
 /**
  * Keeps the stack frame list up-to-date, using the thread client's
  * stack frame cache.
  */
diff --git a/browser/devtools/framework/Target.jsm b/browser/devtools/framework/Target.jsm
--- a/browser/devtools/framework/Target.jsm
+++ b/browser/devtools/framework/Target.jsm
@@ -6,16 +6,18 @@
 
 this.EXPORTED_SYMBOLS = [ "TargetFactory" ];
 
 const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/commonjs/sdk/core/promise.js");
 Cu.import("resource:///modules/devtools/EventEmitter.jsm");
+Cu.import("resource://gre/modules/devtools/dbg-client.jsm");
+Cu.import("resource://gre/modules/devtools/dbg-server.jsm");
 
 
 const targets = new WeakMap();
 
 /**
  * Functions for creating Targets
  */
 this.TargetFactory = {
@@ -66,27 +68,27 @@ this.TargetFactory = {
    *        The serialized form of a debugging protocol actor.
    * @param {DebuggerClient} client
    *        The debuger client instance to communicate with the server.
    * @param {boolean} chrome
    *        A flag denoting that the debugging target is the remote process as a
    *        whole and not a single tab.
    * @return A target object
    */
-  forRemote: function TF_forRemote(form, client, chrome) {
+  forRemote: function TF_forRemote(form, client, chrome=false) {
     let target = targets.get(form);
     if (target == null) {
       target = new RemoteTarget(form, client, chrome);
       targets.set(form, target);
     }
     return target;
   },
 
   /**
-   * Get all of the targets known to some browser instance (local if null)
+   * Get all of the targets known to the local browser instance
    * @return An array of target objects
    */
   allTargets: function TF_allTargets() {
     let windows = [];
     let wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
                        .getService(Components.interfaces.nsIWindowMediator);
     let en = wm.getXULWindowEnumerator(null);
     while (en.hasMoreElements()) {
@@ -205,16 +207,49 @@ TabTarget.prototype = {
     return true;
   },
 
   get isThreadPaused() {
     return !!this._isThreadPaused;
   },
 
   /**
+   * Returns a RemoteTarget that can be used instead of this TabTarget for tools
+   * that support the Remote Debugging Protocol even for local connections.
+   */
+  remote: function TabTarget_remote() {
+    if (this._remote) {
+      return this._remote.promise;
+    }
+
+    // Since a remote protocol connection will be made, let's start the
+    // DebuggerServer here, once and for all.
+    if (!DebuggerServer.initialized) {
+      DebuggerServer.init();
+      DebuggerServer.addBrowserActors();
+    }
+
+    this._remote = Promise.defer();
+    let client = new DebuggerClient(DebuggerServer.connectPipe());
+    client.connect(function(aType, aTraits) {
+      client.listTabs(function(aResponse) {
+        let tab = aResponse.tabs[aResponse.selected];
+        let remoteTarget = TargetFactory.forRemote(tab, client);
+        // Retain the TabTarget for later cleanup, but also for tools that are
+        // not remote-protocol-aware yet.
+        remoteTarget._originTabTarget = this;
+
+        this._remote.resolve(remoteTarget);
+      }.bind(this));
+    }.bind(this));
+
+    return this._remote.promise;
+  },
+
+  /**
    * Listen to the different events.
    */
   _setupListeners: function TabTarget__setupListeners() {
     this._webProgressListener = new TabWebProgressListener(this);
     this.tab.linkedBrowser.addProgressListener(this._webProgressListener);
     this.tab.addEventListener("TabClose", this);
     this.tab.parentNode.addEventListener("TabSelect", this);
     this.tab.ownerDocument.defaultView.addEventListener("close", this);
@@ -257,16 +292,22 @@ TabTarget.prototype = {
   },
 
   /**
    * Target is not alive anymore.
    */
   destroy: function() {
     if (!this._destroyed) {
       this._destroyed = true;
+      // Make sure any sibling RemoteTarget is destroyed as well.
+      if (this._remote) {
+        this._remote.promise.then(function (aRemoteTarget) {
+          aRemoteTarget.destroy();
+        });
+      }
 
       this.tab.linkedBrowser.removeProgressListener(this._webProgressListener)
       this._webProgressListener.target = null;
       this._webProgressListener = null;
       this.tab.ownerDocument.defaultView.removeEventListener("close", this);
       this.tab.removeEventListener("TabClose", this);
       this.tab.parentNode.removeEventListener("TabSelect", this);
       this.off("thread-resumed", this._handleThreadState);
@@ -490,17 +531,22 @@ RemoteTarget.prototype = {
     }
 
     this._destroyer = Promise.defer();
 
     this.client.removeListener("tabNavigated", this._onTabNavigated);
     this.client.removeListener("tabDetached", this.destroy);
 
     this._client.close(function onClosed() {
+      targets.delete(this._form);
       this._client = null;
+      // Clear the reference in any parent TabTarget.
+      if (this._originTabTarget) {
+        this._originTabTarget._remote = null;
+      }
       this.off("thread-resumed", this._handleThreadState);
       this.off("thread-paused", this._handleThreadState);
       this.emit("close");
 
       this._destroyer.resolve(null);
     }.bind(this));
 
     return this._destroyer.promise;
diff --git a/browser/devtools/framework/Toolbox.jsm b/browser/devtools/framework/Toolbox.jsm
--- a/browser/devtools/framework/Toolbox.jsm
+++ b/browser/devtools/framework/Toolbox.jsm
@@ -647,18 +647,24 @@ Toolbox.prototype = {
     // destruction promise so we're sure to destroy only once
     if (this._destroyer) {
       return this._destroyer;
     }
 
     let outstanding = [];
 
     // Remote targets need to be notified that the toolbox is being torn down.
-    if (this._target && this._target.isRemote) {
-      outstanding.push(this._target.destroy());
+    if (this._target) {
+      if (this._target.isRemote) {
+        outstanding.push(this._target.destroy());
+      } else if (this._target._remote) {
+        this._target.remote().then(function(aRemoteTarget) {
+          outstanding.push(aRemoteTarget.destroy());
+        });
+      }
     }
     this._target = null;
 
     for (let [id, panel] of this._toolPanels) {
       outstanding.push(panel.destroy());
     }
 
     outstanding.push(this._host.destroy());
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -241,22 +241,21 @@ WebConsole.prototype = {
     let onFailure = function(aReason) {
       deferred.reject(aReason);
     };
 
     let win, doc;
     if ((win = this.iframe.contentWindow) &&
         (doc = win.document) &&
         doc.readyState == "complete") {
+      initUI();
+    }
+    else {
       this.iframe.addEventListener("load", onIframeLoad, true);
     }
-    else {
-      initUI();
-    }
-
     return deferred.promise;
   },
 
   /**
    * Retrieve the Web Console panel title.
    *
    * @return string
    *         The Web Console panel title.
diff --git a/browser/devtools/webconsole/WebConsolePanel.jsm b/browser/devtools/webconsole/WebConsolePanel.jsm
--- a/browser/devtools/webconsole/WebConsolePanel.jsm
+++ b/browser/devtools/webconsole/WebConsolePanel.jsm
@@ -4,16 +4,17 @@
 
 "use strict";
 
 this.EXPORTED_SYMBOLS = [ "WebConsolePanel" ];
 
 const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/commonjs/sdk/core/promise.js");
 
 XPCOMUtils.defineLazyModuleGetter(this, "HUDService",
     "resource:///modules/HUDService.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "EventEmitter",
     "resource:///modules/devtools/EventEmitter.jsm");
 
 /**
@@ -33,40 +34,54 @@ WebConsolePanel.prototype = {
    *
    * @return object
    *         A Promise that is resolved when the Web Console completes opening.
    */
   open: function WCP_open()
   {
     let parentDoc = this._toolbox.doc;
     let iframe = parentDoc.getElementById("toolbox-panel-iframe-webconsole");
-    let promise = HUDService.openWebConsole(this.target, iframe);
+    let promise;
 
-    return promise.then(function onSuccess(aWebConsole) {
-      this.hud = aWebConsole;
-      this._isReady = true;
-      this.emit("ready");
-      return this;
-    }.bind(this), function onError(aReason) {
-      Cu.reportError("WebConsolePanel open failed. " +
-                     aReason.error + ": " + aReason.message);
-    });
+    // Local debugging needs to convert the TabTarget to a RemoteTarget.
+    if (!this.target.isRemote) {
+      promise = this.target.remote();
+    } else {
+      promise = Promise.resolve(this.target);
+    }
+
+    return promise
+      .then(function(aTarget) {
+        this._frameWindow._remoteTarget = aTarget;
+        return HUDService.openWebConsole(this.target, iframe);
+      }.bind(this))
+      .then(function onSuccess(aWebConsole) {
+        this.hud = aWebConsole;
+        this._isReady = true;
+        this.emit("ready");
+        return this;
+      }.bind(this), function onError(aReason) {
+        let msg = "WebConsolePanel open failed. " +
+                  aReason.error + ": " + aReason.message;
+        dump(msg + "\n");
+        Cu.reportError(msg);
+      });
   },
 
   get target() this._toolbox.target,
 
   _isReady: false,
   get isReady() this._isReady,
 
   destroy: function WCP_destroy()
   {
     if (this._destroyer) {
-      return this._destroyer;
+      return this._destroyer.promise;
     }
 
     this._destroyer = this.hud.destroy();
     this._destroyer.then(function() {
       this.emit("destroyed");
     }.bind(this));
 
-    return this._destroyer;
+    return this._destroyer.promise;
   },
 };
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -10,25 +10,16 @@ const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Services",
                                   "resource://gre/modules/Services.jsm");
 
-XPCOMUtils.defineLazyModuleGetter(this, "DebuggerServer",
-                                  "resource://gre/modules/devtools/dbg-server.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "DebuggerClient",
-                                  "resource://gre/modules/devtools/dbg-client.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "debuggerSocketConnect",
-                                  "resource://gre/modules/devtools/dbg-client.jsm");
-
 XPCOMUtils.defineLazyServiceGetter(this, "clipboardHelper",
                                    "@mozilla.org/widget/clipboardhelper;1",
                                    "nsIClipboardHelper");
 
 XPCOMUtils.defineLazyModuleGetter(this, "PropertyPanel",
                                   "resource:///modules/PropertyPanel.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "PropertyTreeView",
@@ -371,17 +362,17 @@ WebConsoleFrame.prototype = {
    * @return object
    *         A Promise object that is resolved/reject based on the connection
    *         result.
    */
   _initConnection: function WCF__initConnection()
   {
     let deferred = Promise.defer();
 
-    this.proxy = new WebConsoleConnectionProxy(this, this.owner.target);
+    this.proxy = new WebConsoleConnectionProxy(this, this.window._remoteTarget);
 
     let onSuccess = function() {
       this.saveRequestAndResponseBodies = this._saveRequestAndResponseBodies;
       deferred.resolve(this);
     }.bind(this);
 
     let onFailure = function(aReason) {
       let node = this.createMessageNode(CATEGORY_JS, SEVERITY_ERROR,
@@ -3976,17 +3967,16 @@ function WebConsoleConnectionProxy(aWebC
   this.target = aTarget;
 
   this._onPageError = this._onPageError.bind(this);
   this._onConsoleAPICall = this._onConsoleAPICall.bind(this);
   this._onNetworkEvent = this._onNetworkEvent.bind(this);
   this._onNetworkEventUpdate = this._onNetworkEventUpdate.bind(this);
   this._onFileActivity = this._onFileActivity.bind(this);
   this._onTabNavigated = this._onTabNavigated.bind(this);
-  this._onListTabs = this._onListTabs.bind(this);
   this._onAttachTab = this._onAttachTab.bind(this);
   this._onAttachConsole = this._onAttachConsole.bind(this);
   this._onCachedMessages = this._onCachedMessages.bind(this);
   this._connectionTimeout = this._connectionTimeout.bind(this);
 }
 
 WebConsoleConnectionProxy.prototype = {
   /**
@@ -4061,27 +4051,16 @@ WebConsoleConnectionProxy.prototype = {
    * Tells if the window.console object of the remote web page is the native
    * object or not.
    * @private
    * @type boolean
    */
   _hasNativeConsoleAPI: false,
 
   /**
-   * Initialize the debugger server.
-   */
-  initServer: function WCCP_initServer()
-  {
-    if (!DebuggerServer.initialized) {
-      DebuggerServer.init();
-      DebuggerServer.addBrowserActors();
-    }
-  },
-
-  /**
    * Initialize a debugger client and connect it to the debugger server.
    *
    * @return object
    *         A Promise object that is resolved/rejected based on the success of
    *         the connection initialization.
    */
   connect: function WCCP_connect()
   {
@@ -4099,49 +4078,33 @@ WebConsoleConnectionProxy.prototype = {
     let promise = this._connectDefer.promise;
     promise.then(function _onSucess() {
       this._connectTimer.cancel();
       this._connectTimer = null;
     }.bind(this), function _onFailure() {
       this._connectTimer = null;
     }.bind(this));
 
-    // TODO: convert the non-remote path to use the target API as well.
-    let transport, client;
-    if (this.target.isRemote) {
-      client = this.client = this.target.client;
-    }
-    else {
-      this.initServer();
-      transport = DebuggerServer.connectPipe();
-      client = this.client = new DebuggerClient(transport);
-    }
+    let client = this.client = this.target.client;
 
     client.addListener("pageError", this._onPageError);
     client.addListener("consoleAPICall", this._onConsoleAPICall);
     client.addListener("networkEvent", this._onNetworkEvent);
     client.addListener("networkEventUpdate", this._onNetworkEventUpdate);
     client.addListener("fileActivity", this._onFileActivity);
     client.addListener("tabNavigated", this._onTabNavigated);
 
-    if (this.target.isRemote) {
-      if (!this.target.chrome) {
-        // target.form is a TabActor grip
-        this._attachTab(this.target.form);
-      }
-      else {
-        // target.form is a RootActor grip
-        this._consoleActor = this.target.form.consoleActor;
-        this._attachConsole();
-      }
+    if (!this.target.chrome) {
+      // target.form is a TabActor grip
+      this._attachTab(this.target.form);
     }
     else {
-      client.connect(function(aType, aTraits) {
-        client.listTabs(this._onListTabs);
-      }.bind(this));
+      // target.form is a RootActor grip
+      this._consoleActor = this.target.form.consoleActor;
+      this._attachConsole();
     }
 
     return promise;
   },
 
   /**
    * Connection timeout handler.
    * @private
@@ -4152,35 +4115,16 @@ WebConsoleConnectionProxy.prototype = {
       error: "timeout",
       message: l10n.getStr("connectionTimeout"),
     };
 
     this._connectDefer.reject(error);
   },
 
   /**
-   * The "listTabs" response handler.
-   *
-   * @private
-   * @param object aResponse
-   *        The JSON response object received from the server.
-   */
-  _onListTabs: function WCCP__onListTabs(aResponse)
-  {
-    if (aResponse.error) {
-      Cu.reportError("listTabs failed: " + aResponse.error + " " +
-                     aResponse.message);
-      this._connectDefer.reject(aResponse);
-      return;
-    }
-
-    this._attachTab(aResponse.tabs[aResponse.selected]);
-  },
-
-  /**
    * Attach to the tab actor.
    *
    * @private
    * @param object aTab
    *        Grip for the tab to attach to.
    */
   _attachTab: function WCCP__attachTab(aTab)
   {
diff --git a/toolkit/devtools/debugger/server/dbg-browser-actors.js b/toolkit/devtools/debugger/server/dbg-browser-actors.js
--- a/toolkit/devtools/debugger/server/dbg-browser-actors.js
+++ b/toolkit/devtools/debugger/server/dbg-browser-actors.js
@@ -672,17 +672,16 @@ DebuggerProgressListener.prototype = {
         this._tabActor.threadActor.dbg.enabled = false;
         this._tabActor._pendingNavigation = aRequest;
       }
 
       this._tabActor.conn.send({
         from: this._tabActor.actorID,
         type: "tabNavigated",
         url: aRequest.URI.spec,
-        title: "",
         nativeConsoleAPI: true,
         state: "start",
       });
     } else if (isStop) {
       if (this._tabActor.threadActor.state == "running") {
         this._tabActor.threadActor.dbg.enabled = true;
       }
 
