# HG changeset patch
# Parent 0190cdae6b9f3a575a5a02dceac1b436a7f45618
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1346410199 -10800
Bug 768096 - Web Console remote debugging protocol support - Part 2: window.console API and JS evaluation

diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -533,22 +533,18 @@ WebConsole.prototype = {
 
   /**
    * Message names that the HUD listens for. These messages come from the remote
    * Web Console content script.
    *
    * @private
    * @type array
    */
-  _messageListeners: ["JSTerm:EvalObject", "WebConsole:ConsoleAPI",
-    "WebConsole:CachedMessages", "WebConsole:Initialized", "JSTerm:EvalResult",
-    "JSTerm:AutocompleteProperties", "JSTerm:ClearOutput",
-    "JSTerm:InspectObject", "WebConsole:NetworkActivity",
-    "WebConsole:FileActivity", "WebConsole:LocationChange",
-    "JSTerm:NonNativeConsoleAPI"],
+  _messageListeners: ["WebConsole:Initialized", "WebConsole:NetworkActivity",
+    "WebConsole:FileActivity", "WebConsole:LocationChange"],
 
   /**
    * The xul:panel that holds the Web Console when it is positioned as a window.
    * @type nsIDOMElement
    */
   consolePanel: null,
 
   /**
@@ -921,18 +917,17 @@ WebConsole.prototype = {
   {
     this.messageManager.loadFrameScript(CONTENT_SCRIPT_URL, true);
 
     this._messageListeners.forEach(function(aName) {
       this.messageManager.addMessageListener(aName, this.ui);
     }, this);
 
     let message = {
-      features: ["ConsoleAPI", "JSTerm", "NetworkMonitor", "LocationChange"],
-      cachedMessages: ["ConsoleAPI", "PageError"],
+      features: ["JSTerm", "NetworkMonitor", "LocationChange"],
       NetworkMonitor: { monitorFileActivity: true },
       JSTerm: { notifyNonNativeConsoleAPI: true },
       preferences: {
         "NetworkMonitor.saveRequestAndResponseBodies":
           this.ui.saveRequestAndResponseBodies,
       },
     };
 
diff --git a/browser/devtools/webconsole/PropertyPanel.jsm b/browser/devtools/webconsole/PropertyPanel.jsm
--- a/browser/devtools/webconsole/PropertyPanel.jsm
+++ b/browser/devtools/webconsole/PropertyPanel.jsm
@@ -22,95 +22,118 @@ var EXPORTED_SYMBOLS = ["PropertyPanel",
 
 /**
  * This is an implementation of the nsITreeView interface. For comments on the
  * interface properties, see the documentation:
  * https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsITreeView
  */
 var PropertyTreeView = function() {
   this._rows = [];
-  this._objectCache = {};
+  this._objectActors = [];
 };
 
 PropertyTreeView.prototype = {
   /**
    * Stores the visible rows of the tree.
    * @private
    */
   _rows: null,
 
   /**
    * Stores the nsITreeBoxObject for this tree.
    * @private
    */
   _treeBox: null,
 
   /**
-   * Stores cached information about local objects being inspected.
+   * Track known object actor IDs. We clean these when the panel is
+   * destroyed/cleaned up.
+   *
    * @private
+   * @type array
    */
-  _objectCache: null,
+  _objectActors: null,
+
+  /**
+   * Map between inspected objects and the fake object actor grips. This is used
+   * when we inspect local objects.
+   * @private
+   * @type Map
+   */
+  _localObjectActors: null,
+
+  /**
+   * Map between fake object actor IDs and their respective inspected object.
+   * @private
+   * @type object
+   */
+  _localActorToObject: null,
+
+  _trackObjectActor: null,
+  _releaseObject: null,
+  _objectPropertiesProvider: null,
+
+  __n: 0,
+  get _n() ++this.__n,
 
   /**
    * Use this setter to update the content of the tree.
    *
    * @param object aData
    *        A meta object that holds information about the object you want to
    *        display in the property panel. Object properties:
    *        - object:
    *        This is the raw object you want to display. You can only provide
    *        this object if you want the property panel to work in sync mode.
-   *        - remoteObject:
+   *        - objectProperties:
    *        An array that holds information on the remote object being
    *        inspected. Each element in this array describes each property in the
-   *        remote object. See WebConsoleUtils.namesAndValuesOf() for details.
-   *        - rootCacheId:
-   *        The cache ID where the objects referenced in remoteObject are found.
-   *        - panelCacheId:
-   *        The cache ID where any object retrieved by this property panel
-   *        instance should be stored into.
-   *        - remoteObjectProvider:
+   *        remote object. See WebConsoleUtils.inspectObject() for details.
+   *        - objectPropertiesProvider:
    *        A function that is invoked when a new object is needed. This is
    *        called when the user tries to expand an inspectable property. The
    *        callback must take four arguments:
-   *          - fromCacheId:
-   *          Tells from where to retrieve the object the user picked (from
-   *          which cache ID).
-   *          - objectId:
-   *          The object ID the user wants.
-   *          - panelCacheId:
-   *          Tells in which cache ID to store the objects referenced by
-   *          objectId so they can be retrieved later.
+   *          - actorID:
+   *          The object actor ID from which we request the properties.
    *          - callback:
    *          The callback function to be invoked when the remote object is
-   *          received. This function takes one argument: the raw message
-   *          received from the Web Console content script.
+   *          received. This function takes one argument: the array of
+   *          descriptors for each property in the object represented by the
+   *          actor.
+   *        - trackObjectActor:
+   *        Function to invoke when an object actor needs to be tracked. The
+   *        function must take one argument: the object actor ID.
+   *        - releaseObject:
+   *        Function to invoke when an object actor should be released. The
+   *        function must take one argument: the object actor ID.
    */
   set data(aData) {
     let oldLen = this._rows.length;
 
-    this._cleanup();
+    this.cleanup();
 
     if (!aData) {
       return;
     }
 
-    if (aData.remoteObject) {
-      this._rootCacheId = aData.rootCacheId;
-      this._panelCacheId = aData.panelCacheId;
-      this._remoteObjectProvider = aData.remoteObjectProvider;
-      this._rows = [].concat(aData.remoteObject);
-      this._updateRemoteObject(this._rows, 0);
+    if (aData.objectPropertiesProvider) {
+      this._objectPropertiesProvider = aData.objectPropertiesProvider;
+      this._trackObjectActor = aData.trackObjectActor;
+      this._releaseObject = aData.releaseObject;
+      this._propertiesToRows(aData.objectProperties, 0);
+      this._rows = aData.objectProperties;
     }
     else if (aData.object) {
+      this._localObjectActors = new Map();
+      this._localActorToObject = {};
       this._rows = this._inspectObject(aData.object);
     }
     else {
-      throw new Error("First argument must have a .remoteObject or " +
-                      "an .object property!");
+      throw new Error("First argument must have an objectActor or an " +
+                      "object property!");
     }
 
     if (this._treeBox) {
       this._treeBox.beginUpdateBatch();
       if (oldLen) {
         this._treeBox.rowCountChanged(0, -oldLen);
       }
       this._treeBox.rowCountChanged(0, this._rows.length);
@@ -123,87 +146,117 @@ PropertyTreeView.prototype = {
    * adds properties to each array element.
    *
    * @private
    * @param array aObject
    *        The remote object you want prepared for use with the tree view.
    * @param number aLevel
    *        The level you want to give to each property in the remote object.
    */
-  _updateRemoteObject: function PTV__updateRemoteObject(aObject, aLevel)
+  _propertiesToRows: function PTV__propertiesToRows(aObject, aLevel)
   {
-    aObject.forEach(function(aElement) {
-      aElement.level = aLevel;
-      aElement.isOpened = false;
-      aElement.children = null;
-    });
+    aObject.forEach(function(aItem) {
+      aItem._level = aLevel;
+      aItem._open = false;
+      aItem._children = null;
+
+      if (this._trackObjectActor) {
+        ["value", "get", "set"].forEach(function(aProp) {
+          let val = aItem[aProp];
+          if (val && val.actor) {
+            this._trackObjectActor(val.actor);
+            this._objectActors.push(val.actor);
+          }
+        }, this);
+      }
+    }.bind(this));
   },
 
   /**
    * Inspect a local object.
    *
    * @private
    * @param object aObject
    *        The object you want to inspect.
+   * @return array
+   *         The array of properties, each being described in a way that is
+   *         usable by the tree view.
    */
   _inspectObject: function PTV__inspectObject(aObject)
   {
-    this._objectCache = {};
-    this._remoteObjectProvider = this._localObjectProvider.bind(this);
-    let children = WebConsoleUtils.namesAndValuesOf(aObject, this._objectCache);
-    this._updateRemoteObject(children, 0);
+    this._objectPropertiesProvider = this._localPropertiesProvider.bind(this);
+    let children =
+      WebConsoleUtils.inspectObject(aObject, this._localObjectGrip.bind(this));
+    this._propertiesToRows(children, 0);
     return children;
   },
 
   /**
-   * An object provider for when the user inspects local objects (not remote
+   * Make a local fake object grip for the given object.
+   *
+   * @private
+   * @param object aObject
+   *        The object to make a grip for.
+   * @return object
+   *         The grip that represents the given object.
+   */
+  _localObjectGrip: function PTV__localObjectGrip(aObject)
+  {
+    if (this._localObjectActors.has(aObject)) {
+      return this._localObjectActors.get(aObject).grip;
+    }
+
+    let grip = WebConsoleUtils.getObjectGrip(aObject);
+    grip.actor = "obj" + this._n;
+
+    this._localObjectActors.set(aObject, grip);
+    this._localActorToObject[grip.actor] = aObject;
+
+    return grip;
+  },
+
+  /**
+   * A properties provider for when the user inspects local objects (not remote
    * ones).
    *
    * @private
-   * @param string aFromCacheId
-   *        The cache ID from where to retrieve the desired object.
-   * @param string aObjectId
-   *        The ID of the object you want.
-   * @param string aDestCacheId
-   *        The ID of the cache where to store any objects referenced by the
-   *        desired object.
+   * @param string aActor
+   *        The ID of the object actor you want.
    * @param function aCallback
-   *        The function you want to receive the object.
+   *        The function you want to receive the list of properties.
    */
-  _localObjectProvider:
-  function PTV__localObjectProvider(aFromCacheId, aObjectId, aDestCacheId,
-                                    aCallback)
+  _localPropertiesProvider:
+  function PTV__localPropertiesProvider(aActor, aCallback)
   {
-    let object = WebConsoleUtils.namesAndValuesOf(this._objectCache[aObjectId],
-                                                  this._objectCache);
-    aCallback({cacheId: aFromCacheId,
-               objectId: aObjectId,
-               object: object,
-               childrenCacheId: aDestCacheId || aFromCacheId,
-    });
+    let object = this._localActorToObject[aActor];
+    let properties =
+      WebConsoleUtils.inspectObject(object, this._localObjectGrip.bind(this));
+    aCallback(properties);
   },
 
   /** nsITreeView interface implementation **/
 
   selection: null,
 
   get rowCount()                     { return this._rows.length; },
   setTree: function(treeBox)         { this._treeBox = treeBox;  },
-  getCellText: function(idx, column) {
+  getCellText: function PTV_getCellText(idx, column)
+  {
     let row = this._rows[idx];
-    return row.name + ": " + row.value;
+    return row.name + ": " + WebConsoleUtils.getPropertyPanelValue(row);
   },
   getLevel: function(idx) {
-    return this._rows[idx].level;
+    return this._rows[idx]._level;
   },
   isContainer: function(idx) {
-    return !!this._rows[idx].inspectable;
+    return typeof this._rows[idx].value == "object" && this._rows[idx].value &&
+           this._rows[idx].value.inspectable;
   },
   isContainerOpen: function(idx) {
-    return this._rows[idx].isOpened;
+    return this._rows[idx]._open;
   },
   isContainerEmpty: function(idx)    { return false; },
   isSeparator: function(idx)         { return false; },
   isSorted: function()               { return false; },
   isEditable: function(idx, column)  { return false; },
   isSelectable: function(row, col)   { return true; },
 
   getParentIndex: function(idx)
@@ -216,71 +269,67 @@ PropertyTreeView.prototype = {
         return t;
       }
     }
     return -1;
   },
 
   hasNextSibling: function(idx, after)
   {
-    var thisLevel = this.getLevel(idx);
-    return this._rows.slice(after + 1).some(function (r) r.level == thisLevel);
+    let thisLevel = this.getLevel(idx);
+    return this._rows.slice(after + 1).some(function (r) r._level == thisLevel);
   },
 
   toggleOpenState: function(idx)
   {
     let item = this._rows[idx];
-    if (!item.inspectable) {
+    if (!this.isContainer(idx)) {
       return;
     }
 
-    if (item.isOpened) {
+    if (item._open) {
       this._treeBox.beginUpdateBatch();
-      item.isOpened = false;
+      item._open = false;
 
-      var thisLevel = item.level;
+      var thisLevel = item._level;
       var t = idx + 1, deleteCount = 0;
       while (t < this._rows.length && this.getLevel(t++) > thisLevel) {
         deleteCount++;
       }
 
       if (deleteCount) {
         this._rows.splice(idx + 1, deleteCount);
         this._treeBox.rowCountChanged(idx + 1, -deleteCount);
       }
       this._treeBox.invalidateRow(idx);
       this._treeBox.endUpdateBatch();
     }
     else {
       let levelUpdate = true;
-      let callback = function _onRemoteResponse(aResponse) {
+      let callback = function _onRemoteResponse(aProperties) {
         this._treeBox.beginUpdateBatch();
-        item.isOpened = true;
-
         if (levelUpdate) {
-          this._updateRemoteObject(aResponse.object, item.level + 1);
-          item.children = aResponse.object;
+          this._propertiesToRows(aProperties, item._level + 1);
+          item._children = aProperties;
         }
 
-        this._rows.splice.apply(this._rows, [idx + 1, 0].concat(item.children));
+        this._rows.splice.apply(this._rows, [idx + 1, 0].concat(item._children));
 
-        this._treeBox.rowCountChanged(idx + 1, item.children.length);
+        this._treeBox.rowCountChanged(idx + 1, item._children.length);
         this._treeBox.invalidateRow(idx);
         this._treeBox.endUpdateBatch();
+        item._open = true;
       }.bind(this);
 
-      if (!item.children) {
-        let fromCacheId = item.level > 0 ? this._panelCacheId :
-                                           this._rootCacheId;
-        this._remoteObjectProvider(fromCacheId, item.objectId,
-                                   this._panelCacheId, callback);
+      if (!item._children) {
+        this._objectPropertiesProvider(item.value.actor, callback);
       }
       else {
         levelUpdate = false;
-        callback({object: item.children});
+        callback(item._children);
       }
     }
   },
 
   getImageSrc: function(idx, column) { },
   getProgressMode : function(idx,column) { },
   getCellValue: function(idx, column) { },
   cycleHeader: function(col, elem) { },
@@ -293,28 +342,35 @@ PropertyTreeView.prototype = {
   getCellProperties: function(idx, column, prop) { },
   getColumnProperties: function(column, element, prop) { },
 
   setCellValue: function(row, col, value)               { },
   setCellText: function(row, col, value)                { },
   drop: function(index, orientation, dataTransfer)      { },
   canDrop: function(index, orientation, dataTransfer)   { return false; },
 
-  _cleanup: function PTV__cleanup()
+  /**
+   * Cleanup the property tree view.
+   */
+  cleanup: function PTV_cleanup()
   {
-    if (this._rows.length) {
-      // Reset the existing _rows children to the initial state.
-      this._updateRemoteObject(this._rows, 0);
-      this._rows = [];
+    if (this._releaseObject) {
+      this._objectActors.forEach(this._releaseObject);
+      delete this._objectPropertiesProvider;
+      delete this._releaseObject;
+      delete this._trackObjectActor;
+    }
+    if (this._localObjectActors) {
+      delete this._localObjectActors;
+      delete this._localActorToObject;
+      delete this._objectPropertiesProvider;
     }
 
-    delete this._objectCache;
-    delete this._rootCacheId;
-    delete this._panelCacheId;
-    delete this._remoteObjectProvider;
+    this._rows = [];
+    this._objectActors = [];
   },
 };
 
 ///////////////////////////////////////////////////////////////////////////
 //// Helper for creating the panel.
 
 /**
  * Creates a DOMNode and sets all the attributes of aAttributes on the created
diff --git a/browser/devtools/webconsole/WebConsoleUtils.jsm b/browser/devtools/webconsole/WebConsoleUtils.jsm
--- a/browser/devtools/webconsole/WebConsoleUtils.jsm
+++ b/browser/devtools/webconsole/WebConsoleUtils.jsm
@@ -14,16 +14,27 @@ Cu.import("resource://gre/modules/XPCOMU
 
 XPCOMUtils.defineLazyModuleGetter(this, "Services",
                                   "resource://gre/modules/Services.jsm");
 
 var EXPORTED_SYMBOLS = ["WebConsoleUtils", "JSPropertyProvider"];
 
 const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
 
+// Match the function name from the result of toString() or toSource().
+//
+// Examples:
+// (function foobar(a, b) { ...
+// function foobar2(a) { ...
+// function() { ...
+const REGEX_MATCH_FUNCTION_NAME = /^\(?function\s+([^(\s]+)\s*\(/;
+
+// Match the function arguments from the result of toString() or toSource().
+const REGEX_MATCH_FUNCTION_ARGS = /^\(?function\s*[^\s(]*\s*\((.+?)\)/;
+
 const TYPES = { OBJECT: 0,
                 FUNCTION: 1,
                 ARRAY: 2,
                 OTHER: 3,
                 ITERATOR: 4,
                 GETTER: 5,
                 GENERATOR: 6,
                 STRING: 7
@@ -209,17 +220,22 @@ var WebConsoleUtils = {
       case "string":
         output = this.formatResultString(aResult);
         break;
       case "boolean":
       case "date":
       case "error":
       case "number":
       case "regexp":
-        output = aResult.toString();
+        try {
+          output = aResult + "";
+        }
+        catch (ex) {
+          output = ex;
+        }
         break;
       case "null":
       case "undefined":
         output = type;
         break;
       default:
         try {
           if (aResult.toSource) {
@@ -305,19 +321,22 @@ var WebConsoleUtils = {
    *        The evaluation result object you want to check.
    * @return string
    *         Constructor name or type: string, number, boolean, regexp, date,
    *         function, object, null, undefined...
    */
   getResultType: function WCU_getResultType(aResult)
   {
     let type = aResult === null ? "null" : typeof aResult;
-    if (type == "object" && aResult.constructor && aResult.constructor.name) {
-      type = aResult.constructor.name;
+    try {
+      if (type == "object" && aResult.constructor && aResult.constructor.name) {
+        type = aResult.constructor.name;
+      }
     }
+    catch (ex) { }
 
     return type.toLowerCase();
   },
 
   /**
    * Figures out the type of aObject and the string to display as the object
    * value.
    *
@@ -438,37 +457,52 @@ var WebConsoleUtils = {
    * @return boolean
    *         True if the given property is a getter, false otherwise.
    */
   isNonNativeGetter: function WCU_isNonNativeGetter(aObject, aProp)
   {
     if (typeof aObject != "object") {
       return false;
     }
-    let desc;
+    let desc = this.getPropertyDescriptor(aObject, aProp);
+    return desc && desc.get && !this.isNativeFunction(desc.get);
+  },
+
+  /**
+   * Get the property descriptor for the given object.
+   *
+   * @param object aObject
+   *        The object that contains the property.
+   * @param string aProp
+   *        The property you want to get the descriptor for.
+   * @return object
+   *         Property descriptor.
+   */
+  getPropertyDescriptor: function WCU_getPropertyDescriptor(aObject, aProp)
+  {
+    let desc = null;
     while (aObject) {
       try {
         if (desc = Object.getOwnPropertyDescriptor(aObject, aProp)) {
           break;
         }
       }
-      catch (ex) {
+      catch (ex if (ex.name == "NS_ERROR_XPC_BAD_CONVERT_JS" ||
+                    ex.name == "NS_ERROR_XPC_BAD_OP_ON_WN_PROTO" ||
+                    ex.name == "TypeError")) {
         // Native getters throw here. See bug 520882.
-        if (ex.name == "NS_ERROR_XPC_BAD_CONVERT_JS" ||
-            ex.name == "NS_ERROR_XPC_BAD_OP_ON_WN_PROTO") {
-          return false;
-        }
-        throw ex;
       }
-      aObject = Object.getPrototypeOf(aObject);
+      try {
+        aObject = Object.getPrototypeOf(aObject);
+      }
+      catch (ex if (ex.name == "TypeError")) {
+        return desc;
+      }
     }
-    if (desc && desc.get && !this.isNativeFunction(desc.get)) {
-      return true;
-    }
-    return false;
+    return desc;
   },
 
   /**
    * Get an array that describes the properties of the given object.
    *
    * @param object aObject
    *        The object to get the properties from.
    * @param object aObjectCache
@@ -545,48 +579,220 @@ var WebConsoleUtils = {
       if (pair.inspectable && aObjectCache) {
         pair.objectId = ++gObjectId;
         aObjectCache[pair.objectId] = value;
       }
 
       pairs.push(pair);
     }
 
-    pairs.sort(function(a, b)
-    {
-      // Convert the pair.name to a number for later sorting.
-      let aNumber = parseFloat(a.name);
-      let bNumber = parseFloat(b.name);
-
-      // Sort numbers.
-      if (!isNaN(aNumber) && isNaN(bNumber)) {
-        return -1;
-      }
-      else if (isNaN(aNumber) && !isNaN(bNumber)) {
-        return 1;
-      }
-      else if (!isNaN(aNumber) && !isNaN(bNumber)) {
-        return aNumber - bNumber;
-      }
-      // Sort string.
-      else if (a.name < b.name) {
-        return -1;
-      }
-      else if (a.name > b.name) {
-        return 1;
-      }
-      else {
-        return 0;
-      }
-    });
+    pairs.sort(this.propertiesSort);
 
     return pairs;
   },
 
   /**
+   * Sort function for object properties.
+   *
+   * @param object a
+   *        Property descriptor.
+   * @param object b
+   *        Property descriptor.
+   * @return integer
+   *         -1 if a.name < b.name,
+   *         1 if a.name > b.name,
+   *         0 otherwise.
+   */
+  propertiesSort: function WCU_propertiesSort(a, b)
+  {
+    // Convert the pair.name to a number for later sorting.
+    let aNumber = parseFloat(a.name);
+    let bNumber = parseFloat(b.name);
+
+    // Sort numbers.
+    if (!isNaN(aNumber) && isNaN(bNumber)) {
+      return -1;
+    }
+    else if (isNaN(aNumber) && !isNaN(bNumber)) {
+      return 1;
+    }
+    else if (!isNaN(aNumber) && !isNaN(bNumber)) {
+      return aNumber - bNumber;
+    }
+    // Sort string.
+    else if (a.name < b.name) {
+      return -1;
+    }
+    else if (a.name > b.name) {
+      return 1;
+    }
+    else {
+      return 0;
+    }
+  },
+
+  /**
+   * Inspect the properties of the given object. For each property a descriptor
+   * object is created. The descriptor gives you information about the property
+   * name, value, type, getter and setter. When the property value references
+   * another object you get a wrapper that holds information about that object.
+   *
+   * @see this.inspectObjectProperty
+   * @param object aObject
+   *        The object you want to inspect.
+   * @param function aObjectWrapper
+   *        The function that creates wrappers for property values which
+   *        reference other objects. This function must take one argument, the
+   *        object to wrap, and it must return an object grip that gives
+   *        information about the referenced object.
+   * @return array
+   *         An array of property descriptors.
+   */
+  inspectObject: function WCU_inspectObject(aObject, aObjectWrapper)
+  {
+    let properties = [];
+    let isDOMDocument = aObject instanceof Ci.nsIDOMDocument;
+    let deprecated = ["width", "height", "inputEncoding"];
+
+    for (let name in aObject) {
+      // See bug 632275: skip deprecated properties.
+      if (isDOMDocument && deprecated.indexOf(name) > -1) {
+        continue;
+      }
+
+      properties.push(this.inspectObjectProperty(aObject, name, aObjectWrapper));
+    }
+
+    return properties.sort(this.propertiesSort);
+  },
+
+  /**
+   * A helper method that creates a property descriptor for the provided object,
+   * properly formatted for sending in a protocol response.
+   *
+   * The property value can reference other objects. Since actual objects cannot
+   * be sent to the client, we need to send simple object grips - descriptors
+   * for those objects. This is why you need to give an object wrapper function
+   * that creates object grips.
+   *
+   * @param string aProperty
+   *        Property name for which we have the descriptor.
+   * @param object aObject
+   *        The object that the descriptor is generated for.
+   * @param function aObjectWrapper
+   *        This function is given the property value. Whatever the function
+   *        returns is used as the representation of the property value.
+   * @return object
+   *         The property descriptor formatted for sending to the client.
+   */
+  inspectObjectProperty:
+  function WCU_inspectObjectProperty(aObject, aProperty, aObjectWrapper)
+  {
+    let descriptor = this.getPropertyDescriptor(aObject, aProperty) || {};
+
+    let result = { name: aProperty };
+    result.configurable = descriptor.configurable;
+    result.enumerable = descriptor.enumerable;
+    result.writable = descriptor.writable;
+    if (descriptor.value !== undefined) {
+      result.value = this.createValueGrip(descriptor.value, aObjectWrapper);
+    }
+    else {
+      if (this.isNativeFunction(descriptor.get)) {
+        result.value = this.createValueGrip(aObject[aProperty], aObjectWrapper);
+      }
+      else if (descriptor.get) {
+        result.get = this.createValueGrip(descriptor.get, aObjectWrapper);
+        result.set = this.createValueGrip(descriptor.set, aObjectWrapper);
+      }
+    }
+
+    // There are cases with properties that have no value and no getter. For
+    // example window.screen.width.
+    if (result.value === undefined && result.get === undefined) {
+      result.value = this.createValueGrip(aObject[aProperty], aObjectWrapper);
+    }
+
+    return result;
+  },
+
+  /**
+   * Make an object grip for the given object. An object grip of the simplest
+   * form with minimal information about the given object is returned. This
+   * method is usually combined with other functions that add further state
+   * information and object ID such that, later, the client is able to retrieve
+   * more information about the object being represented by this grip.
+   *
+   * @param object aObject
+   *        The object you want to create a grip for.
+   * @return object
+   *         The object grip.
+   */
+  getObjectGrip: function WCU_getObjectGrip(aObject)
+  {
+    let className = null;
+    let type = typeof aObject;
+
+    let result = {
+      "type": type,
+      "className": this.getObjectClassName(aObject),
+      "displayString": this.formatResult(aObject),
+      "inspectable": this.isObjectInspectable(aObject),
+    };
+
+    if (type == "function") {
+      result.functionName = this.getFunctionName(aObject);
+      result.functionArguments = this.getFunctionArguments(aObject);
+    }
+
+    return result;
+  },
+
+  /**
+   * Create a grip for the given value. If the value is an object,
+   * an object wrapper will be created.
+   *
+   * @param mixed aValue
+   *        The value you want to create a grip for, before sending it to the
+   *        client.
+   * @param function aObjectWrapper
+   *        If the value is an object then the aObjectWrapper function is
+   *        invoked to give us an object grip. See this.getObjectGrip().
+   * @return mixed
+   *         The value grip.
+   */
+  createValueGrip: function WCU_createValueGrip(aValue, aObjectWrapper)
+  {
+    let type = typeof(aValue);
+    switch (type) {
+      case "boolean":
+      case "string":
+      case "number":
+        return aValue;
+      case "object":
+      case "function":
+        if (aValue) {
+          return aObjectWrapper(aValue);
+        }
+      default:
+        if (aValue === null) {
+          return { type: "null" };
+        }
+
+        if (aValue === undefined) {
+          return { type: "undefined" };
+        }
+
+        Cu.reportError("Failed to provide a grip for value of " + type + ": " +
+                       aValue);
+        return null;
+    }
+  },
+
+  /**
    * Check if the given object is an iterator or a generator.
    *
    * @param object aObject
    *        The object you want to check.
    * @return boolean
    *         True if the given object is an iterator or a generator, otherwise
    *         false is returned.
    */
@@ -634,16 +840,169 @@ var WebConsoleUtils = {
       let requestURI = Services.io.newURI(aRequest, null, null);
       let contentURI = Services.io.newURI(aLocation, null, null);
       return (contentURI.scheme == "https" && requestURI.scheme != "https");
     }
     catch (ex) {
       return false;
     }
   },
+
+  /**
+   * Make a string representation for an object actor grip.
+   *
+   * @param object aGrip
+   *        The object grip received from the server.
+   * @param boolean [aFormatString=false]
+   *        Optional boolean that tells if you want strings to be unevaled or
+   *        not.
+   * @return string
+   *         The object grip converted to a string.
+   */
+  objectActorGripToString: function WCU_objectActorGripToString(aGrip, aFormatString)
+  {
+    // Primitives like strings and numbers are not sent as objects.
+    // But null and undefined are sent as objects with the type property
+    // telling which type of value we have.
+    let type = typeof(aGrip);
+    if (aGrip && type == "object") {
+      return aGrip.displayString || aGrip.className || aGrip.type || type;
+    }
+    return type == "string" && aFormatString ?
+           this.formatResultString(aGrip) : aGrip + "";
+  },
+
+  /**
+   * Helper function to deduce the name of the provided function.
+   *
+   * @param funtion aFunction
+   *        The function whose name will be returned.
+   * @return string
+   *         Function name.
+   */
+  getFunctionName: function WCF_getFunctionName(aFunction)
+  {
+    let name = null;
+    if (aFunction.name) {
+      name = aFunction.name;
+    }
+    else {
+      let desc;
+      try {
+        desc = aFunction.getOwnPropertyDescriptor("displayName");
+      }
+      catch (ex) { }
+      if (desc && typeof desc.value == "string") {
+        name = desc.value;
+      }
+    }
+    if (!name) {
+      try {
+        let str = (aFunction.toString() || aFunction.toSource()) + "";
+        name = (str.match(REGEX_MATCH_FUNCTION_NAME) || [])[1];
+      }
+      catch (ex) { }
+    }
+    return name;
+  },
+
+  /**
+   * Helper function to deduce the arguments of the provided function.
+   *
+   * @param funtion aFunction
+   *        The function whose name will be returned.
+   * @return array
+   *         Function arguments.
+   */
+  getFunctionArguments: function WCF_getFunctionArguments(aFunction)
+  {
+    let args = [];
+    try {
+      let str = (aFunction.toString() || aFunction.toSource()) + "";
+      let argsString = (str.match(REGEX_MATCH_FUNCTION_ARGS) || [])[1];
+      if (argsString) {
+        args = argsString.split(/\s*,\s*/);
+      }
+    }
+    catch (ex) { }
+    return args;
+  },
+
+  /**
+   * Get the object class name. For example, the |window| object has the Window
+   * class name (based on [object Window]).
+   *
+   * @param object aObject
+   *        The object you want to get the class name for.
+   * @return string
+   *         The object class name.
+   */
+  getObjectClassName: function WCF_getObjectClassName(aObject)
+  {
+    if (aObject === null) {
+      return "null";
+    }
+    if (aObject === undefined) {
+      return "undefined";
+    }
+
+    let type = typeof aObject;
+    if (type != "object") {
+      return type;
+    }
+
+    let className;
+
+    try {
+      className = ((aObject + "").match(/^\[object (\S+)\]$/) || [])[1];
+      if (!className) {
+        className = ((aObject.constructor + "").match(/^\[object (\S+)\]$/) || [])[1];
+      }
+      if (!className && typeof aObject.constructor == "function") {
+        className = this.getFunctionName(aObject.constructor);
+      }
+    }
+    catch (ex) { }
+
+    return className;
+  },
+
+  /**
+   * Determine the string to display as a property value in the property panel.
+   *
+   * @param object aActor
+   *        Object actor grip.
+   * @return string
+   *         Property value as suited for the property panel.
+   */
+  getPropertyPanelValue: function WCU_getPropertyPanelValue(aActor)
+  {
+    if (aActor.get) {
+      return "Getter";
+    }
+
+    let val = aActor.value;
+    if (typeof val == "string") {
+      return this.formatResultString(val);
+    }
+
+    if (typeof val != "object" || !val) {
+      return val;
+    }
+
+    if (val.type == "function" && val.functionName) {
+      return "function " + val.functionName + "(" +
+             val.functionArguments.join(", ") + ")";
+    }
+    if (val.type == "object" && val.className) {
+      return val.className;
+    }
+
+    return val.displayString || val.type;
+  },
 };
 
 //////////////////////////////////////////////////////////////////////////
 // Localization
 //////////////////////////////////////////////////////////////////////////
 
 WebConsoleUtils.l10n = {
   /**
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js b/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
@@ -112,13 +112,13 @@ function testPropertyPanel(aPanel) {
      "gen1 is correctly displayed in the Property Panel");
 
   ok(find("gen2: Generator", false),
      "gen2 is correctly displayed in the Property Panel");
 
   ok(find("iter1: Iterator", false),
      "iter1 is correctly displayed in the Property Panel");
 
-  ok(find("iter2: Iterator", false),
+  ok(find("iter2: Iterator", false) || find("iter2: Object", false),
      "iter2 is correctly displayed in the Property Panel");
 
   executeSoon(finishTest);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js b/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js
@@ -36,17 +36,17 @@ function testConsoleDir(outputNode) {
   let foundQSA = false;
   let foundLocation = false;
   let foundWrite = false;
   for (let i = 0; i < view.rowCount; i++) {
     let text = view.getCellText(i);
     if (text == "querySelectorAll: function querySelectorAll()") {
       foundQSA = true;
     }
-    else if (text  == "location: Object") {
+    else if (text  == "location: Location") {
       foundLocation = true;
     }
     else if (text  == "write: function write()") {
       foundWrite = true;
     }
   }
   ok(foundQSA, "found document.querySelectorAll");
   ok(foundLocation, "found document.location");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_jsterm.js b/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
--- a/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
@@ -171,17 +171,17 @@ function testJSTerm(hud)
   jsterm.execute("pprint('hi')");
   checkResult('0: "h"\n  1: "i"', "pprint('hi')", 1);
   yield;
 
   // check that pprint(function) shows function source, bug 618344
   jsterm.clearOutput();
   jsterm.execute("pprint(print)");
   checkResult(function(nodes) {
-    return nodes[0].textContent.indexOf("aJSTerm.") > -1;
+    return nodes[0].textContent.indexOf("aOwner._helper") > -1;
   }, "pprint(function) shows source", 1);
   yield;
 
   // check that an evaluated null produces "null", bug 650780
   jsterm.clearOutput();
   jsterm.execute("null");
   checkResult("null", "null is null", 1);
   yield;
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -181,16 +181,17 @@ function WebConsoleFrame(aWebConsoleOwne
 {
   this.owner = aWebConsoleOwner;
   this.hudId = this.owner.hudId;
 
   this._cssNodes = {};
   this._outputQueue = [];
   this._pruneCategoriesQueue = {};
   this._networkRequests = {};
+  this._objectActors = {};
 
   this._toggleFilter = this._toggleFilter.bind(this);
   this._onPositionConsoleCommand = this._onPositionConsoleCommand.bind(this);
 
   this._initDefaultFilterPrefs();
   this._commandController = new CommandController(this);
   this.positionConsole(aPosition, window);
 
@@ -306,16 +307,29 @@ WebConsoleFrame.prototype = {
   outputNode: null,
 
   /**
    * The input element that allows the user to filter messages by string.
    * @type nsIDOMElement
    */
   filterBox: null,
 
+  /**
+   * Track object actor IDs to use-counts.
+   * @private
+   * @type object
+   */
+  _objectActors: null,
+
+  /**
+   * Getter for the debugger WebConsoleClient.
+   * @type object
+   */
+  get webConsoleClient() this.proxy ? this.proxy.webConsoleClient : null,
+
   _saveRequestAndResponseBodies: false,
 
   /**
    * Tells whether to save the bodies of network requests and responses.
    * Disabled by default to save memory.
    * @type boolean
    */
   get saveRequestAndResponseBodies() this._saveRequestAndResponseBodies,
@@ -637,50 +651,29 @@ WebConsoleFrame.prototype = {
    */
   receiveMessage: function WCF_receiveMessage(aMessage)
   {
     if (!aMessage.json || aMessage.json.hudId != this.hudId) {
       return;
     }
 
     switch (aMessage.name) {
-      case "JSTerm:EvalResult":
-      case "JSTerm:EvalObject":
-      case "JSTerm:AutocompleteProperties":
-        this.owner._receiveMessageWithCallback(aMessage.json);
-        break;
-      case "JSTerm:ClearOutput":
-        this.jsterm.clearOutput();
-        break;
-      case "JSTerm:InspectObject":
-        this.jsterm.handleInspectObject(aMessage.json);
-        break;
-      case "WebConsole:ConsoleAPI":
-        this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
-                           [aMessage.json]);
-        break;
       case "WebConsole:Initialized":
         this._onMessageManagerInitComplete();
         break;
-      case "WebConsole:CachedMessages":
-        this._displayCachedConsoleMessages(aMessage.json.messages);
-        break;
       case "WebConsole:NetworkActivity":
         this.handleNetworkActivity(aMessage.json);
         break;
       case "WebConsole:FileActivity":
         this.outputMessage(CATEGORY_NETWORK, this.logFileActivity,
                            [aMessage.json.uri]);
         break;
       case "WebConsole:LocationChange":
         this.owner.onLocationChange(aMessage.json);
         break;
-      case "JSTerm:NonNativeConsoleAPI":
-        this.outputMessage(CATEGORY_JS, this.logWarningAboutReplacedAPI);
-        break;
     }
   },
 
   /**
    * Callback method used to track the Web Console initialization via message
    * manager.
    *
    * @private
@@ -1004,88 +997,87 @@ WebConsoleFrame.prototype = {
 
     return false;
   },
 
   /**
    * Display cached messages that may have been collected before the UI is
    * displayed.
    *
-   * @private
    * @param array aRemoteMessages
    *        Array of cached messages coming from the remote Web Console
    *        content instance.
    */
-  _displayCachedConsoleMessages:
-  function WCF__displayCachedConsoleMessages(aRemoteMessages)
+  displayCachedMessages: function WCF_displayCachedMessages(aRemoteMessages)
   {
     if (!aRemoteMessages.length) {
       return;
     }
 
     aRemoteMessages.forEach(function(aMessage) {
       switch (aMessage._type) {
-        case "PageError": {
+        case this.webConsoleClient.CACHED_MESSAGES.PageError: {
           let category = Utils.categoryForScriptError(aMessage);
           this.outputMessage(category, this.reportPageError,
                              [category, aMessage]);
           break;
         }
-        case "ConsoleAPI":
+        case this.webConsoleClient.CACHED_MESSAGES.ConsoleAPI:
           this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
                              [aMessage]);
           break;
       }
     }, this);
   },
 
   /**
-   * Logs a message to the Web Console that originates from the remote Web
-   * Console instance.
+   * Logs a message to the Web Console that originates from the Web Console
+   * server.
    *
    * @param object aMessage
-   *        The message received from the remote Web Console instance.
-   *        console service. This object needs to hold:
-   *          - hudId - the Web Console ID.
-   *          - apiMessage - a representation of the object sent by the console
-   *          storage service. This object holds the console message level, the
-   *          arguments that were passed to the console method and other
-   *          information.
-   *          - argumentsToString - the array of arguments passed to the console
-   *          method, each converted to a string.
+   *        The message received from the server.
    * @return nsIDOMElement|undefined
    *         The message element to display in the Web Console output.
    */
   logConsoleAPIMessage: function WCF_logConsoleAPIMessage(aMessage)
   {
     let body = null;
     let clipboardText = null;
     let sourceURL = null;
     let sourceLine = 0;
-    let level = aMessage.apiMessage.level;
-    let args = aMessage.apiMessage.arguments;
-    let argsToString = aMessage.argumentsToString;
+    let level = aMessage.level;
+    let args = aMessage.arguments;
+    let objectActors = [];
 
     switch (level) {
       case "log":
       case "info":
       case "warn":
       case "error":
       case "debug":
-        body = {
-          cacheId: aMessage.objectsCacheId,
-          remoteObjects: args,
-          argsToString: argsToString,
-        };
-        clipboardText = argsToString.join(" ");
-        sourceURL = aMessage.apiMessage.filename;
-        sourceLine = aMessage.apiMessage.lineNumber;
+      case "dir": {
+        body = { arguments: args };
+        let clipboardArray = [];
+        args.forEach(function(aValue) {
+          clipboardArray.push(WebConsoleUtils.objectActorGripToString(aValue));
+          if (aValue && typeof aValue == "object" && aValue.actor) {
+            objectActors.push(aValue.actor);
+            this._trackObjectActor(aValue.actor);
+          }
+        }, this);
+        clipboardText = clipboardArray.join(" ");
+        sourceURL = aMessage.filename;
+        sourceLine = aMessage.lineNumber;
+        if (level == "dir") {
+          body.objectProperties = aMessage.objectProperties;
+        }
         break;
-
-      case "trace":
+      }
+
+      case "trace": {
         let filename = WebConsoleUtils.abbreviateSourceURL(args[0].filename);
         let functionName = args[0].functionName ||
                            l10n.getStr("stacktrace.anonymousFunction");
         let lineNumber = args[0].lineNumber;
 
         body = l10n.getFormatStr("stacktrace.outputMessage",
                                  [filename, functionName, lineNumber]);
 
@@ -1097,35 +1089,23 @@ WebConsoleFrame.prototype = {
         args.forEach(function(aFrame) {
           clipboardText += aFrame.filename + " :: " +
                            aFrame.functionName + " :: " +
                            aFrame.lineNumber + "\n";
         });
 
         clipboardText = clipboardText.trimRight();
         break;
-
-      case "dir":
-        body = {
-          cacheId: aMessage.objectsCacheId,
-          resultString: argsToString[0],
-          remoteObject: args[0],
-          remoteObjectProvider:
-            this.jsterm.remoteObjectProvider.bind(this.jsterm),
-        };
-        clipboardText = body.resultString;
-        sourceURL = aMessage.apiMessage.filename;
-        sourceLine = aMessage.apiMessage.lineNumber;
-        break;
+      }
 
       case "group":
       case "groupCollapsed":
         clipboardText = body = args;
-        sourceURL = aMessage.apiMessage.filename;
-        sourceLine = aMessage.apiMessage.lineNumber;
+        sourceURL = aMessage.filename;
+        sourceLine = aMessage.lineNumber;
         this.groupDepth++;
         break;
 
       case "groupEnd":
         if (this.groupDepth > 0) {
           this.groupDepth--;
         }
         return;
@@ -1135,39 +1115,43 @@ WebConsoleFrame.prototype = {
           return;
         }
         if (args.error) {
           Cu.reportError(l10n.getStr(args.error));
           return;
         }
         body = l10n.getFormatStr("timerStarted", [args.name]);
         clipboardText = body;
-        sourceURL = aMessage.apiMessage.filename;
-        sourceLine = aMessage.apiMessage.lineNumber;
+        sourceURL = aMessage.filename;
+        sourceLine = aMessage.lineNumber;
         break;
 
       case "timeEnd":
         if (!args) {
           return;
         }
         body = l10n.getFormatStr("timeEnd", [args.name, args.duration]);
         clipboardText = body;
-        sourceURL = aMessage.apiMessage.filename;
-        sourceLine = aMessage.apiMessage.lineNumber;
+        sourceURL = aMessage.filename;
+        sourceLine = aMessage.lineNumber;
         break;
 
       default:
         Cu.reportError("Unknown Console API log level: " + level);
         return;
     }
 
     let node = this.createMessageNode(CATEGORY_WEBDEV, LEVELS[level], body,
                                       sourceURL, sourceLine, clipboardText,
                                       level, aMessage.timeStamp);
 
+    if (objectActors.length) {
+      node._objectActors = objectActors;
+    }
+
     // Make the node bring up the property panel, to allow the user to inspect
     // the stack trace.
     if (level == "trace") {
       node._stacktrace = args;
 
       this.makeOutputMessageLink(node, function _traceNodeClickCallback() {
         if (node._panelOpen) {
           return;
@@ -1179,80 +1163,88 @@ WebConsoleFrame.prototype = {
         };
 
         let propPanel = this.jsterm.openPropertyPanel(options);
         propPanel.panel.setAttribute("hudId", this.hudId);
       }.bind(this));
     }
 
     if (level == "dir") {
-      // Make sure the cached evaluated object will be purged when the node is
-      // removed.
-      node._evalCacheId = aMessage.objectsCacheId;
-
       // Initialize the inspector message node, by setting the PropertyTreeView
       // object on the tree view. This has to be done *after* the node is
       // shown, because the tree binding must be attached first.
       node._onOutput = function _onMessageOutput() {
         node.querySelector("tree").view = node.propertyTreeView;
       };
     }
 
     return node;
   },
 
   /**
+   * Handle ConsoleAPICall objects received from the server. This method outputs
+   * the window.console API call.
+   *
+   * @param object aMessage
+   *        The console API message received from the server.
+   */
+  handleConsoleAPICall: function WCF_handleConsoleAPICall(aMessage)
+  {
+    this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage, [aMessage]);
+  },
+
+  /**
    * The click event handler for objects shown inline coming from the
    * window.console API.
    *
    * @private
    * @param nsIDOMNode aMessage
    *        The message element this handler corresponds to.
    * @param nsIDOMNode aAnchor
    *        The object inspector anchor element. This is the clickable element
    *        in the console.log message we display.
-   * @param array aRemoteObject
-   *        The remote object representation.
+   * @param object aObjectActor
+   *        The object actor grip.
    */
   _consoleLogClick:
-  function WCF__consoleLogClick(aMessage, aAnchor, aRemoteObject)
+  function WCF__consoleLogClick(aMessage, aAnchor, aObjectActor)
   {
     if (aAnchor._panelOpen) {
       return;
     }
 
     let options = {
       title: aAnchor.textContent,
       anchor: aAnchor,
 
       // Data to inspect.
       data: {
-        // This is where the resultObject children are cached.
-        rootCacheId: aMessage._evalCacheId,
-        remoteObject: aRemoteObject,
-        // This is where all objects retrieved by the panel will be cached.
-        panelCacheId: "HUDPanel-" + gSequenceId(),
-        remoteObjectProvider: this.jsterm.remoteObjectProvider.bind(this.jsterm),
+        objectPropertiesProvider: this.objectPropertiesProvider.bind(this),
+        trackObjectActor: this._trackObjectActor.bind(this),
+        releaseObject: this._releaseObject.bind(this),
       },
     };
 
-    let propPanel = this.jsterm.openPropertyPanel(options);
-    propPanel.panel.setAttribute("hudId", this.hudId);
-
-    let onPopupHide = function JST__evalInspectPopupHide() {
+    let propPanel;
+    let onPopupHide = function _onPopupHide() {
       propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
 
-      this.jsterm.clearObjectCache(options.data.panelCacheId);
-
-      if (!aMessage.parentNode && aMessage._evalCacheId) {
-        this.jsterm.clearObjectCache(aMessage._evalCacheId);
+      if (!aMessage.parentNode && aMessage._objectActors) {
+        aMessage._objectActors.forEach(this._releaseObject, this);
+        aMessage._objectActors = null;
       }
     }.bind(this);
 
-    propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+    this.objectPropertiesProvider(aObjectActor.actor,
+      function _onObjectProperties(aProperties) {
+        options.data.objectProperties = aProperties;
+        propPanel = this.jsterm.openPropertyPanel(options);
+        propPanel.panel.setAttribute("hudId", this.hudId);
+        propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+      }.bind(this));
   },
 
   /**
    * Reports an error in the page source, either JavaScript or CSS.
    *
    * @param nsIScriptError aScriptError
    *        The error message to report.
    * @return nsIDOMElement|undefined
@@ -1424,24 +1416,22 @@ WebConsoleFrame.prototype = {
     }.bind(this));
 
     return outputNode;
   },
 
   /**
    * Inform user that the Web Console API has been replaced by a script
    * in a content page.
-   *
-   * @return nsIDOMElement|undefined
-   *         The message element to display in the Web Console output.
    */
   logWarningAboutReplacedAPI: function WCF_logWarningAboutReplacedAPI()
   {
-    return this.createMessageNode(CATEGORY_JS, SEVERITY_WARNING,
-                                  l10n.getStr("ConsoleAPIDisabled"));
+    let node = this.createMessageNode(CATEGORY_JS, SEVERITY_WARNING,
+                                      l10n.getStr("ConsoleAPIDisabled"));
+    this.outputMessage(CATEGORY_JS, node);
   },
 
   /**
    * Handle the "WebConsole:NetworkActivity" message coming from the remote Web
    * Console.
    *
    * @param object aMessage
    *        The HTTP activity object. This object needs to hold two properties:
@@ -1823,37 +1813,59 @@ WebConsoleFrame.prototype = {
    * @private
    * @param array aItem
    *        The item you want to remove from the output queue.
    */
   _pruneItemFromQueue: function WCF__pruneItemFromQueue(aItem)
   {
     let [category, methodOrNode, args] = aItem;
     if (typeof methodOrNode != "function" &&
-        methodOrNode._evalCacheId && !methodOrNode._panelOpen) {
-      this.jsterm.clearObjectCache(methodOrNode._evalCacheId);
+        methodOrNode._objectActors && !methodOrNode._panelOpen) {
+      methodOrNode._objectActors.forEach(this._releaseObject, this);
     }
 
     if (category == CATEGORY_NETWORK) {
       let connectionId = null;
       if (methodOrNode == this.logNetActivity) {
         connectionId = args[0];
       }
       else if (typeof methodOrNode != "function") {
         connectionId = methodOrNode._connectionId;
       }
       if (connectionId && connectionId in this._networkRequests) {
         delete this._networkRequests[connectionId];
       }
     }
     else if (category == CATEGORY_WEBDEV &&
              methodOrNode == this.logConsoleAPIMessage) {
-      let level = args[0].apiMessage.level;
-      if (level == "dir") {
-        this.jsterm.clearObjectCache(args[0].objectsCacheId);
+      let level = args[0].level;
+      switch (level) {
+        case "log":
+        case "info":
+        case "warn":
+        case "error":
+        case "debug":
+        case "dir": {
+          args[0].arguments.forEach(function(aValue) {
+            if (aValue && typeof aValue == "object" && aValue.actor) {
+              // TODO: this avoids releasing objects too early - if we already
+              // use them in other places. However, there's the possibility that
+              // the server has already messages in queue with the same object
+              // actor. In that case, here we release the object actor too
+              // early. More thinking: I could move refcount into the
+              // WebConsoleObjectActor and only require the client to always
+              // release the objects - I only truely release the object once
+              // refcount gets to 0, on the server.Thoughts?
+              let count = this._objectActors[aValue.actor];
+              if (!count) {
+                this._releaseObject(aValue.actor);
+              }
+            }
+          }, this);
+        }
       }
     }
   },
 
   /**
    * Ensures that the number of message nodes of type aCategory don't exceed that
    * category's line limit by removing old messages as needed.
    *
@@ -1887,33 +1899,31 @@ WebConsoleFrame.prototype = {
   pruneConsoleDirNode: function WCF_pruneConsoleDirNode(aMessageNode)
   {
     if (aMessageNode.parentNode) {
       aMessageNode.parentNode.removeChild(aMessageNode);
     }
 
     let tree = aMessageNode.querySelector("tree");
     tree.parentNode.removeChild(tree);
+    aMessageNode.propertyTreeView.data = null;
     aMessageNode.propertyTreeView = null;
-    if (tree.view) {
-      tree.view.data = null;
-    }
     tree.view = null;
   },
 
   /**
    * Remove a given message from the output.
    *
    * @param nsIDOMNode aNode
    *        The message node you want to remove.
    */
   removeOutputMessage: function WCF_removeOutputMessage(aNode)
   {
-    if (aNode._evalCacheId && !aNode._panelOpen) {
-      this.jsterm.clearObjectCache(aNode._evalCacheId);
+    if (aNode._objectActors && !aNode._panelOpen) {
+      aNode._objectActors.forEach(this._releaseObject, this);
     }
 
     if (aNode.classList.contains("webconsole-msg-cssparser")) {
       let desc = aNode.childNodes[2].textContent;
       let location = "";
       if (aNode.childNodes[4]) {
         location = aNode.childNodes[4].getAttribute("title");
       }
@@ -2028,17 +2038,17 @@ WebConsoleFrame.prototype = {
     let node = this.document.createElementNS(XUL_NS, "richlistitem");
 
     if (aBody instanceof Ci.nsIDOMNode) {
       bodyNode.appendChild(aBody);
     }
     else {
       let str = undefined;
       if (aLevel == "dir") {
-        str = aBody.resultString;
+        str = WebConsoleUtils.objectActorGripToString(aBody.arguments[0]);
       }
       else if (["log", "info", "warn", "error", "debug"].indexOf(aLevel) > -1 &&
                typeof aBody == "object") {
         this._makeConsoleLogMessageBody(node, bodyNode, aBody);
       }
       else {
         str = aBody;
       }
@@ -2103,20 +2113,20 @@ WebConsoleFrame.prototype = {
 
       bodyContainer.appendChild(tree);
       node.appendChild(bodyContainer);
       node.classList.add("webconsole-msg-inspector");
       // Create the treeView object.
       let treeView = node.propertyTreeView = new PropertyTreeView();
 
       treeView.data = {
-        rootCacheId: body.cacheId,
-        panelCacheId: body.cacheId,
-        remoteObject: Array.isArray(body.remoteObject) ? body.remoteObject : [],
-        remoteObjectProvider: body.remoteObjectProvider,
+        objectPropertiesProvider: this.objectPropertiesProvider.bind(this),
+        trackObjectActor: this._trackObjectActor.bind(this),
+        releaseObject: this._releaseObject.bind(this),
+        objectProperties: body.objectProperties,
       };
 
       tree.setAttribute("rows", treeView.rowCount);
     }
     else {
       node.appendChild(bodyNode);
     }
     node.appendChild(repeatContainer);
@@ -2135,45 +2145,46 @@ WebConsoleFrame.prototype = {
    * @private
    * @param nsIDOMElement aMessage
    *        The message element that holds the output for the given call.
    * @param nsIDOMElement aContainer
    *        The specific element that will hold each part of the console.log
    *        output.
    * @param object aBody
    *        The object given by this.logConsoleAPIMessage(). This object holds
-   *        the call information that we need to display.
+   *        the call information that we need to display - mainly the arguments
+   *        array of the given API call.
    */
   _makeConsoleLogMessageBody:
   function WCF__makeConsoleLogMessageBody(aMessage, aContainer, aBody)
   {
-    aMessage._evalCacheId = aBody.cacheId;
-
     Object.defineProperty(aMessage, "_panelOpen", {
       get: function() {
         let nodes = aContainer.querySelectorAll(".hud-clickable");
         return Array.prototype.some.call(nodes, function(aNode) {
           return aNode._panelOpen;
         });
       },
       enumerable: true,
       configurable: false
     });
 
-    aBody.remoteObjects.forEach(function(aItem, aIndex) {
+    aBody.arguments.forEach(function(aItem) {
       if (aContainer.firstChild) {
         aContainer.appendChild(this.document.createTextNode(" "));
       }
 
-      let text = aBody.argsToString[aIndex];
-      if (!Array.isArray(aItem)) {
+      let text = WebConsoleUtils.objectActorGripToString(aItem);
+
+      if (aItem && typeof aItem != "object" || !aItem.inspectable) {
         aContainer.appendChild(this.document.createTextNode(text));
         return;
       }
 
+      // For inspectable objects.
       let elem = this.document.createElement("description");
       elem.classList.add("hud-clickable");
       elem.setAttribute("aria-haspopup", "true");
       elem.appendChild(this.document.createTextNode(text));
 
       this._addMessageLinkCallback(elem,
         this._consoleLogClick.bind(this, aMessage, elem, aItem));
 
@@ -2352,21 +2363,82 @@ WebConsoleFrame.prototype = {
         strings.push("[" + timestampString + "] " + item.clipboardText);
       }
     }
 
     clipboardHelper.copyString(strings.join("\n"), this.document);
   },
 
   /**
+   * Object properties provider. This function gives you the properties of the
+   * remote object you want.
+   *
+   * @param string aActor
+   *        The object actor ID from which you want the properties.
+   * @param function aCallback
+   *        Function you want invoked once the properties are received.
+   */
+  objectPropertiesProvider:
+  function WCF_objectPropertiesProvider(aActor, aCallback)
+  {
+    this.webConsoleClient.inspectObjectProperties(aActor,
+      function(aResponse) {
+        if (aResponse.error) {
+          Cu.reportError("Failed to retrieve the object properties from the " +
+                         "server. Error: " + aResponse.error);
+          return;
+        }
+        aCallback(aResponse.properties);
+      });
+  },
+
+  /**
+   * Track an object actor.
+   *
+   * @private
+   * @param string aActor
+   *        The object actor ID you want to track.
+   */
+  _trackObjectActor: function WCF_trackObjectActor(aActor)
+  {
+    if (!(aActor in this._objectActors)) {
+      this._objectActors[aActor] = 0;
+    }
+    this._objectActors[aActor]++;
+  },
+
+  /**
+   * Release an object actor.
+   *
+   * @private
+   * @param string aActor
+   *        The object actor ID you want to release.
+   */
+  _releaseObject: function WCF__releaseObject(aActor)
+  {
+    let count = 0;
+    if (aActor in this._objectActors) {
+      count = --this._objectActors[aActor];
+      if (count <= 0) {
+        delete this._objectActors[aActor];
+      }
+    }
+    if (this.webConsoleClient && count <= 0) {
+      this.webConsoleClient.releaseObject(aActor);
+    }
+  },
+
+  /**
    * Destroy the HUD object. Call this method to avoid memory leaks when the Web
    * Console is closed.
    */
   destroy: function WCF_destroy()
   {
+    Object.keys(this._objectActors).forEach(this._releaseObject, this);
+
     if (this.proxy) {
       this.proxy.disconnect();
     }
 
     if (this.jsterm) {
       this.jsterm.destroy();
     }
   },
@@ -2388,22 +2460,26 @@ function JSTerm(aWebConsoleFrame)
 
   this.lastCompletion = { value: null };
   this.history = [];
   this.historyIndex = 0;
   this.historyPlaceHolder = 0;  // this.history.length;
   this.autocompletePopup = new AutocompletePopup(this.hud.owner.chromeDocument);
   this.autocompletePopup.onSelect = this.onAutocompleteSelect.bind(this);
   this.autocompletePopup.onClick = this.acceptProposedCompletion.bind(this);
+
   this._keyPress = this.keyPress.bind(this);
   this._inputEventHandler = this.inputEventHandler.bind(this);
+  this._evalRequests = {};
   this._initUI();
 }
 
 JSTerm.prototype = {
+  _evalRequests: null,
+
   /**
    * Stores the data for the last completion.
    * @type object
    */
   lastCompletion: null,
 
   /**
    * Last input value.
@@ -2418,16 +2494,22 @@ JSTerm.prototype = {
   history: null,
 
   /**
    * Getter for the element that holds the messages we display.
    * @type nsIDOMElement
    */
   get outputNode() this.hud.outputNode,
 
+  /**
+   * Getter for the debugger WebConsoleClient.
+   * @type object
+   */
+  get webConsoleClient() this.hud.webConsoleClient,
+
   COMPLETE_FORWARD: 0,
   COMPLETE_BACKWARD: 1,
   COMPLETE_HINT_ONLY: 2,
 
   /**
    * Initialize the JSTerminal UI.
    * @private
    */
@@ -2449,82 +2531,96 @@ JSTerm.prototype = {
    * @param string aString
    *        String to evaluate in the content process JavaScript sandbox.
    * @param function [aCallback]
    *        Optional function to be invoked when the evaluation result is
    *        received.
    */
   evalInContentSandbox: function JST_evalInContentSandbox(aString, aCallback)
   {
-    let message = {
-      str: aString,
-      resultCacheId: "HUDEval-" + gSequenceId(),
-    };
-
-    this.hud.owner.sendMessageToContent("JSTerm:EvalRequest", message, aCallback);
-
-    return message;
+    let requestId = this.hudId + "_eval" + gSequenceId();
+
+    this.webConsoleClient.evaluateJS(requestId, aString, aCallback);
+
+    return requestId;
   },
 
   /**
-   * The "JSTerm:EvalResult" message handler. This is the JSTerm execution
-   * result callback which is invoked whenever JavaScript code evaluation
-   * results come from the content process.
+   * The JavaScript evaluation response handler.
    *
    * @private
    * @param function [aCallback]
    *        Optional function to invoke when the evaluation result is added to
    *        the output.
    * @param object aResponse
-   *        The JSTerm:EvalResult message received from the content process. See
-   *        JSTerm.handleEvalRequest() in HUDService-content.js for further
-   *        details.
-   * @param object aRequest
-   *        The JSTerm:EvalRequest message we sent to the content process.
-   * @see JSTerm.handleEvalRequest() in HUDService-content.js
+   *        The message received from the server.
    */
   _executeResultCallback:
-  function JST__executeResultCallback(aCallback, aResponse, aRequest)
+  function JST__executeResultCallback(aCallback, aResponse)
   {
     let errorMessage = aResponse.errorMessage;
-    let resultString = aResponse.resultString;
+    let result = aResponse.result;
+    let inspectable = result && typeof result == "object" && result.inspectable;
+    let helperResult = aResponse.helperResult;
+    let helperRawOutput = !!(helperResult || {}).rawOutput;
+    let resultString =
+      WebConsoleUtils.objectActorGripToString(result, !helperRawOutput);
+
+    if (helperResult && helperResult.type) {
+      switch (helperResult.type) {
+        case "clearOutput":
+          this.clearOutput();
+          break;
+        case "inspectObject":
+          this.handleInspectObject(helperResult.input, helperResult.object);
+          break;
+      }
+    }
+
+    let afterNode = this._evalRequests[aResponse.requestId];
+    if (afterNode) {
+      delete this._evalRequests[aResponse.requestId];
+    }
 
     // Hide undefined results coming from JSTerm helper functions.
-    if (!errorMessage &&
-        resultString == "undefined" &&
-        aResponse.helperResult &&
-        !aResponse.inspectable &&
-        !aResponse.helperRawOutput) {
+    if (!errorMessage && result && typeof result == "object" &&
+        result.type == "undefined" &&
+        helperResult && !helperRawOutput) {
+      aCallback && aCallback();
       return;
     }
 
-    let afterNode = aRequest.outputNode;
-
     if (aCallback) {
       let oldFlushCallback = this.hud._flushCallback;
       this.hud._flushCallback = function() {
         aCallback();
         oldFlushCallback && oldFlushCallback();
         this.hud._flushCallback = oldFlushCallback;
       }.bind(this);
     }
 
-    if (aResponse.errorMessage) {
-      this.writeOutput(aResponse.errorMessage, CATEGORY_OUTPUT, SEVERITY_ERROR,
-                       afterNode, aResponse.timestamp);
+    let node;
+
+    if (errorMessage) {
+      node = this.writeOutput(errorMessage, CATEGORY_OUTPUT, SEVERITY_ERROR,
+                              afterNode, aResponse.timestamp);
     }
-    else if (aResponse.inspectable) {
-      let node = this.writeOutputJS(aResponse.resultString,
-                                    this._evalOutputClick.bind(this, aResponse),
-                                    afterNode, aResponse.timestamp);
-      node._evalCacheId = aResponse.childrenCacheId;
+    else if (inspectable) {
+      node = this.writeOutputJS(resultString,
+                                this._evalOutputClick.bind(this, aResponse),
+                                afterNode, aResponse.timestamp);
     }
     else {
-      this.writeOutput(aResponse.resultString, CATEGORY_OUTPUT, SEVERITY_LOG,
-                       afterNode, aResponse.timestamp);
+      node = this.writeOutput(resultString, CATEGORY_OUTPUT, SEVERITY_LOG,
+                              afterNode, aResponse.timestamp);
+    }
+
+    if (result && typeof result == "object" && result.actor) {
+      this.hud._trackObjectActor(result.actor);
+      node._objectActors = [result.actor];
     }
   },
 
   /**
    * Execute a string. Execution happens asynchronously in the content process.
    *
    * @param string [aExecuteString]
    *        The string you want to execute. If this is not provided, the current
@@ -2539,18 +2635,18 @@ JSTerm.prototype = {
     if (!aExecuteString) {
       this.writeOutput("no value to execute", CATEGORY_OUTPUT, SEVERITY_LOG);
       return;
     }
 
     let node = this.writeOutput(aExecuteString, CATEGORY_INPUT, SEVERITY_LOG);
 
     let onResult = this._executeResultCallback.bind(this, aCallback);
-    let messageToContent = this.evalInContentSandbox(aExecuteString, onResult);
-    messageToContent.outputNode = node;
+    let evalId = this.evalInContentSandbox(aExecuteString, onResult);
+    this._evalRequests[evalId] = node;
 
     this.history.push(aExecuteString);
     this.historyIndex++;
     this.historyPlaceHolder = this.history.length;
     this.setInputValue("");
     this.clearCompletion();
   },
 
@@ -3018,28 +3114,28 @@ JSTerm.prototype = {
    */
   _updateCompletionResult:
   function JST__updateCompletionResult(aType, aCallback)
   {
     if (this.lastCompletion.value == this.inputNode.value) {
       return;
     }
 
-    let message = {
-      id: "HUDComplete-" + gSequenceId(),
-      input: this.inputNode.value,
-    };
-
+    let requestId = this.hudId + "_complete" + gSequenceId();
+    let input = this.inputNode.value;
+    let cursor = this.inputNode.selectionStart;
+
+    // TODO: throttle updates, deal with slow/high latency network connections.
     this.lastCompletion = {
-      requestId: message.id,
+      requestId: requestId,
       completionType: aType,
       value: null,
     };
     let callback = this._receiveAutocompleteProperties.bind(this, aCallback);
-    this.hud.owner.sendMessageToContent("JSTerm:Autocomplete", message, callback);
+    this.webConsoleClient.autocomplete(requestId, input, cursor, callback);
   },
 
   /**
    * Handler for the "JSTerm:AutocompleteProperties" message. This method takes
    * the completion result received from the content process and updates the UI
    * accordingly.
    *
    * @param function [aCallback=null]
@@ -3048,19 +3144,18 @@ JSTerm.prototype = {
    *        The JSON message which holds the completion results received from
    *        the content process.
    */
   _receiveAutocompleteProperties:
   function JST__receiveAutocompleteProperties(aCallback, aMessage)
   {
     let inputNode = this.inputNode;
     let inputValue = inputNode.value;
-    if (aMessage.input != inputValue ||
-        this.lastCompletion.value == inputValue ||
-        aMessage.id != this.lastCompletion.requestId) {
+    if (this.lastCompletion.value == inputValue ||
+        aMessage.requestId != this.lastCompletion.requestId) {
       return;
     }
 
     let matches = aMessage.matches;
     if (!matches.length) {
       this.clearCompletion();
       return;
     }
@@ -3206,99 +3301,105 @@ JSTerm.prototype = {
       objectId: aObjectId,
       resultCacheId: aResultCacheId,
     };
 
     this.hud.owner.sendMessageToContent("JSTerm:GetEvalObject", message, aCallback);
   },
 
   /**
-   * The "JSTerm:InspectObject" remote message handler. This allows the content
+   * The JSTerm InspectObject remote message handler. This allows the remote
    * process to open the Property Panel for a given object.
    *
    * @param object aRequest
    *        The request message from the content process. This message includes
    *        the user input string that was evaluated to inspect an object and
    *        the result object which is to be inspected.
    */
-  handleInspectObject: function JST_handleInspectObject(aRequest)
+  handleInspectObject: function JST_handleInspectObject(aInput, aActor)
   {
     let options = {
-      title: aRequest.input,
+      title: aInput,
 
       data: {
-        rootCacheId: aRequest.objectCacheId,
-        panelCacheId: aRequest.objectCacheId,
-        remoteObject: aRequest.resultObject,
-        remoteObjectProvider: this.remoteObjectProvider.bind(this),
+        objectPropertiesProvider: this.hud.objectPropertiesProvider.bind(this.hud),
+        trackObjectActor: this.hud._trackObjectActor.bind(this.hud),
+        releaseObject: this.hud._releaseObject.bind(this.hud),
       },
     };
 
-    let propPanel = this.openPropertyPanel(options);
-    propPanel.panel.setAttribute("hudId", this.hudId);
+    let propPanel;
 
     let onPopupHide = function JST__onPopupHide() {
       propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
-
-      this.clearObjectCache(options.data.panelCacheId);
+      this.hud._releaseObject(aActor.actor);
     }.bind(this);
 
-    propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+    this.hud._trackObjectActor(aActor.actor);
+
+    this.hud.objectPropertiesProvider(aActor.actor,
+      function _onObjectProperties(aProperties) {
+        options.data.objectProperties = aProperties;
+        propPanel = this.openPropertyPanel(options);
+        propPanel.panel.setAttribute("hudId", this.hudId);
+        propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+      }.bind(this));
   },
 
   /**
    * The click event handler for evaluation results in the output.
    *
    * @private
    * @param object aResponse
-   *        The JSTerm:EvalResult message received from the content process.
+   *        The JavaScript evaluation response received from the server.
    * @param nsIDOMNode aLink
    *        The message node for which we are handling events.
    */
   _evalOutputClick: function JST__evalOutputClick(aResponse, aLinkNode)
   {
     if (aLinkNode._panelOpen) {
       return;
     }
 
     let options = {
       title: aResponse.input,
       anchor: aLinkNode,
 
       // Data to inspect.
       data: {
-        // This is where the resultObject children are cached.
-        rootCacheId: aResponse.childrenCacheId,
-        remoteObject: aResponse.resultObject,
-        // This is where all objects retrieved by the panel will be cached.
-        panelCacheId: "HUDPanel-" + gSequenceId(),
-        remoteObjectProvider: this.remoteObjectProvider.bind(this),
+        objectPropertiesProvider: this.hud.objectPropertiesProvider.bind(this.hud),
+        trackObjectActor: this.hud._trackObjectActor.bind(this.hud),
+        releaseObject: this.hud._releaseObject.bind(this.hud),
       },
     };
 
+    let propPanel;
+
     options.updateButtonCallback = function JST__evalUpdateButton() {
       this.evalInContentSandbox(aResponse.input,
         this._evalOutputUpdatePanelCallback.bind(this, options, propPanel,
                                                  aResponse));
     }.bind(this);
 
-    let propPanel = this.openPropertyPanel(options);
-    propPanel.panel.setAttribute("hudId", this.hudId);
-
     let onPopupHide = function JST__evalInspectPopupHide() {
       propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
 
-      this.clearObjectCache(options.data.panelCacheId);
-
-      if (!aLinkNode.parentNode && aLinkNode._evalCacheId) {
-        this.clearObjectCache(aLinkNode._evalCacheId);
+      if (!aLinkNode.parentNode && aLinkNode._objectActors) {
+        aLinkNode._objectActors.forEach(this.hud._releaseObject, this.hud);
+        aLinkNode._objectActors = null;
       }
     }.bind(this);
 
-    propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+    this.hud.objectPropertiesProvider(aResponse.result.actor,
+      function _onObjectProperties(aProperties) {
+        options.data.objectProperties = aProperties;
+        propPanel = this.openPropertyPanel(options);
+        propPanel.panel.setAttribute("hudId", this.hudId);
+        propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+      }.bind(this));
   },
 
   /**
    * The callback used for updating the Property Panel when the user clicks the
    * Update button.
    *
    * @private
    * @param object aOptions
@@ -3317,42 +3418,52 @@ JSTerm.prototype = {
                                     aNewResponse)
   {
     if (aNewResponse.errorMessage) {
       this.writeOutput(aNewResponse.errorMessage, CATEGORY_OUTPUT,
                        SEVERITY_ERROR);
       return;
     }
 
-    if (!aNewResponse.inspectable) {
+    let result = aNewResponse.result;
+    let inspectable = result && typeof result == "object" && result.inspectable;
+    let newActor = result && typeof result == "object" ? result.actor : null;
+
+    let anchor = aOptions.anchor;
+    if (anchor && newActor) {
+      if (!anchor._objectActors) {
+        anchor._objectActors = [];
+      }
+      if (anchor._objectActors.indexOf(newActor) == -1) {
+        this.hud._trackObjectActor(newActor);
+        anchor._objectActors.push(newActor);
+      }
+    }
+
+    if (!inspectable) {
       this.writeOutput(l10n.getStr("JSTerm.updateNotInspectable"), CATEGORY_OUTPUT, SEVERITY_ERROR);
       return;
     }
 
-    this.clearObjectCache(aOptions.data.panelCacheId);
-    this.clearObjectCache(aOptions.data.rootCacheId);
-
-    if (aOptions.anchor && aOptions.anchor._evalCacheId) {
-      aOptions.anchor._evalCacheId = aNewResponse.childrenCacheId;
-    }
-
     // Update the old response object such that when the panel is reopen, the
     // user sees the new response.
-    aOldResponse.id = aNewResponse.id;
-    aOldResponse.childrenCacheId = aNewResponse.childrenCacheId;
-    aOldResponse.resultObject = aNewResponse.resultObject;
-    aOldResponse.resultString = aNewResponse.resultString;
-
-    aOptions.data.rootCacheId = aNewResponse.childrenCacheId;
-    aOptions.data.remoteObject = aNewResponse.resultObject;
-
-    // TODO: This updates the value of the tree.
-    // However, the states of open nodes is not saved.
-    // See bug 586246.
-    aPropPanel.treeView.data = aOptions.data;
+    aOldResponse.requestId = aNewResponse.requestId;
+    aOldResponse.result = aNewResponse.result;
+    aOldResponse.error = aNewResponse.error;
+    aOldResponse.errorMessage = aNewResponse.errorMessage;
+    aOldResponse.timestamp = aNewResponse.timestamp;
+
+    this.hud.objectPropertiesProvider(newActor,
+      function _onObjectProperties(aProperties) {
+        aOptions.data.objectProperties = aProperties;
+        // TODO: This updates the value of the tree.
+        // However, the states of open nodes is not saved.
+        // See bug 586246.
+        aPropPanel.treeView.data = aOptions.data;
+      }.bind(this));
   },
 
   /**
    * Destroy the JSTerm object. Call this method to avoid memory leaks.
    */
   destroy: function JST_destroy()
   {
     this.clearCompletion();
@@ -3548,16 +3659,17 @@ CommandController.prototype = {
  * @param object aWebConsole
  *        The Web Console instance that owns this connection proxy.
  */
 function WebConsoleConnectionProxy(aWebConsole)
 {
   this.owner = aWebConsole;
 
   this._onPageError = this._onPageError.bind(this);
+  this._onConsoleAPICall = this._onConsoleAPICall.bind(this);
 }
 
 WebConsoleConnectionProxy.prototype = {
   /**
    * The owning Web Console instance.
    *
    * @see WebConsoleFrame
    * @type object
@@ -3589,18 +3701,20 @@ WebConsoleConnectionProxy.prototype = {
    *        Optional function to invoke when connection is established.
    */
   connect: function WCCP_connect(aCallback)
   {
     let transport = DebuggerServer.connectPipe();
     let client = this.client = new DebuggerClient(transport);
 
     client.addListener("pageError", this._onPageError);
-
-    let listeners = [WebConsoleClient.prototype.LISTENERS.PageError];
+    client.addListener("consoleAPICall", this._onConsoleAPICall);
+
+    let listeners = [WebConsoleClient.prototype.LISTENERS.PageError,
+                     WebConsoleClient.prototype.LISTENERS.ConsoleAPI];
 
     client.connect(function(aType, aTraits) {
       client.listTabs(function(aResponse) {
         let tab = aResponse.tabs[aResponse.selected];
         client.attachConsole(tab.consoleActor, listeners,
                              this._onAttachConsole.bind(this, aCallback));
       }.bind(this));
     }.bind(this));
@@ -3624,39 +3738,90 @@ WebConsoleConnectionProxy.prototype = {
     if (aResponse.error) {
       Cu.reportError("attachConsole failed: " + aResponse.error + " " +
                      aResponse.message);
       return;
     }
 
     this.webConsoleClient = aWebConsoleClient;
 
+    let msgs = [this.webConsoleClient.CACHED_MESSAGES.PageError,
+                this.webConsoleClient.CACHED_MESSAGES.ConsoleAPI];
+    this.webConsoleClient.getCachedMessages(msgs,
+      this._onCachedMessages.bind(this, aCallback));
+  },
+
+  /**
+   * The "cachedMessages" response handler.
+   *
+   * @private
+   * @param function [aCallback]
+   *        Optional function to invoke once the connection is established.
+   * @param object aResponse
+   *        The JSON response object received from the server.
+   */
+  _onCachedMessages: function WCCP__onCachedMessages(aCallback, aResponse)
+  {
+    if (aResponse.error) {
+      Cu.reportError("Web Console getCachedMessages error: " + aResponse.error +
+                     " " + aResponse.message);
+      return;
+    }
+
+    this.owner.displayCachedMessages(aResponse.messages);
+
+    if (!this.webConsoleClient.hasNativeConsoleAPI) {
+      this.owner.logWarningAboutReplacedAPI();
+    }
+
     this.connected = true;
     aCallback && aCallback();
   },
 
   /**
    * The "pageError" message type handler. We redirect any page errors to the UI
    * for displaying.
+   *
+   * @private
+   * @param string aType
+   *        Message type.
+   * @param object aPacket
+   *        The message received from the server.
    */
   _onPageError: function WCCP__onPageError(aType, aPacket)
   {
     this.owner.handlePageError(aPacket.pageError);
   },
 
   /**
+   * The "consoleAPICall" message type handler. We redirect any message to
+   * the UI for displaying.
+   *
+   * @private
+   * @param string aType
+   *        Message type.
+   * @param object aPacket
+   *        The message received from the server.
+   */
+  _onConsoleAPICall: function WCCP__onConsoleAPICall(aType, aPacket)
+  {
+    this.owner.handleConsoleAPICall(aPacket.message);
+  },
+
+  /**
    * Disconnect the Web Console from the remote server.
    */
   disconnect: function WCCP_disconnect()
   {
     if (!this.client) {
       return;
     }
 
     this.client.removeListener("pageError", this._onPageError);
+    this.client.removeListener("consoleAPICall", this._onConsoleAPICall);
     this.client.close();
 
     this.client = null;
     this.webConsoleClient = null;
     this.connected = false;
   },
 };
 
diff --git a/toolkit/devtools/debugger/dbg-client.jsm b/toolkit/devtools/debugger/dbg-client.jsm
--- a/toolkit/devtools/debugger/dbg-client.jsm
+++ b/toolkit/devtools/debugger/dbg-client.jsm
@@ -168,16 +168,17 @@ const ThreadStateTypes = {
   "detached": "detached"
 };
 
 /**
  * Set of protocol messages that are sent by the server without a prior request
  * by the client.
  */
 const UnsolicitedNotifications = {
+  "consoleAPICall": "consoleAPICall",
   "newScript": "newScript",
   "pageError": "pageError",
   "tabDetached": "tabDetached",
   "tabNavigated": "tabNavigated"
 };
 
 /**
  * Set of pause types that are sent by the server and not as an immediate
@@ -192,28 +193,32 @@ const UnsolicitedPauses = {
 
 /**
  * Set of debug protocol request types that specify the protocol request being
  * sent to the server.
  */
 const DebugProtocolTypes = {
   "assign": "assign",
   "attach": "attach",
+  "autocomplete": "autocomplete",
   "clientEvaluate": "clientEvaluate",
   "delete": "delete",
   "detach": "detach",
   "frames": "frames",
   "getCachedMessages": "getCachedMessages",
+  "evaluateJS": "evaluateJS",
+  "inspectProperties": "inspectProperties",
   "interrupt": "interrupt",
   "listTabs": "listTabs",
   "nameAndParameters": "nameAndParameters",
   "ownPropertyNames": "ownPropertyNames",
   "property": "property",
   "prototype": "prototype",
   "prototypeAndProperties": "prototypeAndProperties",
+  "release": "release",
   "resume": "resume",
   "scripts": "scripts",
   "setBreakpoint": "setBreakpoint",
   "startListeners": "startListeners",
   "stopListeners": "stopListeners",
 };
 
 const ROOT_ACTOR_NAME = "root";
@@ -348,38 +353,39 @@ DebuggerClient.prototype = {
       }
       aOnResponse(aResponse, tabClient);
     });
   },
 
   /**
    * Attach to a Web Console actor.
    *
-   * @param string aConsoleActor
-   *        The actor ID for the console actor to attach to.
+   * @param object aConsoleActor
+   *        The grip for the console actor to attach to.
    * @param array aListeners
    *        The console listeners you want to start.
    * @param function aOnResponse
    *        Called with the response packet and a WebConsoleClient
    *        instance (which will be undefined on error).
    */
   attachConsole:
   function DC_attachConsole(aConsoleActor, aListeners, aOnResponse) {
+    let actorID = aConsoleActor.actor;
     let self = this;
     let packet = {
-      to: aConsoleActor,
+      to: actorID,
       type: DebugProtocolTypes.startListeners,
       listeners: aListeners,
     };
 
     this.request(packet, function(aResponse) {
       let consoleClient;
       if (!aResponse.error) {
         consoleClient = new WebConsoleClient(self, aConsoleActor);
-        self._consoleClients[aConsoleActor] = consoleClient;
+        self._consoleClients[actorID] = consoleClient;
       }
       aOnResponse(aResponse, consoleClient);
     });
   },
 
   /**
    * Attach to a thread actor.
    *
@@ -559,35 +565,39 @@ TabClient.prototype = {
 eventSource(TabClient.prototype);
 
 /**
  * A WebConsoleClient is used as a front end for the WebConsoleActor that is
  * created on the server, hiding implementation details.
  *
  * @param object aDebuggerClient
  *        The DebuggerClient instance we live for.
- * @param string aActor
- *        The WebConsoleActor ID.
+ * @param object aActorGrip
+ *        The WebConsoleActor grip.
  */
-function WebConsoleClient(aDebuggerClient, aActor) {
-  this._actor = aActor;
+function WebConsoleClient(aDebuggerClient, aActorGrip) {
+  this._actor = aActorGrip.actor;
+  this._grip = aActorGrip;
   this._client = aDebuggerClient;
 }
 
 WebConsoleClient.prototype = {
   LISTENERS: {
     PageError: "PageError",
     ConsoleAPI: "ConsoleAPI",
   },
 
   CACHED_MESSAGES: {
     PageError: "PageError",
     ConsoleAPI: "ConsoleAPI",
   },
 
+  /** @type boolean */
+  get hasNativeConsoleAPI() this._grip.nativeConsole,
+
   /**
    * Retrieve the cached messages from the server.
    *
    * @see this.CACHED_MESSAGES
    * @param array aTypes
    *        The array of message types you want from the server. See
    *        this.CACHED_MESSAGES for known types.
    * @param function aOnResponse
@@ -599,16 +609,91 @@ WebConsoleClient.prototype = {
       to: this._actor,
       type: DebugProtocolTypes.getCachedMessages,
       messageTypes: aTypes,
     };
     this._client.request(packet, aOnResponse);
   },
 
   /**
+   * Inspect the properties of an object.
+   *
+   * @param string aActor
+   *        The WebConsoleObjectActor ID to send the request to.
+   * @param function aOnResponse
+   *        The function invoked when the response is received.
+   */
+  inspectObjectProperties:
+  function WCC_inspectObjectProperties(aActor, aOnResponse) {
+    let packet = {
+      to: aActor,
+      type: DebugProtocolTypes.inspectProperties,
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Release an object actor.
+   *
+   * @param string aActor
+   *        The WebConsoleObjectActor ID to send the request to.
+   */
+  releaseObject: function WCC_releaseObject(aActor) {
+    let packet = {
+      to: aActor,
+      type: DebugProtocolTypes.release,
+    };
+    this._client.request(packet);
+  },
+
+  /**
+   * Evaluate a JavaScript expression.
+   *
+   * @param string aRequestId
+   *        The evaluation request ID.
+   * @param string aString
+   *        The code you want to evaluate.
+   * @param function aOnResponse
+   *        The function invoked when the response is received.
+   */
+  evaluateJS: function WCC_evaluateJS(aRequestId, aString, aOnResponse) {
+    let packet = {
+      to: this._actor,
+      type: DebugProtocolTypes.evaluateJS,
+      requestId: aRequestId,
+      str: aString,
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Autocomplete a JavaScript expression.
+   *
+   * @param string aRequestId
+   *        The evaluation request ID.
+   * @param string aString
+   *        The code you want to autocomplete.
+   * @param number aCursor
+   *        Cursor location inside the string. Index starts from 0.
+   * @param function aOnResponse
+   *        The function invoked when the response is received.
+   */
+  autocomplete:
+  function WCC_autocomplete(aRequestId, aString, aCursor, aOnResponse) {
+    let packet = {
+      to: this._actor,
+      type: DebugProtocolTypes.autocomplete,
+      requestId: aRequestId,
+      str: aString,
+      cursor: aCursor,
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
    * Start the given Web Console listeners.
    *
    * @see this.LISTENERS
    * @param array aListeners
    *        Array of listeners you want to start. See this.LISTENERS for
    *        known listeners.
    * @param function aOnResponse
    *        Function to invoke when the server response is received.
diff --git a/toolkit/devtools/debugger/server/dbg-browser-actors.js b/toolkit/devtools/debugger/server/dbg-browser-actors.js
--- a/toolkit/devtools/debugger/server/dbg-browser-actors.js
+++ b/toolkit/devtools/debugger/server/dbg-browser-actors.js
@@ -253,43 +253,55 @@ BrowserTabActor.prototype = {
     dbg_assert(this.actorID,
                "tab should have an actorID.");
 
     this.consoleActor = new WebConsoleActor(this.conn, this.browser);
     this._createTabActorPool();
     this._tabPool.addActor(this.consoleActor);
 
     return { actor: this.actorID,
-             consoleActor: this.consoleActor.actorID,
+             consoleActor: this.consoleActor.grip(),
              title: this.browser.contentTitle,
              url: this.browser.currentURI.spec }
   },
 
   /**
    * Called when the actor is removed from the connection.
    */
   disconnect: function BTA_disconnect() {
     this._detach();
 
+    if (this.consoleActor) {
+      this._tabPool && this._tabPool.removeActor(this.consoleActor.actorID);
+      this.consoleActor.disconnect();
+      this.consoleActor = null;
+    }
+
     // Shut down actors that belong to this tab's pool.
     this._removeTabActorPool();
 
     if (this._progressListener) {
       this._progressListener.destroy();
     }
   },
 
   /**
    * Called by the root actor when the underlying tab is closed.
    */
   exit: function BTA_exit() {
     if (this.exited) {
       return;
     }
 
+    if (this.consoleActor) {
+      this._tabPool && this._tabPool.removeActor(this.consoleActor.actorID);
+      this.consoleActor.disconnect();
+      this.consoleActor = null;
+    }
+
     if (this.attached) {
       this._detach();
       this.conn.send({ from: this.actorID,
                        type: "tabDetached" });
     }
 
     // Shut down actors that belong to this tab's pool.
     this._removeTabActorPool();
diff --git a/toolkit/devtools/debugger/server/dbg-webconsole-actors.js b/toolkit/devtools/debugger/server/dbg-webconsole-actors.js
--- a/toolkit/devtools/debugger/server/dbg-webconsole-actors.js
+++ b/toolkit/devtools/debugger/server/dbg-webconsole-actors.js
@@ -13,16 +13,22 @@ const Cu = Components.utils;
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Services",
                                   "resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
                                   "resource:///modules/WebConsoleUtils.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "JSPropertyProvider",
+                                  "resource:///modules/WebConsoleUtils.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "ConsoleAPIStorage",
+                                  "resource://gre/modules/ConsoleAPIStorage.jsm");
+
 const LISTENERS = {
   PageError: "PageError",
   ConsoleAPI: "ConsoleAPI",
 };
 
 const CACHED_MESSAGES = {
   PageError: "PageError",
   ConsoleAPI: "ConsoleAPI",
@@ -37,89 +43,212 @@ const CACHED_MESSAGES = {
  *        The connection to the client, DebuggerServerConnection.
  * @param nsIDOMElement aBrowser
  *        The xul:browser we work with.
  */
 function WebConsoleActor(aConnection, aBrowser)
 {
   this.conn = aConnection;
   this._browser = aBrowser;
+
+  this._objectActorsPool = new ActorPool(this.conn);
+  this.conn.addActorPool(this._objectActorsPool);
+
+  this._objectActors = new Map();
 }
 
 WebConsoleActor.prototype =
 {
   /**
    * The xul:browser we work with.
    * @private
    * @type nsIDOMElement
    */
   _browser: null,
 
   /**
+   * Actor pool for all of the object actors for objects we send to the client.
+   * @private
+   * @type object
+   * @see ActorPool
+   * @see this.objectGrip()
+   */
+  _objectActorsPool: null,
+
+  /**
+   * Map between objects and their WebConsoleObjectActor wrappers.
+   * @private
+   * @type object
+   */
+  _objectActors: null,
+
+  /**
    * The debugger server connection instance.
    * @type object
    */
   conn: null,
 
   /**
    * The content window we work with.
    * @type nsIDOMWindow
    */
-  get contentWindow() this._browser.contentWindow,
+  get window() this._browser.contentWindow,
+
+  /**
+   * The PageErrorListener instance.
+   * @type object
+   */
+  pageErrorListener: null,
+
+  /**
+   * The ConsoleAPIListener instance.
+   */
+  consoleAPIListener: null,
 
   actorPrefix: "console",
 
   grip: function WCA_grip()
   {
-    return { actor: this.actorID };
+    let nativeConsole = false;
+    try {
+      let consoleObject = WebConsoleUtils.unwrap(this.window).console;
+      nativeConsole = "__mozillaConsole__" in consoleObject;
+    }
+    catch (ex) { }
+
+    return {
+      actor: this.actorID,
+      nativeConsole: nativeConsole,
+    };
   },
 
   /**
    * Destroy the current WebConsoleActor instance.
    */
   disconnect: function WCA_disconnect()
   {
     if (this.pageErrorListener) {
       this.pageErrorListener.destroy();
       this.pageErrorListener = null;
     }
+    if (this.consoleAPIListener) {
+      this.consoleAPIListener.destroy();
+      this.consoleAPIListener = null;
+    }
+    if (this._objectActorsPool) {
+      this.conn.removeActorPool(this._objectActorsPool);
+      this._objectActorsPool = null;
+    }
+    this._objectActors = null;
     this.conn = this._browser = null;
   },
 
   /**
+   * Create a grip for the given value. If the value is an object,
+   * a WebConsoleObjectActor will be created.
+   *
+   * @param mixed aValue
+   * @return object
+   */
+  createValueGrip: function WCA_createValueGrip(aValue)
+  {
+    return WebConsoleUtils.createValueGrip(aValue,
+                                           this.createObjectActor.bind(this));
+  },
+
+  /**
+   * Create a grip for the given object.
+   *
+   * @param object aObject
+   *        The object you want.
+   * @param object
+   *        The object grip.
+   */
+  createObjectActor: function WCA_createObjectActor(aObject)
+  {
+    // We need to unwrap the object, otherwise we cannot access the properties
+    // and methods added by the content scripts.
+    let obj = WebConsoleUtils.unwrap(aObject);
+    if (this._objectActors.has(obj)) {
+      return this._objectActors.get(obj).grip();
+    }
+
+    let actor = new WebConsoleObjectActor(obj, this);
+    this._objectActorsPool.addActor(actor);
+    this._objectActors.set(obj, actor);
+    return actor.grip();
+  },
+
+  /**
+   * Get an object actor by its ID.
+   *
+   * @param string aActorID
+   * @return object
+   */
+  getObjectActorByID: function WCA_getObjectActorByID(aActorID)
+  {
+    return this._objectActorsPool.get(aActorID);
+  },
+
+  /**
+   * Release an object grip for the given object actor.
+   *
+   * @param object aActor
+   *        The WebConsoleObjectActor instance you want to release.
+   */
+  releaseObject: function WCA_releaseObject(aActor)
+  {
+    this._objectActors.delete(aActor.obj);
+    this._objectActorsPool.removeActor(aActor.actorID);
+  },
+
+  /**
    * Handler for the "startListeners" request.
    *
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
+   * @return object
+   *         The response object which holds the startedListeners array.
    */
   onStartListeners: function WCA_onStartListeners(aRequest)
   {
     let startedListeners = [];
 
     while (aRequest.listeners.length > 0) {
       let listener = aRequest.listeners.shift();
       switch (listener) {
         case LISTENERS.PageError:
           if (!this.pageErrorListener) {
             this.pageErrorListener =
-              new PageErrorListener(this.contentWindow, this);
+              new PageErrorListener(this.window, this);
             this.pageErrorListener.init();
           }
           startedListeners.push(listener);
           break;
+        case LISTENERS.ConsoleAPI:
+          if (!this.consoleAPIListener) {
+            this.consoleAPIListener =
+              new ConsoleAPIListener(this.window, this);
+            this.consoleAPIListener.init();
+          }
+          startedListeners.push(listener);
+          break;
       }
     }
     return { startedListeners: startedListeners };
   },
 
   /**
    * Handler for the "stopListeners" request.
    *
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
+   * @return object
+   *         The response packet to send to the client: holds the
+   *         stoppedListeners array.
    */
   onStopListeners: function WCA_onStopListeners(aRequest)
   {
     let stoppedListeners = [];
     let toDetach = aRequest.listeners || [];
     if (!toDetach.length) {
       // If no specific listeners are requested to be detached, we stop all
       // listeners.
@@ -133,28 +262,38 @@ WebConsoleActor.prototype =
       switch (listener) {
         case LISTENERS.PageError:
           if (this.pageErrorListener) {
             this.pageErrorListener.destroy();
             this.pageErrorListener = null;
           }
           stoppedListeners.push(listener);
           break;
+        case LISTENERS.ConsoleAPI:
+          if (this.consoleAPIListener) {
+            this.consoleAPIListener.destroy();
+            this.consoleAPIListener = null;
+          }
+          stoppedListeners.push(listener);
+          break;
       }
     }
 
     return { stoppedListeners: stoppedListeners };
   },
 
   /**
    * Handler for the "getCachedMessages" request. This method sends the cached
    * error messages and the window.console API calls to the client.
    *
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
+   * @return object
+   *         The response packet to send to the client: it holds the cached
+   *         messages array.
    */
   onGetCachedMessages: function WCA_onGetCachedMessages(aRequest)
   {
     let types = aRequest.messageTypes;
     if (!types) {
       return {
         error: "missingParameter",
         message: "The messageTypes parameter is missing.",
@@ -179,44 +318,275 @@ WebConsoleActor.prototype =
           break;
       }
     }
 
     messages.sort(function(a, b) { return a.timeStamp - b.timeStamp; });
 
     return {
       from: this.actorID,
-      type: "cachedMessages",
       messages: messages,
     };
   },
 
   /**
+   * Handler for the "evaluateJS" request. This method evaluates the given
+   * JavaScript string and sends back the result.
+   *
+   * @param object aRequest
+   *        The JSON request object received from the Web Console client.
+   * @return object
+   *         The evaluation response packet.
+   */
+  onEvaluateJS: function WCA_onEvaluateJS(aRequest)
+  {
+    let input = aRequest.str;
+    let result, error = null;
+    let timestamp;
+
+    this._helperResult = null;
+    this._evalInput = input;
+    try {
+      timestamp = Date.now();
+      result = this.evalInSandbox(input);
+    }
+    catch (ex) {
+      error = ex;
+    }
+
+    let helperResult = this._helperResult;
+    delete this._helperResult;
+    delete this._evalInput;
+
+    return {
+      from: this.actorID,
+      requestId: aRequest.requestId,
+      input: input,
+      result: this.createValueGrip(result),
+      timestamp: timestamp,
+      error: error,
+      errorMessage: error ? String(error) : null,
+      helperResult: helperResult,
+    };
+  },
+
+  /**
+   * The Autocomplete request handler.
+   *
+   * @param object aRequest
+   *        The request message - what input to autocomplete.
+   * @return object
+   *         The response message - matched properties.
+   */
+  onAutocomplete: function WCA_onAutocomplete(aRequest)
+  {
+    let result = JSPropertyProvider(this.window, aRequest.str) || {};
+    return {
+      from: this.actorID,
+      requestId: aRequest.requestId,
+      matches: result.matches || [],
+      matchProp: result.matchProp,
+    };
+  },
+
+  /**
+   * Create the JavaScript sandbox where user input is evaluated.
+   * @private
+   */
+  _createSandbox: function WCA__createSandbox()
+  {
+    this._sandboxLocation = this.window.location;
+    this.sandbox = new Cu.Sandbox(this.window, {
+      sandboxPrototype: this.window,
+      wantXrays: false,
+    });
+
+    this.sandbox.console = this.window.console;
+
+    JSTermHelper(this);
+  },
+
+  /**
+   * Evaluates a string in the sandbox.
+   *
+   * @param string aString
+   *        String to evaluate in the sandbox.
+   * @return mixed
+   *         The result of the evaluation.
+   */
+  evalInSandbox: function WCA_evalInSandbox(aString)
+  {
+    // If the user changed to a different location, we need to update the
+    // sandbox.
+    if (this._sandboxLocation !== this.window.location) {
+      this._createSandbox();
+    }
+
+    // The help function needs to be easy to guess, so we make the () optional
+    if (aString.trim() == "help" || aString.trim() == "?") {
+      aString = "help()";
+    }
+
+    let window = WebConsoleUtils.unwrap(this.sandbox.window);
+    let $ = null, $$ = null;
+
+    // We prefer to execute the page-provided implementations for the $() and
+    // $$() functions.
+    if (typeof window.$ == "function") {
+      $ = this.sandbox.$;
+      delete this.sandbox.$;
+    }
+    if (typeof window.$$ == "function") {
+      $$ = this.sandbox.$$;
+      delete this.sandbox.$$;
+    }
+
+    let result = Cu.evalInSandbox(aString, this.sandbox, "1.8",
+                                  "Web Console", 1);
+
+    if ($) {
+      this.sandbox.$ = $;
+    }
+    if ($$) {
+      this.sandbox.$$ = $$;
+    }
+
+    return result;
+  },
+
+  /**
    * Handler for page errors received from the PageErrorListener. This method
    * sends the nsIScriptError to the remote Web Console client.
    *
    * @param nsIScriptError aPageError
-   *        The page error we need to send to the remote.
+   *        The page error we need to send to the remote client.
    */
   onPageError: function WCA_onPageError(aPageError)
   {
     let packet = {
       from: this.actorID,
       type: "pageError",
       pageError: aPageError,
     };
     this.conn.send(packet);
   },
+
+  /**
+   * Handler for window.console API calls received from the ConsoleAPIListener.
+   * This method sends the object to the remote Web Console client.
+   *
+   * @param object aMessage
+   *        The console API call we need to send to the remote client.
+   */
+  onConsoleAPICall: function WCA_onConsoleAPICall(aMessage)
+  {
+    let packet = {
+      from: this.actorID,
+      type: "consoleAPICall",
+      message: aMessage,
+    };
+    this.conn.send(packet);
+  },
+
+  /**
+   * Find the XUL window that owns the content window.
+   *
+   * @private
+   * @return Window
+   *         The XUL window that owns the content window.
+   */
+  _xulWindow: function WCA__xulWindow()
+  {
+    return this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+           .getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocShell)
+           .chromeEventHandler.ownerDocument.defaultView;
+  },
 };
 
 WebConsoleActor.prototype.requestTypes =
 {
   getCachedMessages: WebConsoleActor.prototype.onGetCachedMessages,
   startListeners: WebConsoleActor.prototype.onStartListeners,
   stopListeners: WebConsoleActor.prototype.onStopListeners,
+  evaluateJS: WebConsoleActor.prototype.onEvaluateJS,
+  autocomplete: WebConsoleActor.prototype.onAutocomplete,
+};
+
+/**
+ * Creates an actor for the specified object.
+ *
+ * @constructor
+ * @param object aObj
+ *        The object you want.
+ * @param object aWebConsoleActor
+ *        The parent WebConsoleActor instance for this object.
+ */
+function WebConsoleObjectActor(aObj, aWebConsoleActor)
+{
+  this.obj = aObj;
+  this.parentActor = aWebConsoleActor;
+}
+
+WebConsoleObjectActor.prototype =
+{
+  actorPrefix: "consoleObj",
+
+  /**
+   * Returns a grip for this actor for returning in a protocol message.
+   */
+  grip: function WCOA_grip()
+  {
+    let grip = WebConsoleUtils.getObjectGrip(this.obj);
+    grip.actor = this.actorID;
+    return grip;
+  },
+
+  /**
+   * Releases this actor from the pool.
+   */
+  release: function WCOA_release()
+  {
+    this.parentActor.releaseObject(this);
+  },
+
+  /**
+   * Handle a protocol request to inspect the properties of the object.
+   *
+   * @return object
+   *         Message to send to the client. This holds the 'properties' property
+   *         - an array with a descriptor for each property in the object.
+   */
+  onInspectProperties: function WCOA_onInspectProperties()
+  {
+    // TODO: use LongStringActor for strings that are too long. Maybe we could
+    // just substr() for now? We don't really need to allow very long strings
+    // here, anyway. Thoughts?
+    let parent = this.parentActor;
+    let props =
+      WebConsoleUtils.inspectObject(this.obj, parent.createObjectActor.bind(parent));
+    return {
+      from: this.actorID,
+      properties: props,
+    };
+  },
+
+  /**
+   * Handle a protocol request to release a thread-lifetime grip.
+   */
+  onRelease: function WCOA_onRelease()
+  {
+    this.release();
+    return {};
+  },
+};
+
+WebConsoleObjectActor.prototype.requestTypes =
+{
+  "inspectProperties": WebConsoleObjectActor.prototype.onInspectProperties,
+  "release": WebConsoleObjectActor.prototype.onRelease,
 };
 
 ///////////////////////////////////////////////////////////////////////////////
 // The page errors listener
 ///////////////////////////////////////////////////////////////////////////////
 
 /**
  * The nsIConsoleService listener. This is used to send all the page errors
@@ -350,8 +720,397 @@ PageErrorListener.prototype =
    * Remove the nsIConsoleService listener.
    */
   destroy: function PEL_destroy()
   {
     Services.console.unregisterListener(this);
     this.listener = this.window = null;
   },
 };
+
+///////////////////////////////////////////////////////////////////////////////
+// The window.console API observer
+///////////////////////////////////////////////////////////////////////////////
+
+/**
+ * The window.console API observer. This allows the window.console API messages
+ * to be sent to the remote Web Console instance.
+ *
+ * @constructor
+ * @param nsIDOMWindow aWindow
+ *        The window object for which we are created.
+ * @param object aOwner
+ *        The owner object must have the following methods:
+ *        - onConsoleAPICall(). This method is invoked with one argument, the
+ *        Console API message that comes from the observer service, whenever
+ *        a relevant console API call is received.
+ *        - createValueGrip(). This method is used to create object actors for
+ *        objects passed to the console API.
+ */
+function ConsoleAPIListener(aWindow, aOwner)
+{
+  this.window = aWindow;
+  this.owner = aOwner;
+}
+
+ConsoleAPIListener.prototype =
+{
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
+
+  /**
+   * The content window for which we listen to window.console API calls.
+   * @type nsIDOMWindow
+   */
+  window: null,
+
+  /**
+   * The owner object which is notified of window.console API calls. It must
+   * have a onConsoleAPICall method which is invoked with one argument: the
+   * console API call object that comes from the observer service.
+   *
+   * @type object
+   * @see WebConsoleActor
+   */
+  owner: null,
+
+  /**
+   * Initialize the window.console API observer.
+   */
+  init: function CAL_init()
+  {
+    // Note that the observer is process-wide. We will filter the messages as
+    // needed, see CAL_observe().
+    Services.obs.addObserver(this, "console-api-log-event", false);
+  },
+
+  /**
+   * The console API message observer. When messages are received from the
+   * observer service we forward them to the remote Web Console instance.
+   *
+   * @param object aMessage
+   *        The message object receives from the observer service.
+   * @param string aTopic
+   *        The message topic received from the observer service.
+   */
+  observe: function CAL_observe(aMessage, aTopic)
+  {
+    if (!this.owner || !this.window || !aMessage) {
+      return;
+    }
+
+    let apiMessage = aMessage.wrappedJSObject;
+    let msgWindow = WebConsoleUtils.getWindowByOuterId(apiMessage.ID,
+                                                       this.window);
+    if (!msgWindow || msgWindow.top != this.window) {
+      // Not the same window!
+      return;
+    }
+
+    let messageToClient = this._prepareMessageForRemote(apiMessage);
+    this.owner.onConsoleAPICall(messageToClient);
+  },
+
+  /**
+   * Prepare a message from the console APi to be sent to the remote Web Console
+   * instance.
+   *
+   * @param object aOriginalMessage
+   *        The original message received from console-api-log-event.
+   * @return object
+   *         The object that can be sent to the remote client.
+   */
+  _prepareMessageForRemote: function CAL__prepareMessageForRemote(aMessage)
+  {
+    let result = WebConsoleUtils.cloneObject(aMessage, true,
+      function(aKey, aValue, aObject) {
+        // We need to skip the arguments property from the original object.
+        if (aKey == "wrappedJSObject" || aObject === aMessage &&
+            aKey == "arguments") {
+          return false;
+        }
+        return true;
+      });
+
+    switch (result.level) {
+      case "trace":
+      case "group":
+      case "groupCollapsed":
+      case "time":
+      case "timeEnd":
+        result.arguments = aMessage.arguments;
+        break;
+      case "groupEnd":
+        result.arguments = [];
+        break;
+      default:
+        result.arguments = Array.map(aMessage.arguments || [],
+          function(aObj) {
+            return this.owner.createValueGrip(aObj);
+          }, this);
+
+        if (result.level == "dir") {
+          result.objectProperties = [];
+          let first = result.arguments[0];
+          if (typeof first == "object" && first && first.inspectable) {
+            let actor = this.owner.getObjectActorByID(first.actor);
+            result.objectProperties = actor.onInspectProperties().properties;
+          }
+        }
+        break;
+    }
+
+    return result;
+  },
+
+  /**
+   * Get the cached messages for the current inner window.
+   *
+   * @return array
+   *         The array of cached messages. Each element is a Console API
+   *         prepared to be sent to the remote Web Console instance.
+   */
+  getCachedMessages: function CAL_getCachedMessages()
+  {
+    let innerWindowId = WebConsoleUtils.getInnerWindowId(this.window);
+    let messages = ConsoleAPIStorage.getEvents(innerWindowId);
+    return messages.map(function(aMessage) {
+      let result = this._prepareMessageForRemote(aMessage.wrappedJSObject);
+      result._type = CACHED_MESSAGES.ConsoleAPI;
+      return result;
+    }, this);
+  },
+
+  /**
+   * Destroy the console API listener.
+   */
+  destroy: function CAL_destroy()
+  {
+    Services.obs.removeObserver(this, "console-api-log-event");
+    this.window = this.owner = null;
+  },
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// JavaScript Terminal
+///////////////////////////////////////////////////////////////////////////////
+
+
+/**
+ * JSTerm helper functions.
+ *
+ * Defines a set of functions ("helper functions") that are available from the
+ * Web Console but not from the web page.
+ *
+ * A list of helper functions used by Firebug can be found here:
+ *   http://getfirebug.com/wiki/index.php/Command_Line_API
+ *
+ * @param object aOwner
+ *        The owning object.
+ */
+function JSTermHelper(aOwner)
+{
+  /**
+   * Find a node by ID.
+   *
+   * @param string aId
+   *        The ID of the element you want.
+   * @return nsIDOMNode or null
+   *         The result of calling document.querySelector(aSelector).
+   */
+  aOwner.sandbox.$ = function JSTH_$(aSelector)
+  {
+    return aOwner.window.document.querySelector(aSelector);
+  };
+
+  /**
+   * Find the nodes matching a CSS selector.
+   *
+   * @param string aSelector
+   *        A string that is passed to window.document.querySelectorAll.
+   * @return nsIDOMNodeList
+   *         Returns the result of document.querySelectorAll(aSelector).
+   */
+  aOwner.sandbox.$$ = function JSTH_$$(aSelector)
+  {
+    return aOwner.window.document.querySelectorAll(aSelector);
+  };
+
+  /**
+   * Runs an xPath query and returns all matched nodes.
+   *
+   * @param string aXPath
+   *        xPath search query to execute.
+   * @param [optional] nsIDOMNode aContext
+   *        Context to run the xPath query on. Uses window.document if not set.
+   * @returns array of nsIDOMNode
+   */
+  aOwner.sandbox.$x = function JSTH_$x(aXPath, aContext)
+  {
+    let nodes = [];
+    let doc = aOwner.window.document;
+    let aContext = aContext || doc;
+
+    try {
+      let results = doc.evaluate(aXPath, aContext, null,
+                                 Ci.nsIDOMXPathResult.ANY_TYPE, null);
+      let node;
+      while (node = results.iterateNext()) {
+        nodes.push(node);
+      }
+    }
+    catch (ex) {
+      aOwner.window.console.error(ex.message);
+    }
+
+    return nodes;
+  };
+
+  /**
+   * Returns the currently selected object in the highlighter.
+   *
+   * Warning: this implementation crosses the process boundaries! This is not
+   * usable within a remote browser. To implement this feature correctly we need
+   * support for remote inspection capabilities within the Inspector as well.
+   *
+   * TODO: file a bug about this issue.
+   *
+   * @return nsIDOMElement|null
+   *         The DOM element currently selected in the highlighter.
+   */
+  Object.defineProperty(aOwner.sandbox, "$0", {
+    get: function() {
+      try {
+        return aOwner._xulWindow().InspectorUI.selection;
+      }
+      catch (ex) {
+        aOwner.window.console.error(ex.message);
+      }
+    },
+    enumerable: true,
+    configurable: false
+  });
+
+  /**
+   * Clears the output of the JSTerm.
+   */
+  aOwner.sandbox.clear = function JSTH_clear()
+  {
+    aOwner._helperResult = {
+      type: "clearOutput",
+    };
+  };
+
+  /**
+   * Returns the result of Object.keys(aObject).
+   *
+   * @param object aObject
+   *        Object to return the property names from.
+   * @returns array of string
+   */
+  aOwner.sandbox.keys = function JSTH_keys(aObject)
+  {
+    return Object.keys(WebConsoleUtils.unwrap(aObject));
+  };
+
+  /**
+   * Returns the values of all properties on aObject.
+   *
+   * @param object aObject
+   *        Object to display the values from.
+   * @returns array of string
+   */
+  aOwner.sandbox.values = function JSTH_values(aObject)
+  {
+    let arrValues = [];
+    let obj = WebConsoleUtils.unwrap(aObject);
+
+    try {
+      for (let prop in obj) {
+        arrValues.push(obj[prop]);
+      }
+    }
+    catch (ex) {
+      aOwner.window.console.error(ex.message);
+    }
+
+    return arrValues;
+  };
+
+  /**
+   * Opens a help window in MDN.
+   */
+  aOwner.sandbox.help = function JSTH_help()
+  {
+    aOwner._helperResult = {};
+    aOwner.window.open(
+        "https://developer.mozilla.org/AppLinks/WebConsoleHelp?locale=" +
+        aOwner.window.navigator.language, "help", "");
+  };
+
+  /**
+   * Inspects the passed aObject. This is done by opening the PropertyPanel.
+   *
+   * @param object aObject
+   *        Object to inspect.
+   */
+  aOwner.sandbox.inspect = function JSTH_inspect(aObject)
+  {
+    let obj = WebConsoleUtils.unwrap(aObject);
+    if (!WebConsoleUtils.isObjectInspectable(obj)) {
+      return aObject;
+    }
+
+    aOwner._helperResult = {
+      type: "inspectObject",
+      input: aOwner._evalInput,
+      object: aOwner.createValueGrip(obj),
+    };
+  };
+
+  /**
+   * Prints aObject to the output.
+   *
+   * @param object aObject
+   *        Object to print to the output.
+   * @return string
+   */
+  aOwner.sandbox.pprint = function JSTH_pprint(aObject)
+  {
+    if (aObject === null || aObject === undefined || aObject === true ||
+        aObject === false) {
+      aOwner._helperResult = {};
+      aOwner.window.console
+        .error(WebConsoleUtils.l10n.getStr("helperFuncUnsupportedTypeError"));
+      return;
+    }
+
+    aOwner._helperResult = { rawOutput: true };
+
+    if (typeof aObject == "function") {
+      return aObject + "\n";
+    }
+
+    let output = [];
+    let getObjectGrip = WebConsoleUtils.getObjectGrip.bind(WebConsoleUtils);
+    let obj = WebConsoleUtils.unwrap(aObject);
+    let props = WebConsoleUtils.inspectObject(obj, getObjectGrip);
+    props.forEach(function(aProp) {
+      output.push(aProp.name + ": " +
+                  WebConsoleUtils.getPropertyPanelValue(aProp));
+    });
+
+    return "  " + output.join("\n  ");
+  };
+
+  /**
+   * Print a string to the output, as-is.
+   *
+   * @param string aString
+   *        A string you want to output.
+   * @returns void
+   */
+  aOwner.sandbox.print = function JSTH_print(aString)
+  {
+    aOwner._helperResult = { rawOutput: true };
+    return String(aString);
+  };
+}
