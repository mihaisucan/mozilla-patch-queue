# HG changeset patch
# Parent 151e47aa39484596eb32c3c5ad95e469e1e4fdf2
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1344629669 -10800
Bug 768096 - Web Console remote debugging protocol support - Part 2: window.console API

diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -1150,16 +1150,17 @@ WebConsole.prototype = {
  *        The Web Console instance that owns this connection proxy.
  */
 function WebConsoleConnectionProxy(aWebConsole)
 {
   this.owner = aWebConsole;
 
   this._onCachedMessages = this._onCachedMessages.bind(this);
   this._onPageError = this._onPageError.bind(this);
+  this._onConsoleAPICall = this._onConsoleAPICall.bind(this);
 }
 
 WebConsoleConnectionProxy.prototype = {
   /**
    * The owning Web Console instance.
    *
    * @see WebConsole
    * @type object
@@ -1191,18 +1192,20 @@ WebConsoleConnectionProxy.prototype = {
    *        Optional function to invoke when connection is established.
    */
   connect: function WCCP_connect(aCallback)
   {
     let transport = DebuggerServer.connectPipe();
     let client = this.client = new DebuggerClient(transport);
 
     client.addListener("pageError", this._onPageError);
+    client.addListener("consoleAPICall", this._onConsoleAPICall);
 
-    let listeners = [WebConsoleClient.prototype.LISTENERS.PageError];
+    let listeners = [WebConsoleClient.prototype.LISTENERS.PageError,
+                     WebConsoleClient.prototype.LISTENERS.ConsoleAPI];
 
     client.connect(function(aType, aTraits) {
       client.listTabs(function(aResponse) {
         let tab = aResponse.tabs[aResponse.selected];
         client.attachConsole(tab.consoleActor, listeners,
                              this._onAttachConsole.bind(this, aCallback));
       }.bind(this));
     }.bind(this));
@@ -1256,25 +1259,35 @@ WebConsoleConnectionProxy.prototype = {
    * for displaying.
    */
   _onPageError: function WCCP__onPageError(aType, aPacket)
   {
     this.owner.ui.handlePageError(aPacket.pageError);
   },
 
   /**
+   * The "consoleAPICall" message type handler. We redirect any message to
+   * the UI for displaying.
+   */
+  _onConsoleAPICall: function WCCP__onConsoleAPICall(aType, aPacket)
+  {
+    this.owner.ui.handleConsoleAPICall(aPacket.message);
+  },
+
+  /**
    * Disconnect the Web Console from the remote server.
    */
   disconnect: function WCCP_disconnect()
   {
     if (!this.client) {
       return;
     }
 
     this.client.removeListener("pageError", this._onPageError);
+    this.client.removeListener("consoleAPICall", this._onConsoleAPICall);
     this.client.close();
 
     this.client = null;
     this.webConsoleClient = null;
     this.connected = false;
   },
 };
 
diff --git a/browser/devtools/webconsole/PropertyPanel.jsm b/browser/devtools/webconsole/PropertyPanel.jsm
--- a/browser/devtools/webconsole/PropertyPanel.jsm
+++ b/browser/devtools/webconsole/PropertyPanel.jsm
@@ -22,37 +22,38 @@ var EXPORTED_SYMBOLS = ["PropertyPanel",
 
 /**
  * This is an implementation of the nsITreeView interface. For comments on the
  * interface properties, see the documentation:
  * https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsITreeView
  */
 var PropertyTreeView = function() {
   this._rows = [];
-  this._objectCache = {};
+  this._objectCache = [];
 };
 
 PropertyTreeView.prototype = {
   /**
    * Stores the visible rows of the tree.
    * @private
    */
   _rows: null,
 
   /**
    * Stores the nsITreeBoxObject for this tree.
    * @private
    */
   _treeBox: null,
 
   /**
-   * Stores cached information about local objects being inspected.
+   * Holds all of the known IDs of object actors.
    * @private
+   * @type array
    */
-  _objectCache: null,
+  _objectActors: null,
 
   /**
    * Use this setter to update the content of the tree.
    *
    * @param object aData
    *        A meta object that holds information about the object you want to
    *        display in the property panel. Object properties:
    *        - object:
@@ -88,29 +89,26 @@ PropertyTreeView.prototype = {
     let oldLen = this._rows.length;
 
     this._cleanup();
 
     if (!aData) {
       return;
     }
 
-    if (aData.remoteObject) {
-      this._rootCacheId = aData.rootCacheId;
-      this._panelCacheId = aData.panelCacheId;
-      this._remoteObjectProvider = aData.remoteObjectProvider;
-      this._rows = [].concat(aData.remoteObject);
-      this._updateRemoteObject(this._rows, 0);
+    if (aData.objectActor) {
+      this._objectPropertiesProvider = aData.objectPropertiesProvider;
+      this._rows = this._propertiesToRows(aData.objectProperties, 0);
     }
     else if (aData.object) {
       this._rows = this._inspectObject(aData.object);
     }
     else {
-      throw new Error("First argument must have a .remoteObject or " +
-                      "an .object property!");
+      throw new Error("First argument must have an objectActor or an " +
+                      "object property!");
     }
 
     if (this._treeBox) {
       this._treeBox.beginUpdateBatch();
       if (oldLen) {
         this._treeBox.rowCountChanged(0, -oldLen);
       }
       this._treeBox.rowCountChanged(0, this._rows.length);
@@ -123,23 +121,32 @@ PropertyTreeView.prototype = {
    * adds properties to each array element.
    *
    * @private
    * @param array aObject
    *        The remote object you want prepared for use with the tree view.
    * @param number aLevel
    *        The level you want to give to each property in the remote object.
    */
-  _updateRemoteObject: function PTV__updateRemoteObject(aObject, aLevel)
+  _propertiesToRows: function PTV__propertiesToRows(aObject, aLevel)
   {
-    aObject.forEach(function(aElement) {
-      aElement.level = aLevel;
-      aElement.isOpened = false;
-      aElement.children = null;
-    });
+    let result = [];
+    for (let prop in aObject) {
+      let descriptor = aObject[prop];
+      descriptor._name = prop;
+      descriptor._level = aLevel;
+      descriptor._open = false;
+      descriptor._children = null;
+      result.push(descriptor);
+      if (typeof descriptor.value == "object" &&
+          descriptor.value.actor) {
+        this._objectActors.push(descriptor.value.actor);
+      }
+    }
+    return result;
   },
 
   /**
    * Inspect a local object.
    *
    * @private
    * @param object aObject
    *        The object you want to inspect.
@@ -184,26 +191,30 @@ PropertyTreeView.prototype = {
   /** nsITreeView interface implementation **/
 
   selection: null,
 
   get rowCount()                     { return this._rows.length; },
   setTree: function(treeBox)         { this._treeBox = treeBox;  },
   getCellText: function(idx, column) {
     let row = this._rows[idx];
-    return row.name + ": " + row.value;
+    return row._name + ": " +
+           (row.get ?
+            "Getter" :
+            WebConsoleUtils.objectActorGripToString(row.value));
   },
   getLevel: function(idx) {
-    return this._rows[idx].level;
+    return this._rows[idx]._level;
   },
   isContainer: function(idx) {
-    return !!this._rows[idx].inspectable;
+    return typeof this._rows[idx].value == "object" &&
+           this._rows[idx].value.type == "object";
   },
   isContainerOpen: function(idx) {
-    return this._rows[idx].isOpened;
+    return this._rows[idx]._open;
   },
   isContainerEmpty: function(idx)    { return false; },
   isSeparator: function(idx)         { return false; },
   isSorted: function()               { return false; },
   isEditable: function(idx, column)  { return false; },
   isSelectable: function(row, col)   { return true; },
 
   getParentIndex: function(idx)
@@ -216,71 +227,66 @@ PropertyTreeView.prototype = {
         return t;
       }
     }
     return -1;
   },
 
   hasNextSibling: function(idx, after)
   {
-    var thisLevel = this.getLevel(idx);
-    return this._rows.slice(after + 1).some(function (r) r.level == thisLevel);
+    let thisLevel = this.getLevel(idx);
+    return this._rows.slice(after + 1).some(function (r) r._level == thisLevel);
   },
 
   toggleOpenState: function(idx)
   {
     let item = this._rows[idx];
-    if (!item.inspectable) {
+    if (!this.isContainer(idx)) {
       return;
     }
 
-    if (item.isOpened) {
+    if (item._open) {
       this._treeBox.beginUpdateBatch();
-      item.isOpened = false;
+      item._open = false;
 
-      var thisLevel = item.level;
+      var thisLevel = item._level;
       var t = idx + 1, deleteCount = 0;
       while (t < this._rows.length && this.getLevel(t++) > thisLevel) {
         deleteCount++;
       }
 
       if (deleteCount) {
         this._rows.splice(idx + 1, deleteCount);
         this._treeBox.rowCountChanged(idx + 1, -deleteCount);
       }
       this._treeBox.invalidateRow(idx);
       this._treeBox.endUpdateBatch();
     }
     else {
       let levelUpdate = true;
-      let callback = function _onRemoteResponse(aResponse) {
+      let callback = function _onRemoteResponse(aProperties) {
         this._treeBox.beginUpdateBatch();
-        item.isOpened = true;
-
         if (levelUpdate) {
-          this._updateRemoteObject(aResponse.object, item.level + 1);
-          item.children = aResponse.object;
+          item._children = this._propertiesToRows(aProperties, item._level + 1);
         }
 
-        this._rows.splice.apply(this._rows, [idx + 1, 0].concat(item.children));
+        this._rows.splice.apply(this._rows, [idx + 1, 0].concat(item._children));
 
-        this._treeBox.rowCountChanged(idx + 1, item.children.length);
+        this._treeBox.rowCountChanged(idx + 1, item._children.length);
         this._treeBox.invalidateRow(idx);
         this._treeBox.endUpdateBatch();
+        item._open = true;
       }.bind(this);
 
-      if (!item.children) {
-        let fromCacheId = item.level > 0 ? this._panelCacheId :
-                                           this._rootCacheId;
-        this._remoteObjectProvider(fromCacheId, item.objectId,
-                                   this._panelCacheId, callback);
+      if (!item._children) {
+        this._objectPropertiesProvider(item.value.actor, callback);
       }
       else {
         levelUpdate = false;
-        callback({object: item.children});
+        callback(item._children);
       }
     }
   },
 
   getImageSrc: function(idx, column) { },
   getProgressMode : function(idx,column) { },
   getCellValue: function(idx, column) { },
   cycleHeader: function(col, elem) { },
@@ -297,24 +303,25 @@ PropertyTreeView.prototype = {
   setCellText: function(row, col, value)                { },
   drop: function(index, orientation, dataTransfer)      { },
   canDrop: function(index, orientation, dataTransfer)   { return false; },
 
   _cleanup: function PTV__cleanup()
   {
     if (this._rows.length) {
       // Reset the existing _rows children to the initial state.
-      this._updateRemoteObject(this._rows, 0);
       this._rows = [];
     }
 
-    delete this._objectCache;
-    delete this._rootCacheId;
-    delete this._panelCacheId;
-    delete this._remoteObjectProvider;
+    if (this._objectActors.length) {
+      // TODO: release object actors.
+    }
+
+    delete this._objectActors;
+    delete this._objectPropertiesProvider;
   },
 };
 
 ///////////////////////////////////////////////////////////////////////////
 //// Helper for creating the panel.
 
 /**
  * Creates a DOMNode and sets all the attributes of aAttributes on the created
diff --git a/browser/devtools/webconsole/WebConsoleUtils.jsm b/browser/devtools/webconsole/WebConsoleUtils.jsm
--- a/browser/devtools/webconsole/WebConsoleUtils.jsm
+++ b/browser/devtools/webconsole/WebConsoleUtils.jsm
@@ -223,28 +223,37 @@ var WebConsoleUtils = {
    * @param mixed aResult
    *        The evaluation result object you want displayed.
    * @return string
    *         The string that can be displayed.
    */
   formatResult: function WCU_formatResult(aResult)
   {
     let output = "";
-    let type = this.getResultType(aResult);
+    let type = null;
+    try {
+      type = this.getResultType(aResult);
+    }
+    catch (ex) { }
 
     switch (type) {
       case "string":
         output = this.formatResultString(aResult);
         break;
       case "boolean":
       case "date":
       case "error":
       case "number":
       case "regexp":
-        output = aResult.toString();
+        try {
+          output = aResult + "";
+        }
+        catch (ex) {
+          output = ex;
+        }
         break;
       case "null":
       case "undefined":
         output = type;
         break;
       default:
         try {
           if (aResult.toSource) {
@@ -659,16 +668,29 @@ var WebConsoleUtils = {
       let requestURI = Services.io.newURI(aRequest, null, null);
       let contentURI = Services.io.newURI(aLocation, null, null);
       return (contentURI.scheme == "https" && requestURI.scheme != "https");
     }
     catch (ex) {
       return false;
     }
   },
+
+  objectActorGripToString: function WCU_objectActorGripToString(aGrip)
+  {
+    // Primitives like strings and numbers are not sent as objects.
+    // But null and undefined are sent as objects with the type property
+    // telling which type of value we have.
+    if (typeof aGrip == "object") {
+      return aGrip.type == "object" ?
+             aGrip.displayString :
+             aGrip.type;
+    }
+    return aGrip + "";
+  },
 };
 
 //////////////////////////////////////////////////////////////////////////
 // Localization
 //////////////////////////////////////////////////////////////////////////
 
 WebConsoleUtils.l10n = {
   /**
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -531,23 +531,16 @@ WebConsoleFrame.prototype = {
         this.owner._receiveMessageWithCallback(aMessage.json);
         break;
       case "JSTerm:ClearOutput":
         this.jsterm.clearOutput();
         break;
       case "JSTerm:InspectObject":
         this.jsterm.handleInspectObject(aMessage.json);
         break;
-      case "WebConsole:ConsoleAPI":
-        this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage,
-                           [aMessage.json]);
-        break;
-      case "WebConsole:PageError":
-        this.handlePageError(aMessage.json.pageError);
-        break;
       case "WebConsole:CachedMessages":
         this._displayCachedConsoleMessages(aMessage.json.messages);
         this.owner._onMessageManagerInitComplete();
         break;
       case "WebConsole:NetworkActivity":
         this.handleNetworkActivity(aMessage.json);
         break;
       case "WebConsole:FileActivity":
@@ -925,35 +918,35 @@ WebConsoleFrame.prototype = {
    *         The message element to display in the Web Console output.
    */
   logConsoleAPIMessage: function WCF_logConsoleAPIMessage(aMessage)
   {
     let body = null;
     let clipboardText = null;
     let sourceURL = null;
     let sourceLine = 0;
-    let level = aMessage.apiMessage.level;
-    let args = aMessage.apiMessage.arguments;
-    let argsToString = aMessage.argumentsToString;
+    let level = aMessage.level;
+    let args = aMessage.arguments;
 
     switch (level) {
       case "log":
       case "info":
       case "warn":
       case "error":
-      case "debug":
-        body = {
-          cacheId: aMessage.objectsCacheId,
-          remoteObjects: args,
-          argsToString: argsToString,
-        };
-        clipboardText = argsToString.join(" ");
-        sourceURL = aMessage.apiMessage.filename;
-        sourceLine = aMessage.apiMessage.lineNumber;
+      case "debug": {
+        body = { arguments: args };
+        let clipboardArray = [];
+        args.forEach(function(aValue) {
+          clipboardArray.push(WebConsoleUtils.objectActorGripToString(aValue));
+        });
+        clipboardText = clipboardArray.join(" ");
+        sourceURL = aMessage.filename;
+        sourceLine = aMessage.lineNumber;
         break;
+      }
 
       case "trace":
         let filename = WebConsoleUtils.abbreviateSourceURL(args[0].filename);
         let functionName = args[0].functionName ||
                            l10n.getStr("stacktrace.anonymousFunction");
         let lineNumber = args[0].lineNumber;
 
         body = l10n.getFormatStr("stacktrace.outputMessage",
@@ -1065,64 +1058,74 @@ WebConsoleFrame.prototype = {
         node.querySelector("tree").view = node.propertyTreeView;
       };
     }
 
     return node;
   },
 
   /**
+   * Handle ConsoleAPICall objects received from the server. This method outputs
+   * the window.console API call.
+   *
+   * @param object aMessage
+   *        The console API message received from the server.
+   */
+  handleConsoleAPICall: function WCF_handleConsoleAPICall(aMessage)
+  {
+    this.outputMessage(CATEGORY_WEBDEV, this.logConsoleAPIMessage, [aMessage]);
+  },
+
+  /**
    * The click event handler for objects shown inline coming from the
    * window.console API.
    *
    * @private
    * @param nsIDOMNode aMessage
    *        The message element this handler corresponds to.
    * @param nsIDOMNode aAnchor
    *        The object inspector anchor element. This is the clickable element
    *        in the console.log message we display.
-   * @param array aRemoteObject
-   *        The remote object representation.
+   * @param object aObjectActor
+   *        The object actor grip.
    */
   _consoleLogClick:
-  function WCF__consoleLogClick(aMessage, aAnchor, aRemoteObject)
+  function WCF__consoleLogClick(aMessage, aAnchor, aObjectActor)
   {
     if (aAnchor._panelOpen) {
       return;
     }
 
     let options = {
       title: aAnchor.textContent,
       anchor: aAnchor,
 
       // Data to inspect.
       data: {
-        // This is where the resultObject children are cached.
-        rootCacheId: aMessage._evalCacheId,
-        remoteObject: aRemoteObject,
-        // This is where all objects retrieved by the panel will be cached.
-        panelCacheId: "HUDPanel-" + gSequenceId(),
-        remoteObjectProvider: this.jsterm.remoteObjectProvider.bind(this.jsterm),
+        objectPropertiesProvider: this.objectPropertiesProvider.bind(this),
       },
     };
 
-    let propPanel = this.jsterm.openPropertyPanel(options);
-    propPanel.panel.setAttribute("hudId", this.hudId);
-
     let onPopupHide = function JST__evalInspectPopupHide() {
       propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
 
       this.jsterm.clearObjectCache(options.data.panelCacheId);
 
       if (!aMessage.parentNode && aMessage._evalCacheId) {
         this.jsterm.clearObjectCache(aMessage._evalCacheId);
       }
     }.bind(this);
 
-    propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+    this.objectPropertiesProvider(aObjectAnchor,
+      function _onObjectProperties(aProperties) {
+        options.data.objectProperties = aProperties;
+        let propPanel = this.jsterm.openPropertyPanel(options);
+        propPanel.panel.setAttribute("hudId", this.hudId);
+        propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+      });
   },
 
   /**
    * Reports an error in the page source, either JavaScript or CSS.
    *
    * @param nsIScriptError aScriptError
    *        The error message to report.
    * @return nsIDOMElement|undefined
@@ -2005,54 +2008,59 @@ WebConsoleFrame.prototype = {
    * @private
    * @param nsIDOMElement aMessage
    *        The message element that holds the output for the given call.
    * @param nsIDOMElement aContainer
    *        The specific element that will hold each part of the console.log
    *        output.
    * @param object aBody
    *        The object given by this.logConsoleAPIMessage(). This object holds
-   *        the call information that we need to display.
+   *        the call information that we need to display - mainly the arguments
+   *        array of the given API call.
    */
   _makeConsoleLogMessageBody:
   function WCF__makeConsoleLogMessageBody(aMessage, aContainer, aBody)
   {
-    aMessage._evalCacheId = aBody.cacheId;
+    aMessage._objectActors = [];
 
     Object.defineProperty(aMessage, "_panelOpen", {
       get: function() {
         let nodes = aContainer.querySelectorAll(".hud-clickable");
         return Array.prototype.some.call(nodes, function(aNode) {
           return aNode._panelOpen;
         });
       },
       enumerable: true,
       configurable: false
     });
 
-    aBody.remoteObjects.forEach(function(aItem, aIndex) {
+    aBody.arguments.forEach(function(aItem) {
       if (aContainer.firstChild) {
         aContainer.appendChild(this.document.createTextNode(" "));
       }
 
-      let text = aBody.argsToString[aIndex];
-      if (!Array.isArray(aItem)) {
+      let text = WebConsoleUtils.objectActorGripToString(aItem);
+
+      if (typeof aItem != "object" || aItem.type != "object") {
         aContainer.appendChild(this.document.createTextNode(text));
         return;
       }
 
+      // For inspectable objects.
       let elem = this.document.createElement("description");
       elem.classList.add("hud-clickable");
       elem.setAttribute("aria-haspopup", "true");
       elem.appendChild(this.document.createTextNode(text));
 
       this._addMessageLinkCallback(elem,
         this._consoleLogClick.bind(this, aMessage, elem, aItem));
 
       aContainer.appendChild(elem);
+
+      aMessage._objectActors.push(aItem.actor);
     }, this);
   },
 
   /**
    * Creates the XUL label that displays the textual location of an incoming
    * message.
    *
    * @param string aSourceURL
diff --git a/toolkit/devtools/debugger/server/dbg-webconsole-actors.js b/toolkit/devtools/debugger/server/dbg-webconsole-actors.js
--- a/toolkit/devtools/debugger/server/dbg-webconsole-actors.js
+++ b/toolkit/devtools/debugger/server/dbg-webconsole-actors.js
@@ -37,59 +37,153 @@ const CACHED_MESSAGES = {
  *        The connection to the client, DebuggerServerConnection.
  * @param nsIDOMElement aBrowser
  *        The xul:browser we work with.
  */
 function WebConsoleActor(aConnection, aBrowser)
 {
   this.conn = aConnection;
   this._browser = aBrowser;
+
+  this._objectActorsPool = new ActorPool(this.conn);
+  this.conn.addActorPool(this._objectActorsPool);
+
+  this._objectActors = new WeakMap();
 }
 
 WebConsoleActor.prototype =
 {
   /**
    * The xul:browser we work with.
    * @private
    * @type nsIDOMElement
    */
   _browser: null,
 
   /**
+   * Actor pool for all of the object actors for objects we send to the client.
+   * @private
+   * @type object
+   * @see ActorPool
+   * @see this.objectGrip()
+   */
+  _objectActorsPool: null,
+
+  /**
+   * Weak map between objects and their WebConsoleObjectActor wrappers.
+   * @private
+   * @type object
+   */
+  _objectActors: null,
+
+  /**
    * The debugger server connection instance.
    * @type object
    */
   conn: null,
 
   /**
    * The content window we work with.
    * @type nsIDOMWindow
    */
   get contentWindow() this._browser.contentWindow,
 
+  /**
+   * The PageErrorListener instance.
+   * @type object
+   */
+  pageErrorListener: null,
+
+  /**
+   * The ConsoleAPIListener instance.
+   */
+  consoleAPIListener: null,
+
   actorPrefix: "console",
 
   grip: function WCA_grip()
   {
     return { actor: this.actorID };
   },
 
   /**
    * Destroy the current WebConsoleActor instance.
    */
   disconnect: function WCA_disconnect()
   {
     if (this.pageErrorListener) {
       this.pageErrorListener.destroy();
       this.pageErrorListener = null;
     }
+    if (this.consoleAPIListener) {
+      this.consoleAPIListener.destroy();
+      this.consoleAPIListener = null;
+    }
     this.conn = this._browser = null;
   },
 
   /**
+   * Create a grip for the given value.  If the value is an object,
+   * a WebConsoleObjectActor will be created.
+   */
+  createValueGrip: function WCA_createValueGrip(aValue)
+  {
+    let type = typeof(aValue);
+    switch (type) {
+      case "boolean":
+      case "string":
+      case "number":
+        return aValue;
+      case "object":
+        return this.objectGrip(aValue);
+      default:
+        if (aValue === null) {
+          return { type: "null" };
+        }
+
+        if (aValue === undefined) {
+          return { type: "undefined" };
+        }
+
+        dbg_assert(false, "Failed to provide a grip for: " + aValue);
+        return null;
+    }
+  },
+
+  /**
+   * Create a grip for the given object.
+   *
+   * @param object aValue
+   *        The object you want.
+   */
+  objectGrip: function TA_objectGrip(aValue)
+  {
+    if (this._objectActors.has(aValue)) {
+      return this._objectActors.get(aValue).grip();
+    }
+
+    let actor = new WebConsoleObjectActor(aValue, this);
+    this._objectActorsPool.addActor(actor);
+    this._objectActors.set(aValue, actor);
+    return actor.grip();
+  },
+
+  /**
+   * Release an object grip for the given object actor.
+   *
+   * @param object aActor
+   *        The WebConsoleObjectActor instance you want to release.
+   */
+  releaseObject: function WCA_releaseObject(aActor)
+  {
+    this._objectActors.delete(aActor.obj);
+    this._objectActorsPool.removeActor(aActor.actorID);
+  },
+
+  /**
    * Handler for the "startListeners" request.
    *
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
    */
   onStartListeners: function WCA_onStartListeners(aRequest)
   {
     let startedListeners = [];
@@ -100,16 +194,24 @@ WebConsoleActor.prototype =
         case LISTENERS.PageError:
           if (!this.pageErrorListener) {
             this.pageErrorListener =
               new PageErrorListener(this.contentWindow, this);
             this.pageErrorListener.init();
           }
           startedListeners.push(listener);
           break;
+        case LISTENERS.ConsoleAPI:
+          if (!this.consoleAPIListener) {
+            this.consoleAPIListener =
+              new ConsoleAPIListener(this.contentWindow, this);
+            this.consoleAPIListener.init();
+          }
+          startedListeners.push(listener);
+          break;
       }
     }
     return { startedListeners: startedListeners };
   },
 
   /**
    * Handler for the "stopListeners" request.
    *
@@ -133,16 +235,23 @@ WebConsoleActor.prototype =
       switch (listener) {
         case LISTENERS.PageError:
           if (this.pageErrorListener) {
             this.pageErrorListener.destroy();
             this.pageErrorListener = null;
           }
           stoppedListeners.push(listener);
           break;
+        case LISTENERS.ConsoleAPI:
+          if (this.consoleAPIListener) {
+            this.consoleAPIListener.destroy();
+            this.consoleAPIListener = null;
+          }
+          stoppedListeners.push(listener);
+          break;
       }
     }
 
     return { stoppedListeners: stoppedListeners };
   },
 
   /**
    * Handler for the "getCachedMessages" request. This method sends the cached
@@ -189,36 +298,170 @@ WebConsoleActor.prototype =
     };
   },
 
   /**
    * Handler for page errors received from the PageErrorListener. This method
    * sends the nsIScriptError to the remote Web Console client.
    *
    * @param nsIScriptError aPageError
-   *        The page error we need to send to the remote.
+   *        The page error we need to send to the remote client.
    */
   onPageError: function WCA_onPageError(aPageError)
   {
     let packet = {
       from: this.actorID,
       type: "pageError",
       pageError: aPageError,
     };
     this.conn.send(packet);
   },
+
+  /**
+   * Handler for window.console API calls received from the ConsoleAPIListener.
+   * This method sends the object to the remote Web Console client.
+   *
+   * @param object aMessage
+   *        The console API call we need to send to the remote client.
+   */
+  onConsoleAPICall: function WCA_onConsoleAPICall(aMessage)
+  {
+    let packet = {
+      from: this.actorID,
+      type: "consoleAPICall",
+      message: aMessage,
+    };
+    this.conn.send(packet);
+  },
 };
 
 WebConsoleActor.prototype.requestTypes =
 {
   getCachedMessages: WebConsoleActor.prototype.onGetCachedMessages,
   startListeners: WebConsoleActor.prototype.onStartListeners,
   stopListeners: WebConsoleActor.prototype.onStopListeners,
 };
 
+/**
+ * Creates an actor for the specified object.
+ *
+ * @constructor
+ * @param object aObj
+ *        The object you want.
+ * @param object aWebConsoleActor
+ *        The parent WebConsoleActor instance for this object.
+ */
+function WebConsoleObjectActor(aObj, aWebConsoleActor)
+{
+  this.obj = aObj;
+  this.parentActor = aWebConsoleActor;
+}
+
+WebConsoleObjectActor.prototype =
+{
+  actorPrefix: "consoleObj",
+
+  /**
+   * Returns a grip for this actor for returning in a protocol message.
+   */
+  grip: function WCOA_grip()
+  {
+    return {
+      "type": "object",
+      "displayString": WebConsoleUtils.formatResult(this.obj),
+      "actor": this.actorID,
+    };
+  },
+
+  /**
+   * Releases this actor from the pool.
+   */
+  release: function WCOA_release()
+  {
+    this.parentActor.releaseObject(this);
+  },
+
+  /**
+   * Handle a protocol request to provide the names of the properties defined on
+   * the object and not its prototype.
+   *
+   * @param aRequest object
+   *        The protocol request object.
+   */
+  onOwnProperties: function WCOA_onOwnProperties(aRequest)
+  {
+    let ownProperties = {};
+
+    for each (let name in Object.getOwnPropertyNames(this.obj)) {
+      let desc = null;
+      try {
+        desc = Object.getOwnPropertyDescriptor(this.obj, name);
+      }
+      catch (ex if (ex.name == "NS_ERROR_XPC_BAD_CONVERT_JS" ||
+                    ex.name == "NS_ERROR_XPC_BAD_OP_ON_WN_PROTO")) {
+        // Calling getOwnPropertyDescriptor on wrapped native prototypes is not
+        // allowed.
+        dumpn("Error while getting the property descriptor for " + name +
+              ": " + ex);
+      }
+
+      if (desc) {
+        ownProperties[name] = this._propertyDescriptor(desc);
+      }
+    }
+
+    return {
+      from: this.actorID,
+      ownProperties: ownProperties,
+    };
+  },
+
+  /**
+   * A helper method that creates a property descriptor for the provided object,
+   * properly formatted for sending in a protocol response.
+   *
+   * @private
+   * @param aObject object
+   *        The object that the descriptor is generated for.
+   */
+  _propertyDescriptor: function WCOA__propertyDescriptor(aObject)
+  {
+    let descriptor = {};
+    descriptor.configurable = aObject.configurable;
+    descriptor.enumerable = aObject.enumerable;
+    descriptor.writable = aObject.writable;
+    if (aObject.value !== undefined) {
+      descriptor.value = this.parentActor.createValueGrip(aObject.value);
+    }
+    else {
+      descriptor.get = this.parentActor.createValueGrip(aObject.get);
+      descriptor.set = this.parentActor.createValueGrip(aObject.set);
+    }
+    return descriptor;
+  },
+
+  /**
+   * Handle a protocol request to release a thread-lifetime grip.
+   *
+   * @param aRequest object
+   *        The protocol request object.
+   */
+  onRelease: function WCOA_onRelease(aRequest)
+  {
+    this.release();
+    return {};
+  },
+};
+
+WebConsoleObjectActor.prototype.requestTypes =
+{
+  "ownProperties": WebConsoleObjectActor.prototype.onOwnProperties,
+  "release": WebConsoleObjectActor.prototype.onRelease,
+};
+
 ///////////////////////////////////////////////////////////////////////////////
 // The page errors listener
 ///////////////////////////////////////////////////////////////////////////////
 
 /**
  * The nsIConsoleService listener. This is used to send all the page errors
  * (JavaScript, CSS and more) to the remote Web Console instance.
  *
@@ -350,8 +593,170 @@ PageErrorListener.prototype =
    * Remove the nsIConsoleService listener.
    */
   destroy: function PEL_destroy()
   {
     Services.console.unregisterListener(this);
     this.listener = this.window = null;
   },
 };
+
+///////////////////////////////////////////////////////////////////////////////
+// The window.console API observer
+///////////////////////////////////////////////////////////////////////////////
+
+/**
+ * The window.console API observer. This allows the window.console API messages
+ * to be sent to the remote Web Console instance.
+ *
+ * @constructor
+ * @param nsIDOMWindow aWindow
+ *        The window object for which we are created.
+ * @param object aOwner
+ *        The owner object must have the following methods:
+ *        - onConsoleAPICall(). This method is invoked with one argument, the
+ *        Console API message that comes from the observer service, whenever
+ *        a relevant console API call is received.
+ *        - createValueGrip(). This method is used to create object actors for
+ *        objects passed to the console API.
+ */
+function ConsoleAPIListener(aWindow, aOwner)
+{
+  this.window = aWindow;
+  this.owner = aOwner;
+}
+
+ConsoleAPIListener.prototype =
+{
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
+
+  /**
+   * The content window for which we listen to window.console API calls.
+   * @type nsIDOMWindow
+   */
+  window: null,
+
+  /**
+   * The owner object which is notified of window.console API calls. It must
+   * have a onConsoleAPICall method which is invoked with one argument: the
+   * console API call object that comes from the observer service.
+   *
+   * @type object
+   * @see WebConsoleActor
+   */
+  owner: null,
+
+  /**
+   * Initialize the window.console API observer.
+   */
+  init: function CAL_init()
+  {
+    // Note that the observer is process-wide. We will filter the messages as
+    // needed, see CAL_observe().
+    Services.obs.addObserver(this, "console-api-log-event", false);
+    dump("CAL_init\n");
+  },
+
+  /**
+   * The console API message observer. When messages are received from the
+   * observer service we forward them to the remote Web Console instance.
+   *
+   * @param object aMessage
+   *        The message object receives from the observer service.
+   * @param string aTopic
+   *        The message topic received from the observer service.
+   */
+  observe: function CAL_observe(aMessage, aTopic)
+  {
+    if (!this.owner || !this.window || !aMessage) {
+      return;
+    }
+
+    let apiMessage = aMessage.wrappedJSObject;
+    let msgWindow = WebConsoleUtils.getWindowByOuterId(apiMessage.ID,
+                                                       this.window);
+    if (!msgWindow || msgWindow.top != this.window) {
+      // Not the same window!
+      return;
+    }
+
+    let messageToClient = this._prepareApiMessageForRemote(apiMessage);
+    this.owner.onConsoleAPICall(messageToClient);
+  },
+
+  /**
+   * Prepare a message from the console APi to be sent to the remote Web Console
+   * instance.
+   *
+   * @param object aOriginalMessage
+   *        The original message received from console-api-log-event.
+   * @return object
+   *         The object that can be sent to the remote client.
+   */
+  _prepareApiMessageForRemote:
+  function CAL__prepareApiMessageForRemote(aOriginalMessage)
+  {
+    let result = WebConsoleUtils.cloneObject(aOriginalMessage, true,
+      function(aKey, aValue, aObject) {
+        // We need to skip the arguments property from the original object.
+        if (aKey == "wrappedJSObject" || aObject === aOriginalMessage &&
+            aKey == "arguments") {
+          return false;
+        }
+        return true;
+      });
+
+    result.arguments = Array.map(aOriginalMessage.arguments || [],
+      function(aObj) {
+        return this.owner.createValueGrip(aObj);
+      }, this);
+
+    return result;
+  },
+
+  /**
+   * Format an object's value to be displayed in the Web Console.
+   *
+   * @private
+   * @param object aObject
+   *        The object you want to display.
+   * @return string
+   *         The string you can display for the given object.
+   */
+  _formatObject: function CAL__formatObject(aObject)
+  {
+    return typeof aObject == "string" ?
+           aObject : WebConsoleUtils.formatResult(aObject);
+  },
+
+
+  /**
+   * Get the cached messages for the current inner window.
+   *
+   * @return array
+   *         The array of cached messages. Each element is a Console API
+   *         prepared to be sent to the remote Web Console instance.
+   */
+  getCachedMessages: function CAL_getCachedMessages()
+  {
+    let innerWindowId = WebConsoleUtils.getInnerWindowId(this.window);
+    let messages = gConsoleStorage.getEvents(innerWindowId);
+    return message; // FIXME?
+  },
+
+  /**
+   * Handler for the "ClearCache" message.
+   */
+  handleClearCache: function CAL_handleClearCache()
+  {
+    let windowId = WebConsoleUtils.getInnerWindowId(this.window);
+    gConsoleStorage.clearEvents(windowId);
+  },
+
+  /**
+   * Destroy the console API listener.
+   */
+  destroy: function CAL_destroy()
+  {
+    Services.obs.removeObserver(this, "console-api-log-event");
+    this.window = this.owner = null;
+  },
+};
