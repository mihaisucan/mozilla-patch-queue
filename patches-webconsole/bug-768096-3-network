# HG changeset patch
# Parent 9dddae4f717c043d84bc55102b45085420e1756d
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1346877118 -10800
Bug 768096 - Web Console remote debugging protocol support - Part 3: network logging

diff --git a/browser/devtools/webconsole/HUDService-content.js b/browser/devtools/webconsole/HUDService-content.js
--- a/browser/devtools/webconsole/HUDService-content.js
+++ b/browser/devtools/webconsole/HUDService-content.js
@@ -13,17 +13,17 @@ let Ci = Components.interfaces;
 let Cu = Components.utils;
 const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
 
 let tempScope = {};
 Cu.import("resource://gre/modules/XPCOMUtils.jsm", tempScope);
 Cu.import("resource://gre/modules/Services.jsm", tempScope);
 Cu.import("resource://gre/modules/ConsoleAPIStorage.jsm", tempScope);
 Cu.import("resource://gre/modules/devtools/WebConsoleUtils.jsm", tempScope);
-Cu.import("resource:///modules/NetworkHelper.jsm", tempScope);
+Cu.import("resource://gre/modules/devtools/NetworkHelper.jsm", tempScope);
 Cu.import("resource://gre/modules/NetUtil.jsm", tempScope);
 
 let XPCOMUtils = tempScope.XPCOMUtils;
 let Services = tempScope.Services;
 let gConsoleStorage = tempScope.ConsoleAPIStorage;
 let WebConsoleUtils = tempScope.WebConsoleUtils;
 let l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 let JSPropertyProvider = tempScope.JSPropertyProvider;
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -525,38 +525,22 @@ WebConsole.prototype = {
    * the content process.
    *
    * @private
    * @type object
    */
   _asyncRequests: null,
 
   /**
-   * Message names that the HUD listens for. These messages come from the remote
-   * Web Console content script.
-   *
-   * @private
-   * @type array
-   */
-  _messageListeners: ["WebConsole:Initialized", "WebConsole:NetworkActivity",
-    "WebConsole:FileActivity", "WebConsole:LocationChange"],
-
-  /**
    * The xul:panel that holds the Web Console when it is positioned as a window.
    * @type nsIDOMElement
    */
   consolePanel: null,
 
   /**
-   * The current tab location.
-   * @type string
-   */
-  contentLocation: "",
-
-  /**
    * Getter for the xul:popupset that holds any popups we open.
    * @type nsIDOMElement
    */
   get mainPopupSet()
   {
     return this.chromeDocument.getElementById("mainPopupSet");
   },
 
@@ -616,17 +600,16 @@ WebConsole.prototype = {
   _onIframeLoad: function WC__onIframeLoad()
   {
     this.iframe.removeEventListener("load", this._onIframeLoad, true);
 
     let position = Services.prefs.getCharPref("devtools.webconsole.position");
 
     this.iframeWindow = this.iframe.contentWindow.wrappedJSObject;
     this.ui = new this.iframeWindow.WebConsoleFrame(this, position);
-    this._setupMessageManager();
   },
 
   /**
    * Create a panel to open the web console if it should float above
    * the content in its own window.
    * @private
    */
   _createOwnWindowPanel: function WC__createOwnWindowPanel()
@@ -761,18 +744,18 @@ WebConsole.prototype = {
   /**
    * Retrieve the Web Console panel title.
    *
    * @return string
    *         The Web Console panel title.
    */
   getPanelTitle: function WC_getPanelTitle()
   {
-    return l10n.getFormatStr("webConsoleWindowTitleAndURL",
-                             [this.contentLocation]);
+    let url = this.ui ? this.ui.contentLocation : "";
+    return l10n.getFormatStr("webConsoleWindowTitleAndURL", [url]);
   },
 
   positions: {
     above: 0, // the childNode index
     below: 2,
     window: null
   },
 
@@ -987,26 +970,26 @@ WebConsole.prototype = {
         message: aMessage,
         callback: aCallback,
       };
     }
     this.messageManager.sendAsyncMessage(aName, aMessage);
   },
 
   /**
-   * Handler for the "WebConsole:LocationChange" message. If the Web Console is
+   * Handler for page location changes. If the Web Console is
    * opened in a panel the panel title is updated.
    *
-   * @param object aMessage
-   *        The message received from the content script. It needs to hold two
-   *        properties: location and title.
+   * @param string aURI
+   *        New page location.
+   * @param string aTitle
+   *        New page title.
    */
-  onLocationChange: function WC_onLocationChange(aMessage)
+  onLocationChange: function WC_onLocationChange(aURI, aTitle)
   {
-    this.contentLocation = aMessage.location;
     if (this.consolePanel) {
       this.consolePanel.label = this.getPanelTitle();
     }
   },
 
   /**
    * Alias for the WebConsoleFrame.setFilterState() method.
    * @see webconsole.js::WebConsoleFrame.setFilterState()
@@ -1028,22 +1011,16 @@ WebConsole.prototype = {
   },
 
   /**
    * Destroy the object. Call this method to avoid memory leaks when the Web
    * Console is closed.
    */
   destroy: function WC_destroy()
   {
-    this.sendMessageToContent("WebConsole:Destroy", {});
-
-    this._messageListeners.forEach(function(aName) {
-      this.messageManager.removeMessageListener(aName, this.ui);
-    }, this);
-
     // Make sure that the console panel does not try to call
     // deactivateHUDForContext() again.
     this.consoleWindowUnregisterOnHide = false;
 
     let popupset = this.mainPopupSet;
     let panels = popupset.querySelectorAll("panel[hudId=" + this.hudId + "]");
     for (let panel of panels) {
       if (panel != this.consolePanel) {
diff --git a/browser/devtools/webconsole/Makefile.in b/browser/devtools/webconsole/Makefile.in
--- a/browser/devtools/webconsole/Makefile.in
+++ b/browser/devtools/webconsole/Makefile.in
@@ -8,16 +8,15 @@ topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 EXTRA_JS_MODULES = \
 		HUDService.jsm \
 		PropertyPanel.jsm \
-		NetworkHelper.jsm \
 		NetworkPanel.jsm \
 		AutocompletePopup.jsm \
 		$(NULL)
 
 TEST_DIRS = test
 
 include $(topsrcdir)/config/rules.mk
diff --git a/browser/devtools/webconsole/NetworkPanel.jsm b/browser/devtools/webconsole/NetworkPanel.jsm
--- a/browser/devtools/webconsole/NetworkPanel.jsm
+++ b/browser/devtools/webconsole/NetworkPanel.jsm
@@ -11,17 +11,17 @@ const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "mimeService", "@mozilla.org/mime;1",
                                    "nsIMIMEService");
 
 XPCOMUtils.defineLazyModuleGetter(this, "NetworkHelper",
-                                  "resource:///modules/NetworkHelper.jsm");
+                                  "resource://gre/modules/devtools/NetworkHelper.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "NetUtil",
                                   "resource://gre/modules/NetUtil.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
 const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js b/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
@@ -24,25 +24,30 @@ function performTest(lastFinishedRequest
   HUDService.lastFinishedRequestCallback = null;
   executeSoon(finishTest);
 }
 
 function test()
 {
   addTab("data:text/html;charset=utf-8,Web Console - bug 600183 test");
 
-  let initialLoad = true;
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
 
-  browser.addEventListener("load", function onLoad() {
-    if (initialLoad) {
-      openConsole(null, function(hud) {
+    openConsole(null, function(hud) {
+      hud.ui.saveRequestAndResponseBodies = true;
 
-        hud.ui.saveRequestAndResponseBodies = true;
-        HUDService.lastFinishedRequestCallback = performTest;
-
-        content.location = TEST_URI;
+      waitForSuccess({
+        name: "saveRequestAndResponseBodies update",
+        validatorFn: function()
+        {
+          return hud.ui.saveRequestAndResponseBodies;
+        },
+        successFn: function()
+        {
+          HUDService.lastFinishedRequestCallback = performTest;
+          content.location = TEST_URI;
+        },
+        failureFn: finishTest,
       });
-      initialLoad = false;
-    } else {
-      browser.removeEventListener("load", onLoad, true);
-    }
+    });
   }, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js b/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
@@ -76,18 +76,27 @@ function onpopupshown2(aEvent)
 
     // Reopen the context menu.
     menupopups[1].addEventListener("popupshown", onpopupshown2b, false);
     executeSoon(function() {
       menupopups[1].openPopup();
     });
   }, false);
 
-  executeSoon(function() {
-    menupopups[1].hidePopup();
+  waitForSuccess({
+    name: "saveRequestAndResponseBodies update",
+    validatorFn: function()
+    {
+      return huds[1].ui.saveRequestAndResponseBodies;
+    },
+    successFn: function()
+    {
+      menupopups[1].hidePopup();
+    },
+    failureFn: finishTest,
   });
 }
 
 function onpopupshown2b(aEvent)
 {
   menupopups[1].removeEventListener(aEvent.type, onpopupshown2b, false);
   is(menuitems[1].getAttribute("checked"), "true", "menuitems[1] is checked");
 
@@ -137,18 +146,27 @@ function onpopupshown1(aEvent)
     gBrowser.selectedTab = tabs[1];
     waitForFocus(function() {
       // Reopen the context menu from tab 2.
       menupopups[1].addEventListener("popupshown", onpopupshown2c, false);
       menupopups[1].openPopup();
     }, tabs[1].linkedBrowser.contentWindow);
   }, false);
 
-  executeSoon(function() {
-    menupopups[0].hidePopup();
+  waitForSuccess({
+    name: "saveRequestAndResponseBodies update",
+    validatorFn: function()
+    {
+      return huds[0].ui.saveRequestAndResponseBodies;
+    },
+    successFn: function()
+    {
+      menupopups[0].hidePopup();
+    },
+    failureFn: finishTest,
   });
 }
 
 function onpopupshown2c(aEvent)
 {
   menupopups[1].removeEventListener(aEvent.type, onpopupshown2c, false);
 
   is(menuitems[1].getAttribute("checked"), "true", "menuitems[1] is checked");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js b/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
@@ -12,17 +12,48 @@ const TEST_URI = "http://example.com/bro
 let lastFinishedRequests = {};
 
 function requestDoneCallback(aHttpRequest)
 {
   let status = aHttpRequest.log.entries[0].response.status;
   lastFinishedRequests[status] = aHttpRequest;
 }
 
-function performTest(aEvent)
+function consoleOpened(hud)
+{
+  hud.ui.saveRequestAndResponseBodies = true;
+
+  waitForSuccess({
+    name: "saveRequestAndResponseBodies update",
+    validatorFn: function()
+    {
+      return hud.ui.saveRequestAndResponseBodies;
+    },
+    successFn: function()
+    {
+      HUDService.lastFinishedRequestCallback = requestDoneCallback;
+      waitForSuccess(waitForResponses);
+      content.location = TEST_URI;
+    },
+    failureFn: finishTest,
+  });
+
+  let waitForResponses = {
+    name: "301 and 404 responses",
+    validatorFn: function()
+    {
+      return "301" in lastFinishedRequests &&
+             "404" in lastFinishedRequests;
+    },
+    successFn: performTest,
+    failureFn: finishTest,
+  };
+}
+
+function performTest()
 {
   HUDService.lastFinishedRequestCallback = null;
 
   ok("301" in lastFinishedRequests, "request 1: 301 Moved Permanently");
   ok("404" in lastFinishedRequests, "request 2: 404 Not found");
 
   function readHeader(aName)
   {
@@ -56,24 +87,13 @@ function performTest(aEvent)
   lastFinishedRequests = null;
   executeSoon(finishTest);
 }
 
 function test()
 {
   addTab("data:text/html;charset=utf-8,<p>Web Console test for bug 630733");
 
-  browser.addEventListener("load", function onLoad1(aEvent) {
-    browser.removeEventListener(aEvent.type, onLoad1, true);
-
-    openConsole(null, function(hud) {
-      hud.ui.saveRequestAndResponseBodies = true;
-      HUDService.lastFinishedRequestCallback = requestDoneCallback;
-
-      browser.addEventListener("load", function onLoad2(aEvent) {
-        browser.removeEventListener(aEvent.type, onLoad2, true);
-        executeSoon(performTest);
-      }, true);
-
-      content.location = TEST_URI;
-    });
+  browser.addEventListener("load", function onLoad(aEvent) {
+    browser.removeEventListener(aEvent.type, onLoad, true);
+    openConsole(null, consoleOpened);
   }, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_netlogging.js b/browser/devtools/webconsole/test/browser_webconsole_netlogging.js
--- a/browser/devtools/webconsole/test/browser_webconsole_netlogging.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_netlogging.js
@@ -63,21 +63,35 @@ function testPageLoad()
     executeSoon(testPageLoadBody);
   };
 
   content.location = TEST_NETWORK_REQUEST_URI;
 }
 
 function testPageLoadBody()
 {
+  // Turn on logging of request bodies and check again.
+  hud.ui.saveRequestAndResponseBodies = true;
+
+  waitForSuccess({
+    name: "saveRequestAndResponseBodies update",
+    validatorFn: function()
+    {
+      return hud.ui.saveRequestAndResponseBodies;
+    },
+    successFn: testPageLoadBodyAfterSettingUpdate,
+    failureFn: finishTest,
+  });
+}
+
+function testPageLoadBodyAfterSettingUpdate()
+{
   let loaded = false;
   let requestCallbackInvoked = false;
 
-  // Turn on logging of request bodies and check again.
-  hud.ui.saveRequestAndResponseBodies = true;
   requestCallback = function() {
     ok(lastRequest, "Page load was logged again");
     is(lastRequest.response.content.text.indexOf("<!DOCTYPE HTML>"), 0,
       "Response body's beginning is okay");
 
     lastRequest = null;
     requestCallback = null;
     requestCallbackInvoked = true;
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -214,23 +214,16 @@ WebConsoleFrame.prototype = {
    * the remote server, using the remote debugging protocol.
    *
    * @see WebConsoleConnectionProxy
    * @type object
    */
   proxy: null,
 
   /**
-   * Tells if the Web Console initialization via message manager completed.
-   * @private
-   * @type boolean
-   */
-  _messageManagerInitComplete: false,
-
-  /**
    * Getter for the xul:popupset that holds any popups we open.
    * @type nsIDOMElement
    */
   get popupset() this.owner.mainPopupSet,
 
   /**
    * Holds the network requests currently displayed by the Web Console. Each key
    * represents the connection ID and the value is network request information.
@@ -288,16 +281,22 @@ WebConsoleFrame.prototype = {
   filterPrefs: null,
 
   /**
    * The nesting depth of the currently active console group.
    */
   groupDepth: 0,
 
   /**
+   * The current tab location.
+   * @type string
+   */
+  contentLocation: "",
+
+  /**
    * The JSTerm object that manage the console's input.
    * @see JSTerm
    * @type object
    */
   jsterm: null,
 
   /**
    * The element that holds all of the messages we display.
@@ -335,40 +334,39 @@ WebConsoleFrame.prototype = {
 
   /**
    * Setter for saving of network request and response bodies.
    *
    * @param boolean aValue
    *        The new value you want to set.
    */
   set saveRequestAndResponseBodies(aValue) {
-    this._saveRequestAndResponseBodies = aValue;
-
-    let message = {
-      preferences: {
-        "NetworkMonitor.saveRequestAndResponseBodies":
-          this._saveRequestAndResponseBodies,
-      },
+    let newValue = !!aValue;
+    let preferences = {
+      "NetworkMonitor.saveRequestAndResponseBodies": newValue,
     };
 
-    this.owner.sendMessageToContent("WebConsole:SetPreferences", message);
+    this.webConsoleClient.setPreferences(preferences, function(aResponse) {
+      if (!aResponse.error) {
+        this._saveRequestAndResponseBodies = newValue;
+      }
+    }.bind(this));
   },
 
   /**
    * Connect to the server using the remote debugging protocol.
    * @private
    */
   _initConnection: function WCF__initConnection()
   {
     this.proxy = new WebConsoleConnectionProxy(this);
     this.proxy.initServer();
     this.proxy.connect(function() {
-      if (this._messageManagerInitComplete) {
-        this._onInitComplete();
-      }
+      this.saveRequestAndResponseBodies = this._saveRequestAndResponseBodies;
+      this._onInitComplete();
     }.bind(this));
   },
 
   /**
    * Find the Web Console UI elements and setup event listeners as needed.
    * @private
    */
   _initUI: function WCF__initUI()
@@ -639,60 +637,16 @@ WebConsoleFrame.prototype = {
       this.completeNode.style.fontSize = "";
       this.inputNode.style.fontSize = "";
       this.outputNode.style.fontSize = "";
       Services.prefs.clearUserPref("devtools.webconsole.fontSize");
     }
   },
 
   /**
-   * Handler for all of the messages coming from the Web Console content script.
-   *
-   * @private
-   * @param object aMessage
-   *        A MessageManager object that holds the remote message.
-   */
-  receiveMessage: function WCF_receiveMessage(aMessage)
-  {
-    if (!aMessage.json || aMessage.json.hudId != this.hudId) {
-      return;
-    }
-
-    switch (aMessage.name) {
-      case "WebConsole:Initialized":
-        this._onMessageManagerInitComplete();
-        break;
-      case "WebConsole:NetworkActivity":
-        this.handleNetworkActivity(aMessage.json);
-        break;
-      case "WebConsole:FileActivity":
-        this.outputMessage(CATEGORY_NETWORK, this.logFileActivity,
-                           [aMessage.json.uri]);
-        break;
-      case "WebConsole:LocationChange":
-        this.owner.onLocationChange(aMessage.json);
-        break;
-    }
-  },
-
-  /**
-   * Callback method used to track the Web Console initialization via message
-   * manager.
-   *
-   * @private
-   */
-  _onMessageManagerInitComplete: function WCF__onMessageManagerInitComplete()
-  {
-    this._messageManagerInitComplete = true;
-    if (this.proxy.connected) {
-      this._onInitComplete();
-    }
-  },
-
-  /**
    * The event handler that is called whenever a user switches a filter on or
    * off.
    *
    * @private
    * @param nsIDOMEvent aEvent
    *        The event that triggered the filter change.
    */
   _toggleFilter: function WCF__toggleFilter(aEvent)
@@ -1327,17 +1281,17 @@ WebConsoleFrame.prototype = {
     urlNode.classList.add("hud-clickable");
     urlNode.classList.add("webconsole-msg-body-piece");
     urlNode.classList.add("webconsole-msg-url");
     linkNode.appendChild(urlNode);
 
     let severity = SEVERITY_LOG;
     let mixedRequest =
       WebConsoleUtils.isMixedHTTPSRequest(request.url,
-                                          this.owner.contentLocation);
+                                          this.contentLocation);
     if (mixedRequest) {
       urlNode.classList.add("webconsole-mixed-content");
       this.makeMixedContentNode(linkNode);
       // If we define a SEVERITY_SECURITY in the future, switch this to
       // SEVERITY_SECURITY.
       severity = SEVERITY_WARNING;
     }
 
@@ -1420,73 +1374,87 @@ WebConsoleFrame.prototype = {
       let viewSourceUtils = this.owner.gViewSourceUtils;
       viewSourceUtils.viewSource(aFileURI, null, this.document);
     }.bind(this));
 
     return outputNode;
   },
 
   /**
+   * Handle the file activity messages coming from the remote Web Console.
+   *
+   * @param string aFileURI
+   *        The file URI that was requested.
+   */
+  handleFileActivity: function WCF_handleFileActivity(aFileURI)
+  {
+    this.outputMessage(CATEGORY_NETWORK, this.logFileActivity, [aFileURI]);
+  },
+
+  /**
    * Inform user that the Web Console API has been replaced by a script
    * in a content page.
    */
   logWarningAboutReplacedAPI: function WCF_logWarningAboutReplacedAPI()
   {
     let node = this.createMessageNode(CATEGORY_JS, SEVERITY_WARNING,
                                       l10n.getStr("ConsoleAPIDisabled"));
     this.outputMessage(CATEGORY_JS, node);
   },
 
   /**
-   * Handle the "WebConsole:NetworkActivity" message coming from the remote Web
+   * Handle the network activity messages coming from the remote Web
    * Console.
    *
-   * @param object aMessage
-   *        The HTTP activity object. This object needs to hold two properties:
-   *        - meta - some metadata about the request log:
+   * @param object aLog
+   *        The request and response information. This is a HAR-like
+   *        object. See NetworkMonitor.createActivityObject().
+   * @param object aMeta
+   *        Additional data about the request log:
    *          - stages - the stages the network request went through.
    *          - discardRequestBody and discardResponseBody - booleans that tell
    *          if the network request/response body was discarded or not.
-   *        - log - the request and response information. This is a HAR-like
-   *        object. See HUDService-content.js
-   *        NetworkMonitor.createActivityObject().
    */
-  handleNetworkActivity: function WCF_handleNetworkActivity(aMessage)
+  handleNetworkActivity: function WCF_handleNetworkActivity(aLog, aMeta)
   {
-    let stage = aMessage.meta.stages[aMessage.meta.stages.length - 1];
-    let entry = aMessage.log.entries[0];
+    let stage = aMeta.stages[aMeta.stages.length - 1];
+    let entry = aLog.entries[0];
 
     if (stage == "REQUEST_HEADER") {
       let networkInfo = {
         node: null,
-        httpActivity: aMessage,
+        httpActivity: {
+          log: aLog,
+          meta: aMeta,
+        },
       };
 
       this._networkRequests[entry.connection] = networkInfo;
       this.outputMessage(CATEGORY_NETWORK, this.logNetActivity,
                          [entry.connection]);
       return;
     }
     else if (!(entry.connection in this._networkRequests)) {
       return;
     }
 
     let networkInfo = this._networkRequests[entry.connection];
-    networkInfo.httpActivity = aMessage;
+    networkInfo.httpActivity.meta = aMeta;
+    networkInfo.httpActivity.log = aLog;
 
     if (networkInfo.node) {
       this._updateNetMessage(entry.connection);
     }
 
     // For unit tests we pass the HTTP activity object to the test callback,
     // once requests complete.
     if (this.owner.lastFinishedRequestCallback &&
-        aMessage.meta.stages.indexOf("REQUEST_STOP") > -1 &&
-        aMessage.meta.stages.indexOf("TRANSACTION_CLOSE") > -1) {
-      this.owner.lastFinishedRequestCallback(aMessage);
+        aMeta.stages.indexOf("REQUEST_STOP") > -1 &&
+        aMeta.stages.indexOf("TRANSACTION_CLOSE") > -1) {
+      this.owner.lastFinishedRequestCallback(networkInfo.httpActivity);
     }
   },
 
   /**
    * Update an output message to reflect the latest state of a network request,
    * given a network connection ID.
    *
    * @private
@@ -1552,31 +1520,45 @@ WebConsoleFrame.prototype = {
   {
     let netPanel = new NetworkPanel(this.popupset, aHttpActivity);
     netPanel.linkNode = aNode;
     aNode._netPanel = netPanel;
 
     let panel = netPanel.panel;
     panel.openPopup(aNode, "after_pointer", 0, 0, false, false);
     panel.sizeTo(450, 500);
-    panel.setAttribute("hudId", aHttpActivity.hudId);
+    panel.setAttribute("hudId", this.hudId);
 
     panel.addEventListener("popuphiding", function WCF_netPanel_onHide() {
       panel.removeEventListener("popuphiding", WCF_netPanel_onHide);
 
       aNode._panelOpen = false;
       aNode._netPanel = null;
     });
 
     aNode._panelOpen = true;
 
     return netPanel;
   },
 
   /**
+   * Handler for page location changes.
+   *
+   * @param string aURI
+   *        New page location.
+   * @param string aTitle
+   *        New page title.
+   */
+  onLocationChange: function WCF_onLocationChange(aURI, aTitle)
+  {
+    this.contentLocation = aURI;
+    this.owner.onLocationChange(aURI, aTitle);
+  },
+
+  /**
    * Output a message node. This filters a node appropriately, then sends it to
    * the output, regrouping and pruning output as necessary.
    *
    * Note: this call is async - the given message node may not be displayed when
    * you call this method.
    *
    * @param integer aCategory
    *        The category of the message you want to output. See the CATEGORY_*
@@ -3675,16 +3657,19 @@ CommandController.prototype = {
  *        The Web Console instance that owns this connection proxy.
  */
 function WebConsoleConnectionProxy(aWebConsole)
 {
   this.owner = aWebConsole;
 
   this._onPageError = this._onPageError.bind(this);
   this._onConsoleAPICall = this._onConsoleAPICall.bind(this);
+  this._onNetworkActivity = this._onNetworkActivity.bind(this);
+  this._onFileActivity = this._onFileActivity.bind(this);
+  this._onLocationChange = this._onLocationChange.bind(this);
 }
 
 WebConsoleConnectionProxy.prototype = {
   /**
    * The owning Web Console instance.
    *
    * @see WebConsoleFrame
    * @type object
@@ -3733,23 +3718,29 @@ WebConsoleConnectionProxy.prototype = {
    */
   connect: function WCCP_connect(aCallback)
   {
     let transport = DebuggerServer.connectPipe();
     let client = this.client = new DebuggerClient(transport);
 
     client.addListener("pageError", this._onPageError);
     client.addListener("consoleAPICall", this._onConsoleAPICall);
+    client.addListener("networkActivity", this._onNetworkActivity);
+    client.addListener("fileActivity", this._onFileActivity);
+    client.addListener("locationChange", this._onLocationChange);
 
     let listeners = [WebConsoleClient.prototype.LISTENERS.PageError,
-                     WebConsoleClient.prototype.LISTENERS.ConsoleAPI];
+                     WebConsoleClient.prototype.LISTENERS.ConsoleAPI,
+                     WebConsoleClient.prototype.LISTENERS.NetworkActivity,
+                     WebConsoleClient.prototype.LISTENERS.FileActivity];
 
     client.connect(function(aType, aTraits) {
       client.listTabs(function(aResponse) {
         let tab = aResponse.tabs[aResponse.selected];
+        this.owner.onLocationChange(tab.url, tab.title);
         client.attachConsole(tab.consoleActor, listeners,
                              this._onAttachConsole.bind(this, aCallback));
       }.bind(this));
     }.bind(this));
   },
 
   /**
    * The "attachConsole" response handler.
@@ -3835,16 +3826,61 @@ WebConsoleConnectionProxy.prototype = {
    *        The message received from the server.
    */
   _onConsoleAPICall: function WCCP__onConsoleAPICall(aType, aPacket)
   {
     this.owner.handleConsoleAPICall(aPacket.message);
   },
 
   /**
+   * The "networkActivity" message type handler. We redirect any message to
+   * the UI for displaying.
+   *
+   * @private
+   * @param string aType
+   *        Message type.
+   * @param object aPacket
+   *        The message received from the server.
+   */
+  _onNetworkActivity: function WCCP__onNetworkActivity(aType, aPacket)
+  {
+    this.owner.handleNetworkActivity(aPacket.log, aPacket.meta);
+  },
+
+  /**
+   * The "fileActivity" message type handler. We redirect any message to
+   * the UI for displaying.
+   *
+   * @private
+   * @param string aType
+   *        Message type.
+   * @param object aPacket
+   *        The message received from the server.
+   */
+  _onFileActivity: function WCCP__onFileActivity(aType, aPacket)
+  {
+    this.owner.handleFileActivity(aPacket.uri);
+  },
+
+  /**
+   * The "locationChange" message type handler. We redirect any message to
+   * the UI for displaying.
+   *
+   * @private
+   * @param string aType
+   *        Message type.
+   * @param object aPacket
+   *        The message received from the server.
+   */
+  _onLocationChange: function WCCP__onLocationChange(aType, aPacket)
+  {
+    this.owner.onLocationChange(aPacket.uri, aPacket.title);
+  },
+
+  /**
    * Release an object actor.
    *
    * @param string aActor
    *        The actor ID to send the request to.
    */
   releaseActor: function WCCP_releaseActor(aActor)
   {
     if (this.client) {
@@ -3858,16 +3894,19 @@ WebConsoleConnectionProxy.prototype = {
   disconnect: function WCCP_disconnect()
   {
     if (!this.client) {
       return;
     }
 
     this.client.removeListener("pageError", this._onPageError);
     this.client.removeListener("consoleAPICall", this._onConsoleAPICall);
+    this.client.removeListener("networkActivity", this._onNetworkActivity);
+    this.client.removeListener("fileActivity", this._onFileActivity);
+    this.client.removeListener("locationChange", this._onLocationChange);
     this.client.close();
 
     this.client = null;
     this.webConsoleClient = null;
     this.connected = false;
   },
 };
 
diff --git a/toolkit/devtools/debugger/dbg-client.jsm b/toolkit/devtools/debugger/dbg-client.jsm
--- a/toolkit/devtools/debugger/dbg-client.jsm
+++ b/toolkit/devtools/debugger/dbg-client.jsm
@@ -161,16 +161,19 @@ const ThreadStateTypes = {
 };
 
 /**
  * Set of protocol messages that are sent by the server without a prior request
  * by the client.
  */
 const UnsolicitedNotifications = {
   "consoleAPICall": "consoleAPICall",
+  "fileActivity": "fileActivity",
+  "locationChange": "locationChange",
+  "networkActivity": "networkActivity",
   "newScript": "newScript",
   "pageError": "pageError",
   "tabDetached": "tabDetached",
   "tabNavigated": "tabNavigated"
 };
 
 /**
  * Set of pause types that are sent by the server and not as an immediate
@@ -552,16 +555,18 @@ function WebConsoleClient(aDebuggerClien
   this._actor = aActor;
   this._client = aDebuggerClient;
 }
 
 WebConsoleClient.prototype = {
   LISTENERS: {
     PageError: "PageError",
     ConsoleAPI: "ConsoleAPI",
+    NetworkActivity: "NetworkActivity",
+    FileActivity: "FileActivity",
   },
 
   CACHED_MESSAGES: {
     PageError: "PageError",
     ConsoleAPI: "ConsoleAPI",
   },
 
   /**
@@ -652,16 +657,50 @@ WebConsoleClient.prototype = {
     let packet = {
       to: this._actor,
       type: "clearMessagesCache",
     };
     this._client.request(packet);
   },
 
   /**
+   * Set Web Console-related preferences on the server.
+   *
+   * @param object aPreferences
+   *        An object with the preferences you want to change.
+   * @param function [aOnResponse]
+   *        Optional function to invoke when the response is received.
+   */
+  setPreferences: function WCC_setPreferences(aPreferences, aOnResponse) {
+    let packet = {
+      to: this._actor,
+      type: "setPreferences",
+      preferences: aPreferences,
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Get Web Console-related preferences from the server.
+   *
+   * @param array aPreferences
+   *        An array with the preferences you want to retrieve.
+   * @param function aOnResponse
+   *        Function to invoke when the response is received.
+   */
+  getPreferences: function WCC_getPreferences(aPreferences, aOnResponse) {
+    let packet = {
+      to: this._actor,
+      type: "getPreferences",
+      preferences: aPreferences,
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
    * Start the given Web Console listeners.
    *
    * @see this.LISTENERS
    * @param array aListeners
    *        Array of listeners you want to start. See this.LISTENERS for
    *        known listeners.
    * @param function aOnResponse
    *        Function to invoke when the server response is received.
diff --git a/toolkit/devtools/debugger/server/dbg-webconsole-actors.js b/toolkit/devtools/debugger/server/dbg-webconsole-actors.js
--- a/toolkit/devtools/debugger/server/dbg-webconsole-actors.js
+++ b/toolkit/devtools/debugger/server/dbg-webconsole-actors.js
@@ -19,28 +19,36 @@ XPCOMUtils.defineLazyModuleGetter(this, 
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "PageErrorListener",
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "ConsoleAPIListener",
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "ConsoleProgressListener",
+                                  "resource://gre/modules/devtools/WebConsoleUtils.jsm");
+
 XPCOMUtils.defineLazyModuleGetter(this, "JSTermHelpers",
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "JSPropertyProvider",
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "NetworkMonitor",
+                                  "resource://gre/modules/devtools/WebConsoleUtils.jsm");
+
 XPCOMUtils.defineLazyModuleGetter(this, "ConsoleAPIStorage",
                                   "resource://gre/modules/ConsoleAPIStorage.jsm");
 
 const LISTENERS = {
   PageError: "PageError",
   ConsoleAPI: "ConsoleAPI",
+  NetworkActivity: "NetworkActivity",
+  FileActivity: "FileActivity",
 };
 
 const CACHED_MESSAGES = {
   PageError: "PageError",
   ConsoleAPI: "ConsoleAPI",
 };
 
 /**
@@ -57,16 +65,21 @@ function WebConsoleActor(aConnection, aB
 {
   this.conn = aConnection;
   this._browser = aBrowser;
 
   this._objectActorsPool = new ActorPool(this.conn);
   this.conn.addActorPool(this._objectActorsPool);
 
   this._objectActors = new Map();
+  this._prefs = {};
+
+  this.consoleProgressListener = new ConsoleProgressListener(this._browser, this);
+  this.consoleProgressListener.startMonitor(this.consoleProgressListener.
+                                            MONITOR_LOCATION_CHANGE);
 }
 
 WebConsoleActor.prototype =
 {
   /**
    * The xul:browser we work with.
    * @private
    * @type nsIDOMElement
@@ -85,16 +98,23 @@ WebConsoleActor.prototype =
   /**
    * Map between objects and their WebConsoleObjectActor wrappers.
    * @private
    * @type Map
    */
   _objectActors: null,
 
   /**
+   * Web Console-related preferences.
+   * @private
+   * @type object
+   */
+  _prefs: null,
+
+  /**
    * The debugger server connection instance.
    * @type object
    */
   conn: null,
 
   /**
    * The content window we work with.
    * @type nsIDOMWindow
@@ -107,16 +127,33 @@ WebConsoleActor.prototype =
    */
   pageErrorListener: null,
 
   /**
    * The ConsoleAPIListener instance.
    */
   consoleAPIListener: null,
 
+  /**
+   * The NetworkMonitor instance.
+   */
+  networkMonitor: null,
+
+  /**
+   * The ConsoleProgressListener instance.
+   */
+  consoleProgressListener: null,
+
+  /**
+   * Getter for the NetworkMonitor.saveRequestAndResponseBodies preference.
+   * @type boolean
+   */
+  get saveRequestAndResponseBodies()
+    this._prefs["NetworkMonitor.saveRequestAndResponseBodies"],
+
   actorPrefix: "console",
 
   grip: function WCA_grip()
   {
     return { actor: this.actorID };
   },
 
   /**
@@ -145,16 +182,24 @@ WebConsoleActor.prototype =
     if (this.pageErrorListener) {
       this.pageErrorListener.destroy();
       this.pageErrorListener = null;
     }
     if (this.consoleAPIListener) {
       this.consoleAPIListener.destroy();
       this.consoleAPIListener = null;
     }
+    if (this.networkMonitor) {
+      this.networkMonitor.destroy();
+      this.networkMonitor = null;
+    }
+    if (this.consoleProgressListener) {
+      this.consoleProgressListener.destroy();
+      this.consoleProgressListener = null;
+    }
     this.conn.removeActorPool(this._objectActorsPool);
     this._objectActorsPool = null;
     this._objectActors = null;
     this.conn = this._browser = null;
   },
 
   /**
    * Create a grip for the given value. If the value is an object,
@@ -210,16 +255,20 @@ WebConsoleActor.prototype =
    *        The WebConsoleObjectActor instance you want to release.
    */
   releaseObject: function WCA_releaseObject(aActor)
   {
     this._objectActors.delete(aActor.obj);
     this._objectActorsPool.removeActor(aActor.actorID);
   },
 
+  //////////////////
+  // Request handlers for known packet types.
+  //////////////////
+
   /**
    * Handler for the "startListeners" request.
    *
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
    * @return object
    *         The response object which holds the startedListeners array.
    */
@@ -241,16 +290,29 @@ WebConsoleActor.prototype =
         case LISTENERS.ConsoleAPI:
           if (!this.consoleAPIListener) {
             this.consoleAPIListener =
               new ConsoleAPIListener(this.window, this);
             this.consoleAPIListener.init();
           }
           startedListeners.push(listener);
           break;
+        case LISTENERS.NetworkActivity:
+          if (!this.networkMonitor) {
+            this.networkMonitor =
+              new NetworkMonitor(this.window, this);
+            this.networkMonitor.init();
+          }
+          startedListeners.push(listener);
+          break;
+        case LISTENERS.FileActivity:
+          this.consoleProgressListener.startMonitor(this.consoleProgressListener.
+                                                    MONITOR_FILE_ACTIVITY);
+          startedListeners.push(listener);
+          break;
       }
     }
     return {
       startedListeners: startedListeners,
       nativeConsoleAPI: this.hasNativeConsoleAPI(),
     };
   },
 
@@ -287,16 +349,28 @@ WebConsoleActor.prototype =
           break;
         case LISTENERS.ConsoleAPI:
           if (this.consoleAPIListener) {
             this.consoleAPIListener.destroy();
             this.consoleAPIListener = null;
           }
           stoppedListeners.push(listener);
           break;
+        case LISTENERS.NetworkActivity:
+          if (this.networkMonitor) {
+            this.networkMonitor.destroy();
+            this.networkMonitor = null;
+          }
+          stoppedListeners.push(listener);
+          break;
+        case LISTENERS.FileActivity:
+          this.consoleProgressListener.stopMonitor(this.consoleProgressListener.
+                                                   MONITOR_FILE_ACTIVITY);
+          stoppedListeners.push(listener);
+          break;
       }
     }
 
     return { stoppedListeners: stoppedListeners };
   },
 
   /**
    * Handler for the "getCachedMessages" request. This method sends the cached
@@ -420,16 +494,55 @@ WebConsoleActor.prototype =
   {
     // TODO: Bug 717611 - Web Console clear button does not clear cached errors
     let windowId = WebConsoleUtils.getInnerWindowId(this.window);
     ConsoleAPIStorage.clearEvents(windowId);
     return {};
   },
 
   /**
+   * The "getPreferences" request handler.
+   *
+   * @param object aRequest
+   *        The request message - which preferences to send back to the client.
+   * @return object
+   *         The response message - preferences and their values.
+   */
+  onGetPreferences: function WCA_onGetPreferences(aRequest)
+  {
+    let prefs = {};
+    aRequest.preferences.forEach(function(aName) {
+      prefs[aName] = this._prefs[aName];
+    }, this);
+
+    return {
+      from: this.actorID,
+      preferences: prefs,
+    };
+  },
+
+  /**
+   * The "setPreferences" request handler.
+   *
+   * @param object aRequest
+   *        The request message - which preferences need to be updated.
+   */
+  onSetPreferences: function WCA_onSetPreferences(aRequest)
+  {
+    for (let key in aRequest.preferences) {
+      this._prefs[key] = aRequest.preferences[key];
+    }
+    return {};
+  },
+
+  //////////////////
+  // End of request handlers.
+  //////////////////
+
+  /**
    * Create the JavaScript sandbox where user input is evaluated.
    * @private
    */
   _createSandbox: function WCA__createSandbox()
   {
     this._sandboxLocation = this.window.location;
     this.sandbox = new Cu.Sandbox(this.window, {
       sandboxPrototype: this.window,
@@ -484,20 +597,25 @@ WebConsoleActor.prototype =
     }
     if ($$) {
       this.sandbox.$$ = $$;
     }
 
     return result;
   },
 
+  //////////////////
+  // Event handlers for various listeners.
+  //////////////////
+
   /**
    * Handler for page errors received from the PageErrorListener. This method
    * sends the nsIScriptError to the remote Web Console client.
    *
+   * @see PageErrorListener
    * @param nsIScriptError aPageError
    *        The page error we need to send to the remote client.
    */
   onPageError: function WCA_onPageError(aPageError)
   {
     let packet = {
       from: this.actorID,
       type: "pageError",
@@ -505,30 +623,101 @@ WebConsoleActor.prototype =
     };
     this.conn.send(packet);
   },
 
   /**
    * Handler for window.console API calls received from the ConsoleAPIListener.
    * This method sends the object to the remote Web Console client.
    *
+   * @see ConsoleAPIListener
    * @param object aMessage
    *        The console API call we need to send to the remote client.
    */
   onConsoleAPICall: function WCA_onConsoleAPICall(aMessage)
   {
     let packet = {
       from: this.actorID,
       type: "consoleAPICall",
       message: this.prepareConsoleMessageForRemote(aMessage),
     };
     this.conn.send(packet);
   },
 
   /**
+   * Handler for network activity. This method sends the network request and
+   * response information to the remote Web Console client.
+   *
+   * @see NetworkMonitor
+   * @param object aLog
+   *        The network request and response object, in a similar format to that
+   *        of a HAR log.
+   * @param object aMeta
+   *        The metadata about network logging - was the request/response body
+   *        discarded? and other information.
+   */
+  onNetworkActivity: function WCA_onNetworkActivity(aLog, aMeta)
+  {
+    let packet = {
+      from: this.actorID,
+      type: "networkActivity",
+      meta: aMeta,
+      log: aLog,
+    };
+    this.conn.send(packet);
+  },
+
+  /**
+   * Handler for file activity. This method sends the file request information
+   * to the remote Web Console client.
+   *
+   * @see ConsoleProgressListener
+   * @param string aFileURI
+   *        The requested file URI.
+   */
+  onFileActivity: function WCA_onFileActivity(aFileURI)
+  {
+    let packet = {
+      from: this.actorID,
+      type: "fileActivity",
+      uri: aFileURI,
+    };
+    this.conn.send(packet);
+  },
+
+  /**
+   * Handler for location changes. This method sends the new browser location
+   * to the remote Web Console client.
+   *
+   * @see ConsoleProgressListener
+   * @param string aURI
+   *        The new browser URI.
+   * @param string aTitle
+   *        The new page title URI.
+   */
+  onLocationChange: function WCA_onLocationChange(aURI, aTitle)
+  {
+    // TODO: we should use tabNavigated, but that lives on the TabActor and in
+    // the Web Console we do not attach to the TabActor. Plus, the tabNavigated
+    // packet is only sent at the end of a page load - for the Web Console we
+    // need it as early as possible. Follow-up bug material?
+    let packet = {
+      from: this.actorID,
+      type: "locationChange",
+      uri: aURI,
+      title: aTitle,
+    };
+    this.conn.send(packet);
+  },
+
+  //////////////////
+  // End of event handlers for various listeners.
+  //////////////////
+
+  /**
    * Prepare a message from the console API to be sent to the remote Web Console
    * instance.
    *
    * @param object aMessage
    *        The original message received from console-api-log-event.
    * @return object
    *         The object that can be sent to the remote client.
    */
@@ -592,16 +781,18 @@ WebConsoleActor.prototype =
 WebConsoleActor.prototype.requestTypes =
 {
   getCachedMessages: WebConsoleActor.prototype.onGetCachedMessages,
   startListeners: WebConsoleActor.prototype.onStartListeners,
   stopListeners: WebConsoleActor.prototype.onStopListeners,
   evaluateJS: WebConsoleActor.prototype.onEvaluateJS,
   autocomplete: WebConsoleActor.prototype.onAutocomplete,
   clearMessagesCache: WebConsoleActor.prototype.onClearMessagesCache,
+  setPreferences: WebConsoleActor.prototype.onSetPreferences,
+  getPreferences: WebConsoleActor.prototype.onGetPreferences,
 };
 
 /**
  * Creates an actor for the specified object.
  *
  * @constructor
  * @param object aObj
  *        The object you want.
diff --git a/browser/devtools/webconsole/NetworkHelper.jsm b/toolkit/devtools/webconsole/NetworkHelper.jsm
rename from browser/devtools/webconsole/NetworkHelper.jsm
rename to toolkit/devtools/webconsole/NetworkHelper.jsm
diff --git a/toolkit/devtools/webconsole/WebConsoleUtils.jsm b/toolkit/devtools/webconsole/WebConsoleUtils.jsm
--- a/toolkit/devtools/webconsole/WebConsoleUtils.jsm
+++ b/toolkit/devtools/webconsole/WebConsoleUtils.jsm
@@ -13,18 +13,30 @@ const Cu = Components.utils;
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Services",
                                   "resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "ConsoleAPIStorage",
                                   "resource://gre/modules/ConsoleAPIStorage.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "NetUtil",
+                                  "resource://gre/modules/NetUtil.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "NetworkHelper",
+                                  "resource://gre/modules/devtools/NetworkHelper.jsm");
+
+XPCOMUtils.defineLazyServiceGetter(this, "gActivityDistributor",
+                                   "@mozilla.org/network/http-activity-distributor;1",
+                                   "nsIHttpActivityDistributor");
+
 var EXPORTED_SYMBOLS = ["WebConsoleUtils", "JSPropertyProvider", "JSTermHelpers",
-                        "PageErrorListener", "ConsoleAPIListener"];
+                        "PageErrorListener", "ConsoleAPIListener",
+                        "NetworkResponseListener", "NetworkMonitor",
+                        "ConsoleProgressListener"];
 
 // Match the function name from the result of toString() or toSource().
 //
 // Examples:
 // (function foobar(a, b) { ...
 // function foobar2(a) { ...
 // function() { ...
 const REGEX_MATCH_FUNCTION_NAME = /^\(?function\s+([^(\s]+)\s*\(/;
@@ -1854,8 +1866,1202 @@ function JSTermHelpers(aOwner)
    * @return void
    */
   aOwner.sandbox.print = function JSTH_print(aString)
   {
     aOwner.helperResult = { rawOutput: true };
     return String(aString);
   };
 }
+
+
+(function(_global, WCU) {
+///////////////////////////////////////////////////////////////////////////////
+// Network logging
+///////////////////////////////////////////////////////////////////////////////
+
+// The maximum uint32 value.
+const PR_UINT32_MAX = 4294967295;
+
+// HTTP status codes.
+const HTTP_MOVED_PERMANENTLY = 301;
+const HTTP_FOUND = 302;
+const HTTP_SEE_OTHER = 303;
+const HTTP_TEMPORARY_REDIRECT = 307;
+
+// The maximum number of bytes a NetworkResponseListener can hold.
+const RESPONSE_BODY_LIMIT = 1048576; // 1 MB
+
+/**
+ * The network response listener implements the nsIStreamListener and
+ * nsIRequestObserver interfaces. This is used within the NetworkMonitor feature
+ * to get the response body of the request.
+ *
+ * The code is mostly based on code listings from:
+ *
+ *   http://www.softwareishard.com/blog/firebug/
+ *      nsitraceablechannel-intercept-http-traffic/
+ *
+ * @constructor
+ * @param object aOwner
+ *        The response listener owner. This object needs to hold the
+ *        |openResponses| object and the |sendActivity| method.
+ * @param object aHttpActivity
+ *        HttpActivity object associated with this request. Once the request is
+ *        complete the aHttpActivity object is updated to include the response
+ *        headers and body.
+ */
+function NetworkResponseListener(aOwner, aHttpActivity)
+{
+  this.owner = aOwner;
+  this.receivedData = "";
+  this.httpActivity = aHttpActivity;
+  this.bodySize = 0;
+}
+
+NetworkResponseListener.prototype = {
+  QueryInterface:
+    XPCOMUtils.generateQI([Ci.nsIStreamListener, Ci.nsIInputStreamCallback,
+                           Ci.nsIRequestObserver, Ci.nsISupports]),
+
+  /**
+   * This NetworkResponseListener tracks the NetworkMonitor.openResponses object
+   * to find the associated uncached headers.
+   * @private
+   */
+  _foundOpenResponse: false,
+
+  /**
+   * The response listener owner.
+   */
+  owner: null,
+
+  /**
+   * The response will be written into the outputStream of this nsIPipe.
+   * Both ends of the pipe must be blocking.
+   */
+  sink: null,
+
+  /**
+   * The HttpActivity object associated with this response.
+   */
+  httpActivity: null,
+
+  /**
+   * Stores the received data as a string.
+   */
+  receivedData: null,
+
+  /**
+   * The network response body size.
+   */
+  bodySize: null,
+
+  /**
+   * The nsIRequest we are started for.
+   */
+  request: null,
+
+  /**
+   * Set the async listener for the given nsIAsyncInputStream. This allows us to
+   * wait asynchronously for any data coming from the stream.
+   *
+   * @param nsIAsyncInputStream aStream
+   *        The input stream from where we are waiting for data to come in.
+   * @param nsIInputStreamCallback aListener
+   *        The input stream callback you want. This is an object that must have
+   *        the onInputStreamReady() method. If the argument is null, then the
+   *        current callback is removed.
+   * @return void
+   */
+  setAsyncListener: function NRL_setAsyncListener(aStream, aListener)
+  {
+    // Asynchronously wait for the stream to be readable or closed.
+    aStream.asyncWait(aListener, 0, 0, Services.tm.mainThread);
+  },
+
+  /**
+   * Stores the received data, if request/response body logging is enabled. It
+   * also does limit the number of stored bytes, based on the
+   * RESPONSE_BODY_LIMIT constant.
+   *
+   * Learn more about nsIStreamListener at:
+   * https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsIStreamListener
+   *
+   * @param nsIRequest aRequest
+   * @param nsISupports aContext
+   * @param nsIInputStream aInputStream
+   * @param unsigned long aOffset
+   * @param unsigned long aCount
+   */
+  onDataAvailable:
+  function NRL_onDataAvailable(aRequest, aContext, aInputStream, aOffset, aCount)
+  {
+    this._findOpenResponse();
+    let data = NetUtil.readInputStreamToString(aInputStream, aCount);
+
+    this.bodySize += aCount;
+
+    if (!this.httpActivity.meta.discardResponseBody &&
+        this.receivedData.length < RESPONSE_BODY_LIMIT) {
+      this.receivedData += NetworkHelper.
+                           convertToUnicode(data, aRequest.contentCharset);
+    }
+  },
+
+  /**
+   * See documentation at
+   * https://developer.mozilla.org/En/NsIRequestObserver
+   *
+   * @param nsIRequest aRequest
+   * @param nsISupports aContext
+   */
+  onStartRequest: function NRL_onStartRequest(aRequest)
+  {
+    this.request = aRequest;
+    this._findOpenResponse();
+    // Asynchronously wait for the data coming from the request.
+    this.setAsyncListener(this.sink.inputStream, this);
+  },
+
+  /**
+   * Handle the onStopRequest by closing the sink output stream.
+   *
+   * For more documentation about nsIRequestObserver go to:
+   * https://developer.mozilla.org/En/NsIRequestObserver
+   */
+  onStopRequest: function NRL_onStopRequest()
+  {
+    this._findOpenResponse();
+    this.sink.outputStream.close();
+  },
+
+  /**
+   * Find the open response object associated to the current request. The
+   * NetworkMonitor._httpResponseExaminer() method saves the response headers in
+   * NetworkMonitor.openResponses. This method takes the data from the open
+   * response object and puts it into the HTTP activity object, then sends it to
+   * the remote Web Console instance.
+   *
+   * @private
+   */
+  _findOpenResponse: function NRL__findOpenResponse()
+  {
+    if (!this.owner || this._foundOpenResponse) {
+      return;
+    }
+
+    let openResponse = null;
+
+    for each (let item in this.owner.openResponses) {
+      if (item.channel === this.httpActivity.channel) {
+        openResponse = item;
+        break;
+      }
+    }
+
+    if (!openResponse) {
+      return;
+    }
+    this._foundOpenResponse = true;
+
+    let logResponse = this.httpActivity.log.entries[0].response;
+    logResponse.headers = openResponse.headers;
+    logResponse.httpVersion = openResponse.httpVersion;
+    logResponse.status = openResponse.status;
+    logResponse.statusText = openResponse.statusText;
+    if (openResponse.cookies) {
+      logResponse.cookies = openResponse.cookies;
+    }
+
+    delete this.owner.openResponses[openResponse.id];
+
+    this.httpActivity.meta.stages.push("http-on-examine-response");
+    this.owner.sendActivity(this.httpActivity);
+  },
+
+  /**
+   * Clean up the response listener once the response input stream is closed.
+   * This is called from onStopRequest() or from onInputStreamReady() when the
+   * stream is closed.
+   * @return void
+   */
+  onStreamClose: function NRL_onStreamClose()
+  {
+    if (!this.httpActivity) {
+      return;
+    }
+    // Remove our listener from the request input stream.
+    this.setAsyncListener(this.sink.inputStream, null);
+
+    this._findOpenResponse();
+
+    let meta = this.httpActivity.meta;
+    let entry = this.httpActivity.log.entries[0];
+    let request = entry.request;
+    let response = entry.response;
+
+    meta.stages.push("REQUEST_STOP");
+
+    if (!meta.discardResponseBody && this.receivedData.length) {
+      this._onComplete(this.receivedData);
+    }
+    else if (!meta.discardResponseBody && response.status == 304) {
+      // Response is cached, so we load it from cache.
+      let charset = this.request.contentCharset || this.httpActivity.charset;
+      NetworkHelper.loadFromCache(request.url, charset,
+                                  this._onComplete.bind(this));
+    }
+    else {
+      this._onComplete();
+    }
+  },
+
+  /**
+   * Handler for when the response completes. This function cleans up the
+   * response listener.
+   *
+   * @param string [aData]
+   *        Optional, the received data coming from the response listener or
+   *        from the cache.
+   */
+  _onComplete: function NRL__onComplete(aData)
+  {
+    let response = this.httpActivity.log.entries[0].response;
+
+    try {
+      response.bodySize = response.status != 304 ? this.request.contentLength : 0;
+    }
+    catch (ex) {
+      response.bodySize = -1;
+    }
+
+    // TODO: Bug 787981 - use LongStringActor for strings that are too long.
+
+    try {
+      response.content = { mimeType: this.request.contentType };
+    }
+    catch (ex) {
+      response.content = { mimeType: "" };
+    }
+
+    if (response.content.mimeType && this.request.contentCharset) {
+      response.content.mimeType += "; charset=" + this.request.contentCharset;
+    }
+
+    response.content.size = this.bodySize || (aData || "").length;
+
+    if (aData) {
+      response.content.text = aData;
+    }
+
+    this.receivedData = "";
+
+    this.owner.sendActivity(this.httpActivity);
+
+    this.httpActivity.channel = null;
+    this.httpActivity = null;
+    this.sink = null;
+    this.inputStream = null;
+    this.request = null;
+    this.owner = null;
+  },
+
+  /**
+   * The nsIInputStreamCallback for when the request input stream is ready -
+   * either it has more data or it is closed.
+   *
+   * @param nsIAsyncInputStream aStream
+   *        The sink input stream from which data is coming.
+   * @returns void
+   */
+  onInputStreamReady: function NRL_onInputStreamReady(aStream)
+  {
+    if (!(aStream instanceof Ci.nsIAsyncInputStream) || !this.httpActivity) {
+      return;
+    }
+
+    let available = -1;
+    try {
+      // This may throw if the stream is closed normally or due to an error.
+      available = aStream.available();
+    }
+    catch (ex) { }
+
+    if (available != -1) {
+      if (available != 0) {
+        // Note that passing 0 as the offset here is wrong, but the
+        // onDataAvailable() method does not use the offset, so it does not
+        // matter.
+        this.onDataAvailable(this.request, null, aStream, 0, available);
+      }
+      this.setAsyncListener(aStream, this);
+    }
+    else {
+      this.onStreamClose();
+    }
+  },
+};
+
+/**
+ * The network monitor uses the nsIHttpActivityDistributor to monitor network
+ * requests. The nsIObserverService is also used for monitoring
+ * http-on-examine-response notifications. All network request information is
+ * routed to the remote Web Console.
+ *
+ * @constructor
+ * @param nsIDOMWindow aWindow
+ *        The window that we monitor network requests for.
+ * @param object aOwner
+ *        The network monitor owner. This object needs to hold:
+ *        - onNetworkActivity(). This method is invoked for every stage of
+ *        every network request and it is given two arguments: the network
+ *        activity object of the request (which is very similar to a HAR object)
+ *        and associated metadata/information for the request.
+ *        - saveRequestAndResponseBodies property which tells if you want to log
+ *        request and response bodies.
+ */
+function NetworkMonitor(aWindow, aOwner)
+{
+  this.window = aWindow;
+  this.owner = aOwner;
+  this.openRequests = {};
+  this.openResponses = {};
+  this._httpResponseExaminer = this._httpResponseExaminer.bind(this);
+}
+
+NetworkMonitor.prototype = {
+  httpTransactionCodes: {
+    0x5001: "REQUEST_HEADER",
+    0x5002: "REQUEST_BODY_SENT",
+    0x5003: "RESPONSE_START",
+    0x5004: "RESPONSE_HEADER",
+    0x5005: "RESPONSE_COMPLETE",
+    0x5006: "TRANSACTION_CLOSE",
+
+    0x804b0003: "STATUS_RESOLVING",
+    0x804b000b: "STATUS_RESOLVED",
+    0x804b0007: "STATUS_CONNECTING_TO",
+    0x804b0004: "STATUS_CONNECTED_TO",
+    0x804b0005: "STATUS_SENDING_TO",
+    0x804b000a: "STATUS_WAITING_FOR",
+    0x804b0006: "STATUS_RECEIVING_FROM"
+  },
+
+  harCreator: {
+    name: Services.appinfo.name + " - Web Console",
+    version: Services.appinfo.version,
+  },
+
+  // Network response bodies are piped through a buffer of the given size (in
+  // bytes).
+  responsePipeSegmentSize: null,
+
+  owner: null,
+
+  /**
+   * Whether to save the bodies of network requests and responses. Disabled by
+   * default to save memory.
+   */
+  get saveRequestAndResponseBodies()
+    this.owner && this.owner.saveRequestAndResponseBodies,
+
+  /**
+   * Object that holds the HTTP activity objects for ongoing requests.
+   */
+  openRequests: null,
+
+  /**
+   * Object that holds response headers coming from this._httpResponseExaminer.
+   */
+  openResponses: null,
+
+  /**
+   * The network monitor initializer.
+   */
+  init: function NM_init()
+  {
+    this.responsePipeSegmentSize = Services.prefs
+                                   .getIntPref("network.buffer.cache.size");
+
+    gActivityDistributor.addObserver(this);
+
+    Services.obs.addObserver(this._httpResponseExaminer,
+                             "http-on-examine-response", false);
+  },
+
+  /**
+   * Observe notifications for the http-on-examine-response topic, coming from
+   * the nsIObserverService.
+   *
+   * @private
+   * @param nsIHttpChannel aSubject
+   * @param string aTopic
+   * @returns void
+   */
+  _httpResponseExaminer: function NM__httpResponseExaminer(aSubject, aTopic)
+  {
+    // The httpResponseExaminer is used to retrieve the uncached response
+    // headers. The data retrieved is stored in openResponses. The
+    // NetworkResponseListener is responsible with updating the httpActivity
+    // object with the data from the new object in openResponses.
+
+    if (!this.owner || aTopic != "http-on-examine-response" ||
+        !(aSubject instanceof Ci.nsIHttpChannel)) {
+      return;
+    }
+
+    let channel = aSubject.QueryInterface(Ci.nsIHttpChannel);
+    // Try to get the source window of the request.
+    let win = NetworkHelper.getWindowForRequest(channel);
+    if (!win || win.top !== this.window) {
+      return;
+    }
+
+    let response = {
+      id: gSequenceId(),
+      channel: channel,
+      headers: [],
+      cookies: [],
+    };
+
+    let setCookieHeader = null;
+
+    channel.visitResponseHeaders({
+      visitHeader: function NM__visitHeader(aName, aValue) {
+        let lowerName = aName.toLowerCase();
+        if (lowerName == "set-cookie") {
+          setCookieHeader = aValue;
+        }
+        response.headers.push({ name: aName, value: aValue });
+      }
+    });
+
+    if (!response.headers.length) {
+      return; // No need to continue.
+    }
+
+    if (setCookieHeader) {
+      response.cookies = NetworkHelper.parseSetCookieHeader(setCookieHeader);
+    }
+
+    // Determine the HTTP version.
+    let httpVersionMaj = {};
+    let httpVersionMin = {};
+
+    channel.QueryInterface(Ci.nsIHttpChannelInternal);
+    channel.getResponseVersion(httpVersionMaj, httpVersionMin);
+
+    response.status = channel.responseStatus;
+    response.statusText = channel.responseStatusText;
+    response.httpVersion = "HTTP/" + httpVersionMaj.value + "." +
+                                     httpVersionMin.value;
+
+    this.openResponses[response.id] = response;
+  },
+
+  /**
+   * Begin observing HTTP traffic that originates inside the current tab.
+   *
+   * @see https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsIHttpActivityObserver
+   *
+   * @param nsIHttpChannel aChannel
+   * @param number aActivityType
+   * @param number aActivitySubtype
+   * @param number aTimestamp
+   * @param number aExtraSizeData
+   * @param string aExtraStringData
+   */
+  observeActivity:
+  function NM_observeActivity(aChannel, aActivityType, aActivitySubtype,
+                              aTimestamp, aExtraSizeData, aExtraStringData)
+  {
+    if (!this.owner ||
+        aActivityType != gActivityDistributor.ACTIVITY_TYPE_HTTP_TRANSACTION &&
+        aActivityType != gActivityDistributor.ACTIVITY_TYPE_SOCKET_TRANSPORT) {
+      return;
+    }
+
+    if (!(aChannel instanceof Ci.nsIHttpChannel)) {
+      return;
+    }
+
+    aChannel = aChannel.QueryInterface(Ci.nsIHttpChannel);
+
+    if (aActivitySubtype ==
+        gActivityDistributor.ACTIVITY_SUBTYPE_REQUEST_HEADER) {
+      this._onRequestHeader(aChannel, aTimestamp, aExtraStringData);
+      return;
+    }
+
+    // Iterate over all currently ongoing requests. If aChannel can't
+    // be found within them, then exit this function.
+    let httpActivity = null;
+    for each (let item in this.openRequests) {
+      if (item.channel === aChannel) {
+        httpActivity = item;
+        break;
+      }
+    }
+
+    if (!httpActivity) {
+      return;
+    }
+
+    let transCodes = this.httpTransactionCodes;
+
+    // Store the time information for this activity subtype.
+    if (aActivitySubtype in transCodes) {
+      let stage = transCodes[aActivitySubtype];
+      if (stage in httpActivity.timings) {
+        httpActivity.timings[stage].last = aTimestamp;
+      }
+      else {
+        httpActivity.meta.stages.push(stage);
+        httpActivity.timings[stage] = {
+          first: aTimestamp,
+          last: aTimestamp,
+        };
+      }
+    }
+
+    switch (aActivitySubtype) {
+      case gActivityDistributor.ACTIVITY_SUBTYPE_REQUEST_BODY_SENT:
+        this._onRequestBodySent(httpActivity);
+        break;
+      case gActivityDistributor.ACTIVITY_SUBTYPE_RESPONSE_HEADER:
+        this._onResponseHeader(httpActivity, aExtraStringData);
+        break;
+      case gActivityDistributor.ACTIVITY_SUBTYPE_TRANSACTION_CLOSE:
+        this._onTransactionClose(httpActivity);
+        break;
+      default:
+        break;
+    }
+  },
+
+  /**
+   * Handler for ACTIVITY_SUBTYPE_REQUEST_HEADER. When a request starts the
+   * headers are sent to the server. This method creates the |httpActivity|
+   * object where we store the request and response information that is
+   * collected through its lifetime.
+   *
+   * @private
+   * @param nsIHttpChannel aChannel
+   * @param number aTimestamp
+   * @param string aExtraStringData
+   * @return void
+   */
+  _onRequestHeader:
+  function NM__onRequestHeader(aChannel, aTimestamp, aExtraStringData)
+  {
+    // Try to get the source window of the request.
+    let win = NetworkHelper.getWindowForRequest(aChannel);
+    if (!win || win.top !== this.window) {
+      return;
+    }
+
+    let httpActivity = this.createActivityObject(aChannel);
+    httpActivity.charset = win.document.characterSet; // see NM__onRequestBodySent()
+    httpActivity.meta.stages.push("REQUEST_HEADER"); // activity stage (aActivitySubtype)
+
+    httpActivity.timings.REQUEST_HEADER = {
+      first: aTimestamp,
+      last: aTimestamp
+    };
+
+    let entry = httpActivity.log.entries[0];
+    entry.startedDateTime = new Date(Math.round(aTimestamp / 1000)).toISOString();
+
+    let request = httpActivity.log.entries[0].request;
+
+    let cookieHeader = null;
+
+    // Copy the request header data.
+    aChannel.visitRequestHeaders({
+      visitHeader: function NM__visitHeader(aName, aValue)
+      {
+        if (aName == "Cookie") {
+          cookieHeader = aValue;
+        }
+        request.headers.push({ name: aName, value: aValue });
+      }
+    });
+
+    if (cookieHeader) {
+      request.cookies = NetworkHelper.parseCookieHeader(cookieHeader);
+    }
+
+    // Determine the HTTP version.
+    let httpVersionMaj = {};
+    let httpVersionMin = {};
+
+    aChannel.QueryInterface(Ci.nsIHttpChannelInternal);
+    aChannel.getRequestVersion(httpVersionMaj, httpVersionMin);
+
+    request.httpVersion = "HTTP/" + httpVersionMaj.value + "." +
+                                    httpVersionMin.value;
+
+    request.headersSize = aExtraStringData.length;
+
+    this._setupResponseListener(httpActivity);
+
+    this.openRequests[httpActivity.id] = httpActivity;
+
+    this.sendActivity(httpActivity);
+  },
+
+  /**
+   * Create the empty HTTP activity object. This object is used for storing all
+   * the request and response information.
+   *
+   * This is a HAR-like object. Conformance to the spec is not guaranteed at
+   * this point.
+   *
+   * TODO: Bug 708717 - Add support for network log export to HAR
+   *
+   * @see http://www.softwareishard.com/blog/har-12-spec
+   * @param nsIHttpChannel aChannel
+   *        The HTTP channel for which the HTTP activity object is created.
+   * @return object
+   *         The new HTTP activity object.
+   */
+  createActivityObject: function NM_createActivityObject(aChannel)
+  {
+    return {
+      id: gSequenceId(),
+      channel: aChannel,
+      charset: null, // see NM__onRequestHeader()
+      meta: { // holds metadata about the activity object
+        stages: [], // activity stages (aActivitySubtype)
+        discardRequestBody: !this.saveRequestAndResponseBodies,
+        discardResponseBody: !this.saveRequestAndResponseBodies,
+      },
+      timings: {}, // internal timing information, see NM_observeActivity()
+      log: { // HAR-like object
+        version: "1.2",
+        creator: this.harCreator,
+        // missing |browser| and |pages|
+        entries: [{  // we only track one entry at a time
+          connection: gSequenceId(), // connection ID
+          startedDateTime: 0, // see NM__onRequestHeader()
+          time: 0, // see NM__setupHarTimings()
+          // missing |serverIPAddress| and |cache|
+          request: {
+            method: aChannel.requestMethod,
+            url: aChannel.URI.spec,
+            httpVersion: "", // see NM__onRequestHeader()
+            headers: [], // see NM__onRequestHeader()
+            cookies: [], // see NM__onRequestHeader()
+            queryString: [], // never set
+            headersSize: -1, // see NM__onRequestHeader()
+            bodySize: -1, // see NM__onRequestBodySent()
+            postData: null, // see NM__onRequestBodySent()
+          },
+          response: {
+            status: 0, // see NM__onResponseHeader()
+            statusText: "", // see NM__onResponseHeader()
+            httpVersion: "", // see NM__onResponseHeader()
+            headers: [], // see NM_httpResponseExaminer()
+            cookies: [], // see NM_httpResponseExaminer()
+            content: null, // see NRL_onStreamClose()
+            redirectURL: "", // never set
+            headersSize: -1, // see NM__onResponseHeader()
+            bodySize: -1, // see NRL_onStreamClose()
+          },
+          timings: {}, // see NM__setupHarTimings()
+        }],
+      },
+    };
+  },
+
+  /**
+   * Setup the network response listener for the given HTTP activity. The
+   * NetworkResponseListener is responsible for storing the response body.
+   *
+   * @private
+   * @param object aHttpActivity
+   *        The HTTP activity object we are tracking.
+   */
+  _setupResponseListener: function NM__setupResponseListener(aHttpActivity)
+  {
+    let channel = aHttpActivity.channel;
+    channel.QueryInterface(Ci.nsITraceableChannel);
+
+    // The response will be written into the outputStream of this pipe.
+    // This allows us to buffer the data we are receiving and read it
+    // asynchronously.
+    // Both ends of the pipe must be blocking.
+    let sink = Cc["@mozilla.org/pipe;1"].createInstance(Ci.nsIPipe);
+
+    // The streams need to be blocking because this is required by the
+    // stream tee.
+    sink.init(false, false, this.responsePipeSegmentSize, PR_UINT32_MAX, null);
+
+    // Add listener for the response body.
+    let newListener = new NetworkResponseListener(this, aHttpActivity);
+
+    // Remember the input stream, so it isn't released by GC.
+    newListener.inputStream = sink.inputStream;
+    newListener.sink = sink;
+
+    let tee = Cc["@mozilla.org/network/stream-listener-tee;1"].
+              createInstance(Ci.nsIStreamListenerTee);
+
+    let originalListener = channel.setNewListener(tee);
+
+    tee.init(originalListener, sink.outputStream, newListener);
+  },
+
+  /**
+   * Send an HTTP activity object to the network monitorowner.
+   *
+   * @param object aHttpActivity
+   *        The HTTP activity object you want to send.
+   */
+  sendActivity: function NM_sendActivity(aHttpActivity)
+  {
+    if (this.owner) {
+      this.owner.onNetworkActivity(aHttpActivity.log, aHttpActivity.meta);
+    }
+  },
+
+  /**
+   * Handler for ACTIVITY_SUBTYPE_REQUEST_BODY_SENT. The request body is logged
+   * here.
+   *
+   * @private
+   * @param object aHttpActivity
+   *        The HTTP activity object we are working with.
+   */
+  _onRequestBodySent: function NM__onRequestBodySent(aHttpActivity)
+  {
+    if (aHttpActivity.meta.discardRequestBody) {
+      return;
+    }
+
+    let request = aHttpActivity.log.entries[0].request;
+
+    let sentBody = NetworkHelper.
+                   readPostTextFromRequest(aHttpActivity.channel,
+                                           aHttpActivity.charset);
+
+    if (!sentBody && request.url == Manager.window.location.href) {
+      // If the request URL is the same as the current page URL, then
+      // we can try to get the posted text from the page directly.
+      // This check is necessary as otherwise the
+      //   NetworkHelper.readPostTextFromPage()
+      // function is called for image requests as well but these
+      // are not web pages and as such don't store the posted text
+      // in the cache of the webpage.
+      sentBody = NetworkHelper.readPostTextFromPage(docShell,
+                                                    aHttpActivity.charset);
+    }
+    if (!sentBody) {
+      return;
+    }
+
+    request.postData = {
+      mimeType: "", // never set
+      params: [],  // never set
+      text: sentBody,
+    };
+
+    request.bodySize = sentBody.length;
+
+    this.sendActivity(aHttpActivity);
+  },
+
+  /**
+   * Handler for ACTIVITY_SUBTYPE_RESPONSE_HEADER. This method stores
+   * information about the response headers.
+   *
+   * @private
+   * @param object aHttpActivity
+   *        The HTTP activity object we are working with.
+   * @param string aExtraStringData
+   *        The uncached response headers.
+   */
+  _onResponseHeader:
+  function NM__onResponseHeader(aHttpActivity, aExtraStringData)
+  {
+    // aExtraStringData contains the uncached response headers. The first line
+    // contains the response status (e.g. HTTP/1.1 200 OK).
+    //
+    // Note: The response header is not saved here. Calling the
+    // channel.visitResponseHeaders() methood at this point sometimes causes an
+    // NS_ERROR_NOT_AVAILABLE exception.
+    //
+    // We could parse aExtraStringData to get the headers and their values, but
+    // that is not trivial to do in an accurate manner. Hence, we save the
+    // response headers in this._httpResponseExaminer().
+
+    let response = aHttpActivity.log.entries[0].response;
+
+    let headers = aExtraStringData.split(/\r\n|\n|\r/);
+    let statusLine = headers.shift();
+
+    let statusLineArray = statusLine.split(" ");
+    response.httpVersion = statusLineArray.shift();
+    response.status = statusLineArray.shift();
+    response.statusText = statusLineArray.join(" ");
+    response.headersSize = aExtraStringData.length;
+
+    // Discard the response body for known response statuses.
+    switch (parseInt(response.status)) {
+      case HTTP_MOVED_PERMANENTLY:
+      case HTTP_FOUND:
+      case HTTP_SEE_OTHER:
+      case HTTP_TEMPORARY_REDIRECT:
+        aHttpActivity.meta.discardResponseBody = true;
+        break;
+    }
+
+    this.sendActivity(aHttpActivity);
+  },
+
+  /**
+   * Handler for ACTIVITY_SUBTYPE_TRANSACTION_CLOSE. This method updates the HAR
+   * timing information on the HTTP activity object and clears the request
+   * from the list of known open requests.
+   *
+   * @private
+   * @param object aHttpActivity
+   *        The HTTP activity object we work with.
+   */
+  _onTransactionClose: function NM__onTransactionClose(aHttpActivity)
+  {
+    this._setupHarTimings(aHttpActivity);
+    this.sendActivity(aHttpActivity);
+    delete this.openRequests[aHttpActivity.id];
+  },
+
+  /**
+   * Update the HTTP activity object to include timing information as in the HAR
+   * spec. The HTTP activity object holds the raw timing information in
+   * |timings| - these are timings stored for each activity notification. The
+   * HAR timing information is constructed based on these lower level data.
+   *
+   * @param object aHttpActivity
+   *        The HTTP activity object we are working with.
+   */
+  _setupHarTimings: function NM__setupHarTimings(aHttpActivity)
+  {
+    let timings = aHttpActivity.timings;
+    let entry = aHttpActivity.log.entries[0];
+    let harTimings = entry.timings;
+
+    // Not clear how we can determine "blocked" time.
+    harTimings.blocked = -1;
+
+    // DNS timing information is available only in when the DNS record is not
+    // cached.
+    harTimings.dns = timings.STATUS_RESOLVING && timings.STATUS_RESOLVED ?
+                     timings.STATUS_RESOLVED.last -
+                     timings.STATUS_RESOLVING.first : -1;
+
+    if (timings.STATUS_CONNECTING_TO && timings.STATUS_CONNECTED_TO) {
+      harTimings.connect = timings.STATUS_CONNECTED_TO.last -
+                           timings.STATUS_CONNECTING_TO.first;
+    }
+    else if (timings.STATUS_SENDING_TO) {
+      harTimings.connect = timings.STATUS_SENDING_TO.first -
+                           timings.REQUEST_HEADER.first;
+    }
+    else {
+      harTimings.connect = -1;
+    }
+
+    if ((timings.STATUS_WAITING_FOR || timings.STATUS_RECEIVING_FROM) &&
+        (timings.STATUS_CONNECTED_TO || timings.STATUS_SENDING_TO)) {
+      harTimings.send = (timings.STATUS_WAITING_FOR ||
+                         timings.STATUS_RECEIVING_FROM).first -
+                        (timings.STATUS_CONNECTED_TO ||
+                         timings.STATUS_SENDING_TO).last;
+    }
+    else {
+      harTimings.send = -1;
+    }
+
+    if (timings.RESPONSE_START) {
+      harTimings.wait = timings.RESPONSE_START.first -
+                        (timings.REQUEST_BODY_SENT ||
+                         timings.STATUS_SENDING_TO).last;
+    }
+    else {
+      harTimings.wait = -1;
+    }
+
+    if (timings.RESPONSE_START && timings.RESPONSE_COMPLETE) {
+      harTimings.receive = timings.RESPONSE_COMPLETE.last -
+                           timings.RESPONSE_START.first;
+    }
+    else {
+      harTimings.receive = -1;
+    }
+
+    entry.time = 0;
+    for (let timing in harTimings) {
+      let time = Math.max(Math.round(harTimings[timing] / 1000), -1);
+      harTimings[timing] = time;
+      if (time > -1) {
+        entry.time += time;
+      }
+    }
+  },
+
+  /**
+   * Suspend Web Console activity. This is called when all Web Consoles are
+   * closed.
+   */
+  destroy: function NM_destroy()
+  {
+    Services.obs.removeObserver(this._httpResponseExaminer,
+                                "http-on-examine-response");
+
+    gActivityDistributor.removeObserver(this);
+
+    //FIXME
+    //ConsoleProgressListener.stopMonitor(ConsoleProgressListener
+    //                                    .MONITOR_FILE_ACTIVITY);
+
+    this.openRequests = {};
+    this.openResponses = {};
+    this.owner = null;
+  },
+};
+
+_global.NetworkMonitor = NetworkMonitor;
+_global.NetworkResponseListener = NetworkResponseListener;
+})(this, WebConsoleUtils);
+
+
+/**
+ * A WebProgressListener that listens for location changes.
+ *
+ * This progress listener is used to track file loads and other kinds of
+ * location changes.
+ *
+ * @constructor
+ * @param object aBrowser
+ *        The xul:browser for which we need to track location changes.
+ * @param object aOwner
+ *        The listener owner which needs to implement two methods:
+ *        - onFileActivity(aFileURI)
+ *        - onLocationChange(aTabURI, aPageTitle)
+ */
+function ConsoleProgressListener(aBrowser, aOwner)
+{
+  this.browser = aBrowser;
+  this.owner = aOwner;
+}
+
+ConsoleProgressListener.prototype = {
+  /**
+   * Constant used for startMonitor()/stopMonitor() that tells you want to
+   * monitor file loads.
+   */
+  MONITOR_FILE_ACTIVITY: 1,
+
+  /**
+   * Constant used for startMonitor()/stopMonitor() that tells you want to
+   * monitor page location changes.
+   */
+  MONITOR_LOCATION_CHANGE: 2,
+
+  /**
+   * Tells if you want to monitor file activity.
+   * @private
+   * @type boolean
+   */
+  _fileActivity: false,
+
+  /**
+   * Tells if you want to monitor location changes.
+   * @private
+   * @type boolean
+   */
+  _locationChange: false,
+
+  /**
+   * Tells if the console progress listener is initialized or not.
+   * @private
+   * @type boolean
+   */
+  _initialized: false,
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIWebProgressListener,
+                                         Ci.nsISupportsWeakReference]),
+
+  /**
+   * Initialize the ConsoleProgressListener.
+   * @private
+   */
+  _init: function CPL__init()
+  {
+    if (this._initialized) {
+      return;
+    }
+
+    this._initialized = true;
+    let webProgress = this.browser.docShell.QueryInterface(Ci.nsIWebProgress);
+    webProgress.addProgressListener(this, Ci.nsIWebProgress.NOTIFY_STATE_ALL);
+  },
+
+  /**
+   * Start a monitor/tracker related to the current nsIWebProgressListener
+   * instance.
+   *
+   * @param number aMonitor
+   *        Tells what you want to track. Available constants:
+   *        - this.MONITOR_FILE_ACTIVITY
+   *          Track file loads.
+   *        - this.MONITOR_LOCATION_CHANGE
+   *          Track location changes for the top window.
+   */
+  startMonitor: function CPL_startMonitor(aMonitor)
+  {
+    switch (aMonitor) {
+      case this.MONITOR_FILE_ACTIVITY:
+        this._fileActivity = true;
+        break;
+      case this.MONITOR_LOCATION_CHANGE:
+        this._locationChange = true;
+        break;
+      default:
+        throw new Error("ConsoleProgressListener: unknown monitor type " +
+                        aMonitor + "!");
+    }
+    this._init();
+  },
+
+  /**
+   * Stop a monitor.
+   *
+   * @param number aMonitor
+   *        Tells what you want to stop tracking. See this.startMonitor() for
+   *        the list of constants.
+   */
+  stopMonitor: function CPL_stopMonitor(aMonitor)
+  {
+    switch (aMonitor) {
+      case this.MONITOR_FILE_ACTIVITY:
+        this._fileActivity = false;
+        break;
+      case this.MONITOR_LOCATION_CHANGE:
+        this._locationChange = false;
+        break;
+      default:
+        throw new Error("ConsoleProgressListener: unknown monitor type " +
+                        aMonitor + "!");
+    }
+
+    if (!this._fileActivity && !this._locationChange) {
+      this.destroy();
+    }
+  },
+
+  onStateChange:
+  function CPL_onStateChange(aProgress, aRequest, aState, aStatus)
+  {
+    if (!this.owner) {
+      return;
+    }
+
+    if (this._fileActivity) {
+      this._checkFileActivity(aProgress, aRequest, aState, aStatus);
+    }
+
+    if (this._locationChange) {
+      this._checkLocationChange(aProgress, aRequest, aState, aStatus);
+    }
+  },
+
+  /**
+   * Check if there is any file load, given the arguments of
+   * nsIWebProgressListener.onStateChange. If the state change tells that a file
+   * URI has been loaded, then the remote Web Console instance is notified.
+   * @private
+   */
+  _checkFileActivity:
+  function CPL__checkFileActivity(aProgress, aRequest, aState, aStatus)
+  {
+    if (!(aState & Ci.nsIWebProgressListener.STATE_START)) {
+      return;
+    }
+
+    let uri = null;
+    if (aRequest instanceof Ci.imgIRequest) {
+      let imgIRequest = aRequest.QueryInterface(Ci.imgIRequest);
+      uri = imgIRequest.URI;
+    }
+    else if (aRequest instanceof Ci.nsIChannel) {
+      let nsIChannel = aRequest.QueryInterface(Ci.nsIChannel);
+      uri = nsIChannel.URI;
+    }
+
+    if (!uri || !uri.schemeIs("file") && !uri.schemeIs("ftp")) {
+      return;
+    }
+
+    this.owner.onFileActivity(uri.spec);
+  },
+
+  /**
+   * Check if the current window.top location is changing, given the arguments
+   * of nsIWebProgressListener.onStateChange. If that is the case, the remote
+   * Web Console instance is notified.
+   * @private
+   */
+  _checkLocationChange:
+  function CPL__checkLocationChange(aProgress, aRequest, aState, aStatus)
+  {
+    let isStart = aState & Ci.nsIWebProgressListener.STATE_START;
+    let isStop = aState & Ci.nsIWebProgressListener.STATE_STOP;
+    let isNetwork = aState & Ci.nsIWebProgressListener.STATE_IS_NETWORK;
+    let isWindow = aState & Ci.nsIWebProgressListener.STATE_IS_WINDOW;
+
+    // Skip non-interesting states.
+    if (!isNetwork || !isWindow ||
+        aProgress.DOMWindow != this.browser.contentWindow) {
+      return;
+    }
+
+    if (isStart && aRequest instanceof Ci.nsIChannel) {
+      this.owner.onLocationChange(aRequest.URI.spec, "");
+    }
+    else if (isStop) {
+      this.owner.onLocationChange(this.browser.contentWindow.location.href,
+                                  this.browser.contentWindow.document.title);
+    }
+  },
+
+  onLocationChange: function() {},
+  onStatusChange: function() {},
+  onProgressChange: function() {},
+  onSecurityChange: function() {},
+
+  /**
+   * Destroy the ConsoleProgressListener.
+   */
+  destroy: function CPL_destroy()
+  {
+    if (!this._initialized) {
+      return;
+    }
+
+    this._initialized = false;
+    this._fileActivity = false;
+    this._locationChange = false;
+
+    let webProgress = this.browser.docShell.QueryInterface(Ci.nsIWebProgress);
+    webProgress.removeProgressListener(this);
+
+    this.browser = null;
+    this.owner = null;
+  },
+};
+
+function gSequenceId()
+{
+  return gSequenceId.n++;
+}
+gSequenceId.n = 0;
