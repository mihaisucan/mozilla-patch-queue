# HG changeset patch
# Parent 2f5dd0bf9cf9e86780c81824238b532765b6b1bf
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1349373724 -10800
Bug 768096 - Web Console remote debugging protocol support - Part 3: network logging; try: -b do -p all -u mochitests,xpcshell -t none

diff --git a/browser/devtools/webconsole/HUDService-content.js b/browser/devtools/webconsole/HUDService-content.js
--- a/browser/devtools/webconsole/HUDService-content.js
+++ b/browser/devtools/webconsole/HUDService-content.js
@@ -13,17 +13,17 @@ let Ci = Components.interfaces;
 let Cu = Components.utils;
 const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
 
 let tempScope = {};
 Cu.import("resource://gre/modules/XPCOMUtils.jsm", tempScope);
 Cu.import("resource://gre/modules/Services.jsm", tempScope);
 Cu.import("resource://gre/modules/ConsoleAPIStorage.jsm", tempScope);
 Cu.import("resource://gre/modules/devtools/WebConsoleUtils.jsm", tempScope);
-Cu.import("resource:///modules/NetworkHelper.jsm", tempScope);
+Cu.import("resource://gre/modules/devtools/NetworkHelper.jsm", tempScope);
 Cu.import("resource://gre/modules/NetUtil.jsm", tempScope);
 
 let XPCOMUtils = tempScope.XPCOMUtils;
 let Services = tempScope.Services;
 let gConsoleStorage = tempScope.ConsoleAPIStorage;
 let WebConsoleUtils = tempScope.WebConsoleUtils;
 let l10n = new WebConsoleUtils.l10n(STRINGS_URI);
 let JSPropertyProvider = tempScope.JSPropertyProvider;
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -525,38 +525,22 @@ WebConsole.prototype = {
    * the content process.
    *
    * @private
    * @type object
    */
   _asyncRequests: null,
 
   /**
-   * Message names that the HUD listens for. These messages come from the remote
-   * Web Console content script.
-   *
-   * @private
-   * @type array
-   */
-  _messageListeners: ["WebConsole:Initialized", "WebConsole:NetworkActivity",
-    "WebConsole:FileActivity", "WebConsole:LocationChange"],
-
-  /**
    * The xul:panel that holds the Web Console when it is positioned as a window.
    * @type nsIDOMElement
    */
   consolePanel: null,
 
   /**
-   * The current tab location.
-   * @type string
-   */
-  contentLocation: "",
-
-  /**
    * Getter for the xul:popupset that holds any popups we open.
    * @type nsIDOMElement
    */
   get mainPopupSet()
   {
     return this.chromeDocument.getElementById("mainPopupSet");
   },
 
@@ -616,17 +600,16 @@ WebConsole.prototype = {
   _onIframeLoad: function WC__onIframeLoad()
   {
     this.iframe.removeEventListener("load", this._onIframeLoad, true);
 
     let position = Services.prefs.getCharPref("devtools.webconsole.position");
 
     this.iframeWindow = this.iframe.contentWindow.wrappedJSObject;
     this.ui = new this.iframeWindow.WebConsoleFrame(this, position);
-    this._setupMessageManager();
   },
 
   /**
    * Create a panel to open the web console if it should float above
    * the content in its own window.
    * @private
    */
   _createOwnWindowPanel: function WC__createOwnWindowPanel()
@@ -761,18 +744,18 @@ WebConsole.prototype = {
   /**
    * Retrieve the Web Console panel title.
    *
    * @return string
    *         The Web Console panel title.
    */
   getPanelTitle: function WC_getPanelTitle()
   {
-    return l10n.getFormatStr("webConsoleWindowTitleAndURL",
-                             [this.contentLocation]);
+    let url = this.ui ? this.ui.contentLocation : "";
+    return l10n.getFormatStr("webConsoleWindowTitleAndURL", [url]);
   },
 
   positions: {
     above: 0, // the childNode index
     below: 2,
     window: null
   },
 
@@ -986,26 +969,26 @@ WebConsole.prototype = {
         message: aMessage,
         callback: aCallback,
       };
     }
     this.messageManager.sendAsyncMessage(aName, aMessage);
   },
 
   /**
-   * Handler for the "WebConsole:LocationChange" message. If the Web Console is
+   * Handler for page location changes. If the Web Console is
    * opened in a panel the panel title is updated.
    *
-   * @param object aMessage
-   *        The message received from the content script. It needs to hold two
-   *        properties: location and title.
+   * @param string aURI
+   *        New page location.
+   * @param string aTitle
+   *        New page title.
    */
-  onLocationChange: function WC_onLocationChange(aMessage)
+  onLocationChange: function WC_onLocationChange(aURI, aTitle)
   {
-    this.contentLocation = aMessage.location;
     if (this.consolePanel) {
       this.consolePanel.label = this.getPanelTitle();
     }
   },
 
   /**
    * Alias for the WebConsoleFrame.setFilterState() method.
    * @see webconsole.js::WebConsoleFrame.setFilterState()
@@ -1031,22 +1014,16 @@ WebConsole.prototype = {
    * Console is closed.
    *
    * @param function [aOnDestroy]
    *        Optional function to invoke when the Web Console instance is
    *        destroyed.
    */
   destroy: function WC_destroy(aOnDestroy)
   {
-    this.sendMessageToContent("WebConsole:Destroy", {});
-
-    this._messageListeners.forEach(function(aName) {
-      this.messageManager.removeMessageListener(aName, this.ui);
-    }, this);
-
     // Make sure that the console panel does not try to call
     // deactivateHUDForContext() again.
     this.consoleWindowUnregisterOnHide = false;
 
     let popupset = this.mainPopupSet;
     let panels = popupset.querySelectorAll("panel[hudId=" + this.hudId + "]");
     for (let panel of panels) {
       if (panel != this.consolePanel) {
diff --git a/browser/devtools/webconsole/Makefile.in b/browser/devtools/webconsole/Makefile.in
--- a/browser/devtools/webconsole/Makefile.in
+++ b/browser/devtools/webconsole/Makefile.in
@@ -8,16 +8,15 @@ topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 EXTRA_JS_MODULES = \
 		HUDService.jsm \
 		PropertyPanel.jsm \
-		NetworkHelper.jsm \
 		NetworkPanel.jsm \
 		AutocompletePopup.jsm \
 		$(NULL)
 
 TEST_DIRS = test
 
 include $(topsrcdir)/config/rules.mk
diff --git a/browser/devtools/webconsole/NetworkPanel.jsm b/browser/devtools/webconsole/NetworkPanel.jsm
--- a/browser/devtools/webconsole/NetworkPanel.jsm
+++ b/browser/devtools/webconsole/NetworkPanel.jsm
@@ -11,17 +11,17 @@ const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "mimeService", "@mozilla.org/mime;1",
                                    "nsIMIMEService");
 
 XPCOMUtils.defineLazyModuleGetter(this, "NetworkHelper",
-                                  "resource:///modules/NetworkHelper.jsm");
+                                  "resource://gre/modules/devtools/NetworkHelper.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "NetUtil",
                                   "resource://gre/modules/NetUtil.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
 const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
@@ -71,41 +71,43 @@ function NetworkPanel(aParent, aHttpActi
 
     if (self.linkNode) {
       self.linkNode._panelOpen = false;
       self.linkNode = null;
     }
   }, false);
 
   // Set the document object and update the content once the panel is loaded.
-  this.panel.addEventListener("load", function onLoad() {
-    self.panel.removeEventListener("load", onLoad, true);
-    self.document = self.iframe.contentWindow.document;
+  this.iframe.addEventListener("load", function onLoad() {
+    if (!self.iframe) {
+      return;
+    }
+
+    self.iframe.removeEventListener("load", onLoad, true);
+    self.update();
+  }, true);
+
+  this.panel.addEventListener("popupshown", function onPopupShown() {
+    self.panel.removeEventListener("popupshown", onPopupShown, true);
     self.update();
   }, true);
 
   // Create the footer.
   let footer = createElement(doc, "hbox", { align: "end" });
   createAndAppendElement(footer, "spacer", { flex: 1 });
 
   createAndAppendElement(footer, "resizer", { dir: "bottomend" });
   this.panel.appendChild(footer);
 
   aParent.appendChild(this.panel);
 }
 
 NetworkPanel.prototype =
 {
   /**
-   * Callback is called once the NetworkPanel is processed completely. Used by
-   * unit tests.
-   */
-  isDoneCallback: null,
-
-  /**
    * The current state of the output.
    */
   _state: 0,
 
   /**
    * State variables.
    */
   _INIT: 0,
@@ -114,16 +116,30 @@ NetworkPanel.prototype =
   _DISPLAYED_RESPONSE_HEADER: 3,
   _TRANSITION_CLOSED: 4,
 
   _fromDataRegExp: /Content-Type\:\s*application\/x-www-form-urlencoded/,
 
   _contentType: null,
 
   /**
+   * Function callback invoked whenever the panel content is updated. This is
+   * used only by tests.
+   *
+   * @private
+   * @type function
+   */
+  _onUpdate: null,
+
+  get document() {
+    return this.iframe && this.iframe.contentWindow ?
+           this.iframe.contentWindow.document : null;
+  },
+
+  /**
    * Small helper function that is nearly equal to l10n.getFormatStr
    * except that it prefixes aName with "NetworkPanel.".
    *
    * @param string aName
    *        The name of an i10n string to format. This string is prefixed with
    *        "NetworkPanel." before calling the HUDService.getFormatStr function.
    * @param array aArray
    *        Values used as placeholder for the i10n string.
@@ -145,19 +161,18 @@ NetworkPanel.prototype =
    *         out.
    */
   get contentType()
   {
     if (this._contentType) {
       return this._contentType;
     }
 
-    let entry = this.httpActivity.log.entries[0];
-    let request = entry.request;
-    let response = entry.response;
+    let request = this.httpActivity.request;
+    let response = this.httpActivity.response;
 
     let contentType = "";
     let types = response.content ?
                 (response.content.mimeType || "").split(/,|;/) : [];
     for (let i = 0; i < types.length; i++) {
       if (types[i] in NetworkHelper.mimeCategoryMap) {
         contentType = types[i];
         break;
@@ -231,28 +246,28 @@ NetworkPanel.prototype =
    * Tells if the server response is cached.
    *
    * @returns boolean
    *          Returns true if the server responded that the request is already
    *          in the browser's cache, false otherwise.
    */
   get _isResponseCached()
   {
-    return this.httpActivity.log.entries[0].response.status == 304;
+    return this.httpActivity.response.status == 304;
   },
 
   /**
    * Tells if the request body includes form data.
    *
    * @returns boolean
    *          Returns true if the posted body contains form data.
    */
   get _isRequestBodyFormData()
   {
-    let requestBody = this.httpActivity.log.entries[0].request.postData.text;
+    let requestBody = this.httpActivity.request.postData.text;
     return this._fromDataRegExp.test(requestBody);
   },
 
   /**
    * Appends the node with id=aId by the text aValue.
    *
    * @param string aId
    * @param string aValue
@@ -336,19 +351,18 @@ NetworkPanel.prototype =
    * If the request header contains cookie data, a list of sent cookies is
    * generated and a special sent cookie section is displayed + the cookie list
    * added to it.
    *
    * @returns void
    */
   _displayRequestHeader: function NP__displayRequestHeader()
   {
-    let entry = this.httpActivity.log.entries[0];
-    let request = entry.request;
-    let requestTime = new Date(entry.startedDateTime);
+    let request = this.httpActivity.request;
+    let requestTime = new Date(this.httpActivity.startedDateTime);
 
     this._appendTextNode("headUrl", request.url);
     this._appendTextNode("headMethod", request.method);
     this._appendTextNode("requestHeadersInfo",
                          l10n.timestampString(requestTime));
 
     this._appendList("requestHeadersContent", request.headers, true);
 
@@ -359,30 +373,32 @@ NetworkPanel.prototype =
   },
 
   /**
    * Displays the request body section of the NetworkPanel and set the request
    * body content on the NetworkPanel.
    *
    * @returns void
    */
-  _displayRequestBody: function NP__displayRequestBody() {
-    let postData = this.httpActivity.log.entries[0].request.postData;
+  _displayRequestBody: function NP__displayRequestBody()
+  {
+    let postData = this.httpActivity.request.postData;
     this._displayNode("requestBody");
     this._appendTextNode("requestBodyContent", postData.text);
   },
 
   /*
    * Displays the `sent form data` section. Parses the request header for the
    * submitted form data displays it inside of the `sent form data` section.
    *
    * @returns void
    */
-  _displayRequestForm: function NP__processRequestForm() {
-    let postData = this.httpActivity.log.entries[0].request.postData.text;
+  _displayRequestForm: function NP__processRequestForm()
+  {
+    let postData = this.httpActivity.request.postData.text;
     let requestBodyLines = postData.split("\n");
     let formData = requestBodyLines[requestBodyLines.length - 1].
                       replace(/\+/g, " ").split("&");
 
     function unescapeText(aText)
     {
       try {
         return decodeURIComponent(aText);
@@ -412,19 +428,18 @@ NetworkPanel.prototype =
    * Displays the response section of the NetworkPanel, sets the response status,
    * the duration between the start of the request and the receiving of the
    * response header as well as the response header content on the the NetworkPanel.
    *
    * @returns void
    */
   _displayResponseHeader: function NP__displayResponseHeader()
   {
-    let entry = this.httpActivity.log.entries[0];
-    let timing = entry.timings;
-    let response = entry.response;
+    let timing = this.httpActivity.timings;
+    let response = this.httpActivity.response;
 
     this._appendTextNode("headStatus",
                          [response.httpVersion, response.status,
                           response.statusText].join(" "));
 
     // Calculate how much time it took from the request start, until the
     // response started to be received.
     let deltaDuration = 0;
@@ -448,26 +463,26 @@ NetworkPanel.prototype =
    * the receiving of the response header and the end of the request. Once the
    * image is loaded, the size of the requested image is set.
    *
    * @returns void
    */
   _displayResponseImage: function NP__displayResponseImage()
   {
     let self = this;
-    let entry = this.httpActivity.log.entries[0];
-    let timing = entry.timings;
-    let request = entry.request;
+    let timing = this.httpActivity.timings;
+    let request = this.httpActivity.request;
     let cached = "";
 
     if (this._isResponseCached) {
       cached = "Cached";
     }
 
-    let imageNode = this.document.getElementById("responseImage" + cached +"Node");
+    let imageNode = this.document.getElementById("responseImage" +
+                                                 cached + "Node");
     imageNode.setAttribute("src", request.url);
 
     // This function is called to set the imageInfo.
     function setImageInfo() {
       self._appendTextNode("responseImage" + cached + "Info",
         self._format("imageSizeDeltaDurationMS",
           [ imageNode.width, imageNode.height, timing.receive ]
         )
@@ -493,19 +508,18 @@ NetworkPanel.prototype =
    * Displays the response body section, sets the the duration between
    * the receiving of the response header and the end of the request as well as
    * the content of the response body on the NetworkPanel.
    *
    * @returns void
    */
   _displayResponseBody: function NP__displayResponseBody()
   {
-    let entry = this.httpActivity.log.entries[0];
-    let timing = entry.timings;
-    let response = entry.response;
+    let timing = this.httpActivity.timings;
+    let response = this.httpActivity.response;
     let cached =  this._isResponseCached ? "Cached" : "";
 
     this._appendTextNode("responseBody" + cached + "Info",
       this._format("durationMS", [timing.receive]));
 
     this._displayNode("responseBody" + cached);
     this._appendTextNode("responseBody" + cached + "Content",
                          response.content.text);
@@ -514,17 +528,17 @@ NetworkPanel.prototype =
   /**
    * Displays the `Unknown Content-Type hint` and sets the duration between the
    * receiving of the response header on the NetworkPanel.
    *
    * @returns void
    */
   _displayResponseBodyUnknownType: function NP__displayResponseBodyUnknownType()
   {
-    let timing = this.httpActivity.log.entries[0].timings;
+    let timing = this.httpActivity.timings;
 
     this._displayNode("responseBodyUnknownType");
     this._appendTextNode("responseBodyUnknownTypeInfo",
       this._format("durationMS", [timing.receive]));
 
     this._appendTextNode("responseBodyUnknownTypeContent",
       this._format("responseBodyUnableToDisplay.content", [this.contentType]));
   },
@@ -532,98 +546,97 @@ NetworkPanel.prototype =
   /**
    * Displays the `no response body` section and sets the the duration between
    * the receiving of the response header and the end of the request.
    *
    * @returns void
    */
   _displayNoResponseBody: function NP_displayNoResponseBody()
   {
-    let timing = this.httpActivity.log.entries[0].timings;
+    let timing = this.httpActivity.timings;
 
     this._displayNode("responseNoBody");
     this._appendTextNode("responseNoBodyInfo",
       this._format("durationMS", [timing.receive]));
   },
 
   /**
    * Updates the content of the NetworkPanel's iframe.
    *
    * @returns void
    */
   update: function NP_update()
   {
     // After the iframe's contentWindow is ready, the document object is set.
     // If the document object is not available yet nothing needs to be updated.
-    if (!this.document) {
+    if (!this.document || !this.document.getElementById("headUrl")) {
       return;
     }
 
-    let stages = this.httpActivity.meta.stages;
-    let entry = this.httpActivity.log.entries[0];
-    let timing = entry.timings;
-    let request = entry.request;
-    let response = entry.response;
+    let updates = this.httpActivity.updates;
+    let timing = this.httpActivity.timings;
+    let request = this.httpActivity.request;
+    let response = this.httpActivity.response;
 
     switch (this._state) {
       case this._INIT:
         this._displayRequestHeader();
         this._state = this._DISPLAYED_REQUEST_HEADER;
         // FALL THROUGH
 
       case this._DISPLAYED_REQUEST_HEADER:
         // Process the request body if there is one.
-        if (!this.httpActivity.meta.discardRequestBody && request.postData) {
+        if (!this.httpActivity.discardRequestBody && request.postData.text) {
           // Check if we send some form data. If so, display the form data special.
           if (this._isRequestBodyFormData) {
             this._displayRequestForm();
           }
           else {
             this._displayRequestBody();
           }
           this._state = this._DISPLAYED_REQUEST_BODY;
         }
         // FALL THROUGH
 
       case this._DISPLAYED_REQUEST_BODY:
-        // There is always a response header. Therefore we can skip here if
-        // we don't have a response header yet and don't have to try updating
-        // anything else in the NetworkPanel.
         if (!response.headers.length || !Object.keys(timing).length) {
           break;
         }
         this._displayResponseHeader();
         this._state = this._DISPLAYED_RESPONSE_HEADER;
         // FALL THROUGH
 
       case this._DISPLAYED_RESPONSE_HEADER:
-        if (stages.indexOf("REQUEST_STOP") == -1 ||
-            stages.indexOf("TRANSACTION_CLOSE") == -1) {
+        if (updates.indexOf("responseContent") == -1 ||
+            updates.indexOf("eventTimings") == -1) {
           break;
         }
 
         this._state = this._TRANSITION_CLOSED;
-        if (this.httpActivity.meta.discardResponseBody) {
+        if (this.httpActivity.discardResponseBody) {
           break;
         }
 
         if (!response.content || !response.content.text) {
           this._displayNoResponseBody();
         }
         else if (this._responseIsImage) {
           this._displayResponseImage();
         }
         else if (!this._isResponseBodyTextData) {
           this._displayResponseBodyUnknownType();
         }
         else if (response.content.text) {
           this._displayResponseBody();
         }
+        break;
+    }
 
-        break;
+    if (this._onUpdate) {
+      this._onUpdate();
     }
   }
 }
 
 /**
  * Creates a DOMNode and sets all the attributes of aAttributes on the created
  * element.
  *
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_599725_response_headers.js b/browser/devtools/webconsole/test/browser_webconsole_bug_599725_response_headers.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_599725_response_headers.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_599725_response_headers.js
@@ -5,37 +5,42 @@
  *
  * Contributor(s):
  *  Mihai Șucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-599725-response-headers.sjs";
 
-function performTest(lastFinishedRequest)
+function performTest(lastFinishedRequest, aConsole)
 {
   ok(lastFinishedRequest, "page load was logged");
 
+  let headers = null;
+
   function readHeader(aName)
   {
     for (let header of headers) {
       if (header.name == aName) {
         return header.value;
       }
     }
     return null;
   }
 
-  let headers = lastFinishedRequest.log.entries[0].response.headers;
-  ok(headers, "we have the response headers");
-  ok(!readHeader("Content-Type"), "we do not have the Content-Type header");
-  isnot(readHeader("Content-Length"), 60, "Content-Length != 60");
+  aConsole.webConsoleClient.getResponseHeaders(lastFinishedRequest.actor,
+    function (aResponse) {
+      headers = aResponse.headers;
+      ok(headers, "we have the response headers");
+      ok(!readHeader("Content-Type"), "we do not have the Content-Type header");
+      isnot(readHeader("Content-Length"), 60, "Content-Length != 60");
+      executeSoon(finishTest);
+    });
 
   HUDService.lastFinishedRequestCallback = null;
-  executeSoon(finishTest);
 }
 
 function test()
 {
   addTab(TEST_URI);
 
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js b/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
@@ -5,44 +5,54 @@
  *
  * Contributor(s):
  *  Mihai Șucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-600183-charset.html";
 
-function performTest(lastFinishedRequest)
+function performTest(lastFinishedRequest, aConsole)
 {
   ok(lastFinishedRequest, "charset test page was loaded and logged");
 
-  let body = lastFinishedRequest.log.entries[0].response.content.text;
-  ok(body, "we have the response body");
+  aConsole.webConsoleClient.getResponseContent(lastFinishedRequest.actor,
+    function (aResponse) {
+      ok(!aResponse.contentDiscarded, "response body was not discarded");
 
-  let chars = "\u7684\u95ee\u5019!"; // 的问候!
-  isnot(body.indexOf("<p>" + chars + "</p>"), -1,
-    "found the chinese simplified string");
+      let body = aResponse.content.text;
+      ok(body, "we have the response body");
+
+      let chars = "\u7684\u95ee\u5019!"; // 的问候!
+      isnot(body.indexOf("<p>" + chars + "</p>"), -1,
+        "found the chinese simplified string");
+      executeSoon(finishTest);
+    });
 
   HUDService.lastFinishedRequestCallback = null;
-  executeSoon(finishTest);
 }
 
 function test()
 {
   addTab("data:text/html;charset=utf-8,Web Console - bug 600183 test");
 
-  let initialLoad = true;
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
 
-  browser.addEventListener("load", function onLoad() {
-    if (initialLoad) {
-      openConsole(null, function(hud) {
+    openConsole(null, function(hud) {
+      hud.ui.saveRequestAndResponseBodies = true;
 
-        hud.ui.saveRequestAndResponseBodies = true;
-        HUDService.lastFinishedRequestCallback = performTest;
-
-        content.location = TEST_URI;
+      waitForSuccess({
+        name: "saveRequestAndResponseBodies update",
+        validatorFn: function()
+        {
+          return hud.ui.saveRequestAndResponseBodies;
+        },
+        successFn: function()
+        {
+          HUDService.lastFinishedRequestCallback = performTest;
+          content.location = TEST_URI;
+        },
+        failureFn: finishTest,
       });
-      initialLoad = false;
-    } else {
-      browser.removeEventListener("load", onLoad, true);
-    }
+    });
   }, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js b/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
@@ -81,18 +81,27 @@ function onpopupshown2(aEvent)
 
     // Reopen the context menu.
     menupopups[1].addEventListener("popupshown", onpopupshown2b, false);
     executeSoon(function() {
       menupopups[1].openPopup();
     });
   }, false);
 
-  executeSoon(function() {
-    menupopups[1].hidePopup();
+  waitForSuccess({
+    name: "saveRequestAndResponseBodies update",
+    validatorFn: function()
+    {
+      return huds[1].ui.saveRequestAndResponseBodies;
+    },
+    successFn: function()
+    {
+      menupopups[1].hidePopup();
+    },
+    failureFn: finishTest,
   });
 }
 
 function onpopupshown2b(aEvent)
 {
   menupopups[1].removeEventListener(aEvent.type, onpopupshown2b, false);
   is(menuitems[1].getAttribute("checked"), "true", "menuitems[1] is checked");
 
@@ -142,18 +151,27 @@ function onpopupshown1(aEvent)
     gBrowser.selectedTab = tabs[runCount*2 + 1];
     waitForFocus(function() {
       // Reopen the context menu from tab 2.
       menupopups[1].addEventListener("popupshown", onpopupshown2c, false);
       menupopups[1].openPopup();
     }, tabs[runCount*2 + 1].linkedBrowser.contentWindow);
   }, false);
 
-  executeSoon(function() {
-    menupopups[0].hidePopup();
+  waitForSuccess({
+    name: "saveRequestAndResponseBodies update",
+    validatorFn: function()
+    {
+      return huds[0].ui.saveRequestAndResponseBodies;
+    },
+    successFn: function()
+    {
+      menupopups[0].hidePopup();
+    },
+    failureFn: finishTest,
   });
 }
 
 function onpopupshown2c(aEvent)
 {
   menupopups[1].removeEventListener(aEvent.type, onpopupshown2c, false);
 
   is(menuitems[1].getAttribute("checked"), "true", "menuitems[1] is checked");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js b/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
@@ -5,75 +5,133 @@
  *
  * Contributor(s):
  *   Mihai Sucan <mihai.sucan@gmail.com>
  */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-630733-response-redirect-headers.sjs";
 
 let lastFinishedRequests = {};
+let webConsoleClient;
 
-function requestDoneCallback(aHttpRequest)
+function requestDoneCallback(aHttpRequest )
 {
-  let status = aHttpRequest.log.entries[0].response.status;
+  let status = aHttpRequest.response.status;
   lastFinishedRequests[status] = aHttpRequest;
 }
 
-function performTest(aEvent)
+function consoleOpened(hud)
+{
+  webConsoleClient = hud.ui.webConsoleClient;
+  hud.ui.saveRequestAndResponseBodies = true;
+
+  waitForSuccess({
+    name: "saveRequestAndResponseBodies update",
+    validatorFn: function()
+    {
+      return hud.ui.saveRequestAndResponseBodies;
+    },
+    successFn: function()
+    {
+      HUDService.lastFinishedRequestCallback = requestDoneCallback;
+      waitForSuccess(waitForResponses);
+      content.location = TEST_URI;
+    },
+    failureFn: finishTest,
+  });
+
+  let waitForResponses = {
+    name: "301 and 404 responses",
+    validatorFn: function()
+    {
+      return "301" in lastFinishedRequests &&
+             "404" in lastFinishedRequests;
+    },
+    successFn: getHeaders,
+    failureFn: finishTest,
+  };
+}
+
+function getHeaders()
 {
   HUDService.lastFinishedRequestCallback = null;
 
   ok("301" in lastFinishedRequests, "request 1: 301 Moved Permanently");
   ok("404" in lastFinishedRequests, "request 2: 404 Not found");
 
+  webConsoleClient.getResponseHeaders(lastFinishedRequests["301"].actor,
+    function (aResponse) {
+      lastFinishedRequests["301"].response.headers = aResponse.headers;
+
+      webConsoleClient.getResponseHeaders(lastFinishedRequests["404"].actor,
+        function (aResponse) {
+          lastFinishedRequests["404"].response.headers = aResponse.headers;
+          executeSoon(getContent);
+        });
+    });
+}
+
+function getContent()
+{
+  webConsoleClient.getResponseContent(lastFinishedRequests["301"].actor,
+    function (aResponse) {
+      lastFinishedRequests["301"].response.content = aResponse.content;
+      lastFinishedRequests["301"].discardResponseBody = aResponse.contentDiscarded;
+
+      webConsoleClient.getResponseContent(lastFinishedRequests["404"].actor,
+        function (aResponse) {
+          lastFinishedRequests["404"].response.content = aResponse.content;
+          lastFinishedRequests["404"].discardResponseBody =
+            aResponse.contentDiscarded;
+
+          webConsoleClient = null;
+          executeSoon(performTest);
+        });
+    });
+}
+
+function performTest()
+{
   function readHeader(aName)
   {
     for (let header of headers) {
       if (header.name == aName) {
         return header.value;
       }
     }
     return null;
   }
 
-  let headers = lastFinishedRequests["301"].log.entries[0].response.headers;
+  let headers = lastFinishedRequests["301"].response.headers;
   is(readHeader("Content-Type"), "text/html",
      "we do have the Content-Type header");
   is(readHeader("Content-Length"), 71, "Content-Length is correct");
   is(readHeader("Location"), "/redirect-from-bug-630733",
      "Content-Length is correct");
   is(readHeader("x-foobar-bug630733"), "bazbaz",
      "X-Foobar-bug630733 is correct");
-  let body = lastFinishedRequests["301"].log.entries[0].response.content;
+
+  let body = lastFinishedRequests["301"].response.content;
   ok(!body.text, "body discarded for request 1");
+  ok(lastFinishedRequests["301"].discardResponseBody,
+     "body discarded for request 1 (confirmed)");
 
-  headers = lastFinishedRequests["404"].log.entries[0].response.headers;
+  headers = lastFinishedRequests["404"].response.headers;
   ok(!readHeader("Location"), "no Location header");
   ok(!readHeader("x-foobar-bug630733"), "no X-Foobar-bug630733 header");
 
-  body = lastFinishedRequests["404"].log.entries[0].response.content.text;
+  body = lastFinishedRequests["404"].response.content.text;
   isnot(body.indexOf("404"), -1,
         "body is correct for request 2");
 
   lastFinishedRequests = null;
   executeSoon(finishTest);
 }
 
 function test()
 {
   addTab("data:text/html;charset=utf-8,<p>Web Console test for bug 630733");
 
-  browser.addEventListener("load", function onLoad1(aEvent) {
-    browser.removeEventListener(aEvent.type, onLoad1, true);
-
-    openConsole(null, function(hud) {
-      hud.ui.saveRequestAndResponseBodies = true;
-      HUDService.lastFinishedRequestCallback = requestDoneCallback;
-
-      browser.addEventListener("load", function onLoad2(aEvent) {
-        browser.removeEventListener(aEvent.type, onLoad2, true);
-        executeSoon(performTest);
-      }, true);
-
-      content.location = TEST_URI;
-    });
+  browser.addEventListener("load", function onLoad(aEvent) {
+    browser.removeEventListener(aEvent.type, onLoad, true);
+    openConsole(null, consoleOpened);
   }, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js b/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_632817.js
@@ -20,17 +20,17 @@ function test()
 
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
 
     openConsole(null, function(aHud) {
       hud = aHud;
 
       HUDService.lastFinishedRequestCallback = function(aRequest) {
-        lastRequest = aRequest.log.entries[0];
+        lastRequest = aRequest;
         if (requestCallback) {
           requestCallback();
         }
       };
 
       executeSoon(testPageLoad);
     });
   }, true);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_netlogging.js b/browser/devtools/webconsole/test/browser_webconsole_netlogging.js
--- a/browser/devtools/webconsole/test/browser_webconsole_netlogging.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_netlogging.js
@@ -16,70 +16,101 @@ const TEST_NETWORK_REQUEST_URI = "http:/
 
 const TEST_IMG = "http://example.com/browser/browser/devtools/webconsole/test/test-image.png";
 
 const TEST_DATA_JSON_CONTENT =
   '{ id: "test JSON data", myArray: [ "foo", "bar", "baz", "biff" ] }';
 
 let lastRequest = null;
 let requestCallback = null;
-let lastActivity = null;
 
 function test()
 {
   addTab("data:text/html;charset=utf-8,Web Console network logging tests");
 
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
 
     openConsole(null, function(aHud) {
       hud = aHud;
 
-      HUDService.lastFinishedRequestCallback = function(aRequest) {
-        lastRequest = aRequest.log.entries[0];
-        lastActivity = aRequest;
-        if (requestCallback) {
-          requestCallback();
-        }
-      };
+      HUDService.lastFinishedRequestCallback = requestCallbackWrapper;
 
       executeSoon(testPageLoad);
     });
   }, true);
 }
 
+function requestCallbackWrapper(aRequest)
+{
+  lastRequest = aRequest;
+
+  hud.ui.webConsoleClient.getResponseContent(lastRequest.actor,
+    function(aResponse) {
+      lastRequest.response.content = aResponse.content;
+      lastRequest.discardResponseBody = aResponse.contentDiscarded;
+
+      hud.ui.webConsoleClient.getRequestPostData(lastRequest.actor,
+        function(aResponse) {
+          lastRequest.request.postData = aResponse.postData;
+          lastRequest.discardRequestBody = aResponse.postDataDiscarded;
+
+          if (requestCallback) {
+            requestCallback();
+          }
+        });
+    });
+}
+
 function testPageLoad()
 {
   requestCallback = function() {
     // Check if page load was logged correctly.
     ok(lastRequest, "Page load was logged");
 
     is(lastRequest.request.url, TEST_NETWORK_REQUEST_URI,
       "Logged network entry is page load");
     is(lastRequest.request.method, "GET", "Method is correct");
-    ok(!lastRequest.request.postData, "No request body was stored");
+    ok(!lastRequest.request.postData.text, "No request body was stored");
+    ok(lastRequest.discardRequestBody, "Request body was discarded");
     ok(!lastRequest.response.content.text, "No response body was stored");
+    ok(lastRequest.discardResponseBody, "Response body was discarded");
 
     lastRequest = null;
     requestCallback = null;
     executeSoon(testPageLoadBody);
   };
 
   content.location = TEST_NETWORK_REQUEST_URI;
 }
 
 function testPageLoadBody()
 {
+  // Turn on logging of request bodies and check again.
+  hud.ui.saveRequestAndResponseBodies = true;
+
+  waitForSuccess({
+    name: "saveRequestAndResponseBodies update",
+    validatorFn: function()
+    {
+      return hud.ui.saveRequestAndResponseBodies;
+    },
+    successFn: testPageLoadBodyAfterSettingUpdate,
+    failureFn: finishTest,
+  });
+}
+
+function testPageLoadBodyAfterSettingUpdate()
+{
   let loaded = false;
   let requestCallbackInvoked = false;
 
-  // Turn on logging of request bodies and check again.
-  hud.ui.saveRequestAndResponseBodies = true;
   requestCallback = function() {
     ok(lastRequest, "Page load was logged again");
+    ok(!lastRequest.discardResponseBody, "Response body was not discarded");
     is(lastRequest.response.content.text.indexOf("<!DOCTYPE HTML>"), 0,
       "Response body's beginning is okay");
 
     lastRequest = null;
     requestCallback = null;
     requestCallbackInvoked = true;
 
     if (loaded) {
@@ -99,17 +130,18 @@ function testPageLoadBody()
   content.location.reload();
 }
 
 function testXhrGet()
 {
   requestCallback = function() {
     ok(lastRequest, "testXhrGet() was logged");
     is(lastRequest.request.method, "GET", "Method is correct");
-    ok(!lastRequest.request.postData, "No request body was sent");
+    ok(!lastRequest.request.postData.text, "No request body was sent");
+    ok(!lastRequest.discardRequestBody, "Request body was not discarded");
     is(lastRequest.response.content.text, TEST_DATA_JSON_CONTENT,
       "Response is correct");
 
     lastRequest = null;
     requestCallback = null;
     executeSoon(testXhrPost);
   };
 
@@ -160,26 +192,25 @@ function testFormSubmission()
   ok(form, "we have the HTML form");
   form.submit();
 }
 
 function testNetworkPanel()
 {
   // Open the NetworkPanel. The functionality of the NetworkPanel is tested
   // within separate test files.
-  let networkPanel = hud.ui.openNetworkPanel(hud.ui.filterBox, lastActivity);
-  is(networkPanel, hud.ui.filterBox._netPanel,
-     "Network panel stored on anchor node");
+  let networkPanel = hud.ui.openNetworkPanel(hud.ui.filterBox, lastRequest);
 
-  networkPanel.panel.addEventListener("load", function onLoad(aEvent) {
-    networkPanel.panel.removeEventListener(aEvent.type, onLoad, true);
+  networkPanel.panel.addEventListener("popupshown", function onPopupShown() {
+    networkPanel.panel.removeEventListener("popupshown", onPopupShown, true);
 
+    is(hud.ui.filterBox._netPanel, networkPanel,
+       "Network panel stored on anchor node");
     ok(true, "NetworkPanel was opened");
 
     // All tests are done. Shutdown.
     networkPanel.panel.hidePopup();
     lastRequest = null;
-    lastActivity = null;
     HUDService.lastFinishedRequestCallback = null;
     executeSoon(finishTest);
   }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_network_panel.js b/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
--- a/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
@@ -60,52 +60,46 @@ function checkNodeKeyValue(aPanel, aId, 
   ok(false, "content check failed for " + aId + ", key " + aKey);
 }
 
 function testGen() {
   let hud = HUDService.getHudByWindow(content);
   let filterBox = hud.ui.filterBox;
 
   let httpActivity = {
-    meta: {
-      stages: [],
-      discardRequestBody: true,
-      discardResponseBody: true,
+    updates: [],
+    discardRequestBody: true,
+    discardResponseBody: true,
+    startedDateTime: (new Date()).toISOString(),
+    request: {
+      url: "http://www.testpage.com",
+      method: "GET",
+      cookies: [],
+      headers: [
+        { name: "foo", value: "bar" },
+      ],
     },
-    log: {
-      entries: [{
-        startedDateTime: (new Date()).toISOString(),
-        request: {
-          url: "http://www.testpage.com",
-          method: "GET",
-          cookies: [],
-          headers: [
-            { name: "foo", value: "bar" },
-          ],
-        },
-        response: {
-          headers: [],
-          content: {},
-        },
-        timings: {},
-      }],
+    response: {
+      headers: [],
+      content: {},
     },
+    timings: {},
   };
 
-  let entry = httpActivity.log.entries[0];
-
   let networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
 
   is(filterBox._netPanel, networkPanel,
      "Network panel stored on the anchor object");
 
-  networkPanel.panel.addEventListener("load", function onLoad() {
-    networkPanel.panel.removeEventListener("load", onLoad, true);
-    testDriver.next();
-  }, true);
+  networkPanel._onUpdate = function() {
+    networkPanel._onUpdate = null;
+    executeSoon(function() {
+      testDriver.next();
+    });
+  };
 
   yield;
 
   info("test 1");
 
   checkIsVisible(networkPanel, {
     requestCookie: false,
     requestFormData: false,
@@ -118,40 +112,40 @@ function testGen() {
   });
 
   checkNodeContent(networkPanel, "header", "http://www.testpage.com");
   checkNodeContent(networkPanel, "header", "GET");
   checkNodeKeyValue(networkPanel, "requestHeadersContent", "foo", "bar");
 
   // Test request body.
   info("test 2: request body");
-  httpActivity.meta.discardRequestBody = false;
-  entry.request.postData = { text: "hello world" };
+  httpActivity.discardRequestBody = false;
+  httpActivity.request.postData = { text: "hello world" };
   networkPanel.update();
 
   checkIsVisible(networkPanel, {
     requestBody: true,
     requestFormData: false,
     requestCookie: false,
     responseContainer: false,
     responseBody: false,
     responseNoBody: false,
     responseImage: false,
     responseImageCached: false
   });
   checkNodeContent(networkPanel, "requestBodyContent", "hello world");
 
   // Test response header.
   info("test 3: response header");
-  entry.timings.wait = 10;
-  entry.response.httpVersion = "HTTP/3.14";
-  entry.response.status = 999;
-  entry.response.statusText = "earthquake win";
-  entry.response.content.mimeType = "text/html";
-  entry.response.headers.push(
+  httpActivity.timings.wait = 10;
+  httpActivity.response.httpVersion = "HTTP/3.14";
+  httpActivity.response.status = 999;
+  httpActivity.response.statusText = "earthquake win";
+  httpActivity.response.content.mimeType = "text/html";
+  httpActivity.response.headers.push(
     { name: "Content-Type", value: "text/html" },
     { name: "leaveHouses", value: "true" }
   );
 
   networkPanel.update();
 
   checkIsVisible(networkPanel, {
     requestBody: true,
@@ -165,34 +159,34 @@ function testGen() {
   });
 
   checkNodeContent(networkPanel, "header", "HTTP/3.14 999 earthquake win");
   checkNodeKeyValue(networkPanel, "responseHeadersContent", "leaveHouses", "true");
   checkNodeContent(networkPanel, "responseHeadersInfo", "10ms");
 
   info("test 4");
 
-  httpActivity.meta.discardResponseBody = false;
-  entry.timings.receive = 2;
+  httpActivity.discardResponseBody = false;
+  httpActivity.timings.receive = 2;
   networkPanel.update();
 
   checkIsVisible(networkPanel, {
     requestBody: true,
     requestCookie: false,
     requestFormData: false,
     responseContainer: true,
     responseBody: false,
     responseNoBody: false,
     responseImage: false,
     responseImageCached: false
   });
 
   info("test 5");
 
-  httpActivity.meta.stages.push("REQUEST_STOP", "TRANSACTION_CLOSE");
+  httpActivity.updates.push("responseContent", "eventTimings");
   networkPanel.update();
 
   checkNodeContent(networkPanel, "responseNoBodyInfo", "2ms");
   checkIsVisible(networkPanel, {
     requestBody: true,
     requestCookie: false,
     responseContainer: true,
     responseBody: false,
@@ -200,30 +194,32 @@ function testGen() {
     responseImage: false,
     responseImageCached: false
   });
 
   networkPanel.panel.hidePopup();
 
   // Second run: Test for cookies and response body.
   info("test 6: cookies and response body");
-  entry.request.cookies.push(
+  httpActivity.request.cookies.push(
     { name: "foo", value: "bar" },
     { name: "hello", value: "world" }
   );
-  entry.response.content.text = "get out here";
+  httpActivity.response.content.text = "get out here";
 
   networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
   is(filterBox._netPanel, networkPanel,
      "Network panel stored on httpActivity object");
 
-  networkPanel.panel.addEventListener("load", function onLoad() {
-    networkPanel.panel.removeEventListener("load", onLoad, true);
-    testDriver.next();
-  }, true);
+  networkPanel._onUpdate = function() {
+    networkPanel._onUpdate = null;
+    executeSoon(function() {
+      testDriver.next();
+    });
+  };
 
   yield;
 
   checkIsVisible(networkPanel, {
     requestBody: true,
     requestFormData: false,
     requestCookie: true,
     responseContainer: true,
@@ -237,25 +233,27 @@ function testGen() {
   checkNodeKeyValue(networkPanel, "requestCookieContent", "hello", "world");
   checkNodeContent(networkPanel, "responseBodyContent", "get out here");
   checkNodeContent(networkPanel, "responseBodyInfo", "2ms");
 
   networkPanel.panel.hidePopup();
 
   // Check image request.
   info("test 7: image request");
-  entry.response.headers[1].value = "image/png";
-  entry.response.content.mimeType = "image/png";
-  entry.request.url = TEST_IMG;
+  httpActivity.response.headers[1].value = "image/png";
+  httpActivity.response.content.mimeType = "image/png";
+  httpActivity.request.url = TEST_IMG;
 
   networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
-  networkPanel.panel.addEventListener("load", function onLoad() {
-    networkPanel.panel.removeEventListener("load", onLoad, true);
-    testDriver.next();
-  }, true);
+  networkPanel._onUpdate = function() {
+    networkPanel._onUpdate = null;
+    executeSoon(function() {
+      testDriver.next();
+    });
+  };
 
   yield;
 
   checkIsVisible(networkPanel, {
     requestBody: true,
     requestFormData: false,
     requestCookie: true,
     responseContainer: true,
@@ -286,25 +284,27 @@ function testGen() {
   }
   else {
     checkImageResponseInfo();
     networkPanel.panel.hidePopup();
   }
 
   // Check cached image request.
   info("test 8: cached image request");
-  entry.response.httpVersion = "HTTP/1.1";
-  entry.response.status = 304;
-  entry.response.statusText = "Not Modified";
+  httpActivity.response.httpVersion = "HTTP/1.1";
+  httpActivity.response.status = 304;
+  httpActivity.response.statusText = "Not Modified";
 
   networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
-  networkPanel.panel.addEventListener("load", function onLoad() {
-    networkPanel.panel.removeEventListener("load", onLoad, true);
-    testDriver.next();
-  }, true);
+  networkPanel._onUpdate = function() {
+    networkPanel._onUpdate = null;
+    executeSoon(function() {
+      testDriver.next();
+    });
+  };
 
   yield;
 
   checkIsVisible(networkPanel, {
     requestBody: true,
     requestFormData: false,
     requestCookie: true,
     responseContainer: true,
@@ -316,27 +316,29 @@ function testGen() {
 
   let imgNode = networkPanel.document.getElementById("responseImageCachedNode");
   is(imgNode.getAttribute("src"), TEST_IMG, "Displayed image is correct");
 
   networkPanel.panel.hidePopup();
 
   // Test sent form data.
   info("test 9: sent form data");
-  entry.request.postData.text = [
+  httpActivity.request.postData.text = [
     "Content-Type:      application/x-www-form-urlencoded",
     "Content-Length: 59",
     "name=rob&age=20"
   ].join("\n");
 
   networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
-  networkPanel.panel.addEventListener("load", function onLoad() {
-    networkPanel.panel.removeEventListener("load", onLoad, true);
-    testDriver.next();
-  }, true);
+  networkPanel._onUpdate = function() {
+    networkPanel._onUpdate = null;
+    executeSoon(function() {
+      testDriver.next();
+    });
+  };
 
   yield;
 
   checkIsVisible(networkPanel, {
     requestBody: false,
     requestFormData: true,
     requestCookie: true,
     responseContainer: true,
@@ -347,23 +349,25 @@ function testGen() {
   });
 
   checkNodeKeyValue(networkPanel, "requestFormDataContent", "name", "rob");
   checkNodeKeyValue(networkPanel, "requestFormDataContent", "age", "20");
   networkPanel.panel.hidePopup();
 
   // Test no space after Content-Type:
   info("test 10: no space after Content-Type header in post data");
-  entry.request.postData.text = "Content-Type:application/x-www-form-urlencoded\n";
+  httpActivity.request.postData.text = "Content-Type:application/x-www-form-urlencoded\n";
 
   networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
-  networkPanel.panel.addEventListener("load", function onLoad() {
-    networkPanel.panel.removeEventListener("load", onLoad, true);
-    testDriver.next();
-  }, true);
+  networkPanel._onUpdate = function() {
+    networkPanel._onUpdate = null;
+    executeSoon(function() {
+      testDriver.next();
+    });
+  };
 
   yield;
 
   checkIsVisible(networkPanel, {
     requestBody: false,
     requestFormData: true,
     requestCookie: true,
     responseContainer: true,
@@ -374,26 +378,28 @@ function testGen() {
   });
 
   networkPanel.panel.hidePopup();
 
   // Test cached data.
 
   info("test 11: cached data");
 
-  entry.request.url = TEST_ENCODING_ISO_8859_1;
-  entry.response.headers[1].value = "application/json";
-  entry.response.content.mimeType = "application/json";
-  entry.response.content.text = "my cached data is here!";
+  httpActivity.request.url = TEST_ENCODING_ISO_8859_1;
+  httpActivity.response.headers[1].value = "application/json";
+  httpActivity.response.content.mimeType = "application/json";
+  httpActivity.response.content.text = "my cached data is here!";
 
   networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
-  networkPanel.panel.addEventListener("load", function onLoad() {
-    networkPanel.panel.removeEventListener("load", onLoad, true);
-    testDriver.next();
-  }, true);
+  networkPanel._onUpdate = function() {
+    networkPanel._onUpdate = null;
+    executeSoon(function() {
+      testDriver.next();
+    });
+  };
 
   yield;
 
   checkIsVisible(networkPanel, {
     requestBody: false,
     requestFormData: true,
     requestCookie: true,
     responseContainer: true,
@@ -407,24 +413,26 @@ function testGen() {
   checkNodeContent(networkPanel, "responseBodyCachedContent",
                    "my cached data is here!");
 
   networkPanel.panel.hidePopup();
 
   // Test a response with a content type that can't be displayed in the
   // NetworkPanel.
   info("test 12: unknown content type");
-  entry.response.headers[1].value = "application/x-shockwave-flash";
-  entry.response.content.mimeType = "application/x-shockwave-flash";
+  httpActivity.response.headers[1].value = "application/x-shockwave-flash";
+  httpActivity.response.content.mimeType = "application/x-shockwave-flash";
 
   networkPanel = hud.ui.openNetworkPanel(filterBox, httpActivity);
-  networkPanel.panel.addEventListener("load", function onLoad() {
-    networkPanel.panel.removeEventListener("load", onLoad, true);
-    testDriver.next();
-  }, true);
+  networkPanel._onUpdate = function() {
+    networkPanel._onUpdate = null;
+    executeSoon(function() {
+      testDriver.next();
+    });
+  };
 
   yield;
 
   checkIsVisible(networkPanel, {
     requestBody: false,
     requestFormData: true,
     requestCookie: true,
     responseContainer: true,
diff --git a/browser/devtools/webconsole/webconsole.js b/browser/devtools/webconsole/webconsole.js
--- a/browser/devtools/webconsole/webconsole.js
+++ b/browser/devtools/webconsole/webconsole.js
@@ -212,23 +212,16 @@ WebConsoleFrame.prototype = {
    * the remote server, using the remote debugging protocol.
    *
    * @see WebConsoleConnectionProxy
    * @type object
    */
   proxy: null,
 
   /**
-   * Tells if the Web Console initialization via message manager completed.
-   * @private
-   * @type boolean
-   */
-  _messageManagerInitComplete: false,
-
-  /**
    * Getter for the xul:popupset that holds any popups we open.
    * @type nsIDOMElement
    */
   get popupset() this.owner.mainPopupSet,
 
   /**
    * Holds the network requests currently displayed by the Web Console. Each key
    * represents the connection ID and the value is network request information.
@@ -286,16 +279,22 @@ WebConsoleFrame.prototype = {
   filterPrefs: null,
 
   /**
    * The nesting depth of the currently active console group.
    */
   groupDepth: 0,
 
   /**
+   * The current tab location.
+   * @type string
+   */
+  contentLocation: "",
+
+  /**
    * The JSTerm object that manage the console's input.
    * @see JSTerm
    * @type object
    */
   jsterm: null,
 
   /**
    * The element that holds all of the messages we display.
@@ -326,40 +325,39 @@ WebConsoleFrame.prototype = {
 
   /**
    * Setter for saving of network request and response bodies.
    *
    * @param boolean aValue
    *        The new value you want to set.
    */
   set saveRequestAndResponseBodies(aValue) {
-    this._saveRequestAndResponseBodies = aValue;
-
-    let message = {
-      preferences: {
-        "NetworkMonitor.saveRequestAndResponseBodies":
-          this._saveRequestAndResponseBodies,
-      },
+    let newValue = !!aValue;
+    let preferences = {
+      "NetworkMonitor.saveRequestAndResponseBodies": newValue,
     };
 
-    this.owner.sendMessageToContent("WebConsole:SetPreferences", message);
+    this.webConsoleClient.setPreferences(preferences, function(aResponse) {
+      if (!aResponse.error) {
+        this._saveRequestAndResponseBodies = newValue;
+      }
+    }.bind(this));
   },
 
   /**
    * Connect to the server using the remote debugging protocol.
    * @private
    */
   _initConnection: function WCF__initConnection()
   {
     this.proxy = new WebConsoleConnectionProxy(this);
     this.proxy.initServer();
     this.proxy.connect(function() {
-      if (this._messageManagerInitComplete) {
-        this._onInitComplete();
-      }
+      this.saveRequestAndResponseBodies = this._saveRequestAndResponseBodies;
+      this._onInitComplete();
     }.bind(this));
   },
 
   /**
    * Find the Web Console UI elements and setup event listeners as needed.
    * @private
    */
   _initUI: function WCF__initUI()
@@ -649,60 +647,16 @@ WebConsoleFrame.prototype = {
       this.completeNode.style.fontSize = "";
       this.inputNode.style.fontSize = "";
       this.outputNode.style.fontSize = "";
       Services.prefs.clearUserPref("devtools.webconsole.fontSize");
     }
   },
 
   /**
-   * Handler for all of the messages coming from the Web Console content script.
-   *
-   * @private
-   * @param object aMessage
-   *        A MessageManager object that holds the remote message.
-   */
-  receiveMessage: function WCF_receiveMessage(aMessage)
-  {
-    if (!aMessage.json || aMessage.json.hudId != this.hudId) {
-      return;
-    }
-
-    switch (aMessage.name) {
-      case "WebConsole:Initialized":
-        this._onMessageManagerInitComplete();
-        break;
-      case "WebConsole:NetworkActivity":
-        this.handleNetworkActivity(aMessage.json);
-        break;
-      case "WebConsole:FileActivity":
-        this.outputMessage(CATEGORY_NETWORK, this.logFileActivity,
-                           [aMessage.json.uri]);
-        break;
-      case "WebConsole:LocationChange":
-        this.owner.onLocationChange(aMessage.json);
-        break;
-    }
-  },
-
-  /**
-   * Callback method used to track the Web Console initialization via message
-   * manager.
-   *
-   * @private
-   */
-  _onMessageManagerInitComplete: function WCF__onMessageManagerInitComplete()
-  {
-    this._messageManagerInitComplete = true;
-    if (this.proxy.connected) {
-      this._onInitComplete();
-    }
-  },
-
-  /**
    * The event handler that is called whenever a user switches a filter on or
    * off.
    *
    * @private
    * @param nsIDOMEvent aEvent
    *        The event that triggered the filter change.
    */
   _toggleFilter: function WCF__toggleFilter(aEvent)
@@ -1299,32 +1253,31 @@ WebConsoleFrame.prototype = {
    */
   handlePageError: function WCF_handlePageError(aPageError)
   {
     let category = Utils.categoryForScriptError(aPageError);
     this.outputMessage(category, this.reportPageError, [category, aPageError]);
   },
 
   /**
-   * Log network activity.
+   * Log network event.
    *
-   * @param object aHttpActivity
-   *        The HTTP activity to log.
+   * @param object aActorId
+   *        The network event actor ID to log.
    * @return nsIDOMElement|undefined
    *         The message element to display in the Web Console output.
    */
-  logNetActivity: function WCF_logNetActivity(aConnectionId)
+  logNetEvent: function WCF_logNetEvent(aActorId)
   {
-    let networkInfo = this._networkRequests[aConnectionId];
+    let networkInfo = this._networkRequests[aActorId];
     if (!networkInfo) {
       return;
     }
 
-    let entry = networkInfo.httpActivity.log.entries[0];
-    let request = entry.request;
+    let request = networkInfo.request;
 
     let msgNode = this.document.createElementNS(XUL_NS, "hbox");
 
     let methodNode = this.document.createElementNS(XUL_NS, "label");
     methodNode.setAttribute("value", request.method);
     methodNode.classList.add("webconsole-msg-body-piece");
     msgNode.appendChild(methodNode);
 
@@ -1342,18 +1295,17 @@ WebConsoleFrame.prototype = {
     urlNode.setAttribute("value", request.url);
     urlNode.classList.add("hud-clickable");
     urlNode.classList.add("webconsole-msg-body-piece");
     urlNode.classList.add("webconsole-msg-url");
     linkNode.appendChild(urlNode);
 
     let severity = SEVERITY_LOG;
     let mixedRequest =
-      WebConsoleUtils.isMixedHTTPSRequest(request.url,
-                                          this.owner.contentLocation);
+      WebConsoleUtils.isMixedHTTPSRequest(request.url, this.contentLocation);
     if (mixedRequest) {
       urlNode.classList.add("webconsole-mixed-content");
       this.makeMixedContentNode(linkNode);
       // If we define a SEVERITY_SECURITY in the future, switch this to
       // SEVERITY_SECURITY.
       severity = SEVERITY_WARNING;
     }
 
@@ -1364,28 +1316,28 @@ WebConsoleFrame.prototype = {
     statusNode.classList.add("webconsole-msg-status");
     linkNode.appendChild(statusNode);
 
     let clipboardText = request.method + " " + request.url;
 
     let messageNode = this.createMessageNode(CATEGORY_NETWORK, severity,
                                              msgNode, null, null, clipboardText);
 
-    messageNode._connectionId = entry.connection;
+    messageNode._connectionId = aActorId;
     messageNode.url = request.url;
 
     this.makeOutputMessageLink(messageNode, function WCF_net_message_link() {
       if (!messageNode._panelOpen) {
-        this.openNetworkPanel(messageNode, networkInfo.httpActivity);
+        this.openNetworkPanel(messageNode, networkInfo);
       }
     }.bind(this));
 
     networkInfo.node = messageNode;
 
-    this._updateNetMessage(entry.connection);
+    this._updateNetMessage(aActorId);
 
     return messageNode;
   },
 
   /**
    * Create a mixed content warning Node.
    *
    * @param aLinkNode
@@ -1437,118 +1389,165 @@ WebConsoleFrame.prototype = {
       let viewSourceUtils = this.owner.gViewSourceUtils;
       viewSourceUtils.viewSource(aFileURI, null, this.document);
     }.bind(this));
 
     return outputNode;
   },
 
   /**
+   * Handle the file activity messages coming from the remote Web Console.
+   *
+   * @param string aFileURI
+   *        The file URI that was requested.
+   */
+  handleFileActivity: function WCF_handleFileActivity(aFileURI)
+  {
+    this.outputMessage(CATEGORY_NETWORK, this.logFileActivity, [aFileURI]);
+  },
+
+  /**
    * Inform user that the Web Console API has been replaced by a script
    * in a content page.
    */
   logWarningAboutReplacedAPI: function WCF_logWarningAboutReplacedAPI()
   {
     let node = this.createMessageNode(CATEGORY_JS, SEVERITY_WARNING,
                                       l10n.getStr("ConsoleAPIDisabled"));
     this.outputMessage(CATEGORY_JS, node);
   },
 
   /**
-   * Handle the "WebConsole:NetworkActivity" message coming from the remote Web
-   * Console.
+   * Handle the network events coming from the remote Web Console.
    *
-   * @param object aMessage
-   *        The HTTP activity object. This object needs to hold two properties:
-   *        - meta - some metadata about the request log:
-   *          - stages - the stages the network request went through.
-   *          - discardRequestBody and discardResponseBody - booleans that tell
-   *          if the network request/response body was discarded or not.
-   *        - log - the request and response information. This is a HAR-like
-   *        object. See HUDService-content.js
-   *        NetworkMonitor.createActivityObject().
+   * @param object aActor
+   *        The NetworkEventActor grip.
    */
-  handleNetworkActivity: function WCF_handleNetworkActivity(aMessage)
+  handleNetworkEvent: function WCF_handleNetworkEvent(aActor)
   {
-    let stage = aMessage.meta.stages[aMessage.meta.stages.length - 1];
-    let entry = aMessage.log.entries[0];
-
-    if (stage == "REQUEST_HEADER") {
-      let networkInfo = {
-        node: null,
-        httpActivity: aMessage,
-      };
-
-      this._networkRequests[entry.connection] = networkInfo;
-      this.outputMessage(CATEGORY_NETWORK, this.logNetActivity,
-                         [entry.connection]);
+    let networkInfo = {
+      node: null,
+      actor: aActor.actor,
+      discardRequestBody: true,
+      discardResponseBody: true,
+      startedDateTime: aActor.startedDateTime,
+      request: {
+        url: aActor.url,
+        method: aActor.method,
+      },
+      response: {},
+      timings: {},
+      updates: [], // track the list of network event updates
+    };
+
+    this._networkRequests[aActor.actor] = networkInfo;
+    this.outputMessage(CATEGORY_NETWORK, this.logNetEvent, [aActor.actor]);
+  },
+
+  /**
+   * Handle network event updates coming from the server.
+   *
+   * @param string aActorId
+   *        The network event actor ID.
+   * @param string aType
+   *        Update type.
+   * @param object aPacket
+   *        Update details.
+   */
+  handleNetworkEventUpdate:
+  function WCF_handleNetworkEventUpdate(aActorId, aType, aPacket)
+  {
+    let networkInfo = this._networkRequests[aActorId];
+    if (!networkInfo) {
       return;
     }
-    else if (!(entry.connection in this._networkRequests)) {
-      return;
+
+    networkInfo.updates.push(aType);
+
+    switch (aType) {
+      case "requestHeaders":
+        networkInfo.request.headersSize = aPacket.headersSize;
+        break;
+      case "requestPostData":
+        networkInfo.discardRequestBody = aPacket.discardRequestBody;
+        networkInfo.request.bodySize = aPacket.dataSize;
+        break;
+      case "responseStart":
+        networkInfo.response.httpVersion = aPacket.response.httpVersion;
+        networkInfo.response.status = aPacket.response.status;
+        networkInfo.response.statusText = aPacket.response.statusText;
+        networkInfo.response.headersSize = aPacket.response.headersSize;
+        networkInfo.discardResponseBody = aPacket.response.discardResponseBody;
+        break;
+      case "responseContent":
+        networkInfo.response.content = {
+          mimeType: aPacket.mimeType,
+        };
+        networkInfo.response.bodySize = aPacket.contentSize;
+        networkInfo.discardResponseBody = aPacket.discardResponseBody;
+        break;
+      case "eventTimings":
+        networkInfo.totalTime = aPacket.totalTime;
+        break;
     }
 
-    let networkInfo = this._networkRequests[entry.connection];
-    networkInfo.httpActivity = aMessage;
-
     if (networkInfo.node) {
-      this._updateNetMessage(entry.connection);
+      this._updateNetMessage(aActorId);
     }
 
     // For unit tests we pass the HTTP activity object to the test callback,
     // once requests complete.
     if (this.owner.lastFinishedRequestCallback &&
-        aMessage.meta.stages.indexOf("REQUEST_STOP") > -1 &&
-        aMessage.meta.stages.indexOf("TRANSACTION_CLOSE") > -1) {
-      this.owner.lastFinishedRequestCallback(aMessage);
+        networkInfo.updates.indexOf("responseContent") > -1 &&
+        networkInfo.updates.indexOf("eventTimings") > -1) {
+      this.owner.lastFinishedRequestCallback(networkInfo, this);
     }
   },
 
   /**
    * Update an output message to reflect the latest state of a network request,
-   * given a network connection ID.
+   * given a network event actor ID.
    *
    * @private
-   * @param string aConnectionId
-   *        The connection ID to update.
+   * @param string aActorId
+   *        The network event actor ID for which you want to update the message.
    */
-  _updateNetMessage: function WCF__updateNetMessage(aConnectionId)
+  _updateNetMessage: function WCF__updateNetMessage(aActorId)
   {
-    let networkInfo = this._networkRequests[aConnectionId];
+    let networkInfo = this._networkRequests[aActorId];
     if (!networkInfo || !networkInfo.node) {
       return;
     }
 
     let messageNode = networkInfo.node;
-    let httpActivity = networkInfo.httpActivity;
-    let stages = httpActivity.meta.stages;
-    let hasTransactionClose = stages.indexOf("TRANSACTION_CLOSE") > -1;
-    let hasResponseHeader = stages.indexOf("RESPONSE_HEADER") > -1;
-    let entry = httpActivity.log.entries[0];
-    let request = entry.request;
-    let response = entry.response;
-
-    if (hasTransactionClose || hasResponseHeader) {
+    let updates = networkInfo.updates;
+    let hasEventTimings = updates.indexOf("eventTimings") > -1;
+    let hasResponseStart = updates.indexOf("responseStart") > -1;
+    let request = networkInfo.request;
+    let response = networkInfo.response;
+
+    if (hasEventTimings || hasResponseStart) {
       let status = [];
       if (response.httpVersion && response.status) {
         status = [response.httpVersion, response.status, response.statusText];
       }
-      if (hasTransactionClose) {
-        status.push(l10n.getFormatStr("NetworkPanel.durationMS", [entry.time]));
+      if (hasEventTimings) {
+        status.push(l10n.getFormatStr("NetworkPanel.durationMS",
+                                      [networkInfo.totalTime]));
       }
       let statusText = "[" + status.join(" ") + "]";
 
       let linkNode = messageNode.querySelector(".webconsole-msg-link");
       let statusNode = linkNode.querySelector(".webconsole-msg-status");
       statusNode.setAttribute("value", statusText);
 
       messageNode.clipboardText = [request.method, request.url, statusText]
                                   .join(" ");
 
-      if (hasResponseHeader && response.status >= MIN_HTTP_ERROR_CODE &&
+      if (hasResponseStart && response.status >= MIN_HTTP_ERROR_CODE &&
           response.status <= MAX_HTTP_ERROR_CODE) {
         this.setMessageType(messageNode, CATEGORY_NETWORK, SEVERITY_ERROR);
       }
     }
 
     if (messageNode._netPanel) {
       messageNode._netPanel.update();
     }
@@ -1562,38 +1561,149 @@ WebConsoleFrame.prototype = {
    * @param object aHttpActivity
    *        The HTTP activity object that holds network request and response
    *        information. This object is given to the NetworkPanel constructor.
    * @return object
    *         The new NetworkPanel instance.
    */
   openNetworkPanel: function WCF_openNetworkPanel(aNode, aHttpActivity)
   {
+    let actor = aHttpActivity.actor;
+
+    if (actor) {
+      this.webConsoleClient.getRequestHeaders(actor, function(aResponse) {
+        if (aResponse.error) {
+          Cu.reportError("WCF_openNetworkPanel getRequestHeaders:" +
+                         aResponse.error);
+          return;
+        }
+
+        aHttpActivity.request.headers = aResponse.headers;
+
+        this.webConsoleClient.getRequestCookies(actor, onRequestCookies);
+      }.bind(this));
+    }
+
+    let onRequestCookies = function(aResponse) {
+      if (aResponse.error) {
+        Cu.reportError("WCF_openNetworkPanel getRequestCookies:" +
+                       aResponse.error);
+        return;
+      }
+
+      aHttpActivity.request.cookies = aResponse.cookies;
+
+      this.webConsoleClient.getResponseHeaders(actor, onResponseHeaders);
+    }.bind(this);
+
+    let onResponseHeaders = function(aResponse) {
+      if (aResponse.error) {
+        Cu.reportError("WCF_openNetworkPanel getResponseHeaders:" +
+                       aResponse.error);
+        return;
+      }
+
+      aHttpActivity.response.headers = aResponse.headers;
+
+      this.webConsoleClient.getResponseCookies(actor, onResponseCookies);
+    }.bind(this);
+
+    let onResponseCookies = function(aResponse) {
+      if (aResponse.error) {
+        Cu.reportError("WCF_openNetworkPanel getResponseCookies:" +
+                       aResponse.error);
+        return;
+      }
+
+      aHttpActivity.response.cookies = aResponse.cookies;
+
+      this.webConsoleClient.getRequestPostData(actor, onRequestPostData);
+    }.bind(this);
+
+    let onRequestPostData = function(aResponse) {
+      if (aResponse.error) {
+        Cu.reportError("WCF_openNetworkPanel getRequestPostData:" +
+                       aResponse.error);
+        return;
+      }
+
+      aHttpActivity.request.postData = aResponse.postData;
+      aHttpActivity.discardRequestBody = aResponse.postDataDiscarded;
+
+      this.webConsoleClient.getResponseContent(actor, onResponseContent);
+    }.bind(this);
+
+    let onResponseContent = function(aResponse) {
+      if (aResponse.error) {
+        Cu.reportError("WCF_openNetworkPanel getResponseContent:" +
+                       aResponse.error);
+        return;
+      }
+
+      aHttpActivity.response.content = aResponse.content;
+      aHttpActivity.discardResponseBody = aResponse.contentDiscarded;
+
+      this.webConsoleClient.getEventTimings(actor, onEventTimings);
+    }.bind(this);
+
+    let onEventTimings = function(aResponse) {
+      if (aResponse.error) {
+        Cu.reportError("WCF_openNetworkPanel getEventTimings:" +
+                       aResponse.error);
+        return;
+      }
+
+      aHttpActivity.timings = aResponse.timings;
+
+      openPanel();
+    }.bind(this);
+
+    let openPanel = function() {
+      aNode._netPanel = netPanel;
+
+      let panel = netPanel.panel;
+      panel.openPopup(aNode, "after_pointer", 0, 0, false, false);
+      panel.sizeTo(450, 500);
+      panel.setAttribute("hudId", this.hudId);
+
+      panel.addEventListener("popuphiding", function WCF_netPanel_onHide() {
+        panel.removeEventListener("popuphiding", WCF_netPanel_onHide);
+
+        aNode._panelOpen = false;
+        aNode._netPanel = null;
+      });
+
+      aNode._panelOpen = true;
+    }.bind(this);
+
     let netPanel = new NetworkPanel(this.popupset, aHttpActivity);
     netPanel.linkNode = aNode;
-    aNode._netPanel = netPanel;
-
-    let panel = netPanel.panel;
-    panel.openPopup(aNode, "after_pointer", 0, 0, false, false);
-    panel.sizeTo(450, 500);
-    panel.setAttribute("hudId", aHttpActivity.hudId);
-
-    panel.addEventListener("popuphiding", function WCF_netPanel_onHide() {
-      panel.removeEventListener("popuphiding", WCF_netPanel_onHide);
-
-      aNode._panelOpen = false;
-      aNode._netPanel = null;
-    });
-
-    aNode._panelOpen = true;
+
+    if (!actor) {
+      openPanel();
+    }
 
     return netPanel;
   },
 
   /**
+   * Handler for page location changes.
+   *
+   * @param string aURI
+   *        New page location.
+   * @param string aTitle
+   *        New page title.
+   */
+  onLocationChange: function WCF_onLocationChange(aURI, aTitle)
+  {
+    this.contentLocation = aURI;
+    this.owner.onLocationChange(aURI, aTitle);
+  },
+
+  /**
    * Output a message node. This filters a node appropriately, then sends it to
    * the output, regrouping and pruning output as necessary.
    *
    * Note: this call is async - the given message node may not be displayed when
    * you call this method.
    *
    * @param integer aCategory
    *        The category of the message you want to output. See the CATEGORY_*
@@ -1842,24 +1952,25 @@ WebConsoleFrame.prototype = {
     let [category, methodOrNode, args] = aItem;
     if (typeof methodOrNode != "function" &&
         methodOrNode._objectActors && !methodOrNode._panelOpen) {
       methodOrNode._objectActors.forEach(this._releaseObject, this);
     }
 
     if (category == CATEGORY_NETWORK) {
       let connectionId = null;
-      if (methodOrNode == this.logNetActivity) {
+      if (methodOrNode == this.logNetEvent) {
         connectionId = args[0];
       }
       else if (typeof methodOrNode != "function") {
         connectionId = methodOrNode._connectionId;
       }
       if (connectionId && connectionId in this._networkRequests) {
         delete this._networkRequests[connectionId];
+        this._releaseObject(connectionId);
       }
     }
     else if (category == CATEGORY_WEBDEV &&
              methodOrNode == this.logConsoleAPIMessage) {
       let level = args[0].level;
       let releaseObject = function _releaseObject(aValue) {
         if (aValue && typeof aValue == "object" && aValue.actor) {
           this._releaseObject(aValue.actor);
@@ -1945,18 +2056,20 @@ WebConsoleFrame.prototype = {
     if (aNode.classList.contains("webconsole-msg-cssparser")) {
       let desc = aNode.childNodes[2].textContent;
       let location = "";
       if (aNode.childNodes[4]) {
         location = aNode.childNodes[4].getAttribute("title");
       }
       delete this._cssNodes[desc + location];
     }
-    else if (aNode.classList.contains("webconsole-msg-network")) {
+    else if (aNode._connectionId &&
+             aNode.classList.contains("webconsole-msg-network")) {
       delete this._networkRequests[aNode._connectionId];
+      this._releaseObject(aNode._connectionId);
     }
     else if (aNode.classList.contains("webconsole-msg-inspector")) {
       this.pruneConsoleDirNode(aNode);
       return;
     }
 
     if (aNode.parentNode) {
       aNode.parentNode.removeChild(aNode);
@@ -2419,21 +2532,21 @@ WebConsoleFrame.prototype = {
                          "server. Error: " + aResponse.error);
           return;
         }
         aCallback(aResponse.properties);
       });
   },
 
   /**
-   * Release an object actor.
+   * Release an actor.
    *
    * @private
    * @param string aActor
-   *        The object actor ID you want to release.
+   *        The actor ID you want to release.
    */
   _releaseObject: function WCF__releaseObject(aActor)
   {
     this.proxy.releaseActor(aActor);
   },
 
   /**
    * Open the selected item's URL in a new tab.
@@ -3696,16 +3809,20 @@ CommandController.prototype = {
  *        The Web Console instance that owns this connection proxy.
  */
 function WebConsoleConnectionProxy(aWebConsole)
 {
   this.owner = aWebConsole;
 
   this._onPageError = this._onPageError.bind(this);
   this._onConsoleAPICall = this._onConsoleAPICall.bind(this);
+  this._onNetworkEvent = this._onNetworkEvent.bind(this);
+  this._onNetworkEventUpdate = this._onNetworkEventUpdate.bind(this);
+  this._onFileActivity = this._onFileActivity.bind(this);
+  this._onLocationChange = this._onLocationChange.bind(this);
 }
 
 WebConsoleConnectionProxy.prototype = {
   /**
    * The owning Web Console instance.
    *
    * @see WebConsoleFrame
    * @type object
@@ -3761,23 +3878,29 @@ WebConsoleConnectionProxy.prototype = {
    */
   connect: function WCCP_connect(aCallback)
   {
     let transport = DebuggerServer.connectPipe();
     let client = this.client = new DebuggerClient(transport);
 
     client.addListener("pageError", this._onPageError);
     client.addListener("consoleAPICall", this._onConsoleAPICall);
-
-    let listeners = ["PageError", "ConsoleAPI"];
+    client.addListener("networkEvent", this._onNetworkEvent);
+    client.addListener("networkEventUpdate", this._onNetworkEventUpdate);
+    client.addListener("fileActivity", this._onFileActivity);
+    client.addListener("locationChange", this._onLocationChange);
+
+    let listeners = ["PageError", "ConsoleAPI", "NetworkActivity",
+                     "FileActivity", "LocationChange"];
 
     client.connect(function(aType, aTraits) {
       client.listTabs(function(aResponse) {
         let tab = aResponse.tabs[aResponse.selected];
         this._consoleActor = tab.consoleActor;
+        this.owner.onLocationChange(tab.url, tab.title);
         client.attachConsole(tab.consoleActor, listeners,
                              this._onAttachConsole.bind(this, aCallback));
       }.bind(this));
     }.bind(this));
   },
 
   /**
    * The "attachConsole" response handler.
@@ -3866,16 +3989,90 @@ WebConsoleConnectionProxy.prototype = {
   _onConsoleAPICall: function WCCP__onConsoleAPICall(aType, aPacket)
   {
     if (this.owner && aPacket.from == this._consoleActor) {
       this.owner.handleConsoleAPICall(aPacket.message);
     }
   },
 
   /**
+   * The "networkEvent" message type handler. We redirect any message to
+   * the UI for displaying.
+   *
+   * @private
+   * @param string aType
+   *        Message type.
+   * @param object aPacket
+   *        The message received from the server.
+   */
+  _onNetworkEvent: function WCCP__onNetworkEvent(aType, aPacket)
+  {
+    if (this.owner && aPacket.from == this._consoleActor) {
+      this.owner.handleNetworkEvent(aPacket.eventActor);
+    }
+  },
+
+  /**
+   * The "networkEventUpdate" message type handler. We redirect any message to
+   * the UI for displaying.
+   *
+   * @private
+   * @param string aType
+   *        Message type.
+   * @param object aPacket
+   *        The message received from the server.
+   */
+  _onNetworkEventUpdate: function WCCP__onNetworkEvenUpdatet(aType, aPacket)
+  {
+    if (this.owner) {
+      this.owner.handleNetworkEventUpdate(aPacket.from, aPacket.updateType,
+                                          aPacket);
+    }
+  },
+
+  /**
+   * The "fileActivity" message type handler. We redirect any message to
+   * the UI for displaying.
+   *
+   * @private
+   * @param string aType
+   *        Message type.
+   * @param object aPacket
+   *        The message received from the server.
+   */
+  _onFileActivity: function WCCP__onFileActivity(aType, aPacket)
+  {
+    if (this.owner && aPacket.from == this._consoleActor) {
+      this.owner.handleFileActivity(aPacket.uri);
+    }
+  },
+
+  /**
+   * The "locationChange" message type handler. We redirect any message to
+   * the UI for displaying.
+   *
+   * @private
+   * @param string aType
+   *        Message type.
+   * @param object aPacket
+   *        The message received from the server.
+   */
+  _onLocationChange: function WCCP__onLocationChange(aType, aPacket)
+  {
+    if (!this.owner || aPacket.from != this._consoleActor) {
+      return;
+    }
+
+    this.owner.onLocationChange(aPacket.uri, aPacket.title);
+    if (aPacket.state == "stop" && !aPacket.nativeConsoleAPI) {
+      this.owner.logWarningAboutReplacedAPI();
+    }
+  },
+
+  /**
    * Release an object actor.
    *
    * @param string aActor
    *        The actor ID to send the request to.
    */
   releaseActor: function WCCP_releaseActor(aActor)
   {
     if (this.client) {
@@ -3893,16 +4090,20 @@ WebConsoleConnectionProxy.prototype = {
   {
     if (!this.client) {
       aOnDisconnect && aOnDisconnect();
       return;
     }
 
     this.client.removeListener("pageError", this._onPageError);
     this.client.removeListener("consoleAPICall", this._onConsoleAPICall);
+    this.client.removeListener("networkEvent", this._onNetworkEvent);
+    this.client.removeListener("networkEventUpdate", this._onNetworkEventUpdate);
+    this.client.removeListener("fileActivity", this._onFileActivity);
+    this.client.removeListener("locationChange", this._onLocationChange);
     this.client.close(aOnDisconnect);
 
     this.client = null;
     this.webConsoleClient = null;
     this.connected = false;
   },
 };
 
diff --git a/toolkit/devtools/debugger/dbg-client.jsm b/toolkit/devtools/debugger/dbg-client.jsm
--- a/toolkit/devtools/debugger/dbg-client.jsm
+++ b/toolkit/devtools/debugger/dbg-client.jsm
@@ -163,16 +163,20 @@ const ThreadStateTypes = {
 };
 
 /**
  * Set of protocol messages that are sent by the server without a prior request
  * by the client.
  */
 const UnsolicitedNotifications = {
   "consoleAPICall": "consoleAPICall",
+  "fileActivity": "fileActivity",
+  "locationChange": "locationChange",
+  "networkEvent": "networkEvent",
+  "networkEventUpdate": "networkEventUpdate",
   "newScript": "newScript",
   "tabDetached": "tabDetached",
   "tabNavigated": "tabNavigated",
   "pageError": "pageError",
   "profilerStateChanged": "profilerStateChanged"
 };
 
 /**
diff --git a/browser/devtools/webconsole/NetworkHelper.jsm b/toolkit/devtools/webconsole/NetworkHelper.jsm
rename from browser/devtools/webconsole/NetworkHelper.jsm
rename to toolkit/devtools/webconsole/NetworkHelper.jsm
--- a/browser/devtools/webconsole/NetworkHelper.jsm
+++ b/toolkit/devtools/webconsole/NetworkHelper.jsm
@@ -94,18 +94,16 @@ var NetworkHelper =
     let conv = Cc["@mozilla.org/intl/scriptableunicodeconverter"].
                createInstance(Ci.nsIScriptableUnicodeConverter);
     conv.charset = aCharset;
 
     try {
       return conv.ConvertToUnicode(aText);
     }
     catch (ex) {
-      Cu.reportError("NH_convertToUnicode(aText, '" +
-        aCharset + "') exception: " + ex);
       return aText;
     }
   },
 
   /**
    * Reads all available bytes from aStream and converts them to aCharset.
    *
    * @param nsIInputStream aStream
@@ -172,18 +170,34 @@ var NetworkHelper =
    * @param string aCharset
    * @returns string or null
    *          Returns the posted string if it was possible to read from
    *          aDocShell otherwise null.
    */
   readPostTextFromPage: function NH_readPostTextFromPage(aDocShell, aCharset)
   {
     let webNav = aDocShell.QueryInterface(Ci.nsIWebNavigation);
-    if (webNav instanceof Ci.nsIWebPageDescriptor) {
-      let descriptor = webNav.currentDescriptor;
+    return this.readPostTextFromPageViaWebNav(webNav, aCharset);
+  },
+
+  /**
+   * Reads the posted text from the page's cache, given an nsIWebNavigation
+   * object.
+   *
+   * @param nsIWebNavigation aWebNav
+   * @param string aCharset
+   * @returns string or null
+   *          Returns the posted string if it was possible to read from
+   *          aWebNav, otherwise null.
+   */
+  readPostTextFromPageViaWebNav:
+  function NH_readPostTextFromPageViaWebNav(aWebNav, aCharset)
+  {
+    if (aWebNav instanceof Ci.nsIWebPageDescriptor) {
+      let descriptor = aWebNav.currentDescriptor;
 
       if (descriptor instanceof Ci.nsISHEntry && descriptor.postData &&
           descriptor instanceof Ci.nsISeekableStream) {
         descriptor.seek(NS_SEEK_SET, 0);
 
         return this.readAndConvertFromStream(descriptor, aCharset);
       }
     }
diff --git a/toolkit/devtools/webconsole/WebConsoleClient.jsm b/toolkit/devtools/webconsole/WebConsoleClient.jsm
--- a/toolkit/devtools/webconsole/WebConsoleClient.jsm
+++ b/toolkit/devtools/webconsole/WebConsoleClient.jsm
@@ -113,16 +113,153 @@ WebConsoleClient.prototype = {
     let packet = {
       to: this._actor,
       type: "clearMessagesCache",
     };
     this._client.request(packet);
   },
 
   /**
+   * Set Web Console-related preferences on the server.
+   *
+   * @param object aPreferences
+   *        An object with the preferences you want to change.
+   * @param function [aOnResponse]
+   *        Optional function to invoke when the response is received.
+   */
+  setPreferences: function WCC_setPreferences(aPreferences, aOnResponse)
+  {
+    let packet = {
+      to: this._actor,
+      type: "setPreferences",
+      preferences: aPreferences,
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Retrieve the request headers from the given NetworkEventActor.
+   *
+   * @param string aActor
+   *        The NetworkEventActor ID.
+   * @param function aOnResponse
+   *        The function invoked when the response is received.
+   */
+  getRequestHeaders: function WCC_getRequestHeaders(aActor, aOnResponse)
+  {
+    let packet = {
+      to: aActor,
+      type: "getRequestHeaders",
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Retrieve the request cookies from the given NetworkEventActor.
+   *
+   * @param string aActor
+   *        The NetworkEventActor ID.
+   * @param function aOnResponse
+   *        The function invoked when the response is received.
+   */
+  getRequestCookies: function WCC_getRequestCookies(aActor, aOnResponse)
+  {
+    let packet = {
+      to: aActor,
+      type: "getRequestCookies",
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Retrieve the request post data from the given NetworkEventActor.
+   *
+   * @param string aActor
+   *        The NetworkEventActor ID.
+   * @param function aOnResponse
+   *        The function invoked when the response is received.
+   */
+  getRequestPostData: function WCC_getRequestPostData(aActor, aOnResponse)
+  {
+    let packet = {
+      to: aActor,
+      type: "getRequestPostData",
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Retrieve the response headers from the given NetworkEventActor.
+   *
+   * @param string aActor
+   *        The NetworkEventActor ID.
+   * @param function aOnResponse
+   *        The function invoked when the response is received.
+   */
+  getResponseHeaders: function WCC_getResponseHeaders(aActor, aOnResponse)
+  {
+    let packet = {
+      to: aActor,
+      type: "getResponseHeaders",
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Retrieve the response cookies from the given NetworkEventActor.
+   *
+   * @param string aActor
+   *        The NetworkEventActor ID.
+   * @param function aOnResponse
+   *        The function invoked when the response is received.
+   */
+  getResponseCookies: function WCC_getResponseCookies(aActor, aOnResponse)
+  {
+    let packet = {
+      to: aActor,
+      type: "getResponseCookies",
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Retrieve the response content from the given NetworkEventActor.
+   *
+   * @param string aActor
+   *        The NetworkEventActor ID.
+   * @param function aOnResponse
+   *        The function invoked when the response is received.
+   */
+  getResponseContent: function WCC_getResponseContent(aActor, aOnResponse)
+  {
+    let packet = {
+      to: aActor,
+      type: "getResponseContent",
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
+   * Retrieve the timing information for the given NetworkEventActor.
+   *
+   * @param string aActor
+   *        The NetworkEventActor ID.
+   * @param function aOnResponse
+   *        The function invoked when the response is received.
+   */
+  getEventTimings: function WCC_getEventTimings(aActor, aOnResponse)
+  {
+    let packet = {
+      to: aActor,
+      type: "getEventTimings",
+    };
+    this._client.request(packet, aOnResponse);
+  },
+
+  /**
    * Start the given Web Console listeners.
    *
    * @see this.LISTENERS
    * @param array aListeners
    *        Array of listeners you want to start. See this.LISTENERS for
    *        known listeners.
    * @param function aOnResponse
    *        Function to invoke when the server response is received.
diff --git a/toolkit/devtools/webconsole/WebConsoleUtils.jsm b/toolkit/devtools/webconsole/WebConsoleUtils.jsm
--- a/toolkit/devtools/webconsole/WebConsoleUtils.jsm
+++ b/toolkit/devtools/webconsole/WebConsoleUtils.jsm
@@ -13,18 +13,30 @@ const Cu = Components.utils;
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Services",
                                   "resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "ConsoleAPIStorage",
                                   "resource://gre/modules/ConsoleAPIStorage.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "NetUtil",
+                                  "resource://gre/modules/NetUtil.jsm");
+
+XPCOMUtils.defineLazyModuleGetter(this, "NetworkHelper",
+                                  "resource://gre/modules/devtools/NetworkHelper.jsm");
+
+XPCOMUtils.defineLazyServiceGetter(this, "gActivityDistributor",
+                                   "@mozilla.org/network/http-activity-distributor;1",
+                                   "nsIHttpActivityDistributor");
+
 var EXPORTED_SYMBOLS = ["WebConsoleUtils", "JSPropertyProvider", "JSTermHelpers",
-                        "PageErrorListener", "ConsoleAPIListener"];
+                        "PageErrorListener", "ConsoleAPIListener",
+                        "NetworkResponseListener", "NetworkMonitor",
+                        "ConsoleProgressListener"];
 
 // Match the function name from the result of toString() or toSource().
 //
 // Examples:
 // (function foobar(a, b) { ...
 // function foobar2(a) { ...
 // function() { ...
 const REGEX_MATCH_FUNCTION_NAME = /^\(?function\s+([^(\s]+)\s*\(/;
@@ -1849,8 +1861,1129 @@ function JSTermHelpers(aOwner)
    * @return void
    */
   aOwner.sandbox.print = function JSTH_print(aString)
   {
     aOwner.helperResult = { rawOutput: true };
     return String(aString);
   };
 }
+
+
+(function(_global, WCU) {
+///////////////////////////////////////////////////////////////////////////////
+// Network logging
+///////////////////////////////////////////////////////////////////////////////
+
+// The maximum uint32 value.
+const PR_UINT32_MAX = 4294967295;
+
+// HTTP status codes.
+const HTTP_MOVED_PERMANENTLY = 301;
+const HTTP_FOUND = 302;
+const HTTP_SEE_OTHER = 303;
+const HTTP_TEMPORARY_REDIRECT = 307;
+
+// The maximum number of bytes a NetworkResponseListener can hold.
+const RESPONSE_BODY_LIMIT = 1048576; // 1 MB
+
+/**
+ * The network response listener implements the nsIStreamListener and
+ * nsIRequestObserver interfaces. This is used within the NetworkMonitor feature
+ * to get the response body of the request.
+ *
+ * The code is mostly based on code listings from:
+ *
+ *   http://www.softwareishard.com/blog/firebug/
+ *      nsitraceablechannel-intercept-http-traffic/
+ *
+ * @constructor
+ * @param object aOwner
+ *        The response listener owner. This object needs to hold the
+ *        |openResponses| object.
+ * @param object aHttpActivity
+ *        HttpActivity object associated with this request. See NetworkMonitor
+ *        for more information.
+ */
+function NetworkResponseListener(aOwner, aHttpActivity)
+{
+  this.owner = aOwner;
+  this.receivedData = "";
+  this.httpActivity = aHttpActivity;
+  this.bodySize = 0;
+}
+
+NetworkResponseListener.prototype = {
+  QueryInterface:
+    XPCOMUtils.generateQI([Ci.nsIStreamListener, Ci.nsIInputStreamCallback,
+                           Ci.nsIRequestObserver, Ci.nsISupports]),
+
+  /**
+   * This NetworkResponseListener tracks the NetworkMonitor.openResponses object
+   * to find the associated uncached headers.
+   * @private
+   */
+  _foundOpenResponse: false,
+
+  /**
+   * The response listener owner.
+   */
+  owner: null,
+
+  /**
+   * The response will be written into the outputStream of this nsIPipe.
+   * Both ends of the pipe must be blocking.
+   */
+  sink: null,
+
+  /**
+   * The HttpActivity object associated with this response.
+   */
+  httpActivity: null,
+
+  /**
+   * Stores the received data as a string.
+   */
+  receivedData: null,
+
+  /**
+   * The network response body size.
+   */
+  bodySize: null,
+
+  /**
+   * The nsIRequest we are started for.
+   */
+  request: null,
+
+  /**
+   * Set the async listener for the given nsIAsyncInputStream. This allows us to
+   * wait asynchronously for any data coming from the stream.
+   *
+   * @param nsIAsyncInputStream aStream
+   *        The input stream from where we are waiting for data to come in.
+   * @param nsIInputStreamCallback aListener
+   *        The input stream callback you want. This is an object that must have
+   *        the onInputStreamReady() method. If the argument is null, then the
+   *        current callback is removed.
+   * @return void
+   */
+  setAsyncListener: function NRL_setAsyncListener(aStream, aListener)
+  {
+    // Asynchronously wait for the stream to be readable or closed.
+    aStream.asyncWait(aListener, 0, 0, Services.tm.mainThread);
+  },
+
+  /**
+   * Stores the received data, if request/response body logging is enabled. It
+   * also does limit the number of stored bytes, based on the
+   * RESPONSE_BODY_LIMIT constant.
+   *
+   * Learn more about nsIStreamListener at:
+   * https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsIStreamListener
+   *
+   * @param nsIRequest aRequest
+   * @param nsISupports aContext
+   * @param nsIInputStream aInputStream
+   * @param unsigned long aOffset
+   * @param unsigned long aCount
+   */
+  onDataAvailable:
+  function NRL_onDataAvailable(aRequest, aContext, aInputStream, aOffset, aCount)
+  {
+    this._findOpenResponse();
+    let data = NetUtil.readInputStreamToString(aInputStream, aCount);
+
+    this.bodySize += aCount;
+
+    if (!this.httpActivity.discardResponseBody &&
+        this.receivedData.length < RESPONSE_BODY_LIMIT) {
+      this.receivedData += NetworkHelper.
+                           convertToUnicode(data, aRequest.contentCharset);
+    }
+  },
+
+  /**
+   * See documentation at
+   * https://developer.mozilla.org/En/NsIRequestObserver
+   *
+   * @param nsIRequest aRequest
+   * @param nsISupports aContext
+   */
+  onStartRequest: function NRL_onStartRequest(aRequest)
+  {
+    this.request = aRequest;
+    this._findOpenResponse();
+    // Asynchronously wait for the data coming from the request.
+    this.setAsyncListener(this.sink.inputStream, this);
+  },
+
+  /**
+   * Handle the onStopRequest by closing the sink output stream.
+   *
+   * For more documentation about nsIRequestObserver go to:
+   * https://developer.mozilla.org/En/NsIRequestObserver
+   */
+  onStopRequest: function NRL_onStopRequest()
+  {
+    this._findOpenResponse();
+    this.sink.outputStream.close();
+  },
+
+  /**
+   * Find the open response object associated to the current request. The
+   * NetworkMonitor._httpResponseExaminer() method saves the response headers in
+   * NetworkMonitor.openResponses. This method takes the data from the open
+   * response object and puts it into the HTTP activity object, then sends it to
+   * the remote Web Console instance.
+   *
+   * @private
+   */
+  _findOpenResponse: function NRL__findOpenResponse()
+  {
+    if (!this.owner || this._foundOpenResponse) {
+      return;
+    }
+
+    let openResponse = null;
+
+    for each (let item in this.owner.openResponses) {
+      if (item.channel === this.httpActivity.channel) {
+        openResponse = item;
+        break;
+      }
+    }
+
+    if (!openResponse) {
+      return;
+    }
+    this._foundOpenResponse = true;
+
+    delete this.owner.openResponses[openResponse.id];
+
+    this.httpActivity.owner.addResponseHeaders(openResponse.headers);
+    this.httpActivity.owner.addResponseCookies(openResponse.cookies);
+  },
+
+  /**
+   * Clean up the response listener once the response input stream is closed.
+   * This is called from onStopRequest() or from onInputStreamReady() when the
+   * stream is closed.
+   * @return void
+   */
+  onStreamClose: function NRL_onStreamClose()
+  {
+    if (!this.httpActivity) {
+      return;
+    }
+    // Remove our listener from the request input stream.
+    this.setAsyncListener(this.sink.inputStream, null);
+
+    this._findOpenResponse();
+
+    if (!this.httpActivity.discardResponseBody && this.receivedData.length) {
+      this._onComplete(this.receivedData);
+    }
+    else if (!this.httpActivity.discardResponseBody &&
+             this.httpActivity.responseStatus == 304) {
+      // Response is cached, so we load it from cache.
+      let charset = this.request.contentCharset || this.httpActivity.charset;
+      NetworkHelper.loadFromCache(this.httpActivity.url, charset,
+                                  this._onComplete.bind(this));
+    }
+    else {
+      this._onComplete();
+    }
+  },
+
+  /**
+   * Handler for when the response completes. This function cleans up the
+   * response listener.
+   *
+   * @param string [aData]
+   *        Optional, the received data coming from the response listener or
+   *        from the cache.
+   */
+  _onComplete: function NRL__onComplete(aData)
+  {
+    let response = {
+      mimeType: "",
+      text: aData || "",
+    };
+
+    // TODO: Bug 787981 - use LongStringActor for strings that are too long.
+
+    try {
+      response.mimeType = this.request.contentType;
+    }
+    catch (ex) { }
+
+    if (response.mimeType && this.request.contentCharset) {
+      response.mimeType += "; charset=" + this.request.contentCharset;
+    }
+
+    this.receivedData = "";
+
+    this.httpActivity.owner.
+      addResponseContent(response, this.httpActivity.discardResponseBody);
+
+    this.httpActivity.channel = null;
+    this.httpActivity.owner = null;
+    this.httpActivity = null;
+    this.sink = null;
+    this.inputStream = null;
+    this.request = null;
+    this.owner = null;
+  },
+
+  /**
+   * The nsIInputStreamCallback for when the request input stream is ready -
+   * either it has more data or it is closed.
+   *
+   * @param nsIAsyncInputStream aStream
+   *        The sink input stream from which data is coming.
+   * @returns void
+   */
+  onInputStreamReady: function NRL_onInputStreamReady(aStream)
+  {
+    if (!(aStream instanceof Ci.nsIAsyncInputStream) || !this.httpActivity) {
+      return;
+    }
+
+    let available = -1;
+    try {
+      // This may throw if the stream is closed normally or due to an error.
+      available = aStream.available();
+    }
+    catch (ex) { }
+
+    if (available != -1) {
+      if (available != 0) {
+        // Note that passing 0 as the offset here is wrong, but the
+        // onDataAvailable() method does not use the offset, so it does not
+        // matter.
+        this.onDataAvailable(this.request, null, aStream, 0, available);
+      }
+      this.setAsyncListener(aStream, this);
+    }
+    else {
+      this.onStreamClose();
+    }
+  },
+};
+
+/**
+ * The network monitor uses the nsIHttpActivityDistributor to monitor network
+ * requests. The nsIObserverService is also used for monitoring
+ * http-on-examine-response notifications. All network request information is
+ * routed to the remote Web Console.
+ *
+ * @constructor
+ * @param nsIDOMWindow aWindow
+ *        The window that we monitor network requests for.
+ * @param object aOwner
+ *        The network monitor owner. This object needs to hold:
+ *        - onNetworkEvent(aRequestInfo). This method is invoked once for every
+ *        new network request and it is given one arguments: the initial network
+ *        request information. onNetworkEvent() must return an object which
+ *        holds several add*() methods which are used to add further network
+ *        request/response information.
+ *        - saveRequestAndResponseBodies property which tells if you want to log
+ *        request and response bodies.
+ */
+function NetworkMonitor(aWindow, aOwner)
+{
+  this.window = aWindow;
+  this.owner = aOwner;
+  this.openRequests = {};
+  this.openResponses = {};
+  this._httpResponseExaminer = this._httpResponseExaminer.bind(this);
+}
+
+NetworkMonitor.prototype = {
+  httpTransactionCodes: {
+    0x5001: "REQUEST_HEADER",
+    0x5002: "REQUEST_BODY_SENT",
+    0x5003: "RESPONSE_START",
+    0x5004: "RESPONSE_HEADER",
+    0x5005: "RESPONSE_COMPLETE",
+    0x5006: "TRANSACTION_CLOSE",
+
+    0x804b0003: "STATUS_RESOLVING",
+    0x804b000b: "STATUS_RESOLVED",
+    0x804b0007: "STATUS_CONNECTING_TO",
+    0x804b0004: "STATUS_CONNECTED_TO",
+    0x804b0005: "STATUS_SENDING_TO",
+    0x804b000a: "STATUS_WAITING_FOR",
+    0x804b0006: "STATUS_RECEIVING_FROM"
+  },
+
+  // Network response bodies are piped through a buffer of the given size (in
+  // bytes).
+  responsePipeSegmentSize: null,
+
+  owner: null,
+
+  /**
+   * Whether to save the bodies of network requests and responses. Disabled by
+   * default to save memory.
+   */
+  get saveRequestAndResponseBodies()
+    this.owner && this.owner.saveRequestAndResponseBodies,
+
+  /**
+   * Object that holds the HTTP activity objects for ongoing requests.
+   */
+  openRequests: null,
+
+  /**
+   * Object that holds response headers coming from this._httpResponseExaminer.
+   */
+  openResponses: null,
+
+  /**
+   * The network monitor initializer.
+   */
+  init: function NM_init()
+  {
+    this.responsePipeSegmentSize = Services.prefs
+                                   .getIntPref("network.buffer.cache.size");
+
+    gActivityDistributor.addObserver(this);
+
+    Services.obs.addObserver(this._httpResponseExaminer,
+                             "http-on-examine-response", false);
+  },
+
+  /**
+   * Observe notifications for the http-on-examine-response topic, coming from
+   * the nsIObserverService.
+   *
+   * @private
+   * @param nsIHttpChannel aSubject
+   * @param string aTopic
+   * @returns void
+   */
+  _httpResponseExaminer: function NM__httpResponseExaminer(aSubject, aTopic)
+  {
+    // The httpResponseExaminer is used to retrieve the uncached response
+    // headers. The data retrieved is stored in openResponses. The
+    // NetworkResponseListener is responsible with updating the httpActivity
+    // object with the data from the new object in openResponses.
+
+    if (!this.owner || aTopic != "http-on-examine-response" ||
+        !(aSubject instanceof Ci.nsIHttpChannel)) {
+      return;
+    }
+
+    let channel = aSubject.QueryInterface(Ci.nsIHttpChannel);
+    // Try to get the source window of the request.
+    let win = NetworkHelper.getWindowForRequest(channel);
+    if (!win || win.top !== this.window) {
+      return;
+    }
+
+    let response = {
+      id: gSequenceId(),
+      channel: channel,
+      headers: [],
+      cookies: [],
+    };
+
+    let setCookieHeader = null;
+
+    channel.visitResponseHeaders({
+      visitHeader: function NM__visitHeader(aName, aValue) {
+        let lowerName = aName.toLowerCase();
+        if (lowerName == "set-cookie") {
+          setCookieHeader = aValue;
+        }
+        response.headers.push({ name: aName, value: aValue });
+      }
+    });
+
+    if (!response.headers.length) {
+      return; // No need to continue.
+    }
+
+    if (setCookieHeader) {
+      response.cookies = NetworkHelper.parseSetCookieHeader(setCookieHeader);
+    }
+
+    // Determine the HTTP version.
+    let httpVersionMaj = {};
+    let httpVersionMin = {};
+
+    channel.QueryInterface(Ci.nsIHttpChannelInternal);
+    channel.getResponseVersion(httpVersionMaj, httpVersionMin);
+
+    response.status = channel.responseStatus;
+    response.statusText = channel.responseStatusText;
+    response.httpVersion = "HTTP/" + httpVersionMaj.value + "." +
+                                     httpVersionMin.value;
+
+    this.openResponses[response.id] = response;
+  },
+
+  /**
+   * Begin observing HTTP traffic that originates inside the current tab.
+   *
+   * @see https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsIHttpActivityObserver
+   *
+   * @param nsIHttpChannel aChannel
+   * @param number aActivityType
+   * @param number aActivitySubtype
+   * @param number aTimestamp
+   * @param number aExtraSizeData
+   * @param string aExtraStringData
+   */
+  observeActivity:
+  function NM_observeActivity(aChannel, aActivityType, aActivitySubtype,
+                              aTimestamp, aExtraSizeData, aExtraStringData)
+  {
+    if (!this.owner ||
+        aActivityType != gActivityDistributor.ACTIVITY_TYPE_HTTP_TRANSACTION &&
+        aActivityType != gActivityDistributor.ACTIVITY_TYPE_SOCKET_TRANSPORT) {
+      return;
+    }
+
+    if (!(aChannel instanceof Ci.nsIHttpChannel)) {
+      return;
+    }
+
+    aChannel = aChannel.QueryInterface(Ci.nsIHttpChannel);
+
+    if (aActivitySubtype ==
+        gActivityDistributor.ACTIVITY_SUBTYPE_REQUEST_HEADER) {
+      this._onRequestHeader(aChannel, aTimestamp, aExtraStringData);
+      return;
+    }
+
+    // Iterate over all currently ongoing requests. If aChannel can't
+    // be found within them, then exit this function.
+    let httpActivity = null;
+    for each (let item in this.openRequests) {
+      if (item.channel === aChannel) {
+        httpActivity = item;
+        break;
+      }
+    }
+
+    if (!httpActivity) {
+      return;
+    }
+
+    let transCodes = this.httpTransactionCodes;
+
+    // Store the time information for this activity subtype.
+    if (aActivitySubtype in transCodes) {
+      let stage = transCodes[aActivitySubtype];
+      if (stage in httpActivity.timings) {
+        httpActivity.timings[stage].last = aTimestamp;
+      }
+      else {
+        httpActivity.timings[stage] = {
+          first: aTimestamp,
+          last: aTimestamp,
+        };
+      }
+    }
+
+    switch (aActivitySubtype) {
+      case gActivityDistributor.ACTIVITY_SUBTYPE_REQUEST_BODY_SENT:
+        this._onRequestBodySent(httpActivity);
+        break;
+      case gActivityDistributor.ACTIVITY_SUBTYPE_RESPONSE_HEADER:
+        this._onResponseHeader(httpActivity, aExtraStringData);
+        break;
+      case gActivityDistributor.ACTIVITY_SUBTYPE_TRANSACTION_CLOSE:
+        this._onTransactionClose(httpActivity);
+        break;
+      default:
+        break;
+    }
+  },
+
+  /**
+   * Handler for ACTIVITY_SUBTYPE_REQUEST_HEADER. When a request starts the
+   * headers are sent to the server. This method creates the |httpActivity|
+   * object where we store the request and response information that is
+   * collected through its lifetime.
+   *
+   * @private
+   * @param nsIHttpChannel aChannel
+   * @param number aTimestamp
+   * @param string aExtraStringData
+   * @return void
+   */
+  _onRequestHeader:
+  function NM__onRequestHeader(aChannel, aTimestamp, aExtraStringData)
+  {
+    // Try to get the source window of the request.
+    let win = NetworkHelper.getWindowForRequest(aChannel);
+    if (!win || win.top !== this.window) {
+      return;
+    }
+
+    let httpActivity = this.createActivityObject(aChannel);
+    httpActivity.charset = win.document.characterSet; // see NM__onRequestBodySent()
+
+    httpActivity.timings.REQUEST_HEADER = {
+      first: aTimestamp,
+      last: aTimestamp
+    };
+
+    let httpVersionMaj = {};
+    let httpVersionMin = {};
+    let event = {};
+    event.startedDateTime = new Date(Math.round(aTimestamp / 1000)).toISOString();
+    event.headersSize = aExtraStringData.length;
+    event.method = aChannel.requestMethod;
+    event.url = aChannel.URI.spec;
+
+    // Determine the HTTP version.
+    aChannel.QueryInterface(Ci.nsIHttpChannelInternal);
+    aChannel.getRequestVersion(httpVersionMaj, httpVersionMin);
+
+    event.httpVersion = "HTTP/" + httpVersionMaj.value + "." +
+                                  httpVersionMin.value;
+
+    event.discardRequestBody = !this.saveRequestAndResponseBodies;
+    event.discardResponseBody = !this.saveRequestAndResponseBodies;
+
+    let headers = [];
+    let cookies = [];
+    let cookieHeader = null;
+
+    // Copy the request header data.
+    aChannel.visitRequestHeaders({
+      visitHeader: function NM__visitHeader(aName, aValue)
+      {
+        if (aName == "Cookie") {
+          cookieHeader = aValue;
+        }
+        headers.push({ name: aName, value: aValue });
+      }
+    });
+
+    if (cookieHeader) {
+      cookies = NetworkHelper.parseCookieHeader(cookieHeader);
+    }
+
+    httpActivity.owner = this.owner.onNetworkEvent(event);
+
+    this._setupResponseListener(httpActivity);
+
+    this.openRequests[httpActivity.id] = httpActivity;
+
+    httpActivity.owner.addRequestHeaders(headers);
+    httpActivity.owner.addRequestCookies(cookies);
+  },
+
+  /**
+   * Create the empty HTTP activity object. This object is used for storing all
+   * the request and response information.
+   *
+   * This is a HAR-like object. Conformance to the spec is not guaranteed at
+   * this point.
+   *
+   * TODO: Bug 708717 - Add support for network log export to HAR
+   *
+   * @see http://www.softwareishard.com/blog/har-12-spec
+   * @param nsIHttpChannel aChannel
+   *        The HTTP channel for which the HTTP activity object is created.
+   * @return object
+   *         The new HTTP activity object.
+   */
+  createActivityObject: function NM_createActivityObject(aChannel)
+  {
+    return {
+      id: gSequenceId(),
+      channel: aChannel,
+      charset: null, // see NM__onRequestHeader()
+      url: aChannel.URI.spec,
+      discardRequestBody: !this.saveRequestAndResponseBodies,
+      discardResponseBody: !this.saveRequestAndResponseBodies,
+      timings: {}, // internal timing information, see NM_observeActivity()
+      responseStatus: null, // see NM__onResponseHeader()
+      owner: null, // the activity owner which is notified when changes happen
+    };
+  },
+
+  /**
+   * Setup the network response listener for the given HTTP activity. The
+   * NetworkResponseListener is responsible for storing the response body.
+   *
+   * @private
+   * @param object aHttpActivity
+   *        The HTTP activity object we are tracking.
+   */
+  _setupResponseListener: function NM__setupResponseListener(aHttpActivity)
+  {
+    let channel = aHttpActivity.channel;
+    channel.QueryInterface(Ci.nsITraceableChannel);
+
+    // The response will be written into the outputStream of this pipe.
+    // This allows us to buffer the data we are receiving and read it
+    // asynchronously.
+    // Both ends of the pipe must be blocking.
+    let sink = Cc["@mozilla.org/pipe;1"].createInstance(Ci.nsIPipe);
+
+    // The streams need to be blocking because this is required by the
+    // stream tee.
+    sink.init(false, false, this.responsePipeSegmentSize, PR_UINT32_MAX, null);
+
+    // Add listener for the response body.
+    let newListener = new NetworkResponseListener(this, aHttpActivity);
+
+    // Remember the input stream, so it isn't released by GC.
+    newListener.inputStream = sink.inputStream;
+    newListener.sink = sink;
+
+    let tee = Cc["@mozilla.org/network/stream-listener-tee;1"].
+              createInstance(Ci.nsIStreamListenerTee);
+
+    let originalListener = channel.setNewListener(tee);
+
+    tee.init(originalListener, sink.outputStream, newListener);
+  },
+
+  /**
+   * Handler for ACTIVITY_SUBTYPE_REQUEST_BODY_SENT. The request body is logged
+   * here.
+   *
+   * @private
+   * @param object aHttpActivity
+   *        The HTTP activity object we are working with.
+   */
+  _onRequestBodySent: function NM__onRequestBodySent(aHttpActivity)
+  {
+    if (aHttpActivity.discardRequestBody) {
+      return;
+    }
+
+    let sentBody = NetworkHelper.
+                   readPostTextFromRequest(aHttpActivity.channel,
+                                           aHttpActivity.charset);
+
+    if (!sentBody && aHttpActivity.url == this.window.location.href) {
+      // If the request URL is the same as the current page URL, then
+      // we can try to get the posted text from the page directly.
+      // This check is necessary as otherwise the
+      //   NetworkHelper.readPostTextFromPageViaWebNav()
+      // function is called for image requests as well but these
+      // are not web pages and as such don't store the posted text
+      // in the cache of the webpage.
+      let webNav = this.window.QueryInterface(Ci.nsIInterfaceRequestor).
+                   getInterface(Ci.nsIWebNavigation);
+      sentBody = NetworkHelper.
+                 readPostTextFromPageViaWebNav(webNav, aHttpActivity.charset);
+    }
+
+    if (sentBody) {
+      aHttpActivity.owner.addRequestPostData({ text: sentBody });
+    }
+  },
+
+  /**
+   * Handler for ACTIVITY_SUBTYPE_RESPONSE_HEADER. This method stores
+   * information about the response headers.
+   *
+   * @private
+   * @param object aHttpActivity
+   *        The HTTP activity object we are working with.
+   * @param string aExtraStringData
+   *        The uncached response headers.
+   */
+  _onResponseHeader:
+  function NM__onResponseHeader(aHttpActivity, aExtraStringData)
+  {
+    // aExtraStringData contains the uncached response headers. The first line
+    // contains the response status (e.g. HTTP/1.1 200 OK).
+    //
+    // Note: The response header is not saved here. Calling the
+    // channel.visitResponseHeaders() methood at this point sometimes causes an
+    // NS_ERROR_NOT_AVAILABLE exception.
+    //
+    // We could parse aExtraStringData to get the headers and their values, but
+    // that is not trivial to do in an accurate manner. Hence, we save the
+    // response headers in this._httpResponseExaminer().
+
+    let headers = aExtraStringData.split(/\r\n|\n|\r/);
+    let statusLine = headers.shift();
+    let statusLineArray = statusLine.split(" ");
+
+    let response = {};
+    response.httpVersion = statusLineArray.shift();
+    response.status = statusLineArray.shift();
+    response.statusText = statusLineArray.join(" ");
+    response.headersSize = aExtraStringData.length;
+
+    aHttpActivity.responseStatus = response.status;
+
+    // Discard the response body for known response statuses.
+    switch (parseInt(response.status)) {
+      case HTTP_MOVED_PERMANENTLY:
+      case HTTP_FOUND:
+      case HTTP_SEE_OTHER:
+      case HTTP_TEMPORARY_REDIRECT:
+        aHttpActivity.discardResponseBody = true;
+        break;
+    }
+
+    response.discardResponseBody = aHttpActivity.discardResponseBody;
+
+    aHttpActivity.owner.addResponseStart(response);
+  },
+
+  /**
+   * Handler for ACTIVITY_SUBTYPE_TRANSACTION_CLOSE. This method updates the HAR
+   * timing information on the HTTP activity object and clears the request
+   * from the list of known open requests.
+   *
+   * @private
+   * @param object aHttpActivity
+   *        The HTTP activity object we work with.
+   */
+  _onTransactionClose: function NM__onTransactionClose(aHttpActivity)
+  {
+    let result = this._setupHarTimings(aHttpActivity);
+    aHttpActivity.owner.addEventTimings(result.total, result.timings);
+    delete this.openRequests[aHttpActivity.id];
+  },
+
+  /**
+   * Update the HTTP activity object to include timing information as in the HAR
+   * spec. The HTTP activity object holds the raw timing information in
+   * |timings| - these are timings stored for each activity notification. The
+   * HAR timing information is constructed based on these lower level data.
+   *
+   * @param object aHttpActivity
+   *        The HTTP activity object we are working with.
+   * @return object
+   *         This object holds two properties:
+   *         - total - the total time for all of the request and response.
+   *         - timings - the HAR timings object.
+   */
+  _setupHarTimings: function NM__setupHarTimings(aHttpActivity)
+  {
+    let timings = aHttpActivity.timings;
+    let harTimings = {};
+
+    // Not clear how we can determine "blocked" time.
+    harTimings.blocked = -1;
+
+    // DNS timing information is available only in when the DNS record is not
+    // cached.
+    harTimings.dns = timings.STATUS_RESOLVING && timings.STATUS_RESOLVED ?
+                     timings.STATUS_RESOLVED.last -
+                     timings.STATUS_RESOLVING.first : -1;
+
+    if (timings.STATUS_CONNECTING_TO && timings.STATUS_CONNECTED_TO) {
+      harTimings.connect = timings.STATUS_CONNECTED_TO.last -
+                           timings.STATUS_CONNECTING_TO.first;
+    }
+    else if (timings.STATUS_SENDING_TO) {
+      harTimings.connect = timings.STATUS_SENDING_TO.first -
+                           timings.REQUEST_HEADER.first;
+    }
+    else {
+      harTimings.connect = -1;
+    }
+
+    if ((timings.STATUS_WAITING_FOR || timings.STATUS_RECEIVING_FROM) &&
+        (timings.STATUS_CONNECTED_TO || timings.STATUS_SENDING_TO)) {
+      harTimings.send = (timings.STATUS_WAITING_FOR ||
+                         timings.STATUS_RECEIVING_FROM).first -
+                        (timings.STATUS_CONNECTED_TO ||
+                         timings.STATUS_SENDING_TO).last;
+    }
+    else {
+      harTimings.send = -1;
+    }
+
+    if (timings.RESPONSE_START) {
+      harTimings.wait = timings.RESPONSE_START.first -
+                        (timings.REQUEST_BODY_SENT ||
+                         timings.STATUS_SENDING_TO).last;
+    }
+    else {
+      harTimings.wait = -1;
+    }
+
+    if (timings.RESPONSE_START && timings.RESPONSE_COMPLETE) {
+      harTimings.receive = timings.RESPONSE_COMPLETE.last -
+                           timings.RESPONSE_START.first;
+    }
+    else {
+      harTimings.receive = -1;
+    }
+
+    let totalTime = 0;
+    for (let timing in harTimings) {
+      let time = Math.max(Math.round(harTimings[timing] / 1000), -1);
+      harTimings[timing] = time;
+      if (time > -1) {
+        totalTime += time;
+      }
+    }
+
+    return {
+      total: totalTime,
+      timings: harTimings,
+    };
+  },
+
+  /**
+   * Suspend Web Console activity. This is called when all Web Consoles are
+   * closed.
+   */
+  destroy: function NM_destroy()
+  {
+    Services.obs.removeObserver(this._httpResponseExaminer,
+                                "http-on-examine-response");
+
+    gActivityDistributor.removeObserver(this);
+
+    this.openRequests = {};
+    this.openResponses = {};
+    this.owner = null;
+    this.window = null;
+  },
+};
+
+_global.NetworkMonitor = NetworkMonitor;
+_global.NetworkResponseListener = NetworkResponseListener;
+})(this, WebConsoleUtils);
+
+
+/**
+ * A WebProgressListener that listens for location changes.
+ *
+ * This progress listener is used to track file loads and other kinds of
+ * location changes.
+ *
+ * @constructor
+ * @param object aBrowser
+ *        The xul:browser for which we need to track location changes.
+ * @param object aOwner
+ *        The listener owner which needs to implement two methods:
+ *        - onFileActivity(aFileURI)
+ *        - onLocationChange(aState, aTabURI, aPageTitle)
+ */
+function ConsoleProgressListener(aBrowser, aOwner)
+{
+  this.browser = aBrowser;
+  this.owner = aOwner;
+}
+
+ConsoleProgressListener.prototype = {
+  /**
+   * Constant used for startMonitor()/stopMonitor() that tells you want to
+   * monitor file loads.
+   */
+  MONITOR_FILE_ACTIVITY: 1,
+
+  /**
+   * Constant used for startMonitor()/stopMonitor() that tells you want to
+   * monitor page location changes.
+   */
+  MONITOR_LOCATION_CHANGE: 2,
+
+  /**
+   * Tells if you want to monitor file activity.
+   * @private
+   * @type boolean
+   */
+  _fileActivity: false,
+
+  /**
+   * Tells if you want to monitor location changes.
+   * @private
+   * @type boolean
+   */
+  _locationChange: false,
+
+  /**
+   * Tells if the console progress listener is initialized or not.
+   * @private
+   * @type boolean
+   */
+  _initialized: false,
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIWebProgressListener,
+                                         Ci.nsISupportsWeakReference]),
+
+  /**
+   * Initialize the ConsoleProgressListener.
+   * @private
+   */
+  _init: function CPL__init()
+  {
+    if (this._initialized) {
+      return;
+    }
+
+    this._initialized = true;
+    this.browser.addProgressListener(this, Ci.nsIWebProgress.NOTIFY_STATE_ALL);
+  },
+
+  /**
+   * Start a monitor/tracker related to the current nsIWebProgressListener
+   * instance.
+   *
+   * @param number aMonitor
+   *        Tells what you want to track. Available constants:
+   *        - this.MONITOR_FILE_ACTIVITY
+   *          Track file loads.
+   *        - this.MONITOR_LOCATION_CHANGE
+   *          Track location changes for the top window.
+   */
+  startMonitor: function CPL_startMonitor(aMonitor)
+  {
+    switch (aMonitor) {
+      case this.MONITOR_FILE_ACTIVITY:
+        this._fileActivity = true;
+        break;
+      case this.MONITOR_LOCATION_CHANGE:
+        this._locationChange = true;
+        break;
+      default:
+        throw new Error("ConsoleProgressListener: unknown monitor type " +
+                        aMonitor + "!");
+    }
+    this._init();
+  },
+
+  /**
+   * Stop a monitor.
+   *
+   * @param number aMonitor
+   *        Tells what you want to stop tracking. See this.startMonitor() for
+   *        the list of constants.
+   */
+  stopMonitor: function CPL_stopMonitor(aMonitor)
+  {
+    switch (aMonitor) {
+      case this.MONITOR_FILE_ACTIVITY:
+        this._fileActivity = false;
+        break;
+      case this.MONITOR_LOCATION_CHANGE:
+        this._locationChange = false;
+        break;
+      default:
+        throw new Error("ConsoleProgressListener: unknown monitor type " +
+                        aMonitor + "!");
+    }
+
+    if (!this._fileActivity && !this._locationChange) {
+      this.destroy();
+    }
+  },
+
+  onStateChange:
+  function CPL_onStateChange(aProgress, aRequest, aState, aStatus)
+  {
+    if (!this.owner) {
+      return;
+    }
+
+    if (this._fileActivity) {
+      this._checkFileActivity(aProgress, aRequest, aState, aStatus);
+    }
+
+    if (this._locationChange) {
+      this._checkLocationChange(aProgress, aRequest, aState, aStatus);
+    }
+  },
+
+  /**
+   * Check if there is any file load, given the arguments of
+   * nsIWebProgressListener.onStateChange. If the state change tells that a file
+   * URI has been loaded, then the remote Web Console instance is notified.
+   * @private
+   */
+  _checkFileActivity:
+  function CPL__checkFileActivity(aProgress, aRequest, aState, aStatus)
+  {
+    if (!(aState & Ci.nsIWebProgressListener.STATE_START)) {
+      return;
+    }
+
+    let uri = null;
+    if (aRequest instanceof Ci.imgIRequest) {
+      let imgIRequest = aRequest.QueryInterface(Ci.imgIRequest);
+      uri = imgIRequest.URI;
+    }
+    else if (aRequest instanceof Ci.nsIChannel) {
+      let nsIChannel = aRequest.QueryInterface(Ci.nsIChannel);
+      uri = nsIChannel.URI;
+    }
+
+    if (!uri || !uri.schemeIs("file") && !uri.schemeIs("ftp")) {
+      return;
+    }
+
+    this.owner.onFileActivity(uri.spec);
+  },
+
+  /**
+   * Check if the current window.top location is changing, given the arguments
+   * of nsIWebProgressListener.onStateChange. If that is the case, the remote
+   * Web Console instance is notified.
+   * @private
+   */
+  _checkLocationChange:
+  function CPL__checkLocationChange(aProgress, aRequest, aState, aStatus)
+  {
+    let isStart = aState & Ci.nsIWebProgressListener.STATE_START;
+    let isStop = aState & Ci.nsIWebProgressListener.STATE_STOP;
+    let isNetwork = aState & Ci.nsIWebProgressListener.STATE_IS_NETWORK;
+    let isWindow = aState & Ci.nsIWebProgressListener.STATE_IS_WINDOW;
+
+    // Skip non-interesting states.
+    if (!isNetwork || !isWindow ||
+        aProgress.DOMWindow != this.browser.contentWindow) {
+      return;
+    }
+
+    if (isStart && aRequest instanceof Ci.nsIChannel) {
+      this.owner.onLocationChange("start", aRequest.URI.spec, "");
+    }
+    else if (isStop) {
+      let window = this.browser.contentWindow;
+      this.owner.onLocationChange("stop", window.location.href,
+                                  window.document.title);
+    }
+  },
+
+  onLocationChange: function() {},
+  onStatusChange: function() {},
+  onProgressChange: function() {},
+  onSecurityChange: function() {},
+
+  /**
+   * Destroy the ConsoleProgressListener.
+   */
+  destroy: function CPL_destroy()
+  {
+    if (!this._initialized) {
+      return;
+    }
+
+    this._initialized = false;
+    this._fileActivity = false;
+    this._locationChange = false;
+
+    if (this.browser.removeProgressListener) {
+      this.browser.removeProgressListener(this);
+    }
+
+    this.browser = null;
+    this.owner = null;
+  },
+};
+
+function gSequenceId()
+{
+  return gSequenceId.n++;
+}
+gSequenceId.n = 0;
diff --git a/toolkit/devtools/webconsole/dbg-webconsole-actors.js b/toolkit/devtools/webconsole/dbg-webconsole-actors.js
--- a/toolkit/devtools/webconsole/dbg-webconsole-actors.js
+++ b/toolkit/devtools/webconsole/dbg-webconsole-actors.js
@@ -19,22 +19,28 @@ XPCOMUtils.defineLazyModuleGetter(this, 
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "PageErrorListener",
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "ConsoleAPIListener",
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "ConsoleProgressListener",
+                                  "resource://gre/modules/devtools/WebConsoleUtils.jsm");
+
 XPCOMUtils.defineLazyModuleGetter(this, "JSTermHelpers",
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "JSPropertyProvider",
                                   "resource://gre/modules/devtools/WebConsoleUtils.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "NetworkMonitor",
+                                  "resource://gre/modules/devtools/WebConsoleUtils.jsm");
+
 XPCOMUtils.defineLazyModuleGetter(this, "ConsoleAPIStorage",
                                   "resource://gre/modules/ConsoleAPIStorage.jsm");
 
 
 /**
  * The WebConsoleActor implements capabilities needed for the Web Console
  * feature.
  *
@@ -46,37 +52,58 @@ XPCOMUtils.defineLazyModuleGetter(this, 
  */
 function WebConsoleActor(aConnection, aTabActor)
 {
   this.conn = aConnection;
   this._browser = aTabActor.browser;
 
   this._objectActorsPool = new ActorPool(this.conn);
   this.conn.addActorPool(this._objectActorsPool);
+
+  this._networkEventActorsPool = new ActorPool(this.conn);
+  this.conn.addActorPool(this._networkEventActorsPool);
+
+  this._prefs = {};
 }
 
 WebConsoleActor.prototype =
 {
   /**
    * The xul:browser we work with.
    * @private
    * @type nsIDOMElement
    */
   _browser: null,
 
   /**
    * Actor pool for all of the object actors for objects we send to the client.
    * @private
    * @type object
    * @see ActorPool
+   * @see WebConsoleObjectActor
    * @see this.objectGrip()
    */
   _objectActorsPool: null,
 
   /**
+   * Actor pool for all of the network event actors.
+   * @private
+   * @type object
+   * @see NetworkEventActor
+   */
+  _networkEventActorsPool: null,
+
+  /**
+   * Web Console-related preferences.
+   * @private
+   * @type object
+   */
+  _prefs: null,
+
+  /**
    * Tells the current page location associated to the sandbox. When the page
    * location is changed, we recreate the sandbox.
    * @private
    * @type object
    */
   _sandboxLocation: null,
 
   /**
@@ -103,16 +130,33 @@ WebConsoleActor.prototype =
    */
   pageErrorListener: null,
 
   /**
    * The ConsoleAPIListener instance.
    */
   consoleAPIListener: null,
 
+  /**
+   * The NetworkMonitor instance.
+   */
+  networkMonitor: null,
+
+  /**
+   * The ConsoleProgressListener instance.
+   */
+  consoleProgressListener: null,
+
+  /**
+   * Getter for the NetworkMonitor.saveRequestAndResponseBodies preference.
+   * @type boolean
+   */
+  get saveRequestAndResponseBodies()
+    this._prefs["NetworkMonitor.saveRequestAndResponseBodies"],
+
   actorPrefix: "console",
 
   grip: function WCA_grip()
   {
     return { actor: this.actorID };
   },
 
   /**
@@ -141,18 +185,28 @@ WebConsoleActor.prototype =
     if (this.pageErrorListener) {
       this.pageErrorListener.destroy();
       this.pageErrorListener = null;
     }
     if (this.consoleAPIListener) {
       this.consoleAPIListener.destroy();
       this.consoleAPIListener = null;
     }
+    if (this.networkMonitor) {
+      this.networkMonitor.destroy();
+      this.networkMonitor = null;
+    }
+    if (this.consoleProgressListener) {
+      this.consoleProgressListener.destroy();
+      this.consoleProgressListener = null;
+    }
     this.conn.removeActorPool(this._objectActorsPool);
+    this.conn.removeActorPool(this._networkEventActorsPool);
     this._objectActorsPool = null;
+    this._networkEventActorsPool = null;
     this._sandboxLocation = this.sandbox = null;
     this.conn = this._browser = null;
   },
 
   /**
    * Create a grip for the given value. If the value is an object,
    * a WebConsoleObjectActor will be created.
    *
@@ -201,16 +255,31 @@ WebConsoleActor.prototype =
    *        The WebConsoleObjectActor instance you want to release.
    */
   releaseObject: function WCA_releaseObject(aActor)
   {
     this._objectActorsPool.removeActor(aActor.actorID);
   },
 
   /**
+   * Release a network event actor.
+   *
+   * @param object aActor
+   *        The NetworkEventActor instance you want to release.
+   */
+  releaseNetworkEvent: function WCA_releaseNetworkEvent(aActor)
+  {
+    this._networkEventActorsPool.removeActor(aActor.actorID);
+  },
+
+  //////////////////
+  // Request handlers for known packet types.
+  //////////////////
+
+  /**
    * Handler for the "startListeners" request.
    *
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
    * @return object
    *         The response object which holds the startedListeners array.
    */
   onStartListeners: function WCA_onStartListeners(aRequest)
@@ -231,16 +300,40 @@ WebConsoleActor.prototype =
         case "ConsoleAPI":
           if (!this.consoleAPIListener) {
             this.consoleAPIListener =
               new ConsoleAPIListener(this.window, this);
             this.consoleAPIListener.init();
           }
           startedListeners.push(listener);
           break;
+        case "NetworkActivity":
+          if (!this.networkMonitor) {
+            this.networkMonitor =
+              new NetworkMonitor(this.window, this);
+            this.networkMonitor.init();
+          }
+          startedListeners.push(listener);
+          break;
+        case "FileActivity":
+          if (!this.consoleProgressListener) {
+            this.consoleProgressListener =
+              new ConsoleProgressListener(this._browser, this);
+          }
+          this.consoleProgressListener.startMonitor(this.consoleProgressListener.
+                                                    MONITOR_FILE_ACTIVITY);
+          startedListeners.push(listener);
+          break;
+        case "LocationChange":
+          if (!this.consoleProgressListener) {
+            this.consoleProgressListener =
+              new ConsoleProgressListener(this._browser, this);
+          }
+          this.consoleProgressListener.startMonitor(this.consoleProgressListener.
+                                                    MONITOR_LOCATION_CHANGE);
       }
     }
     return {
       startedListeners: startedListeners,
       nativeConsoleAPI: this.hasNativeConsoleAPI(),
     };
   },
 
@@ -254,17 +347,19 @@ WebConsoleActor.prototype =
    *         stoppedListeners array.
    */
   onStopListeners: function WCA_onStopListeners(aRequest)
   {
     let stoppedListeners = [];
 
     // If no specific listeners are requested to be detached, we stop all
     // listeners.
-    let toDetach = aRequest.listeners || ["PageError", "ConsoleAPI"];
+    let toDetach = aRequest.listeners ||
+                   ["PageError", "ConsoleAPI", "NetworkActivity",
+                    "FileActivity", "LocationChange"];
 
     while (toDetach.length > 0) {
       let listener = toDetach.shift();
       switch (listener) {
         case "PageError":
           if (this.pageErrorListener) {
             this.pageErrorListener.destroy();
             this.pageErrorListener = null;
@@ -273,16 +368,37 @@ WebConsoleActor.prototype =
           break;
         case "ConsoleAPI":
           if (this.consoleAPIListener) {
             this.consoleAPIListener.destroy();
             this.consoleAPIListener = null;
           }
           stoppedListeners.push(listener);
           break;
+        case "NetworkActivity":
+          if (this.networkMonitor) {
+            this.networkMonitor.destroy();
+            this.networkMonitor = null;
+          }
+          stoppedListeners.push(listener);
+          break;
+        case "FileActivity":
+          if (this.consoleProgressListener) {
+            this.consoleProgressListener.stopMonitor(this.consoleProgressListener.
+                                                     MONITOR_FILE_ACTIVITY);
+          }
+          stoppedListeners.push(listener);
+          break;
+        case "LocationChange":
+          if (this.consoleProgressListener) {
+            this.consoleProgressListener.stopMonitor(this.consoleProgressListener.
+                                                     MONITOR_LOCATION_CHANGE);
+          }
+          stoppedListeners.push(listener);
+          break;
       }
     }
 
     return { stoppedListeners: stoppedListeners };
   },
 
   /**
    * Handler for the "getCachedMessages" request. This method sends the cached
@@ -405,16 +521,34 @@ WebConsoleActor.prototype =
   {
     // TODO: Bug 717611 - Web Console clear button does not clear cached errors
     let windowId = WebConsoleUtils.getInnerWindowId(this.window);
     ConsoleAPIStorage.clearEvents(windowId);
     return {};
   },
 
   /**
+   * The "setPreferences" request handler.
+   *
+   * @param object aRequest
+   *        The request message - which preferences need to be updated.
+   */
+  onSetPreferences: function WCA_onSetPreferences(aRequest)
+  {
+    for (let key in aRequest.preferences) {
+      this._prefs[key] = aRequest.preferences[key];
+    }
+    return { updated: Object.keys(aRequest.preferences) };
+  },
+
+  //////////////////
+  // End of request handlers.
+  //////////////////
+
+  /**
    * Create the JavaScript sandbox where user input is evaluated.
    * @private
    */
   _createSandbox: function WCA__createSandbox()
   {
     this._sandboxLocation = this.window.location;
     this.sandbox = new Cu.Sandbox(this.window, {
       sandboxPrototype: this.window,
@@ -469,16 +603,20 @@ WebConsoleActor.prototype =
     }
     if ($$) {
       this.sandbox.$$ = $$;
     }
 
     return result;
   },
 
+  //////////////////
+  // Event handlers for various listeners.
+  //////////////////
+
   /**
    * Handler for page errors received from the PageErrorListener. This method
    * sends the nsIScriptError to the remote Web Console client.
    *
    * @param nsIScriptError aPageError
    *        The page error we need to send to the client.
    */
   onPageError: function WCA_onPageError(aPageError)
@@ -516,30 +654,113 @@ WebConsoleActor.prototype =
       strict: !!(aPageError.flags & aPageError.strictFlag),
     };
   },
 
   /**
    * Handler for window.console API calls received from the ConsoleAPIListener.
    * This method sends the object to the remote Web Console client.
    *
+   * @see ConsoleAPIListener
    * @param object aMessage
    *        The console API call we need to send to the remote client.
    */
   onConsoleAPICall: function WCA_onConsoleAPICall(aMessage)
   {
     let packet = {
       from: this.actorID,
       type: "consoleAPICall",
       message: this.prepareConsoleMessageForRemote(aMessage),
     };
     this.conn.send(packet);
   },
 
   /**
+   * Handler for network events. This method is invoked when a new network event
+   * is about to be recorded.
+   *
+   * @see NetworkEventActor
+   * @see NetworkMonitor from WebConsoleUtils.jsm
+   *
+   * @param object aEvent
+   *        The initial network request event information.
+   * @return object
+   *         A new NetworkEventActor is returned. This is used for tracking the
+   *         network request and response.
+   */
+  onNetworkEvent: function WCA_onNetworkEvent(aEvent)
+  {
+    let actor = new NetworkEventActor(aEvent, this);
+    this._networkEventActorsPool.addActor(actor);
+
+    let packet = {
+      from: this.actorID,
+      type: "networkEvent",
+      eventActor: actor.grip(),
+    };
+
+    this.conn.send(packet);
+
+    return actor;
+  },
+
+  /**
+   * Handler for file activity. This method sends the file request information
+   * to the remote Web Console client.
+   *
+   * @see ConsoleProgressListener
+   * @param string aFileURI
+   *        The requested file URI.
+   */
+  onFileActivity: function WCA_onFileActivity(aFileURI)
+  {
+    let packet = {
+      from: this.actorID,
+      type: "fileActivity",
+      uri: aFileURI,
+    };
+    this.conn.send(packet);
+  },
+
+  /**
+   * Handler for location changes. This method sends the new browser location
+   * to the remote Web Console client.
+   *
+   * @see ConsoleProgressListener
+   * @param string aState
+   *        Tells the location change state:
+   *        - "start" means a load has begun.
+   *        - "stop" means load completed.
+   * @param string aURI
+   *        The new browser URI.
+   * @param string aTitle
+   *        The new page title URI.
+   */
+  onLocationChange: function WCA_onLocationChange(aState, aURI, aTitle)
+  {
+    // TODO: we should use tabNavigated, but that lives on the TabActor and in
+    // the Web Console we do not attach to the TabActor. Plus, the tabNavigated
+    // packet is only sent at the end of a page load - for the Web Console we
+    // need it as early as possible. Follow-up bug material?
+    let packet = {
+      from: this.actorID,
+      type: "locationChange",
+      uri: aURI,
+      title: aTitle,
+      state: aState,
+      nativeConsoleAPI: this.hasNativeConsoleAPI(),
+    };
+    this.conn.send(packet);
+  },
+
+  //////////////////
+  // End of event handlers for various listeners.
+  //////////////////
+
+  /**
    * Prepare a message from the console API to be sent to the remote Web Console
    * instance.
    *
    * @param object aMessage
    *        The original message received from console-api-log-event.
    * @return object
    *         The object that can be sent to the remote client.
    */
@@ -599,16 +820,17 @@ WebConsoleActor.prototype =
 WebConsoleActor.prototype.requestTypes =
 {
   startListeners: WebConsoleActor.prototype.onStartListeners,
   stopListeners: WebConsoleActor.prototype.onStopListeners,
   getCachedMessages: WebConsoleActor.prototype.onGetCachedMessages,
   evaluateJS: WebConsoleActor.prototype.onEvaluateJS,
   autocomplete: WebConsoleActor.prototype.onAutocomplete,
   clearMessagesCache: WebConsoleActor.prototype.onClearMessagesCache,
+  setPreferences: WebConsoleActor.prototype.onSetPreferences,
 };
 
 /**
  * Creates an actor for the specified object.
  *
  * @constructor
  * @param object aObj
  *        The object you want.
@@ -673,8 +895,380 @@ WebConsoleObjectActor.prototype =
 };
 
 WebConsoleObjectActor.prototype.requestTypes =
 {
   "inspectProperties": WebConsoleObjectActor.prototype.onInspectProperties,
   "release": WebConsoleObjectActor.prototype.onRelease,
 };
 
+
+/**
+ * Creates an actor for a network event.
+ *
+ * @constructor
+ * @param object aNetworkEvent
+ *        The network event you want to use the actor for.
+ * @param object aWebConsoleActor
+ *        The parent WebConsoleActor instance for this object.
+ */
+function NetworkEventActor(aNetworkEvent, aWebConsoleActor)
+{
+  this.parent = aWebConsoleActor;
+  this.conn = this.parent.conn;
+
+  this._startedDateTime = aNetworkEvent.startedDateTime;
+
+  this._request = {
+    method: aNetworkEvent.method,
+    url: aNetworkEvent.url,
+    httpVersion: aNetworkEvent.httpVersion,
+    headers: [],
+    cookies: [],
+    headersSize: aNetworkEvent.headersSize,
+    postData: {},
+  };
+
+  this._response = {
+    headers: [],
+    cookies: [],
+    content: {},
+  };
+
+  this._timings = {};
+
+  this._discardRequestBody = aNetworkEvent.discardRequestBody;
+  this._discardResponseBody = aNetworkEvent.discardResponseBody;
+}
+
+NetworkEventActor.prototype =
+{
+  _request: null,
+  _response: null,
+  _timings: null,
+
+  actorPrefix: "netEvent",
+
+  /**
+   * Returns a grip for this actor for returning in a protocol message.
+   */
+  grip: function NEA_grip()
+  {
+    return {
+      actor: this.actorID,
+      startedDateTime: this._startedDateTime,
+      url: this._request.url,
+      method: this._request.method,
+    };
+  },
+
+  /**
+   * Releases this actor from the pool.
+   */
+  release: function NEA_release()
+  {
+    this.parent.releaseNetworkEvent(this);
+  },
+
+  /**
+   * Handle a protocol request to release a grip.
+   */
+  onRelease: function NEA_onRelease()
+  {
+    this.release();
+    return {};
+  },
+
+  /**
+   * The "getRequestHeaders" packet type handler.
+   *
+   * @return object
+   *         The response packet - network request headers.
+   */
+  onGetRequestHeaders: function NEA_onGetRequestHeaders()
+  {
+    return {
+      from: this.actorID,
+      headers: this._request.headers,
+      headersSize: this._request.headersSize,
+    };
+  },
+
+  /**
+   * The "getRequestCookies" packet type handler.
+   *
+   * @return object
+   *         The response packet - network request cookies.
+   */
+  onGetRequestCookies: function NEA_onGetRequestCookies()
+  {
+    return {
+      from: this.actorID,
+      cookies: this._request.cookies,
+    };
+  },
+
+  /**
+   * The "getRequestPostData" packet type handler.
+   *
+   * @return object
+   *         The response packet - network POST data.
+   */
+  onGetRequestPostData: function NEA_onGetRequestPostData()
+  {
+    return {
+      from: this.actorID,
+      postData: this._request.postData,
+      postDataDiscarded: this._discardRequestBody,
+    };
+  },
+
+  /**
+   * The "getResponseHeaders" packet type handler.
+   *
+   * @return object
+   *         The response packet - network response headers.
+   */
+  onGetResponseHeaders: function NEA_onGetResponseHeaders()
+  {
+    return {
+      from: this.actorID,
+      headers: this._response.headers,
+      headersSize: this._response.headersSize,
+    };
+  },
+
+  /**
+   * The "getResponseCookies" packet type handler.
+   *
+   * @return object
+   *         The response packet - network response cookies.
+   */
+  onGetResponseCookies: function NEA_onGetResponseCookies()
+  {
+    return {
+      from: this.actorID,
+      cookies: this._response.cookies,
+    };
+  },
+
+  /**
+   * The "getResponseContent" packet type handler.
+   *
+   * @return object
+   *         The response packet - network response content.
+   */
+  onGetResponseContent: function NEA_onGetResponseContent()
+  {
+    return {
+      from: this.actorID,
+      content: this._response.content,
+      contentDiscarded: this._discardResponseBody,
+    };
+  },
+
+  /**
+   * The "getEventTimings" packet type handler.
+   *
+   * @return object
+   *         The response packet - network event timings.
+   */
+  onGetEventTimings: function NEA_onGetEventTimings()
+  {
+    return {
+      from: this.actorID,
+      timings: this._timings,
+      totalTime: this._totalTime,
+    };
+  },
+
+  /******************************************************************
+   * Listeners for new network event data coming from NetworkMonitor.
+   ******************************************************************/
+
+  /**
+   * Add network request headers.
+   *
+   * @param array aHeaders
+   *        The request headers array.
+   */
+  addRequestHeaders: function NEA_addRequestHeaders(aHeaders)
+  {
+    this._request.headers = aHeaders;
+
+    let packet = {
+      from: this.actorID,
+      type: "networkEventUpdate",
+      updateType: "requestHeaders",
+      headers: aHeaders.length,
+      headersSize: this._request.headersSize,
+    };
+
+    this.conn.send(packet);
+  },
+
+  /**
+   * Add network request cookies.
+   *
+   * @param array aCookies
+   *        The request cookies array.
+   */
+  addRequestCookies: function NEA_addRequestCookies(aCookies)
+  {
+    this._request.cookies = aCookies;
+
+    let packet = {
+      from: this.actorID,
+      type: "networkEventUpdate",
+      updateType: "requestCookies",
+      cookies: aCookies.length,
+    };
+
+    this.conn.send(packet);
+  },
+
+  /**
+   * Add network request POST data.
+   *
+   * @param object aPostData
+   *        The request POST data.
+   */
+  addRequestPostData: function NEA_addRequestPostData(aPostData)
+  {
+    this._request.postData = aPostData;
+
+    let packet = {
+      from: this.actorID,
+      type: "networkEventUpdate",
+      updateType: "requestPostData",
+      dataSize: aPostData.text.length,
+      discardRequestBody: this._discardRequestBody,
+    };
+
+    this.conn.send(packet);
+  },
+
+  /**
+   * Add the initial network response information.
+   *
+   * @param object aInfo
+   *        The response information.
+   */
+  addResponseStart: function NEA_addResponseStart(aInfo)
+  {
+    this._response.httpVersion = aInfo.httpVersion;
+    this._response.status = aInfo.status;
+    this._response.statusText = aInfo.statusText;
+    this._response.headersSize = aInfo.headersSize;
+    this._discardResponseBody = aInfo.discardResponseBody;
+
+    let packet = {
+      from: this.actorID,
+      type: "networkEventUpdate",
+      updateType: "responseStart",
+      response: aInfo,
+    };
+
+    this.conn.send(packet);
+  },
+
+  /**
+   * Add network response headers.
+   *
+   * @param array aHeaders
+   *        The response headers array.
+   */
+  addResponseHeaders: function NEA_addResponseHeaders(aHeaders)
+  {
+    this._response.headers = aHeaders;
+
+    let packet = {
+      from: this.actorID,
+      type: "networkEventUpdate",
+      updateType: "responseHeaders",
+      headers: aHeaders.length,
+      headersSize: this._response.headersSize,
+    };
+
+    this.conn.send(packet);
+  },
+
+  /**
+   * Add network response cookies.
+   *
+   * @param array aCookies
+   *        The response cookies array.
+   */
+  addResponseCookies: function NEA_addResponseCookies(aCookies)
+  {
+    this._response.cookies = aCookies;
+
+    let packet = {
+      from: this.actorID,
+      type: "networkEventUpdate",
+      updateType: "responseCookies",
+      cookies: aCookies.length,
+    };
+
+    this.conn.send(packet);
+  },
+
+  /**
+   * Add network response content.
+   *
+   * @param object aContent
+   *        The response content.
+   * @param boolean aDiscardedResponseBody
+   *        Tells if the response content was recorded or not.
+   */
+  addResponseContent:
+  function NEA_addResponseContent(aContent, aDiscardedResponseBody)
+  {
+    this._response.content = aContent;
+
+    let packet = {
+      from: this.actorID,
+      type: "networkEventUpdate",
+      updateType: "responseContent",
+      mimeType: aContent.mimeType,
+      contentSize: aContent.text.length,
+      discardResponseBody: aDiscardedResponseBody,
+    };
+
+    this.conn.send(packet);
+  },
+
+  /**
+   * Add network event timing information.
+   *
+   * @param number aTotal
+   *        The total time of the network event.
+   * @param object aTimings
+   *        Timing details about the network event.
+   */
+  addEventTimings: function NEA_addEventTimings(aTotal, aTimings)
+  {
+    this._totalTime = aTotal;
+    this._timings = aTimings;
+
+    let packet = {
+      from: this.actorID,
+      type: "networkEventUpdate",
+      updateType: "eventTimings",
+      totalTime: aTotal,
+    };
+
+    this.conn.send(packet);
+  },
+};
+
+NetworkEventActor.prototype.requestTypes =
+{
+  "release": NetworkEventActor.prototype.onRelease,
+  "getRequestHeaders": NetworkEventActor.prototype.onGetRequestHeaders,
+  "getRequestCookies": NetworkEventActor.prototype.onGetRequestCookies,
+  "getRequestPostData": NetworkEventActor.prototype.onGetRequestPostData,
+  "getResponseHeaders": NetworkEventActor.prototype.onGetResponseHeaders,
+  "getResponseCookies": NetworkEventActor.prototype.onGetResponseCookies,
+  "getResponseContent": NetworkEventActor.prototype.onGetResponseContent,
+  "getEventTimings": NetworkEventActor.prototype.onGetEventTimings,
+};
+
