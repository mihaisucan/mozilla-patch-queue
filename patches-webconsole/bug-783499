# HG changeset patch
# Parent 6d23a1d2d19302648bc929d41ec4a142f848aedf
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1359143839 -7200

Bug 783499 - Web Console should use the debugger API

diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -348,16 +348,50 @@ WebConsole.prototype = {
         return;
       }
     }
     // Open view source if style editor fails.
     this.viewSource(aSourceURL, aSourceLine);
   },
 
   /**
+   * Retrieve information about the JavaScript debugger's stackframes list. This
+   * is used to allow the Web Console to evaluate code in the selected
+   * stackframe.
+   *
+   * @return object|null
+   *         An object which holds:
+   *         - frames: the active ThreadClient.cachedFrames array.
+   *         - selected: depth/index of the selected stackframe in the debugger
+   *         UI.
+   *         If the debugger is not open or if it's not paused, then |null| is
+   *         returned.
+   */
+  getDebuggerFrames: function WC_getDebuggerFrames()
+  {
+    let toolbox = gDevTools.getToolbox(this.target);
+    if (!toolbox) {
+      return null;
+    }
+    let panel = toolbox.getPanel("jsdebugger");
+    if (!panel) {
+      return null;
+    }
+    let framesController = panel.panelWin.gStackFrames;
+    let thread = framesController.activeThread;
+    if (thread && thread.paused) {
+      return {
+        frames: thread.cachedFrames,
+        selected: framesController.currentFrame,
+      };
+    }
+    return null;
+  },
+
+  /**
    * Destroy the object. Call this method to avoid memory leaks when the Web
    * Console is closed.
    *
    * @return object
    *         A Promise object that is resolved once the Web Console is closed.
    */
   destroy: function WC_destroy()
   {
diff --git a/toolkit/devtools/debugger/dbg-client.jsm b/toolkit/devtools/debugger/dbg-client.jsm
--- a/toolkit/devtools/debugger/dbg-client.jsm
+++ b/toolkit/devtools/debugger/dbg-client.jsm
@@ -8,17 +8,18 @@
 const Ci = Components.interfaces;
 const Cc = Components.classes;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 this.EXPORTED_SYMBOLS = ["DebuggerTransport",
                          "DebuggerClient",
                          "debuggerSocketConnect",
-                         "LongStringClient"];
+                         "LongStringClient",
+                         "GripClient"];
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/NetUtil.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "socketTransportService",
                                    "@mozilla.org/network/socket-transport-service;1",
                                    "nsISocketTransportService");
diff --git a/toolkit/devtools/debugger/server/dbg-script-actors.js b/toolkit/devtools/debugger/server/dbg-script-actors.js
--- a/toolkit/devtools/debugger/server/dbg-script-actors.js
+++ b/toolkit/devtools/debugger/server/dbg-script-actors.js
@@ -954,17 +954,17 @@ ThreadActor.prototype = {
     }
 
     if (aPool.objectActors.has(aValue)) {
       return aPool.objectActors.get(aValue).grip();
     } else if (this.threadLifetimePool.objectActors.has(aValue)) {
       return this.threadLifetimePool.objectActors.get(aValue).grip();
     }
 
-    let actor = new ObjectActor(aValue, this);
+    let actor = new PauseScopedObjectActor(aValue, this);
     aPool.addActor(actor);
     aPool.objectActors.set(aValue, actor);
     return actor.grip();
   },
 
   /**
    * Create a grip for the given debuggee object with a pause lifetime.
    *
@@ -1488,20 +1488,17 @@ SourceActor.prototype.requestTypes = {
  *        The parent thread actor for this object.
  */
 function ObjectActor(aObj, aThreadActor)
 {
   this.obj = aObj;
   this.threadActor = aThreadActor;
 }
 
-ObjectActor.prototype = Object.create(PauseScopedActor.prototype);
-
-update(ObjectActor.prototype, {
-  constructor: ObjectActor,
+ObjectActor.prototype = {
   actorPrefix: "obj",
 
   /**
    * Returns a grip for this actor for returning in a protocol message.
    */
   grip: function OA_grip() {
     let g = { "type": "object",
               "class": this.obj.class,
@@ -1525,87 +1522,87 @@ update(ObjectActor.prototype, {
 
     return g;
   },
 
   /**
    * Releases this actor from the pool.
    */
   release: function OA_release() {
-    this.registeredPool.objectActors.delete(this.obj);
+    if (this.registeredPool.objectActors) {
+      this.registeredPool.objectActors.delete(this.obj);
+    }
     this.registeredPool.removeActor(this);
   },
 
   /**
    * Handle a protocol request to provide the names of the properties defined on
    * the object and not its prototype.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onOwnPropertyNames:
-  PauseScopedActor.withPaused(function OA_onOwnPropertyNames(aRequest) {
+  onOwnPropertyNames: function OA_onOwnPropertyNames(aRequest) {
     return { from: this.actorID,
              ownPropertyNames: this.obj.getOwnPropertyNames() };
-  }),
+  },
 
   /**
    * Handle a protocol request to provide the prototype and own properties of
    * the object.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onPrototypeAndProperties:
-  PauseScopedActor.withPaused(function OA_onPrototypeAndProperties(aRequest) {
+  onPrototypeAndProperties: function OA_onPrototypeAndProperties(aRequest) {
     let ownProperties = {};
     for each (let name in this.obj.getOwnPropertyNames()) {
       try {
         let desc = this.obj.getOwnPropertyDescriptor(name);
         ownProperties[name] = this._propertyDescriptor(desc);
       } catch (e if e.name == "NS_ERROR_XPC_BAD_OP_ON_WN_PROTO") {
         // Calling getOwnPropertyDescriptor on wrapped native prototypes is not
         // allowed.
         dumpn("Error while getting the property descriptor for " + name +
               ": " + e.name);
       }
     }
     return { from: this.actorID,
              prototype: this.threadActor.createValueGrip(this.obj.proto),
              ownProperties: ownProperties };
-  }),
+  },
 
   /**
    * Handle a protocol request to provide the prototype of the object.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onPrototype: PauseScopedActor.withPaused(function OA_onPrototype(aRequest) {
+  onPrototype: function OA_onPrototype(aRequest) {
     return { from: this.actorID,
              prototype: this.threadActor.createValueGrip(this.obj.proto) };
-  }),
+  },
 
   /**
    * Handle a protocol request to provide the property descriptor of the
    * object's specified property.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onProperty: PauseScopedActor.withPaused(function OA_onProperty(aRequest) {
+  onProperty: function OA_onProperty(aRequest) {
     if (!aRequest.name) {
       return { error: "missingParameter",
                message: "no property name was specified" };
     }
 
     let desc = this.obj.getOwnPropertyDescriptor(aRequest.name);
     return { from: this.actorID,
              descriptor: this._propertyDescriptor(desc) };
-  }),
+  },
 
   /**
    * A helper method that creates a property descriptor for the provided object,
    * properly formatted for sending in a protocol response.
    *
    * @param aObject object
    *        The object that the descriptor is generated for.
    */
@@ -1624,26 +1621,94 @@ update(ObjectActor.prototype, {
   },
 
   /**
    * Handle a protocol request to provide the source code of a function.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onDecompile: PauseScopedActor.withPaused(function OA_onDecompile(aRequest) {
+  onDecompile: function OA_onDecompile(aRequest) {
     if (this.obj.class !== "Function") {
       return { error: "objectNotFunction",
                message: "decompile request is only valid for object grips " +
                         "with a 'Function' class." };
     }
 
     return { from: this.actorID,
              decompiledCode: this.obj.decompile(!!aRequest.pretty) };
-  }),
+  },
+
+  /**
+   * Handle a protocol request to provide the parameters of a function.
+   *
+   * @param aRequest object
+   *        The protocol request object.
+   */
+  onParameterNames: function OA_onParameterNames(aRequest) {
+    if (this.obj.class !== "Function") {
+      return { error: "objectNotFunction",
+               message: "'parameterNames' request is only valid for object " +
+                        "grips with a 'Function' class." };
+    }
+
+    return { parameterNames: this.obj.parameterNames };
+  },
+
+  /**
+   * Handle a protocol request to release a thread-lifetime grip.
+   *
+   * @param aRequest object
+   *        The protocol request object.
+   */
+  onRelease: function OA_onRelease(aRequest) {
+    this.release();
+    return {};
+  },
+};
+
+ObjectActor.prototype.requestTypes = {
+  "parameterNames": ObjectActor.prototype.onParameterNames,
+  "prototypeAndProperties": ObjectActor.prototype.onPrototypeAndProperties,
+  "prototype": ObjectActor.prototype.onPrototype,
+  "property": ObjectActor.prototype.onProperty,
+  "ownPropertyNames": ObjectActor.prototype.onOwnPropertyNames,
+  "decompile": ObjectActor.prototype.onDecompile,
+  "release": ObjectActor.prototype.onRelease,
+};
+
+
+/**
+ * Creates a pause-scoped  actor for the specified object.
+ * @see ObjectActor
+ */
+function PauseScopedObjectActor()
+{
+  ObjectActor.apply(this, arguments);
+}
+
+PauseScopedObjectActor.prototype = Object.create(PauseScopedActor.prototype);
+
+update(PauseScopedObjectActor.prototype, ObjectActor.prototype);
+
+update(PauseScopedObjectActor.prototype, {
+  constructor: PauseScopedObjectActor,
+
+  onOwnPropertyNames:
+    PauseScopedActor.withPaused(ObjectActor.prototype.onOwnPropertyNames),
+
+  onPrototypeAndProperties:
+    PauseScopedActor.withPaused(ObjectActor.prototype.onPrototypeAndProperties),
+
+  onPrototype: PauseScopedActor.withPaused(ObjectActor.prototype.onPrototype),
+  onProperty: PauseScopedActor.withPaused(ObjectActor.prototype.onProperty),
+  onDecompile: PauseScopedActor.withPaused(ObjectActor.prototype.onDecompile),
+
+  onParameterNames:
+    PauseScopedActor.withPaused(ObjectActor.prototype.onParameterNames),
 
   /**
    * Handle a protocol request to provide the lexical scope of a function.
    *
    * @param aRequest object
    *        The protocol request object.
    */
   onScope: PauseScopedActor.withPaused(function OA_onScope(aRequest) {
@@ -1659,32 +1724,16 @@ update(ObjectActor.prototype, {
       return { error: "notDebuggee",
                message: "cannot access the environment of this function." };
     }
 
     return { from: this.actorID, scope: envActor.form() };
   }),
 
   /**
-   * Handle a protocol request to provide the parameters of a function.
-   *
-   * @param aRequest object
-   *        The protocol request object.
-   */
-  onParameterNames: PauseScopedActor.withPaused(function OA_onParameterNames(aRequest) {
-    if (this.obj.class !== "Function") {
-      return { error: "objectNotFunction",
-               message: "'parameterNames' request is only valid for object " +
-                        "grips with a 'Function' class." };
-    }
-
-    return { parameterNames: this.obj.parameterNames };
-  }),
-
-  /**
    * Handle a protocol request to promote a pause-lifetime grip to a
    * thread-lifetime grip.
    *
    * @param aRequest object
    *        The protocol request object.
    */
   onThreadGrip: PauseScopedActor.withPaused(function OA_onThreadGrip(aRequest) {
     this.threadActor.threadObjectGrip(this);
@@ -1703,27 +1752,20 @@ update(ObjectActor.prototype, {
                message: "Only thread-lifetime actors can be released." };
     }
 
     this.release();
     return {};
   }),
 });
 
-ObjectActor.prototype.requestTypes = {
-  "parameterNames": ObjectActor.prototype.onParameterNames,
-  "prototypeAndProperties": ObjectActor.prototype.onPrototypeAndProperties,
-  "prototype": ObjectActor.prototype.onPrototype,
-  "property": ObjectActor.prototype.onProperty,
-  "ownPropertyNames": ObjectActor.prototype.onOwnPropertyNames,
-  "scope": ObjectActor.prototype.onScope,
-  "decompile": ObjectActor.prototype.onDecompile,
-  "threadGrip": ObjectActor.prototype.onThreadGrip,
-  "release": ObjectActor.prototype.onRelease,
-};
+update(PauseScopedObjectActor.prototype.requestTypes, {
+  "scope": PauseScopedObjectActor.prototype.onScope,
+  "threadGrip": PauseScopedObjectActor.prototype.onThreadGrip,
+});
 
 
 /**
  * Creates an actor for the specied "very long" string. "Very long" is specified
  * at the server's discretion.
  *
  * @param aString String
  *        The string.
diff --git a/toolkit/devtools/webconsole/WebConsoleClient.jsm b/toolkit/devtools/webconsole/WebConsoleClient.jsm
--- a/toolkit/devtools/webconsole/WebConsoleClient.jsm
+++ b/toolkit/devtools/webconsole/WebConsoleClient.jsm
@@ -76,23 +76,45 @@ WebConsoleClient.prototype = {
 
   /**
    * Evaluate a JavaScript expression.
    *
    * @param string aString
    *        The code you want to evaluate.
    * @param function aOnResponse
    *        The function invoked when the response is received.
+   * @param object [aOptions={}]
+   *        Options for evaluation:
+   *
+   *        - bindObjectActor: an ObjectActor ID. The OA holds a reference to
+   *        a Debugger.Object that wraps a content object. This option allows
+   *        you to bind |_self| to the D.O of the given OA, during string
+   *        evaluation.
+   *
+   *        See: Debugger.Object.evalInGlobalWithBindings() for information
+   *        about bindings.
+   *
+   *        Use case: the variable view needs to update objects and it does so
+   *        by knowing the ObjectActor it inspects and binding |_self| to the
+   *        D.O of the OA. As such, variable view sends strings like these for
+   *        eval:
+   *          _self["prop"] = value;
+   *
+   *        - frameActor: a FrameActor ID. The FA holds a reference to
+   *        a Debugger.Frame. This option allow you to evaluate the string in
+   *        the frame of the given FA.
    */
-  evaluateJS: function WCC_evaluateJS(aString, aOnResponse)
+  evaluateJS: function WCC_evaluateJS(aString, aOnResponse, aOptions = {})
   {
     let packet = {
       to: this._actor,
       type: "evaluateJS",
       text: aString,
+      bindObjectActor: aOptions.bindObjectActor,
+      frameActor: aOptions.frameActor,
     };
     this._client.request(packet, aOnResponse);
   },
 
   /**
    * Autocomplete a JavaScript expression.
    *
    * @param string aString
diff --git a/toolkit/devtools/webconsole/WebConsoleUtils.jsm b/toolkit/devtools/webconsole/WebConsoleUtils.jsm
--- a/toolkit/devtools/webconsole/WebConsoleUtils.jsm
+++ b/toolkit/devtools/webconsole/WebConsoleUtils.jsm
@@ -23,22 +23,30 @@ XPCOMUtils.defineLazyModuleGetter(this, 
 
 XPCOMUtils.defineLazyModuleGetter(this, "NetworkHelper",
                                   "resource://gre/modules/devtools/NetworkHelper.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "gActivityDistributor",
                                    "@mozilla.org/network/http-activity-distributor;1",
                                    "nsIHttpActivityDistributor");
 
+// FIXME: toolkit imports from browser. Can we move vview to toolkit or...?
+// It looks like we already import toolbox jsm's from browser/...
+// Maybe we can recheck how strongly WCA depends on WCU. If it's not much, move
+// this back to browser/? I wouldn't favor this kind of back and forth, but it's
+// an option.
 XPCOMUtils.defineLazyModuleGetter(this, "gDevTools",
                                   "resource:///modules/devtools/gDevTools.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "TargetFactory",
                                   "resource:///modules/devtools/Target.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "VariablesView",
+                                  "resource:///modules/devtools/VariablesView.jsm");
+
 this.EXPORTED_SYMBOLS = ["WebConsoleUtils", "JSPropertyProvider", "JSTermHelpers",
                          "PageErrorListener", "ConsoleAPIListener",
                          "NetworkResponseListener", "NetworkMonitor",
                          "ConsoleProgressListener"];
 
 // Match the function name from the result of toString() or toSource().
 //
 // Examples:
@@ -781,17 +789,17 @@ this.WebConsoleUtils = {
    * Get the object class name. For example, the |window| object has the Window
    * class name (based on [object Window]).
    *
    * @param object aObject
    *        The object you want to get the class name for.
    * @return string
    *         The object class name.
    */
-  getObjectClassName: function WCF_getObjectClassName(aObject)
+  getObjectClassName: function WCU_getObjectClassName(aObject)
   {
     if (aObject === null) {
       return "null";
     }
     if (aObject === undefined) {
       return "undefined";
     }
 
@@ -1537,60 +1545,52 @@ this.JSTermHelpers = function JSTermHelp
    * @param string aXPath
    *        xPath search query to execute.
    * @param [optional] nsIDOMNode aContext
    *        Context to run the xPath query on. Uses window.document if not set.
    * @return array of nsIDOMNode
    */
   aOwner.sandbox.$x = function JSTH_$x(aXPath, aContext)
   {
-    let nodes = [];
+    // Work around bug 830818. If we return an object from chrome code the
+    // debuggee value will point to the proxy that wraps the chrome object.
+    let nodes = new aOwner.window.wrappedJSObject.Array();
     let doc = aOwner.window.document;
     let aContext = aContext || doc;
 
-    try {
-      let results = doc.evaluate(aXPath, aContext, null,
-                                 Ci.nsIDOMXPathResult.ANY_TYPE, null);
-      let node;
-      while (node = results.iterateNext()) {
-        nodes.push(node);
-      }
-    }
-    catch (ex) {
-      aOwner.window.console.error(ex.message);
+    let results = doc.evaluate(aXPath, aContext, null,
+                               Ci.nsIDOMXPathResult.ANY_TYPE, null);
+    let node;
+    while (node = results.iterateNext()) {
+      nodes.push(node);
     }
 
     return nodes;
   };
 
   /**
    * Returns the currently selected object in the highlighter.
    *
    * TODO: this implementation crosses the client/server boundaries! This is not
    * usable within a remote browser. To implement this feature correctly we need
    * support for remote inspection capabilities within the Inspector as well.
    * See bug 787975.
    *
    * @return nsIDOMElement|null
    *         The DOM element currently selected in the highlighter.
    */
-  Object.defineProperty(aOwner.sandbox, "$0", {
+   Object.defineProperty(aOwner.sandbox, "$0", {
     get: function() {
-      try {
-        let window = aOwner.chromeWindow();
-        let target = TargetFactory.forTab(window.gBrowser.selectedTab);
-        let toolbox = gDevTools.getToolbox(target);
+      let window = aOwner.chromeWindow();
+      let target = TargetFactory.forTab(window.gBrowser.selectedTab);
+      let toolbox = gDevTools.getToolbox(target);
+      let panel = toolbox ? toolbox.getPanel("inspector") : null;
+      let node = panel ? panel.selection.node : null;
 
-        return toolbox == null ?
-            undefined :
-            toolbox.getPanel("inspector").selection.node;
-      }
-      catch (ex) {
-        aOwner.window.console.error(ex.message);
-      }
+      return node ? aOwner.makeDebuggeeValue(node) : null;
     },
     enumerable: true,
     configurable: false
   });
 
   /**
    * Clears the output of the JSTerm.
    */
@@ -1605,38 +1605,37 @@ this.JSTermHelpers = function JSTermHelp
    * Returns the result of Object.keys(aObject).
    *
    * @param object aObject
    *        Object to return the property names from.
    * @return array of strings
    */
   aOwner.sandbox.keys = function JSTH_keys(aObject)
   {
-    return Object.keys(WebConsoleUtils.unwrap(aObject));
+    // Work around bug 830818. If we return an object from chrome code the
+    // debuggee value will point to the proxy that wraps the chrome object.
+    return aOwner.window.wrappedJSObject.Object.keys(WebConsoleUtils.unwrap(aObject));
   };
 
   /**
    * Returns the values of all properties on aObject.
    *
    * @param object aObject
    *        Object to display the values from.
    * @return array of string
    */
   aOwner.sandbox.values = function JSTH_values(aObject)
   {
-    let arrValues = [];
+    // Work around bug 830818. If we return an object from chrome code the
+    // debuggee value will point to the proxy that wraps the chrome object.
+    let arrValues = new aOwner.window.wrappedJSObject.Array();
     let obj = WebConsoleUtils.unwrap(aObject);
 
-    try {
-      for (let prop in obj) {
-        arrValues.push(obj[prop]);
-      }
-    }
-    catch (ex) {
-      aOwner.window.console.error(ex.message);
+    for (let prop in obj) {
+      arrValues.push(obj[prop]);
     }
 
     return arrValues;
   };
 
   /**
    * Opens a help window in MDN.
    */
@@ -1648,25 +1647,22 @@ this.JSTermHelpers = function JSTermHelp
   /**
    * Inspects the passed aObject. This is done by opening the PropertyPanel.
    *
    * @param object aObject
    *        Object to inspect.
    */
   aOwner.sandbox.inspect = function JSTH_inspect(aObject)
   {
-    let obj = WebConsoleUtils.unwrap(aObject);
-    if (!WebConsoleUtils.isObjectInspectable(obj)) {
-      return aObject;
-    }
-
+    let dbgObj = aOwner.makeDebuggeeValue(aObject);
+    let grip = aOwner.createValueGrip(dbgObj);
     aOwner.helperResult = {
       type: "inspectObject",
       input: aOwner.evalInput,
-      object: aOwner.createValueGrip(obj),
+      object: grip,
     };
   };
 
   /**
    * Prints aObject to the output.
    *
    * @param object aObject
    *        Object to print to the output.
@@ -1685,23 +1681,36 @@ this.JSTermHelpers = function JSTermHelp
 
     aOwner.helperResult = { rawOutput: true };
 
     if (typeof aObject == "function") {
       return aObject + "\n";
     }
 
     let output = [];
-    let getObjectGrip = WebConsoleUtils.getObjectGrip.bind(WebConsoleUtils);
+
     let obj = WebConsoleUtils.unwrap(aObject);
-    let props = WebConsoleUtils.inspectObject(obj, getObjectGrip);
-    props.forEach(function(aProp) {
-      output.push(aProp.name + ": " +
-                  WebConsoleUtils.getPropertyPanelValue(aProp));
-    });
+    for (let name in obj) {
+      let desc = WebConsoleUtils.getPropertyDescriptor(obj, name);
+      if (!desc) {
+        continue;
+      }
+      if (desc.get || desc.set) {
+        let getGrip = VariablesView.getGrip(desc.get);
+        let setGrip = VariablesView.getGrip(desc.set);
+        let getString = VariablesView.getString(getGrip);
+        let setString = VariablesView.getString(setGrip);
+        output.push(name + ":", "  get: " + getString, "  set: " + setString);
+      }
+      else {
+        let valueGrip = VariablesView.getGrip(obj[name]);
+        let valueString = VariablesView.getString(valueGrip);
+        output.push(name + ": " + valueString);
+      }
+    }
 
     return "  " + output.join("\n  ");
   };
 
   /**
    * Print a string to the output, as-is.
    *
    * @param string aString
diff --git a/toolkit/devtools/webconsole/dbg-webconsole-actors.js b/toolkit/devtools/webconsole/dbg-webconsole-actors.js
--- a/toolkit/devtools/webconsole/dbg-webconsole-actors.js
+++ b/toolkit/devtools/webconsole/dbg-webconsole-actors.js
@@ -66,21 +66,33 @@ function WebConsoleActor(aConnection, aP
     this._window = Services.wm.getMostRecentWindow("navigator:browser");
     this._isGlobalActor = true;
   }
 
   this._actorPool = new ActorPool(this.conn);
   this.conn.addActorPool(this._actorPool);
 
   this._prefs = {};
+
+  // TODO: maybe we can reuse the Debugger() from the ThreadActor, if it's
+  // available. Thoughts? See complications in evalWithDebugger().
+  this.dbg = new Debugger();
+  this._createGlobal();
 }
 
 WebConsoleActor.prototype =
 {
   /**
+   * Debugger instance.
+   *
+   * @see jsdebugger.jsm
+   */
+  dbg: null,
+
+  /**
    * Tells if this Web Console actor is a global actor or not.
    * @private
    * @type boolean
    */
   _isGlobalActor: false,
 
   /**
    * Actor pool for all of the actors we send to the client.
@@ -93,28 +105,39 @@ WebConsoleActor.prototype =
   /**
    * Web Console-related preferences.
    * @private
    * @type object
    */
   _prefs: null,
 
   /**
-   * Tells the current inner window associated to the sandbox. When the page
-   * is navigated, we recreate the sandbox.
+   * Tells the current inner window of the window of |this._dbgWindow|. When the
+   * page is navigated, we recreate the debugger object.
    * @private
    * @type object
    */
-  _sandboxWindowId: 0,
+  _globalWindowId: 0,
 
   /**
-   * The JavaScript Sandbox where code is evaluated.
+   * The Debugger.Object that wraps the content window.
+   * @private
    * @type object
    */
-  sandbox: null,
+  _dbgWindow: null,
+
+  /**
+   * Object that holds the API we give to the JSTermHelpers constructor. This is
+   * where the JSTerm helper functions are added.
+   *
+   * @see this._getJSTermHelpers()
+   * @private
+   * @type object
+   */
+  _jstermHelpers: null,
 
   /**
    * The debugger server connection instance.
    * @type object
    */
   conn: null,
 
   /**
@@ -180,76 +203,87 @@ WebConsoleActor.prototype =
       this.networkMonitor = null;
     }
     if (this.consoleProgressListener) {
       this.consoleProgressListener.destroy();
       this.consoleProgressListener = null;
     }
     this.conn.removeActorPool(this._actorPool);
     this._actorPool = null;
-    this.sandbox = null;
-    this._sandboxWindowId = 0;
+    this.dbg.enabled = false;
+    this.dbg = null;
+    this._dbgWindow = null;
+    this._globalWindowId = 0;
     this.conn = this._window = null;
   },
 
+  _createValueGrip: ThreadActor.prototype.createValueGrip,
+
   /**
-   * Create a grip for the given value. If the value is an object,
-   * a WebConsoleObjectActor will be created.
+   * Create a grip for the given value.
    *
    * @param mixed aValue
    * @return object
    */
   createValueGrip: function WCA_createValueGrip(aValue)
   {
-    return WebConsoleUtils.createValueGrip(aValue,
-                                           this.createObjectActor.bind(this));
+    return this._createValueGrip(aValue, this._actorPool);
+  },
+
+  /**
+   * Make a debuggee value for the given value.
+   *
+   * @param mixed aValue
+   *        The value you want to get a debuggee value for.
+   * @return object
+   *         Debuggee value for |aValue|.
+   */
+  makeDebuggeeValue: function WCA_makeDebuggeeValue(aValue)
+  {
+    return this._dbgWindow.makeDebuggeeValue(aValue);
   },
 
   /**
    * Create a grip for the given object.
    *
    * @param object aObject
    *        The object you want.
+   * @param object aPool
+   *        An ActorPool where the new actor instance is added.
    * @param object
    *        The object grip.
    */
-  createObjectActor: function WCA_createObjectActor(aObject)
+  objectGrip: function WCA_objectGrip(aObject, aPool)
   {
-    if (typeof aObject == "string") {
-      return this.createStringGrip(aObject);
-    }
-
     // We need to unwrap the object, otherwise we cannot access the properties
     // and methods added by the content scripts.
-    let obj = WebConsoleUtils.unwrap(aObject);
-    let actor = new WebConsoleObjectActor(obj, this);
-    this._actorPool.addActor(actor);
+    let actor = new ObjectActor(aObject, this);
+    aPool.addActor(actor);
     return actor.grip();
   },
 
   /**
-   * Create a grip for the given string. If the given string is a long string,
-   * then a LongStringActor grip will be used.
+   * Create a grip for the given string.
    *
    * @param string aString
    *        The string you want to create the grip for.
-   * @return string|object
-   *         The same string, as is, or a LongStringActor object that wraps the
-   *         given string.
+   * @param object aPool
+   *        An ActorPool where the new actor instance is added.
+   * @return object
+   *         A LongStringActor object that wraps the given string.
    */
-  createStringGrip: function WCA_createStringGrip(aString)
+  longStringGrip: function WCA_longStringGrip(aString, aPool)
   {
-    if (aString.length >= DebuggerServer.LONG_STRING_LENGTH) {
-      let actor = new LongStringActor(aString, this);
-      this._actorPool.addActor(actor);
-      return actor.grip();
-    }
-    return aString;
+    let actor = new LongStringActor(aString, this);
+    aPool.addActor(actor);
+    return actor.grip();
   },
 
+  _stringIsLong: ThreadActor.prototype._stringIsLong,
+
   /**
    * Get an object actor by its ID.
    *
    * @param string aActorID
    * @return object
    */
   getActorByID: function WCA_getActorByID(aActorID)
   {
@@ -447,54 +481,73 @@ WebConsoleActor.prototype =
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
    * @return object
    *         The evaluation response packet.
    */
   onEvaluateJS: function WCA_onEvaluateJS(aRequest)
   {
     let input = aRequest.text;
-    let result, error = null;
-    let timestamp;
+    let timestamp = Date.now();
 
-    this.helperResult = null;
-    this.evalInput = input;
-    try {
-      timestamp = Date.now();
-      result = this.evalInSandbox(input);
+    this._jstermHelpers.helperResult = null;
+    this._jstermHelpers.evalInput = input;
+    let evalOptions = {
+      bindObjectActor: aRequest.bindObjectActor,
+      frameActor: aRequest.frameActor,
+    };
+    let evalResult = this.evalWithDebugger(input, evalOptions);
+
+    let helperResult = this._jstermHelpers.helperResult;
+    delete this._jstermHelpers.helperResult;
+    delete this._jstermHelpers.evalInput;
+
+    let result, error, errorMessage;
+    if (evalResult) {
+      if ("return" in evalResult) {
+        result = evalResult.return;
+      }
+      else if ("yield" in evalResult) {
+        result = evalResult.yield;
+      }
+
+      if ("throw" in evalResult) {
+        error = evalResult.throw;
+        let errorToString = this._dbgWindow
+                            .evalInGlobalWithBindings("ex + ''", {ex: error});
+        if (errorToString && typeof errorToString.return == "string") {
+          errorMessage = errorToString.return;
+        }
+      }
     }
-    catch (ex) {
-      error = ex;
-    }
-
-    let helperResult = this.helperResult;
-    delete this.helperResult;
-    delete this.evalInput;
 
     return {
       from: this.actorID,
       input: input,
       result: this.createValueGrip(result),
       timestamp: timestamp,
-      error: error,
-      errorMessage: error ? String(error) : null,
+      exception: this.createValueGrip(error),
+      exceptionMessage: errorMessage,
       helperResult: helperResult,
     };
   },
 
   /**
    * The Autocomplete request handler.
    *
    * @param object aRequest
    *        The request message - what input to autocomplete.
    * @return object
    *         The response message - matched properties.
    */
   onAutocomplete: function WCA_onAutocomplete(aRequest)
   {
+    // TODO: file a bug - follow up: use the debugger API for autocomplete in
+    // the Web Console, and provide suggestions for objects in the selected
+    // debugger stack frame.
     let result = JSPropertyProvider(this.window, aRequest.text) || {};
     return {
       from: this.actorID,
       matches: result.matches || [],
       matchProp: result.matchProp,
     };
   },
 
@@ -524,75 +577,190 @@ WebConsoleActor.prototype =
     return { updated: Object.keys(aRequest.preferences) };
   },
 
   //////////////////
   // End of request handlers.
   //////////////////
 
   /**
-   * Create the JavaScript sandbox where user input is evaluated.
+   * Create the Debugger.Object for the current window.
    * @private
    */
-  _createSandbox: function WCA__createSandbox()
+  _createGlobal: function WCA__createGlobal()
   {
-    this._sandboxWindowId = WebConsoleUtils.getInnerWindowId(this.window);
-    this.sandbox = new Cu.Sandbox(this.window, {
-      sandboxPrototype: this.window,
-      wantXrays: false,
-    });
+    let windowId = WebConsoleUtils.getInnerWindowId(this.window);
+    if (this._globalWindowId == windowId) {
+      return;
+    }
 
-    this.sandbox.console = this.window.console;
+    this._globalWindowId = windowId;
 
-    JSTermHelpers(this);
+    this._dbgWindow = this.dbg.addDebuggee(this.window);
+    this.dbg.removeDebuggee(this.window);
+
+    // Update the JSTerm helpers.
+    this._jstermHelpers = this._getJSTermHelpers(this._dbgWindow);
   },
 
   /**
-   * Evaluates a string in the sandbox.
+   * Create an object with the API we expose to the JSTermHelpers constructor.
+   * This object inherits properties and methods from the Web Console actor.
+   *
+   * @private
+   * @param object aDebuggerObject
+   *        A Debugger.Object that wraps a content global. This is used for the
+   *        JSTerm helpers.
+   * @return object
+   */
+  _getJSTermHelpers: function WCA__getJSTermHelpers(aDebuggerObject)
+  {
+    let helpers = Object.create(this);
+    helpers.sandbox = Object.create(null);
+    helpers._dbgWindow = aDebuggerObject;
+    JSTermHelpers(helpers);
+
+    // Make sure the helpers can be used during eval.
+    for (let name in helpers.sandbox) {
+      let desc = Object.getOwnPropertyDescriptor(helpers.sandbox, name);
+      if (desc.get || desc.set) {
+        continue;
+      }
+      helpers.sandbox[name] = helpers.makeDebuggeeValue(desc.value);
+    }
+    return helpers;
+  },
+
+  /**
+   * Evaluates a string using the debugger API.
    *
    * @param string aString
-   *        String to evaluate in the sandbox.
-   * @return mixed
+   *        String to evaluate.
+   * @param object [aOptions]
+   *        Options for evaluation:
+   *        - bindObjectActor: the ObjectActor ID to use for evaluation.
+   *          evalWithBindings() will be called with one additional binding:
+   *          |_self| which will point to the Debugger.Object of the given
+   *          ObjectActor.
+   *        - frameActor: the FrameActor ID to use for evaluation. The given
+   *        debugger frame is used for evaluation, instead of the global window.
+   * @return object
    *         The result of the evaluation.
    */
-  evalInSandbox: function WCA_evalInSandbox(aString)
+  evalWithDebugger: function WCA_evalWithDebugger(aString, aOptions = {})
   {
-    // If the user changed to a different location, we need to update the
-    // sandbox.
-    if (this._sandboxWindowId !== WebConsoleUtils.getInnerWindowId(this.window)) {
-      this._createSandbox();
-    }
+    this._createGlobal();
 
     // The help function needs to be easy to guess, so we make the () optional
     if (aString.trim() == "help" || aString.trim() == "?") {
       aString = "help()";
     }
 
-    let window = WebConsoleUtils.unwrap(this.sandbox.window);
-    let $ = null, $$ = null;
+    // To allow the variables view to update properties from the web console we
+    // provide the "bindObjectActor" mechanism: the Web Console tells the
+    // ObjectActor ID for which it desires to evaluate an expression. The
+    // Debugger.Object pointed at by the actor ID is bound such that it is
+    // available during expression evaluation (evalInGlobalWithBindings()).
+    //
+    // Example:
+    //   _self['foobar'] = 'test'
+    // where |_self| refers to the desired object.
 
-    // We prefer to execute the page-provided implementations for the $() and
-    // $$() functions.
-    if (typeof window.$ == "function") {
-      $ = this.sandbox.$;
-      delete this.sandbox.$;
-    }
-    if (typeof window.$$ == "function") {
-      $$ = this.sandbox.$$;
-      delete this.sandbox.$$;
+    let result, bindSelf = null, bindings = null;
+    if (aOptions.bindObjectActor) {
+      let objActor = this.getActorByID(aOptions.bindObjectActor);
+      if (objActor) {
+        bindSelf = objActor.obj;
+      }
     }
 
-    let result = Cu.evalInSandbox(aString, this.sandbox, "1.8",
-                                  "Web Console", 1);
+    // The |frameActor| property allow the Web Console to provide the frame
+    // actor ID, such that the expression can evaluate in the user-selected
+    // stack frame.
+    //
+    // For the above to work we need the debugger and the web console to share
+    // a connection, otherwise the Web Console actor will not find the frame
+    // actor.
+    //
+    // The Debugger.Frame comes from the jsdebugger's Debugger instance, which
+    // is different from the Web Console's Debugger instance. This means that
+    // for evaluation to work, we need to reinstance the jsterm helpers - they
+    // need to be Debugger.Objects coming from the jsdebugger's Debugger
+    // instance.
 
-    if ($) {
-      this.sandbox.$ = $;
+    let frameActor = null;
+    if (aOptions.frameActor) {
+      frameActor = this.conn.getActor(aOptions.frameActor);
+      if (!frameActor) {
+        Cu.reportError("Web Console Actor: the frame actor was not found: " +
+                       aOptions.frameActor);
+      }
     }
-    if ($$) {
-      this.sandbox.$$ = $$;
+
+    let evalInGlobal = function() {
+      bindings = this._jstermHelpers.sandbox;
+      if (bindSelf) {
+        bindings._self = bindSelf;
+      }
+      //try {
+        result = this._dbgWindow.evalInGlobalWithBindings(aString, bindings);
+      /*}
+      catch (ex) {
+        // The above can fail if bindSelf refers to a Debugger.Object coming
+        // from the jsdebugger's Debugger instance. This can happen if you
+        // evaluate on a stackframe while the debugger is paused:
+        // the result is a D.O belonging to the jsdebugger. After you stop
+        // debugging the Web Console does eval in the window global using its
+        // own Debugger instance.
+        if (bindings._self) {
+          delete bindings._self;
+        }
+
+        // FIXME: need a way to get the global for bindSelf.
+        bindings = this._getJSTermHelpers(bindSelf).sandbox;
+        if (bindSelf) {
+          bindings._self = bindSelf;
+        }
+        result = bindSelf.evalInGlobalWithBindings(aString, bindings);
+      }*/
+    }.bind(this);
+
+    if (frameActor) {
+      let frame = frameActor.frame;
+      let dbgObj = frame.this;
+      if (dbgObj && dbgObj.makeDebuggeeValue) {
+        bindings = this._getJSTermHelpers(dbgObj).sandbox;
+        if (bindSelf) {
+          bindings._self = bindSelf;
+        }
+      }
+
+      if (bindings) {
+        try {
+          result = frame.evalWithBindings(aString, bindings);
+        }
+        catch (ex) {
+          // The above can fail if you try to update a property in some
+          // Debugger.Object created by the Web Console, during debugging.
+          // The error is "Debugger.Object belongs to a different Debugger" and
+          // it happens for reasons explained above.
+          // Here we just fall back to the default behavior.
+          evalInGlobal();
+        }
+      }
+      else {
+        result = frame.eval(aString);
+      }
+    }
+    else {
+      evalInGlobal();
+    }
+
+    if (bindings._self) {
+      delete bindings._self;
     }
 
     return result;
   },
 
   //////////////////
   // Event handlers for various listeners.
   //////////////////
@@ -721,28 +889,20 @@ WebConsoleActor.prototype =
   prepareConsoleMessageForRemote:
   function WCA_prepareConsoleMessageForRemote(aMessage)
   {
     let result = WebConsoleUtils.cloneObject(aMessage);
     delete result.wrappedJSObject;
 
     result.arguments = Array.map(aMessage.arguments || [],
       function(aObj) {
-        return this.createValueGrip(aObj);
+        let dbgObj = this.makeDebuggeeValue(aObj);
+        return this.createValueGrip(dbgObj);
       }, this);
 
-    if (result.level == "dir") {
-      result.objectProperties = [];
-      let first = result.arguments[0];
-      if (typeof first == "object" && first && first.inspectable) {
-        let actor = this.getActorByID(first.actor);
-        result.objectProperties = actor.onInspectProperties().properties;
-      }
-    }
-
     return result;
   },
 
   /**
    * Find the XUL window that owns the content window.
    *
    * @return Window
    *         The XUL window that owns the content window.
@@ -762,89 +922,16 @@ WebConsoleActor.prototype.requestTypes =
   getCachedMessages: WebConsoleActor.prototype.onGetCachedMessages,
   evaluateJS: WebConsoleActor.prototype.onEvaluateJS,
   autocomplete: WebConsoleActor.prototype.onAutocomplete,
   clearMessagesCache: WebConsoleActor.prototype.onClearMessagesCache,
   setPreferences: WebConsoleActor.prototype.onSetPreferences,
 };
 
 /**
- * Creates an actor for the specified object.
- *
- * @constructor
- * @param object aObj
- *        The object you want.
- * @param object aWebConsoleActor
- *        The parent WebConsoleActor instance for this object.
- */
-function WebConsoleObjectActor(aObj, aWebConsoleActor)
-{
-  this.obj = aObj;
-  this.parent = aWebConsoleActor;
-}
-
-WebConsoleObjectActor.prototype =
-{
-  actorPrefix: "consoleObj",
-
-  /**
-   * Returns a grip for this actor for returning in a protocol message.
-   */
-  grip: function WCOA_grip()
-  {
-    let grip = WebConsoleUtils.getObjectGrip(this.obj);
-    grip.actor = this.actorID;
-    grip.displayString = this.parent.createStringGrip(grip.displayString);
-    return grip;
-  },
-
-  /**
-   * Releases this actor from the pool.
-   */
-  release: function WCOA_release()
-  {
-    this.parent.releaseActor(this);
-    this.parent = this.obj = null;
-  },
-
-  /**
-   * Handle a protocol request to inspect the properties of the object.
-   *
-   * @return object
-   *         Message to send to the client. This holds the 'properties' property
-   *         - an array with a descriptor for each property in the object.
-   */
-  onInspectProperties: function WCOA_onInspectProperties()
-  {
-    let createObjectActor = this.parent.createObjectActor.bind(this.parent);
-    let props = WebConsoleUtils.inspectObject(this.obj, createObjectActor);
-    return {
-      from: this.actorID,
-      properties: props,
-    };
-  },
-
-  /**
-   * Handle a protocol request to release a grip.
-   */
-  onRelease: function WCOA_onRelease()
-  {
-    this.release();
-    return {};
-  },
-};
-
-WebConsoleObjectActor.prototype.requestTypes =
-{
-  "inspectProperties": WebConsoleObjectActor.prototype.onInspectProperties,
-  "release": WebConsoleObjectActor.prototype.onRelease,
-};
-
-
-/**
  * Creates an actor for a network event.
  *
  * @constructor
  * @param object aNetworkEvent
  *        The network event you want to use the actor for.
  * @param object aWebConsoleActor
  *        The parent WebConsoleActor instance for this object.
  */
@@ -1078,17 +1165,17 @@ NetworkEventActor.prototype =
    * Add network request POST data.
    *
    * @param object aPostData
    *        The request POST data.
    */
   addRequestPostData: function NEA_addRequestPostData(aPostData)
   {
     this._request.postData = aPostData;
-    aPostData.text = this.parent.createStringGrip(aPostData.text);
+    aPostData.text = this._createStringGrip(aPostData.text);
     if (typeof aPostData.text == "object") {
       this._longStringActors.add(aPostData.text);
     }
 
     let packet = {
       from: this.actorID,
       type: "networkEventUpdate",
       updateType: "requestPostData",
@@ -1173,17 +1260,17 @@ NetworkEventActor.prototype =
    *        The response content.
    * @param boolean aDiscardedResponseBody
    *        Tells if the response content was recorded or not.
    */
   addResponseContent:
   function NEA_addResponseContent(aContent, aDiscardedResponseBody)
   {
     this._response.content = aContent;
-    aContent.text = this.parent.createStringGrip(aContent.text);
+    aContent.text = this._createStringGrip(aContent.text);
     if (typeof aContent.text == "object") {
       this._longStringActors.add(aContent.text);
     }
 
     let packet = {
       from: this.actorID,
       type: "networkEventUpdate",
       updateType: "responseContent",
@@ -1223,22 +1310,40 @@ NetworkEventActor.prototype =
    * LongStringActor for the header values, when needed.
    *
    * @private
    * @param array aHeaders
    */
   _prepareHeaders: function NEA__prepareHeaders(aHeaders)
   {
     for (let header of aHeaders) {
-      header.value = this.parent.createStringGrip(header.value);
+      header.value = this._createStringGrip(header.value);
       if (typeof header.value == "object") {
         this._longStringActors.add(header.value);
       }
     }
   },
+
+  /**
+   * Create a long string grip if needed for the given string.
+   *
+   * @private
+   * @param string aString
+   *        The string you want to create a long string grip for.
+   * @return string|object
+   *         A string is returned if |aString| is not a long string.
+   *         A LongStringActor grip is returned if |aString| is a long string.
+   */
+  _createStringGrip: function NEA__createStringGrip(aString)
+  {
+    if (this.parent._stringIsLong(aString)) {
+      return this.parent.longStringGrip(aString, this.parent._actorPool);
+    }
+    return aString;
+  },
 };
 
 NetworkEventActor.prototype.requestTypes =
 {
   "release": NetworkEventActor.prototype.onRelease,
   "getRequestHeaders": NetworkEventActor.prototype.onGetRequestHeaders,
   "getRequestCookies": NetworkEventActor.prototype.onGetRequestCookies,
   "getRequestPostData": NetworkEventActor.prototype.onGetRequestPostData,
