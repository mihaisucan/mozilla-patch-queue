# HG changeset patch
# Parent 4a1b771880d830a75f83593b31493c0874166b13
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1358353926 -7200

Bug 783499 - Web Console should use the debugger API

diff --git a/toolkit/devtools/debugger/dbg-client.jsm b/toolkit/devtools/debugger/dbg-client.jsm
--- a/toolkit/devtools/debugger/dbg-client.jsm
+++ b/toolkit/devtools/debugger/dbg-client.jsm
@@ -8,17 +8,18 @@
 const Ci = Components.interfaces;
 const Cc = Components.classes;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 this.EXPORTED_SYMBOLS = ["DebuggerTransport",
                          "DebuggerClient",
                          "debuggerSocketConnect",
-                         "LongStringClient"];
+                         "LongStringClient",
+                         "GripClient"];
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/NetUtil.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "socketTransportService",
                                    "@mozilla.org/network/socket-transport-service;1",
                                    "nsISocketTransportService");
diff --git a/toolkit/devtools/debugger/server/dbg-script-actors.js b/toolkit/devtools/debugger/server/dbg-script-actors.js
--- a/toolkit/devtools/debugger/server/dbg-script-actors.js
+++ b/toolkit/devtools/debugger/server/dbg-script-actors.js
@@ -954,17 +954,17 @@ ThreadActor.prototype = {
     }
 
     if (aPool.objectActors.has(aValue)) {
       return aPool.objectActors.get(aValue).grip();
     } else if (this.threadLifetimePool.objectActors.has(aValue)) {
       return this.threadLifetimePool.objectActors.get(aValue).grip();
     }
 
-    let actor = new ObjectActor(aValue, this);
+    let actor = new PauseScopedObjectActor(aValue, this);
     aPool.addActor(actor);
     aPool.objectActors.set(aValue, actor);
     return actor.grip();
   },
 
   /**
    * Create a grip for the given debuggee object with a pause lifetime.
    *
@@ -1488,20 +1488,17 @@ SourceActor.prototype.requestTypes = {
  *        The parent thread actor for this object.
  */
 function ObjectActor(aObj, aThreadActor)
 {
   this.obj = aObj;
   this.threadActor = aThreadActor;
 }
 
-ObjectActor.prototype = Object.create(PauseScopedActor.prototype);
-
-update(ObjectActor.prototype, {
-  constructor: ObjectActor,
+ObjectActor.prototype = {
   actorPrefix: "obj",
 
   /**
    * Returns a grip for this actor for returning in a protocol message.
    */
   grip: function OA_grip() {
     let g = { "type": "object",
               "class": this.obj.class,
@@ -1525,87 +1522,87 @@ update(ObjectActor.prototype, {
 
     return g;
   },
 
   /**
    * Releases this actor from the pool.
    */
   release: function OA_release() {
-    this.registeredPool.objectActors.delete(this.obj);
+    if (this.registeredPool.objectActors) {
+      this.registeredPool.objectActors.delete(this.obj);
+    }
     this.registeredPool.removeActor(this);
   },
 
   /**
    * Handle a protocol request to provide the names of the properties defined on
    * the object and not its prototype.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onOwnPropertyNames:
-  PauseScopedActor.withPaused(function OA_onOwnPropertyNames(aRequest) {
+  onOwnPropertyNames: function OA_onOwnPropertyNames(aRequest) {
     return { from: this.actorID,
              ownPropertyNames: this.obj.getOwnPropertyNames() };
-  }),
+  },
 
   /**
    * Handle a protocol request to provide the prototype and own properties of
    * the object.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onPrototypeAndProperties:
-  PauseScopedActor.withPaused(function OA_onPrototypeAndProperties(aRequest) {
+  onPrototypeAndProperties: function OA_onPrototypeAndProperties(aRequest) {
     let ownProperties = {};
     for each (let name in this.obj.getOwnPropertyNames()) {
       try {
         let desc = this.obj.getOwnPropertyDescriptor(name);
         ownProperties[name] = this._propertyDescriptor(desc);
       } catch (e if e.name == "NS_ERROR_XPC_BAD_OP_ON_WN_PROTO") {
         // Calling getOwnPropertyDescriptor on wrapped native prototypes is not
         // allowed.
         dumpn("Error while getting the property descriptor for " + name +
               ": " + e.name);
       }
     }
     return { from: this.actorID,
              prototype: this.threadActor.createValueGrip(this.obj.proto),
              ownProperties: ownProperties };
-  }),
+  },
 
   /**
    * Handle a protocol request to provide the prototype of the object.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onPrototype: PauseScopedActor.withPaused(function OA_onPrototype(aRequest) {
+  onPrototype: function OA_onPrototype(aRequest) {
     return { from: this.actorID,
              prototype: this.threadActor.createValueGrip(this.obj.proto) };
-  }),
+  },
 
   /**
    * Handle a protocol request to provide the property descriptor of the
    * object's specified property.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onProperty: PauseScopedActor.withPaused(function OA_onProperty(aRequest) {
+  onProperty: function OA_onProperty(aRequest) {
     if (!aRequest.name) {
       return { error: "missingParameter",
                message: "no property name was specified" };
     }
 
     let desc = this.obj.getOwnPropertyDescriptor(aRequest.name);
     return { from: this.actorID,
              descriptor: this._propertyDescriptor(desc) };
-  }),
+  },
 
   /**
    * A helper method that creates a property descriptor for the provided object,
    * properly formatted for sending in a protocol response.
    *
    * @param aObject object
    *        The object that the descriptor is generated for.
    */
@@ -1624,26 +1621,94 @@ update(ObjectActor.prototype, {
   },
 
   /**
    * Handle a protocol request to provide the source code of a function.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onDecompile: PauseScopedActor.withPaused(function OA_onDecompile(aRequest) {
+  onDecompile: function OA_onDecompile(aRequest) {
     if (this.obj.class !== "Function") {
       return { error: "objectNotFunction",
                message: "decompile request is only valid for object grips " +
                         "with a 'Function' class." };
     }
 
     return { from: this.actorID,
              decompiledCode: this.obj.decompile(!!aRequest.pretty) };
-  }),
+  },
+
+  /**
+   * Handle a protocol request to provide the parameters of a function.
+   *
+   * @param aRequest object
+   *        The protocol request object.
+   */
+  onParameterNames: function OA_onParameterNames(aRequest) {
+    if (this.obj.class !== "Function") {
+      return { error: "objectNotFunction",
+               message: "'parameterNames' request is only valid for object " +
+                        "grips with a 'Function' class." };
+    }
+
+    return { parameterNames: this.obj.parameterNames };
+  },
+
+  /**
+   * Handle a protocol request to release a thread-lifetime grip.
+   *
+   * @param aRequest object
+   *        The protocol request object.
+   */
+  onRelease: function OA_onRelease(aRequest) {
+    this.release();
+    return {};
+  },
+};
+
+ObjectActor.prototype.requestTypes = {
+  "parameterNames": ObjectActor.prototype.onParameterNames,
+  "prototypeAndProperties": ObjectActor.prototype.onPrototypeAndProperties,
+  "prototype": ObjectActor.prototype.onPrototype,
+  "property": ObjectActor.prototype.onProperty,
+  "ownPropertyNames": ObjectActor.prototype.onOwnPropertyNames,
+  "decompile": ObjectActor.prototype.onDecompile,
+  "release": ObjectActor.prototype.onRelease,
+};
+
+
+/**
+ * Creates a pause-scoped  actor for the specified object.
+ * @see ObjectActor
+ */
+function PauseScopedObjectActor()
+{
+  ObjectActor.apply(this, arguments);
+}
+
+PauseScopedObjectActor.prototype = Object.create(PauseScopedActor.prototype);
+
+update(PauseScopedObjectActor.prototype, ObjectActor.prototype);
+
+update(PauseScopedObjectActor.prototype, {
+  constructor: PauseScopedObjectActor,
+
+  onOwnPropertyNames:
+    PauseScopedActor.withPaused(ObjectActor.prototype.onOwnPropertyNames),
+
+  onPrototypeAndProperties:
+    PauseScopedActor.withPaused(ObjectActor.prototype.onPrototypeAndProperties),
+
+  onPrototype: PauseScopedActor.withPaused(ObjectActor.prototype.onPrototype),
+  onProperty: PauseScopedActor.withPaused(ObjectActor.prototype.onProperty),
+  onDecompile: PauseScopedActor.withPaused(ObjectActor.prototype.onDecompile),
+
+  onParameterNames:
+    PauseScopedActor.withPaused(ObjectActor.prototype.onParameterNames),
 
   /**
    * Handle a protocol request to provide the lexical scope of a function.
    *
    * @param aRequest object
    *        The protocol request object.
    */
   onScope: PauseScopedActor.withPaused(function OA_onScope(aRequest) {
@@ -1659,32 +1724,16 @@ update(ObjectActor.prototype, {
       return { error: "notDebuggee",
                message: "cannot access the environment of this function." };
     }
 
     return { from: this.actorID, scope: envActor.form() };
   }),
 
   /**
-   * Handle a protocol request to provide the parameters of a function.
-   *
-   * @param aRequest object
-   *        The protocol request object.
-   */
-  onParameterNames: PauseScopedActor.withPaused(function OA_onParameterNames(aRequest) {
-    if (this.obj.class !== "Function") {
-      return { error: "objectNotFunction",
-               message: "'parameterNames' request is only valid for object " +
-                        "grips with a 'Function' class." };
-    }
-
-    return { parameterNames: this.obj.parameterNames };
-  }),
-
-  /**
    * Handle a protocol request to promote a pause-lifetime grip to a
    * thread-lifetime grip.
    *
    * @param aRequest object
    *        The protocol request object.
    */
   onThreadGrip: PauseScopedActor.withPaused(function OA_onThreadGrip(aRequest) {
     this.threadActor.threadObjectGrip(this);
@@ -1703,27 +1752,20 @@ update(ObjectActor.prototype, {
                message: "Only thread-lifetime actors can be released." };
     }
 
     this.release();
     return {};
   }),
 });
 
-ObjectActor.prototype.requestTypes = {
-  "parameterNames": ObjectActor.prototype.onParameterNames,
-  "prototypeAndProperties": ObjectActor.prototype.onPrototypeAndProperties,
-  "prototype": ObjectActor.prototype.onPrototype,
-  "property": ObjectActor.prototype.onProperty,
-  "ownPropertyNames": ObjectActor.prototype.onOwnPropertyNames,
-  "scope": ObjectActor.prototype.onScope,
-  "decompile": ObjectActor.prototype.onDecompile,
-  "threadGrip": ObjectActor.prototype.onThreadGrip,
-  "release": ObjectActor.prototype.onRelease,
-};
+update(PauseScopedObjectActor.prototype.requestTypes, {
+  "scope": PauseScopedObjectActor.prototype.onScope,
+  "threadGrip": PauseScopedObjectActor.prototype.onThreadGrip,
+});
 
 
 /**
  * Creates an actor for the specied "very long" string. "Very long" is specified
  * at the server's discretion.
  *
  * @param aString String
  *        The string.
diff --git a/toolkit/devtools/webconsole/WebConsoleClient.jsm b/toolkit/devtools/webconsole/WebConsoleClient.jsm
--- a/toolkit/devtools/webconsole/WebConsoleClient.jsm
+++ b/toolkit/devtools/webconsole/WebConsoleClient.jsm
@@ -77,22 +77,23 @@ WebConsoleClient.prototype = {
   /**
    * Evaluate a JavaScript expression.
    *
    * @param string aString
    *        The code you want to evaluate.
    * @param function aOnResponse
    *        The function invoked when the response is received.
    */
-  evaluateJS: function WCC_evaluateJS(aString, aOnResponse)
+  evaluateJS: function WCC_evaluateJS(aString, aContext, aOnResponse)
   {
     let packet = {
       to: this._actor,
       type: "evaluateJS",
       text: aString,
+      context: aContext,
     };
     this._client.request(packet, aOnResponse);
   },
 
   /**
    * Autocomplete a JavaScript expression.
    *
    * @param string aString
diff --git a/toolkit/devtools/webconsole/WebConsoleUtils.jsm b/toolkit/devtools/webconsole/WebConsoleUtils.jsm
--- a/toolkit/devtools/webconsole/WebConsoleUtils.jsm
+++ b/toolkit/devtools/webconsole/WebConsoleUtils.jsm
@@ -23,22 +23,26 @@ XPCOMUtils.defineLazyModuleGetter(this, 
 
 XPCOMUtils.defineLazyModuleGetter(this, "NetworkHelper",
                                   "resource://gre/modules/devtools/NetworkHelper.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "gActivityDistributor",
                                    "@mozilla.org/network/http-activity-distributor;1",
                                    "nsIHttpActivityDistributor");
 
+// FIXME: toolkit imports from browser.
 XPCOMUtils.defineLazyModuleGetter(this, "gDevTools",
                                   "resource:///modules/devtools/gDevTools.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "TargetFactory",
                                   "resource:///modules/devtools/Target.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "VariablesView",
+                                  "resource:///modules/devtools/VariablesView.jsm");
+
 this.EXPORTED_SYMBOLS = ["WebConsoleUtils", "JSPropertyProvider", "JSTermHelpers",
                          "PageErrorListener", "ConsoleAPIListener",
                          "NetworkResponseListener", "NetworkMonitor",
                          "ConsoleProgressListener"];
 
 // Match the function name from the result of toString() or toSource().
 //
 // Examples:
@@ -781,17 +785,17 @@ this.WebConsoleUtils = {
    * Get the object class name. For example, the |window| object has the Window
    * class name (based on [object Window]).
    *
    * @param object aObject
    *        The object you want to get the class name for.
    * @return string
    *         The object class name.
    */
-  getObjectClassName: function WCF_getObjectClassName(aObject)
+  getObjectClassName: function WCU_getObjectClassName(aObject)
   {
     if (aObject === null) {
       return "null";
     }
     if (aObject === undefined) {
       return "undefined";
     }
 
@@ -1540,56 +1544,46 @@ this.JSTermHelpers = function JSTermHelp
    * @return array of nsIDOMNode
    */
   aOwner.sandbox.$x = function JSTH_$x(aXPath, aContext)
   {
     let nodes = [];
     let doc = aOwner.window.document;
     let aContext = aContext || doc;
 
-    try {
-      let results = doc.evaluate(aXPath, aContext, null,
-                                 Ci.nsIDOMXPathResult.ANY_TYPE, null);
-      let node;
-      while (node = results.iterateNext()) {
-        nodes.push(node);
-      }
-    }
-    catch (ex) {
-      aOwner.window.console.error(ex.message);
+    let results = doc.evaluate(aXPath, aContext, null,
+                               Ci.nsIDOMXPathResult.ANY_TYPE, null);
+    let node;
+    while (node = results.iterateNext()) {
+      nodes.push(node);
     }
 
     return nodes;
   };
 
   /**
    * Returns the currently selected object in the highlighter.
    *
    * TODO: this implementation crosses the client/server boundaries! This is not
    * usable within a remote browser. To implement this feature correctly we need
    * support for remote inspection capabilities within the Inspector as well.
    * See bug 787975.
    *
    * @return nsIDOMElement|null
    *         The DOM element currently selected in the highlighter.
    */
-  Object.defineProperty(aOwner.sandbox, "$0", {
+   Object.defineProperty(aOwner.sandbox, "$0", {
     get: function() {
-      try {
-        let window = aOwner.chromeWindow();
-        let target = TargetFactory.forTab(window.gBrowser.selectedTab);
-        let toolbox = gDevTools.getToolbox(target);
+      let window = aOwner.chromeWindow();
+      let target = TargetFactory.forTab(window.gBrowser.selectedTab);
+      let toolbox = gDevTools.getToolbox(target);
+      let panel = toolbox ? toolbox.getPanel("inspector") : null;
+      let node = panel ? panel.selection.node : null;
 
-        return toolbox == null ?
-            undefined :
-            toolbox.getPanel("inspector").selection.node;
-      }
-      catch (ex) {
-        aOwner.window.console.error(ex.message);
-      }
+      return node ? aOwner.makeDebuggeeValue(node) : null;
     },
     enumerable: true,
     configurable: false
   });
 
   /**
    * Clears the output of the JSTerm.
    */
@@ -1604,40 +1598,37 @@ this.JSTermHelpers = function JSTermHelp
    * Returns the result of Object.keys(aObject).
    *
    * @param object aObject
    *        Object to return the property names from.
    * @return array of strings
    */
   aOwner.sandbox.keys = function JSTH_keys(aObject)
   {
+    // FIXME: this return [object Proxy] for the array. ouch :(
     return Object.keys(WebConsoleUtils.unwrap(aObject));
   };
 
   /**
    * Returns the values of all properties on aObject.
    *
    * @param object aObject
    *        Object to display the values from.
    * @return array of string
    */
   aOwner.sandbox.values = function JSTH_values(aObject)
   {
     let arrValues = [];
     let obj = WebConsoleUtils.unwrap(aObject);
 
-    try {
-      for (let prop in obj) {
-        arrValues.push(obj[prop]);
-      }
-    }
-    catch (ex) {
-      aOwner.window.console.error(ex.message);
+    for (let prop in obj) {
+      arrValues.push(obj[prop]);
     }
 
+    // FIXME: this return [object Proxy] for the array. ouch :(
     return arrValues;
   };
 
   /**
    * Opens a help window in MDN.
    */
   aOwner.sandbox.help = function JSTH_help()
   {
@@ -1647,25 +1638,22 @@ this.JSTermHelpers = function JSTermHelp
   /**
    * Inspects the passed aObject. This is done by opening the PropertyPanel.
    *
    * @param object aObject
    *        Object to inspect.
    */
   aOwner.sandbox.inspect = function JSTH_inspect(aObject)
   {
-    let obj = WebConsoleUtils.unwrap(aObject);
-    if (!WebConsoleUtils.isObjectInspectable(obj)) {
-      return aObject;
-    }
-
+    let dbgObj = aOwner.makeDebuggeeValue(aObject);
+    let grip = aOwner.createValueGrip(dbgObj);
     aOwner.helperResult = {
       type: "inspectObject",
       input: aOwner.evalInput,
-      object: aOwner.createValueGrip(obj),
+      object: grip,
     };
   };
 
   /**
    * Prints aObject to the output.
    *
    * @param object aObject
    *        Object to print to the output.
@@ -1684,23 +1672,36 @@ this.JSTermHelpers = function JSTermHelp
 
     aOwner.helperResult = { rawOutput: true };
 
     if (typeof aObject == "function") {
       return aObject + "\n";
     }
 
     let output = [];
-    let getObjectGrip = WebConsoleUtils.getObjectGrip.bind(WebConsoleUtils);
+
     let obj = WebConsoleUtils.unwrap(aObject);
-    let props = WebConsoleUtils.inspectObject(obj, getObjectGrip);
-    props.forEach(function(aProp) {
-      output.push(aProp.name + ": " +
-                  WebConsoleUtils.getPropertyPanelValue(aProp));
-    });
+    for (let name in obj) {
+      let desc = WebConsoleUtils.getPropertyDescriptor(obj, name);
+      if (!desc) {
+        continue;
+      }
+      if (desc.get || desc.set) {
+        let getGrip = VariablesView.getGrip(desc.get);
+        let setGrip = VariablesView.getGrip(desc.set);
+        let getString = VariablesView.getString(getGrip);
+        let setString = VariablesView.getString(setGrip);
+        output.push(name + ":", "  get: " + getString, "  set: " + setString);
+      }
+      else {
+        let valueGrip = VariablesView.getGrip(obj[name]);
+        let valueString = VariablesView.getString(valueGrip);
+        output.push(name + ": " + valueString);
+      }
+    }
 
     return "  " + output.join("\n  ");
   };
 
   /**
    * Print a string to the output, as-is.
    *
    * @param string aString
diff --git a/toolkit/devtools/webconsole/dbg-webconsole-actors.js b/toolkit/devtools/webconsole/dbg-webconsole-actors.js
--- a/toolkit/devtools/webconsole/dbg-webconsole-actors.js
+++ b/toolkit/devtools/webconsole/dbg-webconsole-actors.js
@@ -66,21 +66,31 @@ function WebConsoleActor(aConnection, aP
     this._window = Services.wm.getMostRecentWindow("navigator:browser");
     this._isGlobalActor = true;
   }
 
   this._actorPool = new ActorPool(this.conn);
   this.conn.addActorPool(this._actorPool);
 
   this._prefs = {};
+
+  this.dbg = new Debugger();
+  this._createGlobal();
 }
 
 WebConsoleActor.prototype =
 {
   /**
+   * Debugger instance.
+   *
+   * @see jsdebugger.jsm
+   */
+  dbg: null,
+
+  /**
    * Tells if this Web Console actor is a global actor or not.
    * @private
    * @type boolean
    */
   _isGlobalActor: false,
 
   /**
    * Actor pool for all of the actors we send to the client.
@@ -180,76 +190,78 @@ WebConsoleActor.prototype =
       this.networkMonitor = null;
     }
     if (this.consoleProgressListener) {
       this.consoleProgressListener.destroy();
       this.consoleProgressListener = null;
     }
     this.conn.removeActorPool(this._actorPool);
     this._actorPool = null;
-    this.sandbox = null;
-    this._sandboxWindowId = 0;
+    // TODO: cleanup dbg stuff
     this.conn = this._window = null;
   },
 
+  _createValueGrip: ThreadActor.prototype.createValueGrip,
+
   /**
-   * Create a grip for the given value. If the value is an object,
-   * a WebConsoleObjectActor will be created.
+   * Create a grip for the given value.
    *
    * @param mixed aValue
    * @return object
    */
   createValueGrip: function WCA_createValueGrip(aValue)
   {
-    return WebConsoleUtils.createValueGrip(aValue,
-                                           this.createObjectActor.bind(this));
+    return this._createValueGrip(aValue, this._actorPool);
+  },
+
+  makeDebuggeeValue: function WCA_makeDebuggeeValue(aValue)
+  {
+    // TODO: is dbgWindow reusable for any object coming from any content
+    // window?
+    return this._dbgWindow.makeDebuggeeValue(aValue);
   },
 
   /**
    * Create a grip for the given object.
    *
    * @param object aObject
    *        The object you want.
+   * @param object aPool
+   *        An ActorPoo where the new LSA instance is added.
    * @param object
    *        The object grip.
    */
-  createObjectActor: function WCA_createObjectActor(aObject)
+  objectGrip: function WCA_objectGrip(aObject, aPool)
   {
-    if (typeof aObject == "string") {
-      return this.createStringGrip(aObject);
-    }
-
     // We need to unwrap the object, otherwise we cannot access the properties
     // and methods added by the content scripts.
-    let obj = WebConsoleUtils.unwrap(aObject);
-    let actor = new WebConsoleObjectActor(obj, this);
-    this._actorPool.addActor(actor);
+    let actor = new ObjectActor(aObject, this);
+    aPool.addActor(actor);
     return actor.grip();
   },
 
   /**
-   * Create a grip for the given string. If the given string is a long string,
-   * then a LongStringActor grip will be used.
+   * Create a grip for the given string.
    *
    * @param string aString
    *        The string you want to create the grip for.
-   * @return string|object
-   *         The same string, as is, or a LongStringActor object that wraps the
-   *         given string.
+   * @param object aPool
+   *        An ActorPoo where the new LSA instance is added.
+   * @return object
+   *         A LongStringActor object that wraps the given string.
    */
-  createStringGrip: function WCA_createStringGrip(aString)
+  longStringGrip: function WCA_longStringGrip(aString, aPool)
   {
-    if (aString.length >= DebuggerServer.LONG_STRING_LENGTH) {
-      let actor = new LongStringActor(aString, this);
-      this._actorPool.addActor(actor);
-      return actor.grip();
-    }
-    return aString;
+    let actor = new LongStringActor(aString, this);
+    aPool.addActor(actor);
+    return actor.grip();
   },
 
+  _stringIsLong: ThreadActor.prototype._stringIsLong,
+
   /**
    * Get an object actor by its ID.
    *
    * @param string aActorID
    * @return object
    */
   getActorByID: function WCA_getActorByID(aActorID)
   {
@@ -447,40 +459,54 @@ WebConsoleActor.prototype =
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
    * @return object
    *         The evaluation response packet.
    */
   onEvaluateJS: function WCA_onEvaluateJS(aRequest)
   {
     let input = aRequest.text;
-    let result, error = null;
-    let timestamp;
+    let timestamp = Date.now();
+    let context = aRequest.context;
 
-    this.helperResult = null;
-    this.evalInput = input;
-    try {
-      timestamp = Date.now();
-      result = this.evalInSandbox(input);
+    this._jstermHelpers.helperResult = null;
+    this._jstermHelpers.evalInput = input;
+    let evalResult = this.evalWithDebugger(input, { objectActorID: context });
+
+    let helperResult = this._jstermHelpers.helperResult;
+    delete this._jstermHelpers.helperResult;
+    delete this._jstermHelpers.evalInput;
+
+    let result, error, errorMessage;
+    if (evalResult) {
+      if ("return" in evalResult) {
+        result = evalResult.return;
+      }
+      else if ("yield" in evalResult) {
+        result = evalResult.yield;
+      }
+
+      if ("throw" in evalResult) {
+        error = evalResult.throw;
+        let errorToString = this._dbgWindow
+                            .evalInGlobalWithBindings("ex + ''", {ex: error});
+        if (errorToString && typeof errorToString.return == "string") {
+          errorMessage = errorToString.return;
+        }
+      }
     }
-    catch (ex) {
-      error = ex;
-    }
-
-    let helperResult = this.helperResult;
-    delete this.helperResult;
-    delete this.evalInput;
 
     return {
       from: this.actorID,
       input: input,
+      context: context,
       result: this.createValueGrip(result),
       timestamp: timestamp,
-      error: error,
-      errorMessage: error ? String(error) : null,
+      error: this.createValueGrip(error),
+      errorMessage: errorMessage,
       helperResult: helperResult,
     };
   },
 
   /**
    * The Autocomplete request handler.
    *
    * @param object aRequest
@@ -524,75 +550,87 @@ WebConsoleActor.prototype =
     return { updated: Object.keys(aRequest.preferences) };
   },
 
   //////////////////
   // End of request handlers.
   //////////////////
 
   /**
-   * Create the JavaScript sandbox where user input is evaluated.
+   * Create the Debugger.Object for the current window.
    * @private
    */
-  _createSandbox: function WCA__createSandbox()
+  _createGlobal: function WCA__createGlobal()
   {
-    this._sandboxWindowId = WebConsoleUtils.getInnerWindowId(this.window);
-    this.sandbox = new Cu.Sandbox(this.window, {
-      sandboxPrototype: this.window,
-      wantXrays: false,
-    });
+    let windowId = WebConsoleUtils.getInnerWindowId(this.window);
+    if (this._sandboxWindowId == windowId) {
+      return;
+    }
 
-    this.sandbox.console = this.window.console;
+    this._sandboxWindowId = windowId;
 
-    JSTermHelpers(this);
+    this._dbgWindow = this.dbg.addDebuggee(this.window);
+    this.dbg.removeDebuggee(this.window);
+
+    // Update the JSTerm helpers.
+    let helpers = Object.create(this);
+    helpers.sandbox = Object.create(null);
+    JSTermHelpers(helpers);
+
+    // Make sure the helpers can be used during eval.
+    for (let name in helpers.sandbox) {
+      let desc = Object.getOwnPropertyDescriptor(helpers.sandbox, name);
+      if (desc.get || desc.set) {
+        continue;
+      }
+      helpers.sandbox[name] = this.makeDebuggeeValue(desc.value);
+    }
+
+    this._jstermHelpers = helpers;
   },
 
   /**
-   * Evaluates a string in the sandbox.
+   * Evaluates a string using the debugger API.
    *
    * @param string aString
-   *        String to evaluate in the sandbox.
-   * @return mixed
+   *        String to evaluate.
+   * @param object [aOptions]
+   *        Options for evaluation:
+   *        - objectActorID: the ObjectActor ID to use for evaluation.
+   *          evalWithBindings() will be called with one additional binding:
+   *          |_self| which will point to the Debugger.Object of the given
+   *          ObjectActor.
+   * @return object
    *         The result of the evaluation.
    */
-  evalInSandbox: function WCA_evalInSandbox(aString)
+  // TODO: update comment.
+  evalWithDebugger: function WCA_evalWithDebugger(aString, aOptions = {})
   {
-    // If the user changed to a different location, we need to update the
-    // sandbox.
-    if (this._sandboxWindowId !== WebConsoleUtils.getInnerWindowId(this.window)) {
-      this._createSandbox();
-    }
+    this._createGlobal();
 
     // The help function needs to be easy to guess, so we make the () optional
     if (aString.trim() == "help" || aString.trim() == "?") {
       aString = "help()";
     }
 
-    let window = WebConsoleUtils.unwrap(this.sandbox.window);
-    let $ = null, $$ = null;
-
-    // We prefer to execute the page-provided implementations for the $() and
-    // $$() functions.
-    if (typeof window.$ == "function") {
-      $ = this.sandbox.$;
-      delete this.sandbox.$;
-    }
-    if (typeof window.$$ == "function") {
-      $$ = this.sandbox.$$;
-      delete this.sandbox.$$;
+    let result, bindings = this._jstermHelpers.sandbox;
+    if (aOptions.objectActorID) {
+      let objActor = this.getActorByID(aOptions.objectActorID);
+      if (objActor) {
+        bindings._self = objActor.obj;
+      }
     }
 
-    let result = Cu.evalInSandbox(aString, this.sandbox, "1.8",
-                                  "Web Console", 1);
-
-    if ($) {
-      this.sandbox.$ = $;
+    // TODO: eval in client-selected frame
+    let frame = this.dbg.getNewestFrame();
+    if (frame) {
+      result = frame.evalWithBindings(aString, bindings);
     }
-    if ($$) {
-      this.sandbox.$$ = $$;
+    else {
+      result = this._dbgWindow.evalInGlobalWithBindings(aString, bindings);
     }
 
     return result;
   },
 
   //////////////////
   // Event handlers for various listeners.
   //////////////////
@@ -721,28 +759,20 @@ WebConsoleActor.prototype =
   prepareConsoleMessageForRemote:
   function WCA_prepareConsoleMessageForRemote(aMessage)
   {
     let result = WebConsoleUtils.cloneObject(aMessage);
     delete result.wrappedJSObject;
 
     result.arguments = Array.map(aMessage.arguments || [],
       function(aObj) {
-        return this.createValueGrip(aObj);
+        let dbgObj = this.makeDebuggeeValue(aObj);
+        return this.createValueGrip(dbgObj);
       }, this);
 
-    if (result.level == "dir") {
-      result.objectProperties = [];
-      let first = result.arguments[0];
-      if (typeof first == "object" && first && first.inspectable) {
-        let actor = this.getActorByID(first.actor);
-        result.objectProperties = actor.onInspectProperties().properties;
-      }
-    }
-
     return result;
   },
 
   /**
    * Find the XUL window that owns the content window.
    *
    * @return Window
    *         The XUL window that owns the content window.
@@ -762,89 +792,16 @@ WebConsoleActor.prototype.requestTypes =
   getCachedMessages: WebConsoleActor.prototype.onGetCachedMessages,
   evaluateJS: WebConsoleActor.prototype.onEvaluateJS,
   autocomplete: WebConsoleActor.prototype.onAutocomplete,
   clearMessagesCache: WebConsoleActor.prototype.onClearMessagesCache,
   setPreferences: WebConsoleActor.prototype.onSetPreferences,
 };
 
 /**
- * Creates an actor for the specified object.
- *
- * @constructor
- * @param object aObj
- *        The object you want.
- * @param object aWebConsoleActor
- *        The parent WebConsoleActor instance for this object.
- */
-function WebConsoleObjectActor(aObj, aWebConsoleActor)
-{
-  this.obj = aObj;
-  this.parent = aWebConsoleActor;
-}
-
-WebConsoleObjectActor.prototype =
-{
-  actorPrefix: "consoleObj",
-
-  /**
-   * Returns a grip for this actor for returning in a protocol message.
-   */
-  grip: function WCOA_grip()
-  {
-    let grip = WebConsoleUtils.getObjectGrip(this.obj);
-    grip.actor = this.actorID;
-    grip.displayString = this.parent.createStringGrip(grip.displayString);
-    return grip;
-  },
-
-  /**
-   * Releases this actor from the pool.
-   */
-  release: function WCOA_release()
-  {
-    this.parent.releaseActor(this);
-    this.parent = this.obj = null;
-  },
-
-  /**
-   * Handle a protocol request to inspect the properties of the object.
-   *
-   * @return object
-   *         Message to send to the client. This holds the 'properties' property
-   *         - an array with a descriptor for each property in the object.
-   */
-  onInspectProperties: function WCOA_onInspectProperties()
-  {
-    let createObjectActor = this.parent.createObjectActor.bind(this.parent);
-    let props = WebConsoleUtils.inspectObject(this.obj, createObjectActor);
-    return {
-      from: this.actorID,
-      properties: props,
-    };
-  },
-
-  /**
-   * Handle a protocol request to release a grip.
-   */
-  onRelease: function WCOA_onRelease()
-  {
-    this.release();
-    return {};
-  },
-};
-
-WebConsoleObjectActor.prototype.requestTypes =
-{
-  "inspectProperties": WebConsoleObjectActor.prototype.onInspectProperties,
-  "release": WebConsoleObjectActor.prototype.onRelease,
-};
-
-
-/**
  * Creates an actor for a network event.
  *
  * @constructor
  * @param object aNetworkEvent
  *        The network event you want to use the actor for.
  * @param object aWebConsoleActor
  *        The parent WebConsoleActor instance for this object.
  */
