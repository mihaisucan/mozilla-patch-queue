# HG changeset patch
# Parent 14eb0cb2afa7157a69105f4239fe87420a4393b1
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1357836903 -7200

Bug 783499 - Web Console should use the debugger API

diff --git a/toolkit/devtools/debugger/dbg-client.jsm b/toolkit/devtools/debugger/dbg-client.jsm
--- a/toolkit/devtools/debugger/dbg-client.jsm
+++ b/toolkit/devtools/debugger/dbg-client.jsm
@@ -8,17 +8,18 @@
 const Ci = Components.interfaces;
 const Cc = Components.classes;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 this.EXPORTED_SYMBOLS = ["DebuggerTransport",
                          "DebuggerClient",
                          "debuggerSocketConnect",
-                         "LongStringClient"];
+                         "LongStringClient",
+                         "GripClient"];
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/NetUtil.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "socketTransportService",
                                    "@mozilla.org/network/socket-transport-service;1",
                                    "nsISocketTransportService");
diff --git a/toolkit/devtools/debugger/server/dbg-script-actors.js b/toolkit/devtools/debugger/server/dbg-script-actors.js
--- a/toolkit/devtools/debugger/server/dbg-script-actors.js
+++ b/toolkit/devtools/debugger/server/dbg-script-actors.js
@@ -954,17 +954,17 @@ ThreadActor.prototype = {
     }
 
     if (aPool.objectActors.has(aValue)) {
       return aPool.objectActors.get(aValue).grip();
     } else if (this.threadLifetimePool.objectActors.has(aValue)) {
       return this.threadLifetimePool.objectActors.get(aValue).grip();
     }
 
-    let actor = new ObjectActor(aValue, this);
+    let actor = new PauseScopedObjectActor(aValue, this);
     aPool.addActor(actor);
     aPool.objectActors.set(aValue, actor);
     return actor.grip();
   },
 
   /**
    * Create a grip for the given debuggee object with a pause lifetime.
    *
@@ -1492,20 +1492,17 @@ SourceActor.prototype.requestTypes = {
  *        The parent thread actor for this object.
  */
 function ObjectActor(aObj, aThreadActor)
 {
   this.obj = aObj;
   this.threadActor = aThreadActor;
 }
 
-ObjectActor.prototype = Object.create(PauseScopedActor.prototype);
-
-update(ObjectActor.prototype, {
-  constructor: ObjectActor,
+ObjectActor.prototype = {
   actorPrefix: "obj",
 
   /**
    * Returns a grip for this actor for returning in a protocol message.
    */
   grip: function OA_grip() {
     let g = { "type": "object",
               "class": this.obj.class,
@@ -1529,87 +1526,87 @@ update(ObjectActor.prototype, {
 
     return g;
   },
 
   /**
    * Releases this actor from the pool.
    */
   release: function OA_release() {
-    this.registeredPool.objectActors.delete(this.obj);
+    if (this.registeredPool.objectActors) {
+      this.registeredPool.objectActors.delete(this.obj);
+    }
     this.registeredPool.removeActor(this);
   },
 
   /**
    * Handle a protocol request to provide the names of the properties defined on
    * the object and not its prototype.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onOwnPropertyNames:
-  PauseScopedActor.withPaused(function OA_onOwnPropertyNames(aRequest) {
+  onOwnPropertyNames: function OA_onOwnPropertyNames(aRequest) {
     return { from: this.actorID,
              ownPropertyNames: this.obj.getOwnPropertyNames() };
-  }),
+  },
 
   /**
    * Handle a protocol request to provide the prototype and own properties of
    * the object.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onPrototypeAndProperties:
-  PauseScopedActor.withPaused(function OA_onPrototypeAndProperties(aRequest) {
+  onPrototypeAndProperties: function OA_onPrototypeAndProperties(aRequest) {
     let ownProperties = {};
     for each (let name in this.obj.getOwnPropertyNames()) {
       try {
         let desc = this.obj.getOwnPropertyDescriptor(name);
         ownProperties[name] = this._propertyDescriptor(desc);
       } catch (e if e.name == "NS_ERROR_XPC_BAD_OP_ON_WN_PROTO") {
         // Calling getOwnPropertyDescriptor on wrapped native prototypes is not
         // allowed.
         dumpn("Error while getting the property descriptor for " + name +
               ": " + e.name);
       }
     }
     return { from: this.actorID,
              prototype: this.threadActor.createValueGrip(this.obj.proto),
              ownProperties: ownProperties };
-  }),
+  },
 
   /**
    * Handle a protocol request to provide the prototype of the object.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onPrototype: PauseScopedActor.withPaused(function OA_onPrototype(aRequest) {
+  onPrototype: function OA_onPrototype(aRequest) {
     return { from: this.actorID,
              prototype: this.threadActor.createValueGrip(this.obj.proto) };
-  }),
+  },
 
   /**
    * Handle a protocol request to provide the property descriptor of the
    * object's specified property.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onProperty: PauseScopedActor.withPaused(function OA_onProperty(aRequest) {
+  onProperty: function OA_onProperty(aRequest) {
     if (!aRequest.name) {
       return { error: "missingParameter",
                message: "no property name was specified" };
     }
 
     let desc = this.obj.getOwnPropertyDescriptor(aRequest.name);
     return { from: this.actorID,
              descriptor: this._propertyDescriptor(desc) };
-  }),
+  },
 
   /**
    * A helper method that creates a property descriptor for the provided object,
    * properly formatted for sending in a protocol response.
    *
    * @param aObject object
    *        The object that the descriptor is generated for.
    */
@@ -1628,26 +1625,94 @@ update(ObjectActor.prototype, {
   },
 
   /**
    * Handle a protocol request to provide the source code of a function.
    *
    * @param aRequest object
    *        The protocol request object.
    */
-  onDecompile: PauseScopedActor.withPaused(function OA_onDecompile(aRequest) {
+  onDecompile: function OA_onDecompile(aRequest) {
     if (this.obj.class !== "Function") {
       return { error: "objectNotFunction",
                message: "decompile request is only valid for object grips " +
                         "with a 'Function' class." };
     }
 
     return { from: this.actorID,
              decompiledCode: this.obj.decompile(!!aRequest.pretty) };
-  }),
+  },
+
+  /**
+   * Handle a protocol request to provide the parameters of a function.
+   *
+   * @param aRequest object
+   *        The protocol request object.
+   */
+  onParameterNames: function OA_onParameterNames(aRequest) {
+    if (this.obj.class !== "Function") {
+      return { error: "objectNotFunction",
+               message: "'parameterNames' request is only valid for object " +
+                        "grips with a 'Function' class." };
+    }
+
+    return { parameterNames: this.obj.parameterNames };
+  },
+
+  /**
+   * Handle a protocol request to release a thread-lifetime grip.
+   *
+   * @param aRequest object
+   *        The protocol request object.
+   */
+  onRelease: function OA_onRelease(aRequest) {
+    this.release();
+    return {};
+  },
+};
+
+ObjectActor.prototype.requestTypes = {
+  "parameterNames": ObjectActor.prototype.onParameterNames,
+  "prototypeAndProperties": ObjectActor.prototype.onPrototypeAndProperties,
+  "prototype": ObjectActor.prototype.onPrototype,
+  "property": ObjectActor.prototype.onProperty,
+  "ownPropertyNames": ObjectActor.prototype.onOwnPropertyNames,
+  "decompile": ObjectActor.prototype.onDecompile,
+  "release": ObjectActor.prototype.onRelease,
+};
+
+
+/**
+ * Creates a pause-scoped  actor for the specified object.
+ * @see ObjectActor
+ */
+function PauseScopedObjectActor()
+{
+  ObjectActor.apply(this, arguments);
+}
+
+PauseScopedObjectActor.prototype = Object.create(PauseScopedActor.prototype);
+
+update(PauseScopedObjectActor.prototype, ObjectActor.prototype);
+
+update(PauseScopedObjectActor.prototype, {
+  constructor: PauseScopedObjectActor,
+
+  onOwnPropertyNames:
+    PauseScopedActor.withPaused(ObjectActor.prototype.onOwnPropertyNames),
+
+  onPrototypeAndProperties:
+    PauseScopedActor.withPaused(ObjectActor.prototype.onPrototypeAndProperties),
+
+  onPrototype: PauseScopedActor.withPaused(ObjectActor.prototype.onPrototype),
+  onProperty: PauseScopedActor.withPaused(ObjectActor.prototype.onProperty),
+  onDecompile: PauseScopedActor.withPaused(ObjectActor.prototype.onDecompile),
+
+  onParameterNames:
+    PauseScopedActor.withPaused(ObjectActor.prototype.onParameterNames),
 
   /**
    * Handle a protocol request to provide the lexical scope of a function.
    *
    * @param aRequest object
    *        The protocol request object.
    */
   onScope: PauseScopedActor.withPaused(function OA_onScope(aRequest) {
@@ -1668,32 +1733,16 @@ update(ObjectActor.prototype, {
     // We can't get to the frame that defined this function's environment,
     // neither here, nor during ObjectActor's construction. Luckily, we don't
     // use the 'scope' request in the debugger frontend.
     return { name: this.obj.name || null,
              scope: envActor.form(this.obj) };
   }),
 
   /**
-   * Handle a protocol request to provide the parameters of a function.
-   *
-   * @param aRequest object
-   *        The protocol request object.
-   */
-  onParameterNames: PauseScopedActor.withPaused(function OA_onParameterNames(aRequest) {
-    if (this.obj.class !== "Function") {
-      return { error: "objectNotFunction",
-               message: "'parameterNames' request is only valid for object " +
-                        "grips with a 'Function' class." };
-    }
-
-    return { parameterNames: this.obj.parameterNames };
-  }),
-
-  /**
    * Handle a protocol request to promote a pause-lifetime grip to a
    * thread-lifetime grip.
    *
    * @param aRequest object
    *        The protocol request object.
    */
   onThreadGrip: PauseScopedActor.withPaused(function OA_onThreadGrip(aRequest) {
     this.threadActor.threadObjectGrip(this);
@@ -1712,27 +1761,20 @@ update(ObjectActor.prototype, {
                message: "Only thread-lifetime actors can be released." };
     }
 
     this.release();
     return {};
   }),
 });
 
-ObjectActor.prototype.requestTypes = {
-  "parameterNames": ObjectActor.prototype.onParameterNames,
-  "prototypeAndProperties": ObjectActor.prototype.onPrototypeAndProperties,
-  "prototype": ObjectActor.prototype.onPrototype,
-  "property": ObjectActor.prototype.onProperty,
-  "ownPropertyNames": ObjectActor.prototype.onOwnPropertyNames,
-  "scope": ObjectActor.prototype.onScope,
-  "decompile": ObjectActor.prototype.onDecompile,
-  "threadGrip": ObjectActor.prototype.onThreadGrip,
-  "release": ObjectActor.prototype.onRelease,
-};
+update(PauseScopedObjectActor.prototype.requestTypes, {
+  "scope": PauseScopedObjectActor.prototype.onScope,
+  "threadGrip": PauseScopedObjectActor.prototype.onThreadGrip,
+});
 
 
 /**
  * Creates an actor for the specied "very long" string. "Very long" is specified
  * at the server's discretion.
  *
  * @param aString String
  *        The string.
diff --git a/toolkit/devtools/webconsole/WebConsoleClient.jsm b/toolkit/devtools/webconsole/WebConsoleClient.jsm
--- a/toolkit/devtools/webconsole/WebConsoleClient.jsm
+++ b/toolkit/devtools/webconsole/WebConsoleClient.jsm
@@ -77,22 +77,23 @@ WebConsoleClient.prototype = {
   /**
    * Evaluate a JavaScript expression.
    *
    * @param string aString
    *        The code you want to evaluate.
    * @param function aOnResponse
    *        The function invoked when the response is received.
    */
-  evaluateJS: function WCC_evaluateJS(aString, aOnResponse)
+  evaluateJS: function WCC_evaluateJS(aString, aContext, aOnResponse)
   {
     let packet = {
       to: this._actor,
       type: "evaluateJS",
       text: aString,
+      context: aContext,
     };
     this._client.request(packet, aOnResponse);
   },
 
   /**
    * Autocomplete a JavaScript expression.
    *
    * @param string aString
diff --git a/toolkit/devtools/webconsole/dbg-webconsole-actors.js b/toolkit/devtools/webconsole/dbg-webconsole-actors.js
--- a/toolkit/devtools/webconsole/dbg-webconsole-actors.js
+++ b/toolkit/devtools/webconsole/dbg-webconsole-actors.js
@@ -66,21 +66,31 @@ function WebConsoleActor(aConnection, aP
     this._window = Services.wm.getMostRecentWindow("navigator:browser");
     this._isGlobalActor = true;
   }
 
   this._actorPool = new ActorPool(this.conn);
   this.conn.addActorPool(this._actorPool);
 
   this._prefs = {};
+
+  this.dbg = new Debugger();
+  this._createGlobal();
 }
 
 WebConsoleActor.prototype =
 {
   /**
+   * Debugger instance.
+   *
+   * @see jsdebugger.jsm
+   */
+  dbg: null,
+
+  /**
    * Tells if this Web Console actor is a global actor or not.
    * @private
    * @type boolean
    */
   _isGlobalActor: false,
 
   /**
    * Actor pool for all of the actors we send to the client.
@@ -185,71 +195,74 @@ WebConsoleActor.prototype =
     }
     this.conn.removeActorPool(this._actorPool);
     this._actorPool = null;
     this.sandbox = null;
     this._sandboxWindowId = 0;
     this.conn = this._window = null;
   },
 
+  _createValueGrip: ThreadActor.prototype.createValueGrip,
+
   /**
-   * Create a grip for the given value. If the value is an object,
-   * a WebConsoleObjectActor will be created.
+   * Create a grip for the given value.
    *
    * @param mixed aValue
    * @return object
    */
   createValueGrip: function WCA_createValueGrip(aValue)
   {
-    return WebConsoleUtils.createValueGrip(aValue,
-                                           this.createObjectActor.bind(this));
+    return this._createValueGrip(aValue, this._actorPool);
+  },
+
+  makeDebuggeeValue: function WCA_makeDebuggeeValue(aValue)
+  {
+    // TODO: is dbgWindow reusable for any object coming from any content
+    // window?
+    return this._dbgWindow.makeDebuggeeValue(aValue);
   },
 
   /**
    * Create a grip for the given object.
    *
    * @param object aObject
    *        The object you want.
+   * @param object aPool
+   *        An ActorPoo where the new LSA instance is added.
    * @param object
    *        The object grip.
    */
-  createObjectActor: function WCA_createObjectActor(aObject)
+  objectGrip: function WCA_objectGrip(aObject, aPool)
   {
-    if (typeof aObject == "string") {
-      return this.createStringGrip(aObject);
-    }
-
     // We need to unwrap the object, otherwise we cannot access the properties
     // and methods added by the content scripts.
-    let obj = WebConsoleUtils.unwrap(aObject);
-    let actor = new WebConsoleObjectActor(obj, this);
-    this._actorPool.addActor(actor);
+    let actor = new ObjectActor(aObject, this);
+    aPool.addActor(actor);
     return actor.grip();
   },
 
   /**
-   * Create a grip for the given string. If the given string is a long string,
-   * then a LongStringActor grip will be used.
+   * Create a grip for the given string.
    *
    * @param string aString
    *        The string you want to create the grip for.
-   * @return string|object
-   *         The same string, as is, or a LongStringActor object that wraps the
-   *         given string.
+   * @param object aPool
+   *        An ActorPoo where the new LSA instance is added.
+   * @return object
+   *         A LongStringActor object that wraps the given string.
    */
-  createStringGrip: function WCA_createStringGrip(aString)
+  longStringGrip: function WCA_longStringGrip(aString, aPool)
   {
-    if (aString.length >= DebuggerServer.LONG_STRING_LENGTH) {
-      let actor = new LongStringActor(aString, this);
-      this._actorPool.addActor(actor);
-      return actor.grip();
-    }
-    return aString;
+    let actor = new LongStringActor(aString, this);
+    aPool.addActor(actor);
+    return actor.grip();
   },
 
+  _stringIsLong: ThreadActor.prototype._stringIsLong,
+
   /**
    * Get an object actor by its ID.
    *
    * @param string aActorID
    * @return object
    */
   getActorByID: function WCA_getActorByID(aActorID)
   {
@@ -447,40 +460,54 @@ WebConsoleActor.prototype =
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
    * @return object
    *         The evaluation response packet.
    */
   onEvaluateJS: function WCA_onEvaluateJS(aRequest)
   {
     let input = aRequest.text;
-    let result, error = null;
-    let timestamp;
+    let timestamp = Date.now();
+    let context = aRequest.context;
 
     this.helperResult = null;
     this.evalInput = input;
-    try {
-      timestamp = Date.now();
-      result = this.evalInSandbox(input);
-    }
-    catch (ex) {
-      error = ex;
-    }
+    let evalResult = this.evalWithDebugger(input, context);
 
     let helperResult = this.helperResult;
     delete this.helperResult;
     delete this.evalInput;
 
+    let result, error, errorMessage;
+    if (evalResult) {
+      if ("return" in evalResult) {
+        result = evalResult.return;
+      }
+      else if ("yield" in evalResult) {
+        result = evalResult.yield;
+      }
+
+      if ("throw" in evalResult) {
+        error = evalResult.throw;
+        let errorToString = this._dbgWindow
+                            .evalInGlobalWithBindings("ex + ''", {ex: error});
+        if (errorToString && typeof errorToString.return == "string") {
+          errorMessage = errorToString.return;
+        }
+      }
+    }
+
     return {
       from: this.actorID,
       input: input,
+      context: context,
       result: this.createValueGrip(result),
       timestamp: timestamp,
-      error: error,
-      errorMessage: error ? String(error) : null,
+      error: this.createValueGrip(error),
+      errorMessage: errorMessage,
       helperResult: helperResult,
     };
   },
 
   /**
    * The Autocomplete request handler.
    *
    * @param object aRequest
@@ -541,16 +568,55 @@ WebConsoleActor.prototype =
     });
 
     this.sandbox.console = this.window.console;
 
     JSTermHelpers(this);
   },
 
   /**
+   * Create the Debugger.Object for the current window.
+   * @private
+   */
+  _createGlobal: function WCA__createGlobal()
+  {
+    let windowId = WebConsoleUtils.getInnerWindowId(this.window);
+    if (this._sandboxWindowId == windowId) {
+      return;
+    }
+
+    this._sandboxWindowId = windowId;
+
+    this._dbgWindow = this.dbg.addDebuggee(this.window);
+    this.dbg.removeDebuggee(this.window);
+
+    /*
+    try {
+      let global = this.dbg.addDebuggee(this.window);
+      let f = this.dbg.getNewestFrame();
+      if (f) {
+        return f.evalWithBindings(expr, {});
+      }
+      else {
+        globalWrapper.evalInGlobalWithBindings(expr, bindings);
+      }
+    } finally {
+      dbg.removeDebuggee(global);
+    }
+
+    debugger.removeDebuggee(DOwindow);
+    // Now debugger has no debuggees. But the D.O's are still usable.
+
+    // makeDebuggeeValue returns a D.O referring to random_object.
+    var DOrandom = DOwindow.makeDebuggeeValue(random_object);
+    JSTermHelpers(this);
+    */
+  },
+
+  /**
    * Evaluates a string in the sandbox.
    *
    * @param string aString
    *        String to evaluate in the sandbox.
    * @return mixed
    *         The result of the evaluation.
    */
   evalInSandbox: function WCA_evalInSandbox(aString)
@@ -588,16 +654,54 @@ WebConsoleActor.prototype =
     }
     if ($$) {
       this.sandbox.$$ = $$;
     }
 
     return result;
   },
 
+  /**
+   * Evaluates a string using the debugger API.
+   *
+   * @param string aString
+   *        String to evaluate.
+   * @return object
+   *         The result of the evaluation.
+   */
+  evalWithDebugger: function WCA_evalWithDebugger(aString, aContext)
+  {
+    this._createGlobal();
+
+    // The help function needs to be easy to guess, so we make the () optional
+    if (aString.trim() == "help" || aString.trim() == "?") {
+      aString = "help()";
+    }
+
+    // TODO: add jsterm helpers.
+
+    let result, bindings = {};
+    if (aContext) {
+      let objActor = this.getActorByID(aContext);
+      if (objActor) {
+        bindings = { "_self": objActor.obj };
+      }
+    }
+
+    let frame = this.dbg.getNewestFrame();
+    if (frame) {
+      result = frame.evalWithBindings(aString, bindings);
+    }
+    else {
+      result = this._dbgWindow.evalInGlobalWithBindings(aString, bindings);
+    }
+
+    return result;
+  },
+
   //////////////////
   // Event handlers for various listeners.
   //////////////////
 
   /**
    * Handler for page errors received from the PageErrorListener. This method
    * sends the nsIScriptError to the remote Web Console client.
    *
@@ -735,27 +839,19 @@ WebConsoleActor.prototype =
       case "groupCollapsed":
       case "time":
       case "timeEnd":
         result.arguments = aMessage.arguments;
         break;
       default:
         result.arguments = Array.map(aMessage.arguments || [],
           function(aObj) {
-            return this.createValueGrip(aObj);
+            let dbgObj = this.makeDebuggeeValue(aObj);
+            return this.createValueGrip(dbgObj);
           }, this);
-
-        if (result.level == "dir") {
-          result.objectProperties = [];
-          let first = result.arguments[0];
-          if (typeof first == "object" && first && first.inspectable) {
-            let actor = this.getActorByID(first.actor);
-            result.objectProperties = actor.onInspectProperties().properties;
-          }
-        }
         break;
     }
 
     return result;
   },
 
   /**
    * Find the XUL window that owns the content window.
