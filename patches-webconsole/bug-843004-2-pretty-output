# HG changeset patch
# Parent 965482620c147047494b2ddf133a0057963cf431
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1385586757 -7200
Bug 843004 - Part 2: ObjectActor grip changes to allow pretty output.

diff --git a/browser/devtools/shared/widgets/VariablesView.jsm b/browser/devtools/shared/widgets/VariablesView.jsm
--- a/browser/devtools/shared/widgets/VariablesView.jsm
+++ b/browser/devtools/shared/widgets/VariablesView.jsm
@@ -3183,20 +3183,121 @@ VariablesView.getString = function(aGrip
       case "NaN":
       case "Infinity":
       case "-Infinity":
       case "-0":
         return aGrip.type;
       case "longString":
         return "\"" + aGrip.initial + "\"";
       default:
-        if (!aConciseFlag) {
-          return "[" + aGrip.type + " " + aGrip.class + "]";
+        if (aGrip.type == "object" && aGrip.class == "Function") {
+          let name = aGrip.userDisplayName || aGrip.displayName || aGrip.name || "";
+          let params = aGrip.parameterNames || "";
+          if (!aConciseFlag) {
+            return "function " + name + "(" + params + ")";
+          }
+          return (name || "function") + "(" + params + ")";
         }
-        return aGrip.class;
+
+        if (aGrip.type == "object" && aGrip.class == "Array" && aGrip.preview) {
+          let arrayLength = aGrip.preview.arrayLength;
+          let preview = [];
+          if (!aConciseFlag && aGrip.preview.elements) {
+            for (let elem of aGrip.preview.elements) {
+              preview.push(VariablesView.getString(elem, true));
+            }
+            if (preview.length < arrayLength) {
+              preview.push((arrayLength - preview.length) + " more\u2026"); // TODO: localize
+            }
+            return "[" + preview.join(", ") + "]";
+          }
+          return "Array(" + arrayLength + ")";
+        }
+
+        if (aGrip.type == "object" && aGrip.displayString &&
+            aGrip.class == "RegExp") {
+          // TODO: handle longStrings
+          return aGrip.displayString;
+        }
+
+        if (aGrip.type == "object" && aGrip.class == "Date" &&
+            aGrip.dateTimestamp) {
+          return new Date(aGrip.dateTimestamp).toLocaleString();
+        }
+
+        if (!aConciseFlag && aGrip.type == "object" && aGrip.preview &&
+            ["DOMWindow", "DOMDocument"].indexOf(aGrip.preview.kind) != -1) {
+          let location = WebConsoleUtils.abbreviateSourceURL(aGrip.preview.location);
+          return aGrip.class + " {" + location + "}";
+        }
+
+        if (aGrip.type == "object" && aGrip.preview &&
+            aGrip.preview.kind == "DOMElement") {
+          let preview = aGrip.preview;
+          if (!aConciseFlag) {
+            let result = "<" + preview.tagName;
+            if (preview.id) {
+              result += ' id="' + preview.id + '"';
+            }
+            if (preview.className) {
+              result += ' class="' + preview.className + '"';
+            }
+            return result + ">";
+          }
+
+          let result = "<" + preview.tagName;
+          if (preview.id) {
+            result += "#" + preview.id;
+          }
+          return result + ">";
+        }
+
+        if (aGrip.type == "object" && aGrip.preview &&
+            ["Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError",
+             "TypeError", "URIError"].indexOf(aGrip.class) != -1) {
+          if (aConciseFlag) {
+            return aGrip.class;
+          }
+
+          // TODO: handle non-string properties, including longStrings.
+          let msg = aGrip.preview.name + ": " + aGrip.preview.message;
+          let stack = aGrip.preview.stack;
+          if (!VariablesView.isFalsy({ value: stack })) {
+            msg += "\nStack trace:\n" + stack;
+          }
+          return msg;
+        }
+
+        if (aGrip.type == "object" && aConciseFlag) {
+          return aGrip.class;
+        }
+
+        if (aGrip.type == "object" && aGrip.preview && aGrip.preview.names) {
+          let nrNames = aGrip.preview.names;
+          let props = [];
+          for (let key in aGrip.preview.ownProperties) {
+            let value = aGrip.preview.ownProperties[key];
+            let valueString = "";
+            if (value.get) {
+              valueString = "Getter";
+            } else if (value.set) {
+              valueString = "Setter";
+            } else {
+              valueString = VariablesView.getString(value.value, true);
+            }
+            props.push(key + ": " + valueString);
+          }
+          if (nrNames > props.length) {
+            props.push("more\u2026");
+          }
+          let klass = aGrip.class != "Object" ? aGrip.class + " " : "";
+          return klass + "{" + props.join(", ") + "}";
+        }
+
+        return "[" + aGrip.type + " " + aGrip.class + "]";
     }
   }
   switch (typeof aGrip) {
     case "string":
       return "\"" + aGrip + "\"";
     case "boolean":
       return aGrip ? "true" : "false";
     case "number":
diff --git a/toolkit/devtools/server/actors/script.js b/toolkit/devtools/server/actors/script.js
--- a/toolkit/devtools/server/actors/script.js
+++ b/toolkit/devtools/server/actors/script.js
@@ -2681,23 +2681,23 @@ function hasSafeGetter(aDesc) {
  *        The Debugger.Object to get the value from.
  * @param String aKey
  *        The key to look for.
  * @return Any
  */
 function getProperty(aObj, aKey) {
   try {
     do {
-      const desc = aObj.getOwnPropertyDescriptor(aKey);
+      let desc = aObj.getOwnPropertyDescriptor(aKey);
       if (desc) {
         if ("value" in desc) {
           return desc.value
         }
         // Call the getter if it's safe.
-        return hasSafeGetter(desc) ? desc.get.call(aObj) : undefined;
+        return hasSafeGetter(desc) ? desc.get.call(aObj).return : null;
       }
       aObj = aObj.proto;
     } while (aObj);
   } catch (e) {
     // If anything goes wrong report the error and return undefined.
     DevToolsUtils.reportException("getProperty", e);
   }
   return undefined;
@@ -2768,16 +2768,17 @@ let stringifiers = {
   Error: errorStringify,
   EvalError: errorStringify,
   RangeError: errorStringify,
   ReferenceError: errorStringify,
   SyntaxError: errorStringify,
   TypeError: errorStringify,
   URIError: errorStringify,
   Boolean: createBuiltinStringifier(Boolean),
+  Date: createBuiltinStringifier(Date),
   Function: createBuiltinStringifier(Function),
   Number: createBuiltinStringifier(Number),
   RegExp: createBuiltinStringifier(RegExp),
   String: createBuiltinStringifier(String),
   Object: obj => "[object " + obj.class + "]",
   Array: obj => {
     // If we're at the top level then we need to create the Set for tracking
     // previously stringified arrays.
@@ -2837,27 +2838,41 @@ let stringifiers = {
  *        The debuggee object.
  * @param aThreadActor ThreadActor
  *        The parent thread actor for this object.
  */
 function ObjectActor(aObj, aThreadActor)
 {
   this.obj = aObj;
   this.threadActor = aThreadActor;
+
+  if (!("_gripDepth" in this.threadActor)) {
+    this.threadActor._gripDepth = 0;
+  }
 }
 
 ObjectActor.prototype = {
   actorPrefix: "obj",
 
   _forcedMagicProps: false,
 
   /**
    * Returns a grip for this actor for returning in a protocol message.
    */
   grip: function () {
+    let doPreview = this.threadActor._gripDepth++ == 0;
+    dump("doPreview " + doPreview + " _gripDepth " + this.threadActor._gripDepth + "\n");
+    //XXX: no previews in browser debugger, for testing only
+    //if (!this.threadActor || !this.threadActor.parentActor || this.threadActor.actorPrefix != "console") {
+    //  doPreview = false;
+    //}
+    //if (this.threadActor && this.threadActor.parentActor && this.threadActor.parentActor.isRootActor) {
+    //  doPreview = false;
+    //}
+
     let g = {
       "type": "object",
       "class": this.obj.class,
       "actor": this.actorID,
       "extensible": this.obj.isExtensible(),
       "frozen": this.obj.isFrozen(),
       "sealed": this.obj.isSealed()
     };
@@ -2878,18 +2893,114 @@ ObjectActor.prototype = {
         if (desc && desc.value && typeof desc.value == "string") {
           g.userDisplayName = this.threadActor.createValueGrip(desc.value);
         }
       } catch (e) {
         // Calling getOwnPropertyDescriptor with displayName might throw
         // with "permission denied" errors for some functions.
         dumpn(e);
       }
+
+      g.parameterNames = this.obj.parameterNames;
+      doPreview = false;
     }
 
+    if (this.obj.class == "Array") {
+      let len = getProperty(this.obj, "length");
+      if (typeof len == "number") {
+        g.preview = { arrayLength: len };
+
+        if (doPreview) {
+          let elements = g.preview.elements = new Array(Math.min(5, len));
+          for (let i = 0; i < elements.length; i++) {
+            let prop = getProperty(this.obj, i);
+            elements[i] = this.threadActor.createValueGrip(prop);
+          }
+        }
+      }
+    }
+
+    if (this.obj.class == "RegExp") {
+      let str = stringifiers[this.obj.class](this.obj);
+      g.displayString = this.threadActor.createValueGrip(str);
+    }
+
+    if (this.obj.class == "Date") {
+      // TODO: better way without unsafeDereference?
+      let timestamp = Date.prototype.getTime.call(this.obj.unsafeDereference());
+      g.dateTimestamp = this.threadActor.createValueGrip(timestamp);
+      doPreview = false;
+    }
+
+    if (["Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError",
+         "TypeError", "URIError"].indexOf(this.obj.class) != -1) {
+      g.preview = {
+        name: this.threadActor.createValueGrip(getProperty(this.obj, "name")),
+        message: this.threadActor.createValueGrip(getProperty(this.obj, "message")),
+        stack: this.threadActor.createValueGrip(getProperty(this.obj, "stack")),
+      };
+    }
+
+    let raw = this.obj.unsafeDereference();
+    if (Cu.isDeadWrapper(raw)) {
+      // TODO: check if isDeadWrapper() supports D.O
+      g.displayString = "<dead object>"; // TODO maybe localize
+      g.dead = true;
+    }
+
+    if (raw instanceof Ci.nsIDOMWindow) {
+      let location = raw.location.href;
+      g.preview = {
+        kind: "DOMWindow",
+        location: this.threadActor.createValueGrip(location),
+      };
+    }
+
+    if (raw instanceof Ci.nsIDOMElement) {
+      g.preview = {
+        kind: "DOMElement",
+        tagName: this.threadActor.createValueGrip(raw.tagName),
+        id: this.threadActor.createValueGrip(raw.id),
+        className: this.threadActor.createValueGrip(raw.className),
+      };
+    }
+
+    if (raw instanceof Ci.nsIDOMDocument) {
+      let location = raw.location.href;
+      g.preview = {
+        kind: "DOMDocument",
+        location: this.threadActor.createValueGrip(location),
+      };
+    }
+
+    if (this.obj.class == "Object" && !g.preview && !g.displayString && doPreview) {
+      let i = 0, names = this.obj.getOwnPropertyNames();
+      g.preview = {
+        names: names.length,
+        ownProperties: Object.create(null),
+      };
+      // XXX not sure if it makes sense to use the number of own properties. we
+      // need it to determine if an object preview should show an ellipsis or
+      // not. thoughts?
+
+      for (let name of names) {
+        if (+name == +name) { // skip numbers
+          continue;
+        }
+        g.preview.ownProperties[name] = this._propertyDescriptor(name);
+        if (++i == 5) {
+          break;
+        }
+      }
+    }
+
+    // TODO: do not do previews for __proto__
+
+    this.threadActor._gripDepth--;
+
     return g;
   },
 
   /**
    * Releases this actor from the pool.
    */
   release: function () {
     if (this.registeredPool.objectActors) {
